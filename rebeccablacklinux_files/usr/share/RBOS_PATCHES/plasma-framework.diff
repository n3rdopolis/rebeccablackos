diff --git a/src/declarativeimports/core/dialog.cpp b/src/declarativeimports/core/dialog.cpp
index 0248596..8b62ac0 100644
--- a/src/declarativeimports/core/dialog.cpp
+++ b/src/declarativeimports/core/dialog.cpp
@@ -37,9 +37,9 @@
 
 #include <QDebug>
 
-#if HAVE_XCB_SHAPE
-#include <QX11Info>
-#include <xcb/shape.h>
+#ifdef HAVE_X11
+//#include <QX11Info>
+//#include <xcb/shape.h>
 #endif
 
 DialogProxy::DialogProxy(QQuickItem *parent)
@@ -530,7 +530,7 @@ void DialogProxy::updateInputShape()
     if (!isVisible()) {
         return;
     }
-#if HAVE_XCB_SHAPE
+#if 0
     if (QGuiApplication::platformName() == QStringLiteral("xcb")) {
         xcb_connection_t *c = QX11Info::connection();
         static bool s_shapeExtensionChecked = false;
diff --git a/src/declarativeimports/core/dialogshadows.cpp b/src/declarativeimports/core/dialogshadows.cpp
index 5a0ee82..cd440b3 100644
--- a/src/declarativeimports/core/dialogshadows.cpp
+++ b/src/declarativeimports/core/dialogshadows.cpp
@@ -17,11 +17,12 @@
 */
 
 #include "dialogshadows_p.h"
-
+#include "config-plasma.h"
 #include <QGlobalStatic>
 #include <QWindow>
 #include <QPainter>
 
+/*
 #ifdef HAVE_X11
 #include <QX11Info>
 #include <X11/Xatom.h>
@@ -29,6 +30,7 @@
 #include <X11/Xlib-xcb.h>
 #include <fixx11h.h>
 #endif
+*/
 
 #include <qdebug.h>
 
@@ -37,10 +39,12 @@ class DialogShadows::Private
 public:
     Private(DialogShadows *shadows)
         : q(shadows)
-#if HAVE_X11
+/*
+#ifdef HAVE_X11
         ,_connection( 0x0 ),
         _gc( 0x0 )
 #endif
+*/
     {
     }
 
@@ -73,13 +77,15 @@ public:
     QPixmap m_emptyCornerBottomPix;
     QPixmap m_emptyVerticalPix;
     QPixmap m_emptyHorizontalPix;
-
+/*
+#ifdef HAVE_X11
     //! xcb connection
     xcb_connection_t* _connection;
 
     //! graphical context
     xcb_gcontext_t _gc;
-
+#endif
+*/
     QHash<Plasma::FrameSvg::EnabledBorders, QVector<unsigned long> > data;
     QHash<const QWindow *, Plasma::FrameSvg::EnabledBorders> m_windows;
 };
@@ -170,8 +176,8 @@ Qt::HANDLE DialogShadows::Private::createPixmap(const QPixmap& source)
     when Qt uses to RasterEngine. In this case, we create an X11 Pixmap
     explicitly and draw the source pixmap on it.
     */
-
-    #if HAVE_X11
+/*
+    #ifdef HAVE_X11
     
     // check connection 
     if( !_connection ) _connection = QX11Info::connection();
@@ -211,9 +217,11 @@ Qt::HANDLE DialogShadows::Private::createPixmap(const QPixmap& source)
     return (Qt::HANDLE)pixmap;
     
     #else
+*/
     return 0;
+/*
     #endif
-
+*/
 }
 
 void DialogShadows::Private::initPixmap(const QString &element)
@@ -223,6 +231,7 @@ void DialogShadows::Private::initPixmap(const QString &element)
 
 QPixmap DialogShadows::Private::initEmptyPixmap(const QSize &size)
 {
+/*
 #ifdef HAVE_X11
     QPixmap tempEmptyPix(size);
     if (!size.isEmpty()) {
@@ -230,8 +239,11 @@ QPixmap DialogShadows::Private::initEmptyPixmap(const QSize &size)
     }
     return tempEmptyPix;
 #else
+*/
     return QPixmap();
+/*
 #endif
+*/
 }
 
 void DialogShadows::Private::setupPixmaps()
@@ -259,6 +271,7 @@ void DialogShadows::Private::setupPixmaps()
 
 void DialogShadows::Private::setupData(Plasma::FrameSvg::EnabledBorders enabledBorders)
 {
+/*
 #ifdef HAVE_X11
     //shadow-top
     if (enabledBorders & Plasma::FrameSvg::TopBorder) {
@@ -336,7 +349,7 @@ void DialogShadows::Private::setupData(Plasma::FrameSvg::EnabledBorders enabledB
         data[enabledBorders] << reinterpret_cast<unsigned long>(createPixmap(m_emptyCornerPix));
     }
 #endif
-
+*/
     int left, top, right, bottom = 0;
 
     QSize marginHint;
@@ -389,6 +402,7 @@ void DialogShadows::Private::setupData(Plasma::FrameSvg::EnabledBorders enabledB
 
 void DialogShadows::Private::freeX11Pixmaps()
 {
+/*
 #ifdef HAVE_X11
     foreach (const QPixmap &pixmap, m_shadowPixmaps) {
         if (!QX11Info::display()) {
@@ -421,10 +435,12 @@ void DialogShadows::Private::freeX11Pixmaps()
         XFreePixmap(QX11Info::display(), reinterpret_cast<unsigned long>(createPixmap(m_emptyHorizontalPix)));
     }
 #endif
+*/
 }
 
 void DialogShadows::Private::clearPixmaps()
 {
+/*
 #ifdef HAVE_X11
     freeX11Pixmaps();
 
@@ -436,12 +452,14 @@ void DialogShadows::Private::clearPixmaps()
     m_emptyVerticalPix = QPixmap();
     m_emptyHorizontalPix = QPixmap();
 #endif
+*/
     m_shadowPixmaps.clear();
     data.clear();
 }
 
 void DialogShadows::Private::updateShadow(const QWindow *window, Plasma::FrameSvg::EnabledBorders enabledBorders)
 {
+/*
 #ifdef HAVE_X11
     if (m_shadowPixmaps.isEmpty()) {
         setupPixmaps();
@@ -458,15 +476,18 @@ void DialogShadows::Private::updateShadow(const QWindow *window, Plasma::FrameSv
     XChangeProperty(dpy, window->winId(), atom, XA_CARDINAL, 32, PropModeReplace,
                     reinterpret_cast<const unsigned char *>(data[enabledBorders].constData()), data[enabledBorders].size());
 #endif
+*/
 }
 
 void DialogShadows::Private::clearShadow(const QWindow *window)
 {
+/*
 #ifdef HAVE_X11
     Display *dpy = QX11Info::display();
     Atom atom = XInternAtom(dpy, "_KDE_NET_WM_SHADOW", False);
     XDeleteProperty(dpy, window->winId(), atom);
 #endif
+*/
 }
 
 bool DialogShadows::enabled() const
diff --git a/src/declarativeimports/core/windowthumbnail.cpp b/src/declarativeimports/core/windowthumbnail.cpp
index b96d939..f8c8d43 100644
--- a/src/declarativeimports/core/windowthumbnail.cpp
+++ b/src/declarativeimports/core/windowthumbnail.cpp
@@ -25,7 +25,7 @@
 #include <QOpenGLContext>
 #include <QQuickWindow>
 // X11
-#if HAVE_XCB_COMPOSITE
+#if HAVE_X11
 #include <QX11Info>
 #include <xcb/composite.h>
 #if HAVE_GLX
@@ -59,7 +59,7 @@ WindowThumbnail::WindowThumbnail(QQuickItem* parent)
     , m_xcb(false)
     , m_winId(0)
     , m_damaged(false)
-#if HAVE_XCB_COMPOSITE
+#if HAVE_X11
     , m_openGLFunctionsResolved(false)
     , m_damageEventBase(0)
     , m_damage(XCB_NONE)
@@ -83,7 +83,7 @@ WindowThumbnail::WindowThumbnail(QQuickItem* parent)
         m_xcb = (gui->platformName() == QStringLiteral("xcb"));
         if (m_xcb) {
             gui->installNativeEventFilter(this);
-#if HAVE_XCB_COMPOSITE
+#if HAVE_X11
             xcb_connection_t *c = QX11Info::connection();
             xcb_prefetch_extension_data(c, &xcb_damage_id);
             const auto *reply = xcb_get_extension_data(c, &xcb_damage_id);
@@ -112,6 +112,7 @@ uint32_t WindowThumbnail::winId() const
 
 void WindowThumbnail::setWinId(uint32_t winId)
 {
+/*
     if (m_winId == winId) {
         return;
     }
@@ -127,6 +128,8 @@ void WindowThumbnail::setWinId(uint32_t winId)
     m_winId = winId;
     startRedirecting();
     emit winIdChanged();
+*/
+return;
 }
 
 QSGNode *WindowThumbnail::updatePaintNode(QSGNode *oldNode, UpdatePaintNodeData *updatePaintNodeData)
@@ -157,7 +160,7 @@ bool WindowThumbnail::nativeEventFilter(const QByteArray &eventType, void *messa
         // currently we are only interested in XCB events
         return false;
     }
-#if HAVE_XCB_COMPOSITE
+#if HAVE_X11
     xcb_generic_event_t *event = static_cast<xcb_generic_event_t*>(message);
     const uint8_t responseType = event->response_type & ~0x80;
     if (responseType == m_damageEventBase + XCB_DAMAGE_NOTIFY) {
@@ -178,6 +181,7 @@ bool WindowThumbnail::nativeEventFilter(const QByteArray &eventType, void *messa
 
 void WindowThumbnail::iconToTexture(WindowTextureNode *textureNode)
 {
+/*
     QIcon icon;
     if (KWindowSystem::self()->hasWId(m_winId)) {
         icon = KWindowSystem::self()->icon(m_winId);
@@ -187,6 +191,7 @@ void WindowThumbnail::iconToTexture(WindowTextureNode *textureNode)
     }
     QImage image = icon.pixmap(boundingRect().size().toSize()).toImage();
     textureNode->reset(window()->createTextureFromImage(image));
+*/
 }
 
 void WindowThumbnail::windowToTexture(WindowTextureNode *textureNode)
@@ -194,7 +199,7 @@ void WindowThumbnail::windowToTexture(WindowTextureNode *textureNode)
     if (!m_damaged && textureNode->texture()) {
         return;
     }
-#if HAVE_XCB_COMPOSITE
+#if HAVE_X11
     xcb_connection_t *c = QX11Info::connection();
     if (m_pixmap == XCB_PIXMAP_NONE) {
         m_pixmap = pixmapForWindow();
@@ -243,7 +248,7 @@ void WindowThumbnail::windowToTexture(WindowTextureNode *textureNode)
 #endif
 }
 
-#if HAVE_XCB_COMPOSITE
+#if HAVE_X11
 xcb_pixmap_t WindowThumbnail::pixmapForWindow()
 {
     xcb_connection_t *c = QX11Info::connection();
@@ -326,7 +331,7 @@ bool WindowThumbnail::loadGLXTexture()
 void WindowThumbnail::resetDamaged()
 {
     m_damaged = false;
-#if HAVE_XCB_COMPOSITE
+#if HAVE_X11
     xcb_damage_subtract(QX11Info::connection(), m_damage, XCB_NONE, XCB_NONE);
 #endif
 }
@@ -336,7 +341,7 @@ void WindowThumbnail::stopRedirecting()
     if (!m_xcb) {
         return;
     }
-#if HAVE_XCB_COMPOSITE
+#if HAVE_X11
     xcb_connection_t *c = QX11Info::connection();
     if (m_pixmap != XCB_PIXMAP_NONE) {
         xcb_free_pixmap(c, m_pixmap);
@@ -362,7 +367,7 @@ void WindowThumbnail::startRedirecting()
     if (!m_xcb || !window() || window()->winId() == m_winId) {
         return;
     }
-#if HAVE_XCB_COMPOSITE
+#if HAVE_X11
     xcb_connection_t *c = QX11Info::connection();
 
     // redirect the window
@@ -384,7 +389,7 @@ void WindowThumbnail::discardPixmap()
     if (!m_xcb) {
         return;
     }
-#if HAVE_XCB_COMPOSITE
+#if HAVE_X11
 #if HAVE_GLX
     if (m_glxPixmap != XCB_PIXMAP_NONE) {
         Display *d = QX11Info::display();
diff --git a/src/plasma/CMakeLists.txt b/src/plasma/CMakeLists.txt
index 064d3cc..d6d10e0 100644
--- a/src/plasma/CMakeLists.txt
+++ b/src/plasma/CMakeLists.txt
@@ -12,9 +12,9 @@ if(KDE_PLATFORM_FEATURE_BINARY_COMPATIBLE_FEATURE_REDUCTION)
     set(PLASMA_NO_PACKAGE_EXTRADATA TRUE)
 endif()
 
-if(NOT X11_FOUND)
-    set(PLASMA_NO_PACKAGEKIT TRUE)
-endif()
+#if(NOT X11_FOUND)
+#    set(PLASMA_NO_PACKAGEKIT TRUE)
+#endif()
 
 #find_package(KdepimLibs 4.5.60)
 #find_package(Gpgme)
diff --git a/src/plasma/private/effectwatcher.cpp b/src/plasma/private/effectwatcher.cpp
index 495fa59..98a0153 100644
--- a/src/plasma/private/effectwatcher.cpp
+++ b/src/plasma/private/effectwatcher.cpp
@@ -21,11 +21,14 @@
 
 #include <QCoreApplication>
 
+#if HAVE_X11
 #include <QtX11Extras/QX11Info>
+#endif
 
 namespace Plasma
 {
 
+#if HAVE_X11
 EffectWatcher::EffectWatcher(const QString& property, QObject *parent)
     : QObject(parent),
       m_property(XCB_ATOM_NONE)
@@ -49,9 +52,10 @@ EffectWatcher::EffectWatcher(const QString& property, QObject *parent)
         xcb_change_window_attributes(c, QX11Info::appRootWindow(), XCB_CW_EVENT_MASK, &events);
     }
 }
-
+#endif
 bool EffectWatcher::nativeEventFilter(const QByteArray& eventType, void *message, long *result)
 {
+#if HAVE_X11
     Q_UNUSED(result);
     if (eventType != "xcb_generic_event_t")
         return false;
@@ -68,11 +72,13 @@ bool EffectWatcher::nativeEventFilter(const QByteArray& eventType, void *message
             emit effectChanged(m_effectActive);
         }
     }
+#endif
     return false;
 }
 
 bool EffectWatcher::isEffectActive() const
 {
+#if HAVE_X11
     if (m_property == XCB_ATOM_NONE) {
         return false;
     }
@@ -88,6 +94,7 @@ bool EffectWatcher::isEffectActive() const
             return true;
         }
     }
+#endif
     return false;
 }
 
diff --git a/src/shell/panelshadows.cpp b/src/shell/panelshadows.cpp
index d2fa85b..b07ff94 100644
--- a/src/shell/panelshadows.cpp
+++ b/src/shell/panelshadows.cpp
@@ -21,14 +21,15 @@
 #include <QWindow>
 #include <QPainter>
 
+/*
 #ifdef HAVE_X11
-#include <QX11Info>
+#include <QtX11Extras/QX11Info>
 #include <X11/Xatom.h>
 #include <X11/Xlib.h>
 #include <X11/Xlib-xcb.h>
 #include <fixx11h.h>
 #endif
-
+*/
 #include <qdebug.h>
 
 class PanelShadows::Private
@@ -36,10 +37,12 @@ class PanelShadows::Private
 public:
     Private(PanelShadows *shadows)
         : q(shadows)
-#if HAVE_X11
+/*
+#ifdef HAVE_X11
         ,_connection( 0x0 ),
         _gc( 0x0 )
 #endif
+*/
     {
     }
 
@@ -72,13 +75,15 @@ public:
     QPixmap m_emptyCornerBottomPix;
     QPixmap m_emptyVerticalPix;
     QPixmap m_emptyHorizontalPix;
-
+/*
+#ifdef HAVE_X11
     //! xcb connection
     xcb_connection_t* _connection;
 
     //! graphical context
     xcb_gcontext_t _gc;
-
+#endif
+*/
     QHash<Plasma::FrameSvg::EnabledBorders, QVector<unsigned long> > data;
     QHash<const QWindow *, Plasma::FrameSvg::EnabledBorders> m_windows;
 };
@@ -169,8 +174,8 @@ Qt::HANDLE PanelShadows::Private::createPixmap(const QPixmap& source)
     when Qt uses to RasterEngine. In this case, we create an X11 Pixmap
     explicitly and draw the source pixmap on it.
     */
-
-    #if HAVE_X11
+/*
+    #ifdef HAVE_X11
     
     // check connection 
     if( !_connection ) _connection = QX11Info::connection();
@@ -210,8 +215,11 @@ Qt::HANDLE PanelShadows::Private::createPixmap(const QPixmap& source)
     return (Qt::HANDLE)pixmap;
     
     #else
+*/
     return 0;
+/*
     #endif
+*/
 
 }
 
@@ -222,6 +230,7 @@ void PanelShadows::Private::initPixmap(const QString &element)
 
 QPixmap PanelShadows::Private::initEmptyPixmap(const QSize &size)
 {
+/*
 #ifdef HAVE_X11
     QPixmap tempEmptyPix(size);
     if (!size.isEmpty()) {
@@ -229,8 +238,11 @@ QPixmap PanelShadows::Private::initEmptyPixmap(const QSize &size)
     }
     return tempEmptyPix;
 #else
+*/
     return QPixmap();
+/*
 #endif
+*/
 }
 
 void PanelShadows::Private::setupPixmaps()
@@ -258,6 +270,7 @@ void PanelShadows::Private::setupPixmaps()
 
 void PanelShadows::Private::setupData(Plasma::FrameSvg::EnabledBorders enabledBorders)
 {
+/*
 #ifdef HAVE_X11
     //shadow-top
     if (enabledBorders & Plasma::FrameSvg::TopBorder) {
@@ -335,7 +348,7 @@ void PanelShadows::Private::setupData(Plasma::FrameSvg::EnabledBorders enabledBo
         data[enabledBorders] << reinterpret_cast<unsigned long>(createPixmap(m_emptyCornerPix));
     }
 #endif
-
+*/
     int left, top, right, bottom = 0;
 
     QSize marginHint;
@@ -388,6 +401,7 @@ void PanelShadows::Private::setupData(Plasma::FrameSvg::EnabledBorders enabledBo
 
 void PanelShadows::Private::freeX11Pixmaps()
 {
+/*
 #ifdef HAVE_X11
     foreach (const QPixmap &pixmap, m_shadowPixmaps) {
         if (!QX11Info::display()) {
@@ -420,10 +434,12 @@ void PanelShadows::Private::freeX11Pixmaps()
         XFreePixmap(QX11Info::display(), reinterpret_cast<unsigned long>(createPixmap(m_emptyHorizontalPix)));
     }
 #endif
+*/
 }
 
 void PanelShadows::Private::clearPixmaps()
 {
+/*
 #ifdef HAVE_X11
     freeX11Pixmaps();
 
@@ -435,12 +451,14 @@ void PanelShadows::Private::clearPixmaps()
     m_emptyVerticalPix = QPixmap();
     m_emptyHorizontalPix = QPixmap();
 #endif
+*/
     m_shadowPixmaps.clear();
     data.clear();
 }
 
 void PanelShadows::Private::updateShadow(const QWindow *window, Plasma::FrameSvg::EnabledBorders enabledBorders)
 {
+/*
 #ifdef HAVE_X11
     if (m_shadowPixmaps.isEmpty()) {
         setupPixmaps();
@@ -457,15 +475,18 @@ void PanelShadows::Private::updateShadow(const QWindow *window, Plasma::FrameSvg
     XChangeProperty(dpy, window->winId(), atom, XA_CARDINAL, 32, PropModeReplace,
                     reinterpret_cast<const unsigned char *>(data[enabledBorders].constData()), data[enabledBorders].size());
 #endif
+*/
 }
 
 void PanelShadows::Private::clearShadow(const QWindow *window)
 {
+/*
 #ifdef HAVE_X11
     Display *dpy = QX11Info::display();
     Atom atom = XInternAtom(dpy, "_KDE_NET_WM_SHADOW", False);
     XDeleteProperty(dpy, window->winId(), atom);
 #endif
+*/
 }
 
 bool PanelShadows::enabled() const
