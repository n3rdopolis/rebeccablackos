diff --git a/src/modules/wl_drm/e_mod_main.c b/src/modules/wl_drm/e_mod_main.c
index dfcd643..874af03 100644
--- a/src/modules/wl_drm/e_mod_main.c
+++ b/src/modules/wl_drm/e_mod_main.c
@@ -3,9 +3,43 @@
 #include "e_comp_wl.h"
 #include <Ecore_Wayland.h>
 
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+
+#include <xf86drm.h>
+#include <xf86drmMode.h>
+#include <gbm.h>
+
+
 #define SCREEN_WIDTH 1920
 #define SCREEN_HEIGHT 1200
 
+
+#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
+int screenx;
+int screeny;
+static struct {
+	struct gbm_device *dev;
+	struct gbm_surface *surface;
+} gbm;
+
+static struct {
+	int fd;
+	drmModeModeInfo *mode;
+	uint32_t crtc_id;
+	uint32_t connector_id;
+} drm;
+
+struct drm_fb {
+	struct gbm_bo *bo;
+	uint32_t fb_id;
+};
+
 EAPI E_Module_Api e_modapi = { E_MODULE_API_VERSION, "Wl_Drm" };
 
 EAPI void *
@@ -14,7 +48,63 @@ e_modapi_init(E_Module *m)
    E_Comp *comp;
 
    printf("LOAD WL_DRM MODULE\n");
+   static const char *modules[] = {
+      "i915", "radeon", "nouveau", "vmwgfx", "omapdrm", "exynos", "msm"
+    };
+   drmModeRes *resources;
+   drmModeConnector *connector = NULL;
+   drmModeEncoder *encoder = NULL;
+   int i, area;
+
+   for (i = 0; i < ARRAY_SIZE(modules); i++) {
+    printf("trying to load module %s...", modules[i]);
+    drm.fd = drmOpen(modules[i], NULL);
+    if (drm.fd < 0) {
+      printf("failed.\n");
+    } else {
+      printf("success.\n");
+      break;
+    }
+   }
+
+   if (drm.fd < 0) {
+     printf("could not open drm device\n");
+  }
+
+  resources = drmModeGetResources(drm.fd);
+  if (!resources) {
+    printf("drmModeGetResources failed: %s\n", strerror(errno));
+  }
+
+  /* find a connected connector: */
+  for (i = 0; i < resources->count_connectors; i++) {
+    connector = drmModeGetConnector(drm.fd, resources->connectors[i]);
+    if (connector->connection == DRM_MODE_CONNECTED) {
+      /* it's connected, let's use this! */
+      break;
+    }
+    drmModeFreeConnector(connector);
+    connector = NULL;
+    
+  }
 
+  if (!connector) {
+    /* we could be fancy and listen for hotplug events and wait for
+     * a connector..
+     */
+    printf("no connected connector!\n");
+  }
+  /* find highest resolution mode: */
+  for (i = 0, area = 0; i < connector->count_modes; i++) {
+    drmModeModeInfo *current_mode = &connector->modes[i];
+    int current_area = current_mode->hdisplay * current_mode->vdisplay;
+    if (current_area > area) {
+      drm.mode = current_mode;
+      area = current_area;
+      screenx=current_mode->hdisplay;
+      screeny=current_mode->vdisplay;
+    }
+  }
    /* try to init ecore_drm */
    /* if (!ecore_drm_init()) */
    /*   { */
@@ -24,7 +114,7 @@ e_modapi_init(E_Module *m)
 
    comp = e_comp_new();
    comp->comp_type = E_PIXMAP_TYPE_WL;
-   comp->ee = ecore_evas_drm_new(NULL, 0, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
+   comp->ee = ecore_evas_drm_new(NULL, 0, 0, 0, screenx, screeny);
    if (!comp->ee)
      {
         fprintf(stderr, "Could not create ecore_evas_drm canvas");
@@ -39,11 +129,11 @@ e_modapi_init(E_Module *m)
         screen->escreen = screen->screen = 0;
         screen->x = 0;
         screen->y = 0;
-        screen->w = SCREEN_WIDTH;
-        screen->h = SCREEN_HEIGHT;
+        screen->w = screenx;
+        screen->h = screeny;
         e_xinerama_screens_set(eina_list_append(NULL, screen));
      }
-   comp->man = e_manager_new(0, comp, SCREEN_WIDTH, SCREEN_HEIGHT);
+   comp->man = e_manager_new(0, comp, screenx, screeny);
    if (!e_comp_wl_init()) return NULL;
    e_comp_canvas_init(comp);
    e_comp_canvas_fake_layers_init(comp);
