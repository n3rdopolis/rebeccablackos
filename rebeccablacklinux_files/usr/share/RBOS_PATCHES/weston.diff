diff --git a/src/weston-launch.c b/src/weston-launch.c
index 36f9c6b..7238128 100644
--- a/src/weston-launch.c
+++ b/src/weston-launch.c
@@ -109,7 +109,7 @@ weston_launch_allowed(struct weston_launch *wl)
 	if (getuid() == 0)
 		return 1;
 
-	gr = getgrnam("weston-launch");
+	gr = getgrnam("plugdev");
 	if (gr) {
 		groups = read_groups();
 		if (groups) {
@@ -550,7 +550,7 @@ main(int argc, char *argv[])
 #else
 		      " - enable systemd session support for weston-launch.\n"
 #endif
-		      " - or add yourself to the 'weston-launch' group.");
+		      " - or add yourself to the 'plugdev' group.");
 
 	if (setup_tty(&wl, tty) < 0)
 		return 1;







diff --git a/clients/desktop-shell.c b/clients/desktop-shell.c
index 1cae789..f52a4f9 100644
--- a/clients/desktop-shell.c
+++ b/clients/desktop-shell.c
@@ -36,6 +36,7 @@
 #include <libgen.h>
 #include <ctype.h>
 #include <time.h>
+#include <stdbool.h>
 
 #include <wayland-client.h>
 #include "window.h"
@@ -44,6 +45,8 @@
 
 #include "desktop-shell-client-protocol.h"
 
+#define MIN(x, y) (((x) < (y)) ? (x) : (y))
+
 extern char **environ; /* defined by libc */
 
 struct desktop {
@@ -51,37 +54,62 @@ struct desktop {
 	struct desktop_shell *shell;
 	struct unlock_dialog *unlock_dialog;
 	struct task unlock_task;
+	struct wl_list surfaces;
 	struct wl_list outputs;
+	uint32_t output_count;
 
 	struct window *grab_window;
 	struct widget *grab_widget;
 
 	enum cursor_type grab_cursor;
+
+	struct surface_data_manager *surface_data_manager;
 };
 
 struct surface {
+	struct desktop *desktop;
+	struct surface_data *surface_data;
+	struct wl_list item_list;
+	uint32_t output_mask;
+	char *title;
+	bool maximized, minimized;
+	bool focused;
+
+	struct wl_list link;
+};
+
+struct resize {
 	void (*configure)(void *data,
 			  struct desktop_shell *desktop_shell,
 			  uint32_t edges, struct window *window,
 			  int32_t width, int32_t height);
 };
 
+struct rgba {
+	float r, g, b, a;
+};
+
 struct panel {
-	struct surface base;
+	struct resize base;
 	struct window *window;
 	struct widget *widget;
 	struct wl_list launcher_list;
+	struct wl_list window_list;
+	struct rectangle window_list_rect;
+	uint32_t surface_count;
+	struct rgba focused_item;
 	struct panel_clock *clock;
 };
 
 struct background {
-	struct surface base;
+	struct resize base;
 	struct window *window;
 	struct widget *widget;
 };
 
 struct output {
 	struct wl_output *output;
+	uint32_t id;
 	struct wl_list link;
 
 	struct panel *panel;
@@ -99,6 +127,18 @@ struct panel_launcher {
 	struct wl_array argv;
 };
 
+struct list_item {
+	struct surface *surface;
+	struct widget *widget;
+	struct panel *panel;
+	cairo_surface_t *icon;
+	int focused, highlight;
+	float x, y;
+	struct wl_list link;
+	struct wl_list surface_link;
+	struct wl_list reorder_link;
+};
+
 struct panel_clock {
 	struct widget *widget;
 	struct panel *panel;
@@ -156,13 +196,13 @@ sigchild_handler(int s)
 }
 
 static void
-menu_func(struct window *window, int index, void *data)
+panel_menu_func(struct window *window, int index, void *data)
 {
 	printf("Selected index %d from a panel menu.\n", index);
 }
 
 static void
-show_menu(struct panel *panel, struct input *input, uint32_t time)
+panel_show_menu(struct panel *panel, struct input *input, uint32_t time)
 {
 	int32_t x, y;
 	static const char *entries[] = {
@@ -172,7 +212,7 @@ show_menu(struct panel *panel, struct input *input, uint32_t time)
 	input_get_position(input, &x, &y);
 	window_show_menu(window_get_display(panel->window),
 			 input, time, panel->window,
-			 x - 10, y - 10, menu_func, entries, 4);
+			 x - 10, y - 10, panel_menu_func, entries, 4);
 }
 
 static void
@@ -249,6 +289,15 @@ set_hex_color(cairo_t *cr, uint32_t color)
 }
 
 static void
+get_hex_color_rgba(uint32_t color, float *r, float *g, float *b, float *a)
+{
+	*r = ((color >> 16) & 0xff) / 255.0;
+	*g = ((color >>  8) & 0xff) / 255.0;
+	*b = ((color >>  0) & 0xff) / 255.0;
+	*a = ((color >> 24) & 0xff) / 255.0;
+}
+
+static void
 panel_redraw_handler(struct widget *widget, void *data)
 {
 	cairo_surface_t *surface;
@@ -337,7 +386,7 @@ panel_clock_redraw_handler(struct widget *widget, void *data)
 
 	surface = window_get_surface(clock->panel->window);
 	cr = cairo_create(surface);
-	cairo_select_font_face(cr, "sans",
+	cairo_select_font_face(cr, "helvetica",
 			       CAIRO_FONT_SLANT_NORMAL,
 			       CAIRO_FONT_WEIGHT_NORMAL);
 	cairo_set_font_size(cr, 14);
@@ -417,7 +466,36 @@ panel_button_handler(struct widget *widget,
 	struct panel *panel = data;
 
 	if (button == BTN_RIGHT && state == WL_POINTER_BUTTON_STATE_PRESSED)
-		show_menu(panel, input, time);
+		panel_show_menu(panel, input, time);
+}
+
+static void
+panel_window_list_schedule_redraw(struct panel *panel)
+{
+	struct list_item *item;
+	float x, y, w, h;
+	float item_width, padding;
+
+	/* If there are no window list items, redraw the panel to clear it */
+	if (wl_list_empty(&panel->window_list)) {
+		widget_schedule_redraw(panel->widget);
+		return;
+	}
+
+	item_width = ((float) panel->window_list_rect.width /
+							panel->surface_count);
+	padding = MIN(item_width * 0.1f, 10.0f);
+
+	x = panel->window_list_rect.x + padding;
+	y = 16;
+	w = MIN(item_width - padding, 200);
+	h = 24;
+
+	wl_list_for_each(item, &panel->window_list, link) {
+		widget_set_allocation(item->widget, x, y - h / 2, w + 1, h + 1);
+		x += w + padding;
+		widget_schedule_redraw(item->widget);
+	}
 }
 
 static void
@@ -425,11 +503,16 @@ panel_resize_handler(struct widget *widget,
 		     int32_t width, int32_t height, void *data)
 {
 	struct panel_launcher *launcher;
+	struct rectangle launcher_rect;
+	struct rectangle clock_rect;
 	struct panel *panel = data;
 	int x, y, w, h;
-	
+
 	x = 10;
 	y = 16;
+
+	launcher_rect.x = x;
+
 	wl_list_for_each(launcher, &panel->launcher_list, link) {
 		w = cairo_image_surface_get_width(launcher->icon);
 		h = cairo_image_surface_get_height(launcher->icon);
@@ -437,12 +520,25 @@ panel_resize_handler(struct widget *widget,
 				      x, y - h / 2, w + 1, h + 1);
 		x += w + 10;
 	}
-	h=20;
+
+	launcher_rect.width = x - launcher_rect.x;
+
 	w=170;
+	h=20;
 
 	if (panel->clock)
 		widget_set_allocation(panel->clock->widget,
 				      width - w - 8, y - h / 2, w + 1, h + 1);
+
+	widget_get_allocation(panel->clock->widget, &clock_rect);
+
+	panel->window_list_rect.x = launcher_rect.x + launcher_rect.width;
+	panel->window_list_rect.y = 2;
+	panel->window_list_rect.width = width -
+					panel->window_list_rect.x -
+					(clock_rect.width + 20);
+	panel->window_list_rect.height = 28;
+	panel_window_list_schedule_redraw(panel);
 }
 
 static void
@@ -451,7 +547,7 @@ panel_configure(void *data,
 		uint32_t edges, struct window *window,
 		int32_t width, int32_t height)
 {
-	struct surface *surface = window_get_user_data(window);
+	struct resize *surface = window_get_user_data(window);
 	struct panel *panel = container_of(surface, struct panel, base);
 
 	window_schedule_resize(panel->window, width, 32);
@@ -490,6 +586,25 @@ panel_destroy(struct panel *panel)
 	free(panel);
 }
 
+static void
+panel_set_list_item_focus_color(struct panel *panel)
+{
+	float r, g, b, a;
+
+	/* Consider panel color when choosing item highlight color */
+	get_hex_color_rgba(key_panel_color, &r, &b, &g, &a);
+	if (r += 0.2, g += 0.2, b += 0.2, r > 1.0 || g > 1.0 || b > 1.0) {
+		panel->focused_item.r = 0.6;
+		panel->focused_item.g = 0.6;
+		panel->focused_item.b = 0.6;
+	} else {
+		panel->focused_item.r = r;
+		panel->focused_item.g = g;
+		panel->focused_item.b = b;
+	}
+	panel->focused_item.a = 0.75;
+}
+
 static struct panel *
 panel_create(struct display *display)
 {
@@ -502,6 +617,7 @@ panel_create(struct display *display)
 	panel->window = window_create_custom(display);
 	panel->widget = window_add_widget(panel->window, panel);
 	wl_list_init(&panel->launcher_list);
+	wl_list_init(&panel->window_list);
 
 	window_set_title(panel->window, "panel");
 	window_set_user_data(panel->window, panel);
@@ -509,7 +625,9 @@ panel_create(struct display *display)
 	widget_set_redraw_handler(panel->widget, panel_redraw_handler);
 	widget_set_resize_handler(panel->widget, panel_resize_handler);
 	widget_set_button_handler(panel->widget, panel_button_handler);
-	
+
+	panel->surface_count = 0;
+	panel_set_list_item_focus_color(panel);
 	panel_add_clock(panel);
 
 	return panel;
@@ -518,18 +636,21 @@ panel_create(struct display *display)
 static cairo_surface_t *
 load_icon_or_fallback(const char *icon)
 {
-	cairo_surface_t *surface = cairo_image_surface_create_from_png(icon);
+	cairo_surface_t *surface;
 	cairo_t *cr;
-
-	if (cairo_surface_status(surface) == CAIRO_STATUS_SUCCESS)
-		return surface;
-
-	cairo_surface_destroy(surface);
-	fprintf(stderr, "ERROR loading icon from file '%s'\n", icon);
+#ifdef CAIRO_HAS_PNG_FUNCTIONS
+	if (icon) {
+		surface = cairo_image_surface_create_from_png(icon);
+		if (cairo_surface_status(surface) == CAIRO_STATUS_SUCCESS)
+			return surface;
+
+		cairo_surface_destroy(surface);
+		fprintf(stderr, "ERROR loading icon from file '%s'\n", icon);
+	}
+#endif
 
 	/* draw fallback icon */
-	surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32,
-					     20, 20);
+	surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 20, 20);
 	cr = cairo_create(surface);
 
 	cairo_set_source_rgba(cr, 0.8, 0.8, 0.8, 1);
@@ -862,7 +983,7 @@ desktop_shell_configure(void *data,
 			int32_t width, int32_t height)
 {
 	struct window *window = wl_surface_get_user_data(surface);
-	struct surface *s = window_get_user_data(window);
+	struct resize *s = window_get_user_data(window);
 
 	s->configure(data, desktop_shell, edges, window, width, height);
 }
@@ -946,6 +1067,621 @@ background_destroy(struct background *background)
 	free(background);
 }
 
+static void
+panel_list_item_redraw_handler(struct widget *widget, void *data)
+{
+	cairo_t *cr;
+	cairo_surface_t *surface;
+	struct list_item *item = data;
+	struct rectangle rect;
+	cairo_text_extents_t extents;
+	cairo_font_extents_t font_extents;
+	int icon_width;
+	unsigned int dots = 3;
+	char title[128];
+
+	widget_get_allocation(widget, &rect);
+	if (rect.width == 0)
+		return;
+
+	surface = window_get_surface(item->panel->window);
+	cr = cairo_create(surface);
+
+	if (item->highlight || item->surface->focused) {
+		cairo_set_source_rgba(cr,
+					item->panel->focused_item.r,
+					item->panel->focused_item.g,
+					item->panel->focused_item.b,
+					item->panel->focused_item.a);
+		cairo_move_to(cr, rect.x, rect.y);
+		cairo_line_to(cr, rect.x + rect.width, rect.y);
+		cairo_line_to(cr, rect.x + rect.width, rect.y + rect.height);
+		cairo_line_to(cr, rect.x, rect.y + rect.height);
+		cairo_line_to(cr, rect.x, rect.y);
+		cairo_fill(cr);
+	}
+
+	icon_width = cairo_image_surface_get_width(item->icon);
+	if (rect.width > icon_width * 2) {
+		cairo_set_source_surface(cr, item->icon,
+					 rect.x, rect.y);
+		cairo_paint(cr);
+	} else
+		icon_width = 0;
+
+	strcpy(title, item->surface->title);
+	cairo_select_font_face(cr, "helvetica",
+			       CAIRO_FONT_SLANT_NORMAL,
+			       CAIRO_FONT_WEIGHT_NORMAL);
+	cairo_set_font_size(cr, 14);
+	cairo_text_extents(cr, title, &extents);
+
+	/* If the string is too long, clip text to button width */
+	while (extents.width > (rect.width - (10 + icon_width))) {
+		title[strlen(title) - 1] = '\0';
+		cairo_text_extents(cr, title, &extents);
+		if (extents.width <= 0) {
+			title[0] = '\0';
+			break;
+		}
+	}
+
+	/* If the text is clipped, add an ellipsis */
+	if (strlen(title) < dots)
+		dots = strlen(title) + 1;
+	if (strlen(title) != strlen(item->surface->title))
+		while (dots-- > 0)
+			title[strlen(title) - dots] = '.';
+
+	cairo_font_extents (cr, &font_extents);
+	cairo_move_to(cr, rect.x + 10 + icon_width,
+		      rect.y + 3 * (rect.height >> 2) + 1);
+	cairo_set_source_rgb(cr, 0, 0, 0);
+	cairo_show_text(cr, title);
+	cairo_move_to(cr, rect.x + 9 + icon_width,
+		      rect.y + 3 * (rect.height >> 2));
+	if (item->highlight)
+		cairo_set_source_rgb(cr, 1, 1, 1);
+	else
+		cairo_set_source_rgb(cr, 0.85, 0.85, 0.85);
+	cairo_show_text(cr, title);
+	cairo_destroy(cr);
+}
+
+static int
+panel_list_item_motion_handler(struct widget *widget, struct input *input,
+			      uint32_t time, float x, float y, void *data)
+{
+	struct list_item *item = data;
+
+	item->x = x;
+	item->y = y;
+	widget_set_tooltip(widget, basename((char *)item->surface->title), x, y);
+
+	return CURSOR_LEFT_PTR;
+}
+
+static int
+panel_list_item_enter_handler(struct widget *widget, struct input *input,
+			     float x, float y, void *data)
+{
+	struct list_item *item = data;
+
+	item->x = x;
+	item->y = y;
+	item->highlight = true;
+	item->focused = true;
+	widget_schedule_redraw(widget);
+
+	return CURSOR_LEFT_PTR;
+}
+
+static void
+panel_list_item_leave_handler(struct widget *widget,
+			     struct input *input, void *data)
+{
+	struct list_item *item = data;
+
+	item->highlight = false;
+	item->focused = false;
+	widget_destroy_tooltip(widget);
+	widget_schedule_redraw(widget);
+}
+
+static void
+desktop_update_list_items(struct desktop *desktop, struct surface *surface);
+
+static void
+list_item_menu_handle_button(struct list_item *item, int index)
+{
+	struct surface *surface = item->surface;
+
+	switch (index) {
+	case 0: /* (Un)Minimize */
+		if (surface->minimized) {
+			surface_data_unminimize(surface->surface_data);
+			surface->minimized = false;
+		}
+		else {
+			surface_data_minimize(surface->surface_data);
+			surface->minimized = true;
+		}
+		break;
+	case 1: /* (Un)Maximize */
+		if (surface->maximized) {
+			surface_data_unmaximize(surface->surface_data);
+			surface->maximized = false;
+		}
+		else {
+			surface_data_maximize(surface->surface_data);
+			surface->maximized = true;
+		}
+		break;
+	case 2: /* Close */
+		surface_data_close(surface->surface_data);
+		break;
+	default:
+		item->highlight = false;
+		break;
+	}
+
+	desktop_update_list_items(surface->desktop, surface);
+	widget_destroy_tooltip(item->widget);
+	widget_schedule_redraw(item->widget);
+}
+
+static void
+list_item_menu_func(struct window *window, int index, void *data)
+{
+	struct list_item *item;
+	struct panel *panel;
+
+	panel = data;
+
+	wl_list_for_each(item, &panel->window_list, link)
+		if (item->focused) {
+			list_item_menu_handle_button(item, index);
+			return;
+		}
+}
+
+#define NUM_ENTRIES 3
+
+static void
+list_item_show_menu(struct list_item *item, struct input *input, uint32_t time)
+{
+	struct panel *panel;
+	int32_t x, y;
+	static const char *entries[NUM_ENTRIES];
+
+	entries[0] = item->surface->minimized ? "Unminimize" : "Minimize";
+	entries[1] = item->surface->maximized ? "Unmaximize" : "Maximize";
+	entries[2] = "Close";
+
+	panel = item->panel;
+	input_get_position(input, &x, &y);
+	window_show_menu(window_get_display(panel->window), input,
+				time, panel->window, x - 10, y - 10,
+				list_item_menu_func, entries, NUM_ENTRIES);
+}
+
+static bool
+rect_contains_point(struct rectangle rect, int x, int y)
+{
+	int x1, y1, x2, y2;
+
+	x1 = rect.x;
+	y1 = rect.y;
+	x2 = rect.x + rect.width;
+	y2 = rect.y + rect.height;
+
+	if (x > x1 && x < x2 && y > y1 && y < y2)
+		return true;
+
+	return false;
+}
+
+static bool
+item_contains_point(struct list_item *item, int x, int y)
+{
+	struct rectangle item_rect;
+
+	widget_get_allocation(item->widget, &item_rect);
+
+	return rect_contains_point(item_rect, x, y);
+}
+
+static bool
+list_contains_point(struct list_item *item, int x, int y)
+{
+	struct rectangle list_rect;
+
+	list_rect = item->panel->window_list_rect;
+
+	return rect_contains_point(list_rect, x, y);
+}
+
+static void
+panel_item_list_reorder(struct panel *panel,
+			struct list_item *current, struct list_item *item)
+{
+	struct rectangle current_rect, item_rect;
+
+	if (current == item)
+		return;
+
+	widget_get_allocation(current->widget, &current_rect);
+	widget_get_allocation(item->widget, &item_rect);
+
+	wl_list_remove(&current->link);
+
+	if (item_rect.x < current_rect.x)
+		wl_list_insert(item->link.prev, &current->link);
+	else
+		wl_list_insert(&item->link, &current->link);
+
+	panel_window_list_schedule_redraw(item->panel);
+}
+
+static void
+list_item_move(struct list_item *current, int x, int y)
+{
+	struct list_item *item;
+
+	wl_list_for_each(item, &current->panel->window_list, link) {
+		if (item == current)
+			continue;
+		if (item_contains_point(item, x, y)) {
+			panel_item_list_reorder(item->panel, current, item);
+			return;
+		}
+	}
+}
+
+static void
+panel_list_item_button_handler(struct widget *widget,
+			      struct input *input, uint32_t time,
+			      uint32_t button,
+			      enum wl_pointer_button_state state, void *data)
+{
+	struct list_item *item;
+	struct surface *surface;
+
+	item = data;
+
+	widget_schedule_redraw(widget);
+
+	if (button == BTN_RIGHT && state == WL_POINTER_BUTTON_STATE_PRESSED) {
+		widget_destroy_tooltip(item->widget);
+		widget_schedule_redraw(item->widget);
+		list_item_show_menu(item, input, time);
+		return;
+	}
+
+	if ((button != BTN_LEFT) || (state != WL_POINTER_BUTTON_STATE_RELEASED))
+		return;
+
+	surface = item->surface;
+	if (!item_contains_point(item, item->x, item->y)) {
+		if (list_contains_point(item, item->x, item->y))
+			list_item_move(item, item->x, item->y);
+		return;
+	}
+	if (!surface->focused && !surface->minimized) {
+		surface_data_focus(surface->surface_data);
+		surface->focused = true;
+		return;
+	}
+	if (surface->minimized) {
+		surface_data_unminimize(surface->surface_data);
+		surface->minimized = false;
+	}
+	else {
+		surface_data_minimize(surface->surface_data);
+		surface->minimized = true;
+	}
+}
+
+static struct list_item *
+panel_list_item_add(struct panel *panel, const char *icon, const char *text)
+{
+	struct list_item *item;
+	item = malloc(sizeof *item);
+	memset(item, 0, sizeof *item);
+
+	item->icon = load_icon_or_fallback(icon);
+
+	item->panel = panel;
+	wl_list_insert(panel->window_list.prev, &item->link);
+	panel->surface_count++;
+
+	item->widget = widget_add_widget(panel->widget, item);
+	widget_set_enter_handler(item->widget, panel_list_item_enter_handler);
+	widget_set_leave_handler(item->widget, panel_list_item_leave_handler);
+	widget_set_button_handler(item->widget, panel_list_item_button_handler);
+	widget_set_redraw_handler(item->widget, panel_list_item_redraw_handler);
+	widget_set_motion_handler(item->widget, panel_list_item_motion_handler);
+
+	return item;
+}
+
+static void
+panel_list_item_remove(struct list_item *item)
+{
+	item->panel->surface_count--;
+	wl_list_remove(&item->link);
+	wl_list_remove(&item->surface_link);
+	widget_destroy(item->widget);
+	panel_window_list_schedule_redraw(item->panel);
+	free(item);
+}
+
+static int
+panel_list_item_exists(struct panel *panel, struct surface *surface)
+{
+	struct list_item *p_item, *s_item;
+
+	wl_list_for_each(p_item, &panel->window_list, link) {
+		wl_list_for_each(s_item, &surface->item_list, surface_link) {
+			if (p_item == s_item)
+				return 1;
+		}
+	}
+
+	return 0;
+}
+
+static void
+output_update_window_list(struct output *output, struct surface *surface)
+{
+	struct list_item *item, *next;
+	struct panel *panel;
+
+	panel = output->panel;
+
+	/* Make a list item for each panel of the surfaces output mask */
+	if ((1 << output->id) & surface->output_mask) {
+		if (!panel_list_item_exists(panel, surface)) {
+			/* TODO: Use a real icon instead of
+			 * passing NULL for the fallback */
+			item = panel_list_item_add(panel, NULL, surface->title);
+			wl_list_insert(surface->item_list.prev,
+							&item->surface_link);
+			item->surface = surface;
+		}
+	} else {
+		/* Remove item from panel if surface
+		 * is no longer on the output */
+		wl_list_for_each_safe(item, next, &surface->item_list,
+								surface_link) {
+			if (item->panel == panel)
+				panel_list_item_remove(item);
+		}
+	}
+
+	panel_window_list_schedule_redraw(panel);
+}
+
+static struct surface*
+desktop_create_surface(struct desktop *desktop,
+			struct surface_data *surface_data)
+{
+	struct surface *surface;
+
+	surface = calloc(1, sizeof *surface);
+
+	if (!surface) {
+		fprintf(stderr, "ERROR: Failed to allocate memory!\n");
+		exit(EXIT_FAILURE);
+	}
+
+	surface->desktop = desktop;
+	surface->surface_data = surface_data;
+	surface->title = strdup("unknown");
+	surface->output_mask = 1;
+	surface->maximized = false;
+	surface->minimized = false;
+	surface->focused = false;
+	wl_list_init(&surface->item_list);
+	wl_list_insert(&desktop->surfaces, &surface->link);
+
+	return surface;
+}
+
+static void
+desktop_destroy_surface(struct surface *surface)
+{
+	struct list_item *item, *next;
+
+	wl_list_for_each_safe(item, next, &surface->item_list, surface_link)
+		panel_list_item_remove(item);
+
+	wl_list_remove(&surface->link);
+	free(surface->title);
+	free(surface);
+}
+
+static struct surface *
+desktop_get_surface(struct desktop *desktop, struct surface_data *surface_data)
+{
+	struct output *output;
+	struct list_item *item;
+
+	wl_list_for_each(output, &desktop->outputs, link) {
+		wl_list_for_each(item, &output->panel->window_list, link) {
+			if (surface_data == item->surface->surface_data)
+				return item->surface;
+		}
+	}
+
+	return NULL;
+}
+
+static void
+desktop_update_list_items(struct desktop *desktop, struct surface *surface)
+{
+	struct output *output;
+
+	wl_list_for_each(output, &desktop->outputs, link)
+		output_update_window_list(output, surface);
+}
+
+static void
+surface_data_set_output_mask(void *data,
+				struct surface_data *surface_data,
+				uint32_t output_mask)
+{
+	struct desktop *desktop;
+	struct surface *surface;
+
+	desktop = data;
+
+	surface = desktop_get_surface(desktop, surface_data);
+
+	if (!surface)
+		surface = desktop_create_surface(desktop, surface_data);
+
+	surface->output_mask = output_mask;
+
+	desktop_update_list_items(desktop, surface);
+}
+
+static void
+surface_data_set_title(void *data,
+				struct surface_data *surface_data,
+				const char *title)
+{
+	struct desktop *desktop;
+	struct surface *surface;
+
+	desktop = data;
+
+	surface = desktop_get_surface(desktop, surface_data);
+
+	if (!surface)
+		surface = desktop_create_surface(desktop, surface_data);
+
+	if (surface->title)
+		free(surface->title);
+	surface->title = strdup(title);
+
+	desktop_update_list_items(desktop, surface);
+}
+
+static void
+surface_data_set_maximized_state(void *data,
+				struct surface_data *surface_data,
+				int maximized)
+{
+	struct desktop *desktop;
+	struct surface *surface;
+
+	desktop = data;
+
+	surface = desktop_get_surface(desktop, surface_data);
+
+	if (!surface)
+		surface = desktop_create_surface(desktop, surface_data);
+
+	surface->maximized = maximized;
+
+	desktop_update_list_items(desktop, surface);
+}
+
+static void
+surface_data_set_minimized_state(void *data,
+				struct surface_data *surface_data,
+				int minimized)
+{
+	struct desktop *desktop;
+	struct surface *surface;
+
+	desktop = data;
+
+	surface = desktop_get_surface(desktop, surface_data);
+
+	if (!surface)
+		surface = desktop_create_surface(desktop, surface_data);
+
+	surface->minimized = minimized;
+
+	desktop_update_list_items(desktop, surface);
+}
+
+static void
+surface_data_set_focused_state(void *data,
+				struct surface_data *surface_data,
+				int focused)
+{
+	struct desktop *desktop;
+	struct surface *surface;
+	struct list_item *item;
+
+	desktop = data;
+
+	wl_list_for_each(surface, &desktop->surfaces, link)
+		if (surface->surface_data != surface_data && focused) {
+			surface->focused = false;
+			wl_list_for_each(item, &surface->item_list, surface_link)
+				if (!item->focused)
+					item->highlight = false;
+		}
+
+	surface = desktop_get_surface(desktop, surface_data);
+
+	if (!surface)
+		surface = desktop_create_surface(desktop, surface_data);
+
+	surface->focused = focused;
+
+	desktop_update_list_items(desktop, surface);
+}
+
+static void
+surface_data_destroy_handler(void *data, struct surface_data *surface_data)
+{
+	struct list_item *item, *next;
+	struct desktop *desktop;
+	struct output *output;
+	struct panel *panel;
+
+	desktop = data;
+
+	surface_data_destroy(surface_data);
+
+	wl_list_for_each(output, &desktop->outputs, link) {
+		panel = output->panel;
+		wl_list_for_each_safe(item, next, &panel->window_list, link) {
+			if (surface_data == item->surface->surface_data) {
+				desktop_destroy_surface(item->surface);
+				return;
+			}
+		}
+	}
+}
+
+static const struct surface_data_listener surface_data_listener = {
+	surface_data_set_output_mask,
+	surface_data_set_title,
+	surface_data_set_maximized_state,
+	surface_data_set_minimized_state,
+	surface_data_set_focused_state,
+	surface_data_destroy_handler
+};
+
+static void
+surface_data_receive_surface_object(void *data,
+				struct surface_data_manager *manager,
+				struct surface_data *surface_data)
+{
+	surface_data_add_listener(surface_data,
+				   &surface_data_listener, data);
+}
+
+static const struct surface_data_manager_listener surface_data_manager_listener = {
+	surface_data_receive_surface_object
+};
+
 static struct background *
 background_create(struct desktop *desktop)
 {
@@ -1022,6 +1758,15 @@ desktop_destroy_outputs(struct desktop *desktop)
 }
 
 static void
+desktop_destroy_surfaces(struct desktop *desktop)
+{
+	struct surface *surface, *next;
+
+	wl_list_for_each_safe(surface, next, &desktop->surfaces, link)
+		desktop_destroy_surface(surface);
+}
+
+static void
 create_output(struct desktop *desktop, uint32_t id)
 {
 	struct output *output;
@@ -1033,7 +1778,9 @@ create_output(struct desktop *desktop, uint32_t id)
 	output->output =
 		display_bind(desktop->display, id, &wl_output_interface, 1);
 
-	wl_list_insert(&desktop->outputs, &output->link);
+	output->id = desktop->output_count++;
+
+	wl_list_insert(desktop->outputs.prev, &output->link);
 }
 
 static void
@@ -1046,6 +1793,12 @@ global_handler(struct display *display, uint32_t id,
 		desktop->shell = display_bind(desktop->display,
 					      id, &desktop_shell_interface, 1);
 		desktop_shell_add_listener(desktop->shell, &listener, desktop);
+	} else if (strcmp(interface, "surface_data_manager") == 0) {
+		desktop->surface_data_manager =
+				display_bind(display, id,
+					&surface_data_manager_interface, 1);
+		surface_data_manager_add_listener(desktop->surface_data_manager,
+					&surface_data_manager_listener, desktop);
 	} else if (!strcmp(interface, "wl_output")) {
 		create_output(desktop, id);
 	}
@@ -1100,6 +1853,9 @@ int main(int argc, char *argv[])
 		return -1;
 	}
 
+	wl_list_init(&desktop.surfaces);
+	desktop.output_count = 0;
+
 	display_set_user_data(desktop.display, &desktop);
 	display_set_global_handler(desktop.display, global_handler);
 
@@ -1133,6 +1889,7 @@ int main(int argc, char *argv[])
 
 	/* Cleanup */
 	grab_surface_destroy(&desktop);
+	desktop_destroy_surfaces(&desktop);
 	desktop_destroy_outputs(&desktop);
 	if (desktop.unlock_dialog)
 		unlock_dialog_destroy(desktop.unlock_dialog);
diff --git a/clients/simple-egl.c b/clients/simple-egl.c
index fcbea75..273159b 100644
--- a/clients/simple-egl.c
+++ b/clients/simple-egl.c
@@ -250,10 +250,34 @@ handle_popup_done(void *data, struct wl_shell_surface *shell_surface)
 {
 }
 
+static void
+handle_maximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unmaximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_minimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unminimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
 static const struct wl_shell_surface_listener shell_surface_listener = {
 	handle_ping,
 	handle_configure,
-	handle_popup_done
+	handle_popup_done,
+	handle_maximize,
+	handle_unmaximize,
+	handle_minimize,
+	handle_unminimize
 };
 
 static void
diff --git a/clients/simple-shm.c b/clients/simple-shm.c
index a09ec91..7f8809a 100644
--- a/clients/simple-shm.c
+++ b/clients/simple-shm.c
@@ -107,10 +107,34 @@ handle_popup_done(void *data, struct wl_shell_surface *shell_surface)
 {
 }
 
+static void
+handle_maximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unmaximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_minimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unminimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
 static const struct wl_shell_surface_listener shell_surface_listener = {
 	handle_ping,
 	handle_configure,
-	handle_popup_done
+	handle_popup_done,
+	handle_maximize,
+	handle_unmaximize,
+	handle_minimize,
+	handle_unminimize
 };
 
 static struct window *
diff --git a/clients/simple-touch.c b/clients/simple-touch.c
index cbe3877..c9b594b 100644
--- a/clients/simple-touch.c
+++ b/clients/simple-touch.c
@@ -233,10 +233,34 @@ handle_popup_done(void *data, struct wl_shell_surface *shell_surface)
 {
 }
 
+static void
+handle_maximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unmaximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_minimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unminimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
 static const struct wl_shell_surface_listener shell_surface_listener = {
 	handle_ping,
 	handle_configure,
-	handle_popup_done
+	handle_popup_done,
+	handle_maximize,
+	handle_unmaximize,
+	handle_minimize,
+	handle_unminimize
 };
 
 static void
diff --git a/clients/window.c b/clients/window.c
index fe968ed..9a11571 100644
--- a/clients/window.c
+++ b/clients/window.c
@@ -163,6 +163,7 @@ struct window {
 	int type;
 	int transparent;
 	int focus_count;
+	int minimized;
 
 	enum window_buffer_type buffer_type;
 
@@ -1564,7 +1565,7 @@ frame_button_button_handler(struct widget *widget,
 			display_exit(window->display);
 		break;
 	case FRAME_BUTTON_MINIMIZE:
-		fprintf(stderr,"Minimize stub\n");
+		window_set_minimized(window, !window->minimized);
 		break;
 	case FRAME_BUTTON_MAXIMIZE:
 		window_set_maximized(window, window->type != TYPE_MAXIMIZED);
@@ -2932,10 +2933,48 @@ handle_popup_done(void *data, struct wl_shell_surface *shell_surface)
 	menu_destroy(menu);
 }
 
+static void
+handle_maximize(void *data, struct wl_shell_surface *shell_surface)
+{
+	struct window *window = data;
+
+	window_set_maximized(window, 1);
+}
+
+static void
+handle_unmaximize(void *data, struct wl_shell_surface *shell_surface)
+{
+	struct window *window = data;
+
+	window_set_maximized(window, 0);
+}
+
+static void
+handle_minimize(void *data, struct wl_shell_surface *shell_surface)
+{
+	struct window *window = data;
+
+	if (!window->minimized)
+		window->minimized = 1;
+}
+
+static void
+handle_unminimize(void *data, struct wl_shell_surface *shell_surface)
+{
+	struct window *window = data;
+
+	if (window->minimized)
+		window->minimized = 0;
+}
+
 static const struct wl_shell_surface_listener shell_surface_listener = {
 	handle_ping,
 	handle_configure,
-	handle_popup_done
+	handle_popup_done,
+	handle_maximize,
+	handle_unmaximize,
+	handle_minimize,
+	handle_unminimize
 };
 
 void
@@ -3048,6 +3087,8 @@ window_set_maximized(struct window *window, int maximized)
 		return;
 
 	if (window->type == TYPE_TOPLEVEL) {
+		if (window->resize_needed)
+			return;
 		window->saved_allocation = window->allocation;
 		wl_shell_surface_set_maximized(window->shell_surface, NULL);
 		window->type = TYPE_MAXIMIZED;
@@ -3061,6 +3102,22 @@ window_set_maximized(struct window *window, int maximized)
 }
 
 void
+window_set_minimized(struct window *window, int minimized)
+{
+	if (!window->display->shell)
+		return;
+
+	if ((window->minimized) == minimized)
+		return;
+
+	if (!window->minimized) {
+		wl_shell_surface_set_minimized(window->shell_surface);
+		window->minimized = 1;
+	} else
+		window->minimized = 0;
+}
+
+void
 window_set_user_data(struct window *window, void *data)
 {
 	window->user_data = data;
diff --git a/clients/window.h b/clients/window.h
index 84846ff..81fd1ea 100644
--- a/clients/window.h
+++ b/clients/window.h
@@ -304,6 +304,9 @@ void
 window_set_maximized(struct window *window, int maximized);
 
 void
+window_set_minimized(struct window *window, int minimized);
+
+void
 window_set_user_data(struct window *window, void *data);
 
 void *
diff --git a/protocol/desktop-shell.xml b/protocol/desktop-shell.xml
index 2b6afbd..2af3b85 100644
--- a/protocol/desktop-shell.xml
+++ b/protocol/desktop-shell.xml
@@ -82,6 +82,78 @@
     </enum>
   </interface>
 
+  <interface name="surface_data" version="1">
+    <description summary="the surface data offer object">
+	The shell can use this interface to receive surface information or make
+	requests for this surface.
+    </description>
+    <request name="maximize">
+      <description summary="ask the compositor to maximize the surface"/>
+    </request>
+    <request name="unmaximize">
+      <description summary="ask the compositor to unmaximize the surface"/>
+    </request>
+    <request name="minimize">
+      <description summary="ask the compositor to minimize the surface"/>
+    </request>
+    <request name="unminimize">
+      <description summary="ask the compositor to unminimize the surface"/>
+    </request>
+    <request name="focus">
+      <description summary="ask the compositor to focus the surface"/>
+    </request>
+    <request name="close">
+      <description summary="ask the compositor to close the surface"/>
+    </request>
+    <request name="destroy" type="destructor">
+      <description summary="destroy surface request">
+	The shell must send this request in response to a gone event so	the
+	compositor can destroy the object properly.
+      </description>
+    </request>
+    <event name="output_mask">
+      <description summary="send the surface object output_mask to the shell"/>
+      <arg name="output_mask" type="uint"/>
+    </event>
+    <event name="title">
+      <description summary="send the surface object title to the shell"/>
+      <arg name="title" type="string"/>
+    </event>
+    <event name="maximized">
+      <description summary="send the surface object maximize state to the shell"/>
+      <arg name="maximized" type="int"/>
+    </event>
+    <event name="minimized">
+      <description summary="send the surface object minimize state to the shell"/>
+      <arg name="minimized" type="int"/>
+    </event>
+    <event name="focused">
+      <description summary="send the surface object focus state to the shell"/>
+      <arg name="focused" type="int"/>
+    </event>
+    <event name="gone">
+      <description summary="destroy surface notification">
+	The compositor should send this event to notify the shell that a
+	surface has been destroyed. The client must respond with a destroy
+	request.
+      </description>
+    </event>
+  </interface>
+
+  <interface name="surface_data_manager" version="1">
+    <description summary="send surface object to shell">
+	The compositor can offer surface data to a shell. The client can use
+	this interface as a way to receive special surface_data objects.
+    </description>
+    <event name="surface_object">
+      <description summary="surface object">
+	Surface object sent to a shell. This object is intended to allow the
+	shell to initiate a surface_data object interface.
+      </description>
+      <arg name="id" type="new_id" interface="surface_data"/>
+    </event>
+  </interface>
+
   <interface name="screensaver" version="1">
     <description summary="interface for implementing screensavers">
       Only one client can bind this interface at a time.
diff --git a/src/compositor.c b/src/compositor.c
index 2d5b263..403f910 100644
--- a/src/compositor.c
+++ b/src/compositor.c
@@ -374,6 +374,8 @@ weston_surface_update_output_mask(struct weston_surface *es, uint32_t mask)
 		if (1 << output->id & left)
 			wl_surface_send_leave(&es->surface.resource, resource);
 	}
+
+	es->compositor->shell_interface.send_output_mask(es);
 }
 
 static void
@@ -1056,6 +1058,7 @@ WL_EXPORT void
 weston_layer_init(struct weston_layer *layer, struct wl_list *below)
 {
 	wl_list_init(&layer->surface_list);
+	wl_list_init(&layer->minimized_list);
 	if (below != NULL)
 		wl_list_insert(below, &layer->link);
 }
diff --git a/src/compositor.h b/src/compositor.h
index 121f6bf..31f1949 100644
--- a/src/compositor.h
+++ b/src/compositor.h
@@ -94,6 +94,7 @@ struct weston_shell_interface {
 	int (*move)(struct shell_surface *shsurf, struct weston_seat *ws);
 	int (*resize)(struct shell_surface *shsurf,
 		      struct weston_seat *ws, uint32_t edges);
+	void (*send_output_mask)(struct weston_surface *surface);
 
 };
 
@@ -265,6 +266,7 @@ enum {
 
 struct weston_layer {
 	struct wl_list surface_list;
+	struct wl_list minimized_list;
 	struct wl_list link;
 };
 
diff --git a/src/shell.c b/src/shell.c
index b28353e..26068cd 100644
--- a/src/shell.c
+++ b/src/shell.c
@@ -97,6 +97,8 @@ struct desktop_shell {
 		uint32_t deathstamp;
 	} child;
 
+	struct wl_resource *surface_data_manager;
+
 	bool locked;
 	bool showing_input_panels;
 	bool prepare_event_sent;
@@ -152,6 +154,11 @@ struct ping_timer {
 	uint32_t serial;
 };
 
+struct surface_data {
+	struct shell_surface *shsurf;
+	struct wl_resource resource;
+};
+
 struct shell_surface {
 	struct wl_resource resource;
 
@@ -160,11 +167,12 @@ struct shell_surface {
 	struct weston_surface *parent;
 	struct desktop_shell *shell;
 
-	enum shell_surface_type type, next_type;
+	enum shell_surface_type type, next_type, saved_type;
 	char *title, *class;
 	int32_t saved_x, saved_y;
 	bool saved_position_valid;
 	bool saved_rotation_valid;
+	bool minimized;
 	int unresponsive;
 
 	struct {
@@ -202,6 +210,7 @@ struct shell_surface {
 	struct wl_list link;
 
 	const struct weston_shell_client *client;
+	struct surface_data *surface_data;
 };
 
 struct shell_grab {
@@ -1397,6 +1406,339 @@ shell_surface_pong(struct wl_client *client, struct wl_resource *resource,
 }
 
 static void
+surface_data_destroy_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	wl_resource_destroy(resource);
+}
+
+static void
+send_surface_data_focused_state(struct weston_surface *surface);
+
+static void
+activate(struct desktop_shell *shell, struct weston_surface *es,
+	 struct weston_seat *seat);
+
+static void
+shell_surface_focus(struct shell_surface *shsurf)
+{
+	struct desktop_shell *shell;
+	struct weston_compositor *compositor;
+	struct weston_surface *surface;
+	struct weston_seat *seat;
+
+	shell = shsurf->shell;
+	compositor = shell->compositor;
+	surface = shsurf->surface;
+
+	wl_list_for_each(seat, &surface->compositor->seat_list, link)
+		if (seat->seat.keyboard) {
+			wl_keyboard_set_focus(seat->seat.keyboard,
+							&surface->surface);
+			activate(shell, surface, seat);
+		}
+
+	weston_compositor_damage_all(compositor);
+}
+
+static void
+shell_surface_minimize(struct shell_surface *shsurf)
+{
+	struct desktop_shell *shell;
+	struct weston_compositor *compositor;
+	struct weston_surface *surface;
+	struct workspace *ws;
+	struct weston_seat *seat;
+	struct weston_surface *focus;
+
+	shell = shsurf->shell;
+	compositor = shell->compositor;
+	surface = shsurf->surface;
+	ws = get_current_workspace(shell);
+
+	wl_list_remove(&surface->layer_link);
+	wl_list_insert(ws->layer.minimized_list.prev, &surface->layer_link);
+	shsurf->saved_type = shsurf->type;
+	shsurf->minimized = true;
+
+	/* Focus next surface in stack */
+	if (!wl_list_empty(&ws->layer.surface_list)) {
+		focus = container_of(ws->layer.surface_list.next,
+					 struct weston_surface,
+					 layer_link);
+		wl_list_for_each(seat, &compositor->seat_list, link)
+			if (seat->seat.keyboard &&
+			    seat->keyboard.focus == &surface->surface) {
+				shsurf = get_shell_surface(focus);
+				if (!shsurf)
+					break;
+				shell_surface_focus(shsurf);
+			}
+	}
+
+	send_surface_data_focused_state(surface);
+	wl_shell_surface_send_minimize(&shsurf->resource);
+
+	weston_compositor_damage_all(compositor);
+}
+
+static void
+surface_unminimize(struct shell_surface *shsurf, struct workspace *ws)
+{
+	struct desktop_shell *shell;
+	struct weston_compositor *compositor;
+	struct weston_surface *surface;
+
+	shell = shsurf->shell;
+	compositor = shell->compositor;
+	surface = shsurf->surface;
+
+	wl_list_remove(&surface->layer_link);
+	wl_list_insert(ws->layer.surface_list.prev, &surface->layer_link);
+	shell_surface_focus(shsurf);
+	send_surface_data_focused_state(surface);
+	wl_shell_surface_send_unminimize(&shsurf->resource);
+	shsurf->minimized = false;
+	weston_compositor_damage_all(compositor);
+}
+
+static void
+shell_surface_unminimize(struct shell_surface *shsurf)
+{
+	struct weston_surface *surface;
+	struct workspace *ws = get_current_workspace(shsurf->shell);
+
+	wl_list_for_each(surface, &ws->layer.minimized_list, layer_link)
+		if (surface == shsurf->surface) {
+			surface_unminimize(shsurf, ws);
+			return;
+		}
+}
+
+static void
+surface_data_maximize_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data = resource->data;
+
+	wl_shell_surface_send_maximize(&surface_data->shsurf->resource);
+}
+
+static void
+surface_data_unmaximize_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data = resource->data;
+
+	wl_shell_surface_send_unmaximize(&surface_data->shsurf->resource);
+}
+
+static void
+surface_data_minimize_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data = resource->data;
+
+	shell_surface_minimize(surface_data->shsurf);
+}
+
+static void
+surface_data_unminimize_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data = resource->data;
+
+	shell_surface_unminimize(surface_data->shsurf);
+}
+
+static void
+surface_data_focus_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data = resource->data;
+
+	shell_surface_focus(surface_data->shsurf);
+}
+
+static void
+surface_data_close_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data;
+	struct shell_surface *shsurf;
+	struct wl_surface *target_surface;
+	struct wl_client *target_client;
+	struct desktop_shell *shell;
+	struct weston_compositor *compositor;
+	pid_t pid;
+
+	surface_data = resource->data;
+	shsurf = surface_data->shsurf;
+	target_surface = &shsurf->surface->surface;
+	shell = shsurf->shell;
+	compositor = shell->compositor;
+
+	if (!target_surface)
+		return;
+
+	wl_signal_emit(&compositor->kill_signal, target_surface);
+
+	target_client = target_surface->resource.client;
+	wl_client_get_credentials(target_client, &pid, NULL, NULL);
+
+	/* Skip clients that we launched ourselves (the credentials of
+	 * the socketpair is ours) */
+	if (pid == getpid())
+		return;
+
+	kill(pid, SIGTERM);
+}
+
+static const struct surface_data_interface
+					surface_data_implementation = {
+	surface_data_maximize_handler,
+	surface_data_unmaximize_handler,
+	surface_data_minimize_handler,
+	surface_data_unminimize_handler,
+	surface_data_focus_handler,
+	surface_data_close_handler,
+	surface_data_destroy_handler
+};
+
+static void
+surface_data_object_destroy(struct wl_resource *resource)
+{
+	struct shell_surface *shsurf;
+	struct surface_data *surface_data = resource->data;
+
+	shsurf = surface_data->shsurf;
+
+	free(surface_data);
+
+	if (!shsurf)
+		return;
+
+	shsurf->surface_data = NULL;
+}
+
+static int
+create_surface_data(struct desktop_shell *shell, struct shell_surface *shsurf)
+{
+	struct surface_data *surface_data;
+
+	surface_data = malloc(sizeof *surface_data);
+	if (surface_data == NULL)
+		return -1;
+
+	surface_data->resource.data = surface_data;
+	surface_data->resource.object.id = 0;
+	surface_data->resource.object.interface = &surface_data_interface;
+	surface_data->resource.destroy = surface_data_object_destroy;
+	surface_data->resource.object.implementation =
+			(void (**)(void)) &surface_data_implementation;
+	surface_data->shsurf = shsurf;
+	wl_signal_init(&surface_data->resource.destroy_signal);
+
+	wl_client_add_resource(shell->surface_data_manager->client,
+					&surface_data->resource);
+
+	shsurf->surface_data = surface_data;
+
+	return 0;
+}
+
+static void
+send_surface_data_object(struct desktop_shell *shell, struct shell_surface *shsurf)
+{
+	surface_data_manager_send_surface_object(shell->surface_data_manager,
+					&shsurf->surface_data->resource);
+}
+
+static bool
+surface_is_window_list_candidate(struct weston_surface *surface,
+					struct shell_surface *out)
+{
+	struct desktop_shell *shell;
+	struct shell_surface *shsurf;
+
+	shsurf = get_shell_surface(surface);
+	if (!shsurf)
+		return false;
+
+	shell = shsurf->shell;
+
+	if (!shell->surface_data_manager)
+		return false;
+
+	switch (shsurf->type) {
+	default:
+	case SHELL_SURFACE_TRANSIENT:
+	case SHELL_SURFACE_POPUP:
+	case SHELL_SURFACE_NONE:
+		return false;
+	case SHELL_SURFACE_FULLSCREEN:
+	case SHELL_SURFACE_MAXIMIZED:
+	case SHELL_SURFACE_TOPLEVEL:
+		if (!shsurf->surface_data) {
+			if (create_surface_data(shell, shsurf))
+				return 0;
+			send_surface_data_object(shell, shsurf);
+		}
+		*out = *shsurf;
+		return true;
+	}
+}
+
+static void
+send_surface_data_output_mask(struct weston_surface *surface)
+{
+	struct shell_surface shsurf;
+
+	if (surface_is_window_list_candidate(surface, &shsurf))
+		surface_data_send_output_mask(&shsurf.surface_data->resource,
+						surface->output_mask);
+}
+
+static void
+send_surface_data_title(struct weston_surface *surface)
+{
+	struct shell_surface shsurf;
+
+	if (surface_is_window_list_candidate(surface, &shsurf))
+		surface_data_send_title(&shsurf.surface_data->resource,
+						shsurf.title == NULL ?
+						"Surface" : shsurf.title);
+}
+
+static void
+send_surface_data_minimized_state(struct weston_surface *surface)
+{
+	struct shell_surface shsurf;
+
+	if (surface_is_window_list_candidate(surface, &shsurf))
+		surface_data_send_minimized(&shsurf.surface_data->resource,
+					shsurf.minimized ? true : false);
+}
+
+static void
+send_surface_data_focused_state(struct weston_surface *surface)
+{
+	struct shell_surface shsurf;
+	struct focus_state *state;
+	struct workspace *ws;
+	bool focused = false;
+
+	if (surface_is_window_list_candidate(surface, &shsurf)) {
+		ws = get_current_workspace(shsurf.shell);
+		wl_list_for_each(state, &ws->focus_list, link)
+			if (state->keyboard_focus == shsurf.surface)
+				focused = true;
+		surface_data_send_focused(&shsurf.surface_data->resource,
+					focused);
+	}
+}
+
+static void
 shell_surface_set_title(struct wl_client *client,
 			struct wl_resource *resource, const char *title)
 {
@@ -1404,6 +1746,7 @@ shell_surface_set_title(struct wl_client *client,
 
 	free(shsurf->title);
 	shsurf->title = strdup(title);
+	send_surface_data_title(shsurf->surface);
 }
 
 static void
@@ -1466,6 +1809,7 @@ reset_shell_surface_type(struct shell_surface *surface)
 		weston_surface_set_position(surface->surface,
 					    surface->saved_x,
 					    surface->saved_y);
+		surface_data_send_maximized(&surface->surface_data->resource, false);
 		break;
 	case SHELL_SURFACE_NONE:
 	case SHELL_SURFACE_TOPLEVEL:
@@ -1502,6 +1846,7 @@ set_surface_type(struct shell_surface *shsurf)
 		shsurf->saved_x = surface->geometry.x;
 		shsurf->saved_y = surface->geometry.y;
 		shsurf->saved_position_valid = true;
+		surface_data_send_maximized(&shsurf->surface_data->resource, true);
 		break;
 
 	case SHELL_SURFACE_FULLSCREEN:
@@ -1520,6 +1865,8 @@ set_surface_type(struct shell_surface *shsurf)
 	default:
 		break;
 	}
+
+	send_surface_data_title(surface);
 }
 
 static void
@@ -1618,6 +1965,16 @@ shell_surface_set_maximized(struct wl_client *client,
 }
 
 static void
+shell_surface_set_minimized(struct wl_client *client,
+			    struct wl_resource *resource)
+{
+	struct shell_surface *shsurf = resource->data;
+
+	shell_surface_minimize(shsurf);
+	send_surface_data_minimized_state(shsurf->surface);
+}
+
+static void
 black_surface_configure(struct weston_surface *es, int32_t sx, int32_t sy);
 
 static struct weston_surface *
@@ -1924,6 +2281,7 @@ static const struct wl_shell_surface_interface shell_surface_implementation = {
 	shell_surface_set_fullscreen,
 	shell_surface_set_popup,
 	shell_surface_set_maximized,
+	shell_surface_set_minimized,
 	shell_surface_set_title,
 	shell_surface_set_class
 };
@@ -1931,6 +2289,10 @@ static const struct wl_shell_surface_interface shell_surface_implementation = {
 static void
 destroy_shell_surface(struct shell_surface *shsurf)
 {
+	if (shsurf->surface_data) {
+		shsurf->surface_data->shsurf = NULL;
+		surface_data_send_gone(&shsurf->surface_data->resource);
+	}
 	if (shsurf->popup.grab.pointer)
 		wl_pointer_end_grab(shsurf->popup.grab.pointer);
 
@@ -2012,6 +2374,7 @@ create_shell_surface(void *shell, struct weston_surface *surface,
 
 	shsurf->shell = (struct desktop_shell *) shell;
 	shsurf->unresponsive = 0;
+	shsurf->minimized = false;
 	shsurf->saved_position_valid = false;
 	shsurf->saved_rotation_valid = false;
 	shsurf->surface = surface;
@@ -2315,6 +2678,28 @@ static const struct desktop_shell_interface desktop_shell_implementation = {
 	desktop_shell_set_grab_surface
 };
 
+static void
+surface_data_send_all_info(struct desktop_shell *shell)
+{
+	struct weston_surface *surface;
+	struct workspace *ws;
+
+	ws = get_current_workspace(shell);
+
+	wl_list_for_each(surface, &ws->layer.surface_list, layer_link) {
+		send_surface_data_minimized_state(surface);
+		send_surface_data_focused_state(surface);
+		send_surface_data_output_mask(surface);
+		send_surface_data_title(surface);
+	}
+	wl_list_for_each(surface, &ws->layer.minimized_list, layer_link) {
+		send_surface_data_minimized_state(surface);
+		send_surface_data_focused_state(surface);
+		send_surface_data_output_mask(surface);
+		send_surface_data_title(surface);
+	}
+}
+
 static enum shell_surface_type
 get_shell_surface_type(struct weston_surface *surface)
 {
@@ -2650,6 +3035,7 @@ activate(struct desktop_shell *shell, struct weston_surface *es,
 		return;
 
 	state->keyboard_focus = es;
+	send_surface_data_focused_state(es);
 	wl_list_remove(&state->surface_destroy_listener.link);
 	wl_signal_add(&es->surface.resource.destroy_signal,
 		      &state->surface_destroy_listener);
@@ -2674,7 +3060,7 @@ black_surface_configure(struct weston_surface *es, int32_t sx, int32_t sy)
 {
 }
 
-static bool 
+static bool
 is_black_surface (struct weston_surface *es, struct weston_surface **fs_surface)
 {
 	if (es->configure == black_surface_configure) {
@@ -3143,6 +3529,37 @@ bind_desktop_shell(struct wl_client *client,
 }
 
 static void
+unbind_surface_data_manager(struct wl_resource *resource)
+{
+	struct desktop_shell *shell = resource->data;
+
+	shell->surface_data_manager = NULL;
+	free(resource);
+}
+
+static void
+bind_surface_data_manager(struct wl_client *client,
+		   void *data, uint32_t version, uint32_t id)
+{
+	struct desktop_shell *shell = data;
+	struct wl_resource *resource;
+
+	resource = wl_client_add_object(client, &surface_data_manager_interface,
+					NULL, id, shell);
+
+	if (client == shell->child.client) {
+		resource->destroy = unbind_surface_data_manager;
+		shell->surface_data_manager = resource;
+		surface_data_send_all_info(shell);
+		return;
+	}
+
+	wl_resource_post_error(resource, WL_DISPLAY_ERROR_INVALID_OBJECT,
+			       "permission to bind desktop_shell denied");
+	wl_resource_destroy(resource);
+}
+
+static void
 screensaver_configure(struct weston_surface *surface, int32_t sx, int32_t sy)
 {
 	struct desktop_shell *shell = surface->private;
@@ -3757,6 +4174,7 @@ module_init(struct weston_compositor *ec)
 	ec->shell_interface.set_transient = set_transient;
 	ec->shell_interface.move = surface_move;
 	ec->shell_interface.resize = surface_resize;
+	ec->shell_interface.send_output_mask = send_surface_data_output_mask;
 
 	wl_list_init(&shell->screensaver.surfaces);
 	wl_list_init(&shell->input_panel.surfaces);
@@ -3808,6 +4226,10 @@ module_init(struct weston_compositor *ec)
 				  shell, bind_workspace_manager) == NULL)
 		return -1;
 
+	if (wl_display_add_global(ec->wl_display, &surface_data_manager_interface,
+				  shell, bind_surface_data_manager) == NULL)
+		return -1;
+
 	shell->child.deathstamp = weston_compositor_get_time();
 
 	loop = wl_display_get_event_loop(ec->wl_display);

































diff --git a/protocol/remote.xml b/protocol/remote.xml
new file mode 100644
index 0000000..430a7f3
--- /dev/null
+++ b/protocol/remote.xml
@@ -0,0 +1,44 @@
+<protocol name="remote">
+
+  <interface name="remote" version="1">
+    <enum name="format">
+      <entry name="argb8888" value="0"/>
+      <entry name="xrgb8888" value="1"/>
+    </enum>
+
+    <request name="create_buffer">
+      <description summary="create wl_buffer from pool">
+	Create a wl_buffer from the pool.  The buffer is created a
+	offset bytes into the pool and has width and height as
+	specified.  The stride arguments specifies the number of bytes
+	from beginning of one row to the beginning of the next.  The
+	format is the pixel format of the buffer and must be one of
+	those advertised through the wl_shm.format event.
+
+	A buffer will keep a reference to the pool it was created from
+	so it is valid to destroy the pool immediatedly after creating
+	a buffer from it.
+      </description>
+
+      <arg name="id" type="new_id" interface="wl_buffer"/>
+      <arg name="width" type="int"/>
+      <arg name="height" type="int"/>
+      <arg name="format" type="uint"/>
+    </request>
+
+    <request name="update_buffer">
+      <arg name="buffer" type="object" interface="wl_buffer"/>
+      <arg name="tag" type="uint"
+	   summary="reference to out of band block carrying data"/> 
+      <arg name="region" type="object" interface="wl_region"/>
+    </request>
+
+    <event name="keymap">
+      <arg name="keyboard" type="object" interface="wl_keyboard"/>
+      <arg name="format" type="uint"/>
+      <arg name="tag" type="uint"/>
+      <arg name="size" type="uint"/>
+    </event>
+
+  </interface>
+</protocol>
diff --git a/src/Makefile.am b/src/Makefile.am
index fb5f8fc..5a216b6 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -76,7 +76,9 @@ module_LTLIBRARIES =				\
 	$(x11_backend)				\
 	$(drm_backend)				\
 	$(wayland_backend)			\
-	$(headless_backend)
+	$(headless_backend)			\
+	remote-proxy.la				\
+	remote-server.la
 
 # Do not install, since the binary produced via autotools is unusable.
 # The real backend is built by the Android build system.
@@ -206,6 +208,31 @@ tablet_shell_la_SOURCES =			\
 	tablet-shell-server-protocol.h
 endif
 
+remote_proxy_la_LDFLAGS = -module -avoid-version
+remote_proxy_la_LIBADD = $(COMPOSITOR_LIBS)
+remote_proxy_la_CFLAGS = $(GCC_CFLAGS) $(COMPOSITOR_CFLAGS)
+remote_proxy_la_SOURCES =			\
+	remote-proxy.c				\
+	remote-stream.c				\
+	remote-stream.h				\
+	remote-protocol.c			\
+	remote-client-protocol.h		\
+	../shared/os-compatibility.c		\
+	../shared/os-compatibility.h
+
+remote_server_la_LDFLAGS = -module -avoid-version
+remote_server_la_LIBADD = $(COMPOSITOR_LIBS)
+remote_server_la_CFLAGS = $(GCC_CFLAGS) $(COMPOSITOR_CFLAGS)
+remote_server_la_SOURCES =			\
+	remote-server.c				\
+	remote-stream.c				\
+	remote-stream.h				\
+	remote-protocol.c			\
+	remote-server-protocol.h		\
+	../shared/os-compatibility.c		\
+	../shared/os-compatibility.h
+
+
 BUILT_SOURCES =					\
 	screenshooter-server-protocol.h		\
 	screenshooter-protocol.c		\
@@ -221,6 +248,9 @@ BUILT_SOURCES =					\
 	input-method-server-protocol.h		\
 	workspaces-server-protocol.h		\
 	workspaces-protocol.c			\
+	remote-protocol.c			\
+	remote-client-protocol.h		\
+	remote-server-protocol.h		\
 	git-version.h
 
 CLEANFILES = $(BUILT_SOURCES)
diff --git a/src/compositor.c b/src/compositor.c
index 83bd244..767befb 100644
--- a/src/compositor.c
+++ b/src/compositor.c
@@ -2121,6 +2121,7 @@ seat_get_keyboard(struct wl_client *client, struct wl_resource *resource,
 		  uint32_t id)
 {
 	struct weston_seat *seat = resource->data;
+	struct weston_compositor *ec = seat->compositor;
 	struct wl_resource *cr;
 
 	if (!seat->seat.keyboard)
@@ -2131,9 +2132,11 @@ seat_get_keyboard(struct wl_client *client, struct wl_resource *resource,
 	wl_list_insert(&seat->seat.keyboard->resource_list, &cr->link);
 	cr->destroy = unbind_resource;
 
-	wl_keyboard_send_keymap(cr, WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1,
-				seat->xkb_info.keymap_fd,
-				seat->xkb_info.keymap_size);
+	if (!ec->try_send_keymap ||
+	    ec->try_send_keymap(client, seat, cr) < 0)
+		wl_keyboard_send_keymap(cr, WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1,
+					seat->xkb_info.keymap_fd,
+					seat->xkb_info.keymap_size);
 
 	if (seat->seat.keyboard->focus &&
 	    seat->seat.keyboard->focus->resource.client == client) {
diff --git a/src/compositor.h b/src/compositor.h
index d2e121b..3416318 100644
--- a/src/compositor.h
+++ b/src/compositor.h
@@ -373,6 +373,10 @@ struct weston_compositor {
 	struct xkb_rule_names xkb_names;
 	struct xkb_context *xkb_context;
 	struct weston_xkb_info xkb_info;
+
+	int (*try_send_keymap)(struct wl_client *client,
+			       struct weston_seat *seat,
+			       struct wl_resource *cr);
 };
 
 struct weston_region {
diff --git a/src/remote-proxy.c b/src/remote-proxy.c
new file mode 100644
index 0000000..d715e23
--- /dev/null
+++ b/src/remote-proxy.c
@@ -0,0 +1,1368 @@
+/*
+ * Copyright  2012 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of the copyright holders not be used in
+ * advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  The copyright holders make
+ * no representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <linux/input.h>
+#include <sys/uio.h>
+#include <assert.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <errno.h>
+
+#include <wayland-server.h>
+#include <wayland-client.h>
+#include "compositor.h"
+
+#include "../shared/os-compatibility.h"
+
+#include "remote-stream.h"
+#include "remote-client-protocol.h"
+
+/*
+ * - Don't abuse weston_seat, weston_output etc.
+ *
+ * - Encapsulate fd users in abstract objects?  wl_buffer,
+ *   wl_keyboard_map... idea is to keep most of core protocol the
+ *   same, but allow the out of band usage to be encapsulated.
+ *
+ * - Minimize shm update regions.
+ *
+ * - Surface enter/leave.
+ *
+ * - Different background image for other compositor (for demos).
+ *
+ */
+
+struct remote {
+	struct weston_compositor *compositor;
+	struct wl_listener destroy_listener;
+	struct wl_display *display;
+	struct wl_registry *registry;
+	struct wl_list surface_list;
+	struct wl_compositor *remote_compositor;
+	struct wl_shell *shell;
+	struct wl_event_source *source;
+	uint32_t event_mask;
+
+	int protocol_fd[2];
+	char protocol_buffer[4096];
+	struct wl_event_source *protocol_source;
+	struct remote_stream *stream;
+	struct remote *proxy_remote;
+
+	struct remote_stream_block protocol_stream_block;
+};
+
+struct remote_output {
+	struct weston_output output;
+	struct remote *remote;
+	struct wl_output *proxy;
+};
+
+struct remote_seat {
+	struct wl_seat seat;
+	struct remote *remote;
+	struct wl_seat *proxy;
+	struct wl_pointer *proxy_pointer;
+	struct wl_keyboard *proxy_keyboard;
+	uint32_t enter_serial;
+	struct wl_pointer pointer;
+	struct wl_keyboard keyboard;
+
+	int keymap_fd;
+	void *keymap_area;
+	size_t keymap_size;
+};
+
+struct shell_surface {
+	struct wl_resource resource;
+	struct weston_surface *surface;
+};
+
+struct remote_surface {
+	struct weston_surface *surface;
+	struct wl_surface *proxy;
+	struct wl_shell_surface *proxy_shell_surface;
+
+	struct shell_surface *shell_surface;
+
+	struct remote *remote;
+	struct wl_buffer *proxy_buffer;
+	void *map;
+	int width, height;
+
+	uint32_t remote_ping_serial;
+	uint32_t subst_ping_serial;
+
+	struct wl_listener destroy_listener;
+
+	const struct wl_surface_interface *interface;
+	const struct wl_shell_surface_interface *shell_surface_interface;
+	GLuint fbo;
+
+	struct remote_stream_block stream_block;
+};
+
+static struct remote_seat *
+is_remote_seat(struct wl_resource *resource);
+
+static void
+destroy_remote(struct wl_listener *listener, void *data);
+
+static int
+keymap_tag_handler(struct remote_stream *stream,
+		   size_t remain, void *data)
+{
+	struct remote_seat *seat = data;
+	int len;
+
+	if (stream->len == 0) {
+		seat->keymap_size = stream->total;
+		seat->keymap_fd =
+			os_create_anonymous_file(seat->keymap_size);
+		seat->keymap_area = mmap(NULL, seat->keymap_size,
+					 PROT_READ | PROT_WRITE,
+					 MAP_SHARED,
+					 seat->keymap_fd, 0);
+	}
+
+	len = read(stream->fd, seat->keymap_area + stream->len, remain);
+	if (len < 0)
+		return -1;
+
+	stream->len += len;
+
+	return len;
+}
+
+static int
+stream_data(int fd, uint32_t mask, void *data)
+{
+	struct remote *remote = data;
+
+	if (mask & (WL_EVENT_HANGUP | WL_EVENT_ERROR)) {
+		fprintf(stderr, "stream_data: hangup\n");
+		destroy_remote(&remote->destroy_listener, NULL);
+		return 1;
+	}
+
+	if (mask & WL_EVENT_WRITABLE) {
+		remote_stream_write(remote->stream);
+		if (wl_list_empty(&remote->stream->block_queue)) {
+			wl_event_source_fd_update(remote->source,
+						  WL_EVENT_READABLE);
+			wl_event_source_fd_update(remote->stream->source,
+						  WL_EVENT_READABLE);
+		}
+	}
+
+	if (mask & WL_EVENT_READABLE)
+		remote_stream_read(remote->stream);
+
+	return 1;
+}
+ 
+static int
+protocol_data(int fd, uint32_t mask, void *data)
+{
+	struct remote *remote = data;
+	struct remote_stream_block *block;
+	int len;
+
+	len = read(fd, remote->protocol_buffer,
+		   sizeof remote->protocol_buffer);
+
+	block = &remote->protocol_stream_block;
+	wl_list_insert(&remote->stream->block_queue, &block->link);
+	block->tag = 0;
+	block->written = 0;
+	block->size = len;
+	block->data = remote->protocol_buffer;
+
+	/* FIXME: Try non-blocking write before switching poll masks
+	 * around. */
+	wl_event_source_fd_update(remote->source, 0);
+	wl_event_source_fd_update(remote->stream->source,
+				  WL_EVENT_READABLE | WL_EVENT_WRITABLE);
+
+	return 1;
+}
+
+static int
+protocol_tag_handler(struct remote_stream *stream, size_t remain, void *data)
+{
+	struct remote *remote = data;
+	char buffer[4096];
+	int len;
+
+	if (remain > sizeof buffer)
+		len = sizeof buffer;
+	else
+		len = remain;
+
+	len = read(stream->fd, buffer, len);
+	stream->len += len;
+	write(remote->protocol_fd[0], buffer, len);
+
+	return 1;
+}
+
+static struct remote_stream *
+remote_stream_connect(struct remote *remote,
+		      const char *hostname, int port)
+{
+	struct wl_event_loop *loop =
+		wl_display_get_event_loop(remote->compositor->wl_display);
+	struct remote_stream *stream;
+	struct sockaddr_in name;
+	struct hostent *hostinfo;
+
+	stream = malloc(sizeof *stream);
+	if (stream == NULL)
+		return NULL;
+
+	memset(stream, 0, sizeof *stream);
+	stream->tag_handler[0].func = protocol_tag_handler;
+	stream->tag_handler[0].data = remote;
+	stream->tag = 1;
+	stream->tag_handler_count = 1;
+	wl_list_init(&stream->block_queue);
+
+	hostinfo = gethostbyname(hostname);
+	if (hostinfo == NULL) {
+		weston_log("Unknown host %s.\n", hostname);
+		free(stream);
+		return NULL;
+	}
+
+	name.sin_family = AF_INET;
+	name.sin_port = htons(port);
+	name.sin_addr = *(struct in_addr *) hostinfo->h_addr;
+
+	stream->fd = socket(PF_INET,
+			    SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);
+	if (stream->fd < 0) {
+		weston_log("Failed to create socket for remote stream: %m.\n");
+		free(stream);
+		return NULL;
+	}
+	
+	if (connect(stream->fd, (struct sockaddr *) &name, sizeof name) < 0 &&
+	    errno != EINPROGRESS) {
+		weston_log("Could not connect to remote server: %m.\n");
+		return NULL;
+	}
+
+	/* FIXME: Poll socket for writability, check for error with
+	 * getsockopt for SO_ERROR, level SOL_SOCKET. */
+
+	stream->source =
+		wl_event_loop_add_fd(loop, stream->fd,
+				     WL_EVENT_READABLE, stream_data, remote);
+
+	return stream;
+}
+
+static void
+surface_enter(void *data,
+	      struct wl_surface *wl_surface, struct wl_output *wl_output)
+{
+}
+
+static void
+surface_leave(void *data,
+	      struct wl_surface *wl_surface, struct wl_output *output)
+{
+}
+
+static const struct wl_surface_listener surface_listener = {
+	surface_enter,
+	surface_leave
+};
+
+static void
+shell_surface_handle_ping(void *data, struct wl_shell_surface *shell_surface,
+			  uint32_t serial)
+{
+	struct remote_surface *surface = data;
+	struct weston_compositor *compositor = surface->remote->compositor;
+
+	surface->remote_ping_serial = serial;
+	surface->subst_ping_serial =
+		wl_display_get_serial(compositor->wl_display);
+	wl_shell_surface_send_ping(&surface->shell_surface->resource,
+				   surface->subst_ping_serial);
+}
+
+static void
+shell_surface_handle_configure(void *data,
+			       struct wl_shell_surface *shell_surface,
+			       uint32_t edges, int32_t width, int32_t height)
+{
+	struct remote_surface *surface = data;
+
+	wl_shell_surface_send_configure(&surface->shell_surface->resource,
+					edges, width, height);
+}
+
+static void
+shell_surface_handle_popup_done(void *data,
+				struct wl_shell_surface *shell_surface)
+{
+}
+
+static const struct wl_shell_surface_listener shell_surface_listener = {
+	shell_surface_handle_ping,
+	shell_surface_handle_configure,
+	shell_surface_handle_popup_done
+};
+
+static void
+remote_surface_commit(struct remote_surface *surface)
+{
+	struct remote *remote = surface->remote;
+	struct wl_buffer *buffer = surface->surface->buffer;
+	struct wl_region *region;
+	void *data;
+	int size;
+
+	size = surface->width * 4 * surface->height;
+	if (buffer && wl_buffer_is_shm(buffer)) {
+		data = wl_shm_buffer_get_data(buffer);
+		memcpy(surface->map, data, size);
+	} else {
+		glGenFramebuffers(1, &surface->fbo);
+		glBindFramebuffer(GL_FRAMEBUFFER, surface->fbo);
+		glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
+				       GL_TEXTURE_2D, surface->surface->textures[0], 0);
+
+		glReadPixels(0, 0, surface->width, surface->height,
+			     remote->compositor->read_format,
+			     GL_UNSIGNED_BYTE, surface->map);
+
+		glBindFramebuffer(GL_FRAMEBUFFER, 0);
+	}
+
+	remote_stream_queue_block(remote->stream,
+				  &surface->stream_block, surface->map,
+				  surface->width * 4 * surface->height);
+	region = wl_compositor_create_region(remote->remote_compositor);
+	wl_region_add(region, 0, 0, surface->width, surface->height);
+	remote_update_buffer(remote->proxy_remote, surface->proxy_buffer,
+			     surface->stream_block.tag, region);
+	wl_region_destroy(region);
+
+	wl_surface_damage(surface->proxy,
+			  0, 0, surface->width, surface->height);
+}
+
+static void
+remote_surface_destroy(struct wl_listener *listener, void *data)
+{
+	struct remote_surface *surface =
+		container_of(listener,
+			     struct remote_surface, destroy_listener);
+
+	wl_surface_destroy(surface->proxy);
+	if (surface->proxy_shell_surface)
+		wl_shell_surface_destroy(surface->proxy_shell_surface);
+
+	free(surface);
+}
+
+static struct remote_surface *
+get_remote_surface(struct wl_resource *resource)
+{
+	struct wl_listener *listener;
+
+	listener = wl_signal_get(&resource->destroy_signal,
+				 remote_surface_destroy);
+
+	if (listener == NULL)
+		return NULL;
+
+	return container_of(listener, struct remote_surface, destroy_listener);
+}
+
+static void
+surface_handle_destroy(struct wl_client *client, struct wl_resource *resource)
+{
+	struct remote_surface *surface = get_remote_surface(resource);
+
+	surface->interface->destroy(client, resource);
+}
+
+static void
+remote_surface_attach(struct remote_surface *surface,
+		      struct wl_buffer *buffer, int32_t sx, int32_t sy)
+{
+	struct remote *remote = surface->remote;
+	struct weston_compositor *compositor = remote->compositor;
+	int stride, size;
+	uint32_t format;
+	EGLint texture_format;
+
+	if (surface->proxy_buffer != NULL && buffer != NULL &&
+	    surface->width == buffer->width &&
+	    surface->height == buffer->height)
+		return;
+
+	if (surface->proxy_buffer != NULL)
+		wl_buffer_destroy(surface->proxy_buffer);
+
+	if (buffer == NULL) {
+		wl_surface_attach(surface->proxy, NULL, sx, sy);
+		return;
+	}
+
+	stride = buffer->width * 4;
+	size = stride * buffer->height;
+
+	if (wl_buffer_is_shm(buffer)) {
+		/* Remote formats match shm formats */
+		format = wl_shm_buffer_get_format(buffer);
+	} else if (compositor->query_buffer(compositor->egl_display, buffer,
+					    EGL_TEXTURE_FORMAT,
+					    &texture_format)) {
+		switch (texture_format) {
+		case EGL_TEXTURE_RGB:
+			format = REMOTE_FORMAT_XRGB8888;
+			break;
+		case EGL_TEXTURE_RGBA:
+			format = REMOTE_FORMAT_ARGB8888;
+			break;
+		default:
+			weston_log("can't forward yuv surfaces\n");
+			return;
+		}
+	} else {
+		weston_log("unhandled surface type\n");
+		return;
+	}
+
+	surface->width = buffer->width;
+	surface->height = buffer->height;
+	surface->map = malloc(size);
+
+	surface->proxy_buffer =
+		remote_create_buffer(remote->proxy_remote,
+				     buffer->width, buffer->height, format);
+
+	wl_surface_attach(surface->proxy, surface->proxy_buffer, sx, sy);
+}
+
+static void
+surface_handle_attach(struct wl_client *client,
+		      struct wl_resource *resource,
+		      struct wl_resource *buffer_resource,
+		      int32_t sx, int32_t sy)
+{
+	struct remote_surface *surface = get_remote_surface(resource);
+	struct wl_buffer *buffer = NULL;
+
+	surface->interface->attach(client, resource, buffer_resource, sx, sy);
+
+	if (buffer_resource)
+		buffer = buffer_resource->data;
+
+	remote_surface_attach(surface, buffer, sx, sy);
+}
+
+static void
+surface_handle_damage(struct wl_client *client,
+		      struct wl_resource *resource,
+		      int32_t x, int32_t y, int32_t width, int32_t height)
+{
+	struct remote_surface *surface = get_remote_surface(resource);
+
+	surface->interface->damage(client, resource, x, y, width, height);
+}
+
+static void
+surface_handle_frame(struct wl_client *client,
+		     struct wl_resource *resource, uint32_t callback)
+{
+	struct remote_surface *surface = get_remote_surface(resource);
+
+	surface->interface->frame(client, resource, callback);
+}
+
+static struct wl_region *
+get_remote_region(struct remote *remote, pixman_region32_t *region)
+{
+	struct wl_region *remote_region;
+	pixman_box32_t *rectangles;
+	int i, n;
+
+	remote_region = wl_compositor_create_region(remote->remote_compositor);
+	rectangles = pixman_region32_rectangles(region, &n);
+	for (i = 0; i < n; i++)
+		wl_region_add(remote_region,
+			      rectangles[i].x1, rectangles[i].y1,
+			      rectangles[i].x2 - rectangles[i].x1,
+			      rectangles[i].y2 - rectangles[i].y1);
+
+	return remote_region;
+}
+
+static void
+surface_handle_set_opaque_region(struct wl_client *client,
+				 struct wl_resource *resource,
+				 struct wl_resource *region_resource)
+{
+	struct remote_surface *surface = get_remote_surface(resource);
+	struct weston_region *region = region_resource->data;
+	struct wl_region *proxy;
+
+	surface->interface->set_opaque_region(client,
+					      resource, region_resource);
+
+	proxy = get_remote_region(surface->remote, &region->region);
+	wl_surface_set_opaque_region(surface->proxy, proxy);
+	wl_region_destroy(proxy);
+}
+
+static void
+surface_handle_set_input_region(struct wl_client *client,
+				struct wl_resource *resource,
+				struct wl_resource *region_resource)
+{
+	struct remote_surface *surface = get_remote_surface(resource);
+	struct weston_region *region = region_resource->data;
+	struct wl_region *proxy;
+
+	surface->interface->set_input_region(client,
+					     resource, region_resource);
+
+	proxy = get_remote_region(surface->remote, &region->region);
+	wl_surface_set_input_region(surface->proxy, proxy);
+	wl_region_destroy(proxy);
+}
+
+static void
+surface_handle_commit(struct wl_client *client,
+		      struct wl_resource *resource)
+{
+	struct remote_surface *surface = get_remote_surface(resource);
+
+	surface->interface->commit(client, resource);
+
+	remote_surface_commit(surface);
+
+	wl_surface_commit(surface->proxy);
+}
+
+static const struct wl_surface_interface surface_interface = {
+	surface_handle_destroy,
+	surface_handle_attach,
+	surface_handle_damage,
+	surface_handle_frame,
+	surface_handle_set_opaque_region,
+	surface_handle_set_input_region,
+	surface_handle_commit
+};
+
+
+static void
+shell_surface_handle_pong(struct wl_client *client,
+			  struct wl_resource *resource, uint32_t serial)
+{
+	struct shell_surface *shell_surface = resource->data;
+	struct remote_surface *surface =
+		get_remote_surface(&shell_surface->surface->surface.resource);
+
+	if (serial == surface->subst_ping_serial)
+		wl_shell_surface_pong(surface->proxy_shell_surface,
+				      surface->remote_ping_serial);
+	else
+		surface->shell_surface_interface->pong(client,
+						       resource, serial);
+}
+
+static void
+shell_surface_handle_move(struct wl_client *client,
+			  struct wl_resource *resource,
+			  struct wl_resource *seat_resource, uint32_t serial)
+{
+	struct remote_seat *seat;
+	struct shell_surface *shell_surface = resource->data;
+	struct remote_surface *surface =
+		get_remote_surface(&shell_surface->surface->surface.resource);
+
+	seat = is_remote_seat(seat_resource);
+	if (seat) {
+		wl_shell_surface_move(surface->proxy_shell_surface,
+				      seat->proxy, serial);
+	} else {
+		surface->shell_surface_interface->move(client, resource,
+						       seat_resource, serial);
+	}
+}
+
+static void
+shell_surface_handle_resize(struct wl_client *client,
+			    struct wl_resource *resource,
+			    struct wl_resource *seat_resource,
+			    uint32_t serial, uint32_t edges)
+{
+	struct remote_seat *seat;
+	struct shell_surface *shell_surface = resource->data;
+	struct remote_surface *surface =
+		get_remote_surface(&shell_surface->surface->surface.resource);
+
+	seat = is_remote_seat(seat_resource);
+	if (seat) {
+		wl_shell_surface_resize(surface->proxy_shell_surface,
+					seat->proxy, serial, edges);
+	} else {
+		surface->shell_surface_interface->resize(client, resource,
+							 seat_resource,
+							 serial, edges);
+	}
+}
+
+static void
+shell_surface_handle_set_toplevel(struct wl_client *client,
+				  struct wl_resource *resource)
+{
+}
+
+static void
+shell_surface_handle_set_transient(struct wl_client *client,
+				   struct wl_resource *resource,
+				   struct wl_resource *parent_resource,
+				   int x, int y, uint32_t flags)
+{
+}
+
+static void
+shell_surface_handle_set_fullscreen(struct wl_client *client,
+				    struct wl_resource *resource,
+				    uint32_t method,
+				    uint32_t framerate,
+				    struct wl_resource *output_resource)
+{
+	/* FIXME: How could this ever work with different size outputs */
+}
+
+static void
+shell_surface_handle_set_popup(struct wl_client *client,
+			       struct wl_resource *resource,
+			       struct wl_resource *seat_resource,
+			       uint32_t serial,
+			       struct wl_resource *parent_resource,
+			       int32_t x, int32_t y, uint32_t flags)
+{
+}
+
+static void
+shell_surface_handle_set_maximized(struct wl_client *client,
+				   struct wl_resource *resource,
+				   struct wl_resource *output_resource)
+{
+}
+
+static void
+shell_surface_handle_set_title(struct wl_client *client,
+			       struct wl_resource *resource, const char *title)
+{
+}
+
+static void
+shell_surface_handle_set_class(struct wl_client *client,
+			       struct wl_resource *resource, const char *class)
+{
+}
+
+static const struct wl_shell_surface_interface shell_surface_implementation = {
+	shell_surface_handle_pong,
+	shell_surface_handle_move,
+	shell_surface_handle_resize,
+	shell_surface_handle_set_toplevel,
+	shell_surface_handle_set_transient,
+	shell_surface_handle_set_fullscreen,
+	shell_surface_handle_set_popup,
+	shell_surface_handle_set_maximized,
+	shell_surface_handle_set_title,
+	shell_surface_handle_set_class
+};
+
+static struct remote_surface *
+remote_surface_create(struct remote *remote, struct weston_surface *surface,
+		      struct shell_surface *shell_surface)
+{
+	struct remote_surface *rs;
+	struct wl_region *proxy;
+
+	weston_log("creating remote surface for %p\n", surface);
+
+	rs = malloc(sizeof *rs);
+	if (rs == NULL)
+		return NULL;
+
+	memset(rs, 0, sizeof *rs);
+	rs->remote = remote;
+	rs->surface = surface;
+	wl_list_init(&rs->stream_block.link);
+	rs->proxy = wl_compositor_create_surface(remote->remote_compositor);
+	wl_surface_add_listener(rs->proxy, &surface_listener, rs);
+
+	rs->destroy_listener.notify = remote_surface_destroy;
+	wl_signal_add(&surface->surface.resource.destroy_signal,
+		      &rs->destroy_listener);
+
+	rs->interface = (const struct wl_surface_interface *)
+		surface->surface.resource.object.implementation;
+	surface->surface.resource.object.implementation =
+		(void *) &surface_interface;
+
+	rs->shell_surface = shell_surface;
+	if (shell_surface) {
+		rs->proxy_shell_surface =
+			wl_shell_get_shell_surface(remote->shell, rs->proxy);
+		wl_shell_surface_add_listener(rs->proxy_shell_surface,
+					      &shell_surface_listener, rs);
+
+		wl_shell_surface_set_toplevel(rs->proxy_shell_surface);
+
+		rs->shell_surface_interface =
+			(const struct wl_shell_surface_interface *)
+			rs->shell_surface->resource.object.implementation;
+		rs->shell_surface->resource.object.implementation =
+			(void *) &shell_surface_implementation;
+	}
+
+	if (surface->buffer) {
+		remote_surface_attach(rs, surface->buffer, 0, 0);
+		remote_surface_commit(rs);
+	}
+
+	if (pixman_region32_not_empty(&surface->opaque)) {
+		proxy = get_remote_region(remote, &surface->opaque);
+		wl_surface_set_opaque_region(rs->proxy, proxy);
+		wl_region_destroy(proxy);
+	}
+
+	if (pixman_region32_not_empty(&surface->input)) {
+		proxy = get_remote_region(remote, &surface->input);
+		wl_surface_set_input_region(rs->proxy, proxy);
+		wl_region_destroy(proxy);
+	}
+
+	wl_surface_commit(rs->proxy);
+	wl_display_flush(remote->display);
+
+	return rs;
+}
+
+static void
+remote_binding(struct wl_seat *seat, uint32_t time, uint32_t key, void *data)
+{
+	struct remote *remote = data;
+	struct weston_surface *surface;
+
+	if (seat->keyboard->focus == NULL)
+		return;
+
+	/* FIXME: Verify this is a shell surface, handle other surface
+	 * types (eg cursor) */
+
+	surface = (struct weston_surface *) seat->keyboard->focus;
+	remote_surface_create(remote, surface, surface->private);
+
+#if 0
+	wl_list_remove(&surface->layer_link);
+	wl_list_insert(&remote->surface_list, &surface->layer_link);
+	weston_surface_schedule_repaint(surface);
+#endif
+}
+
+static void
+pointer_handle_set_cursor(struct wl_client *client,
+			  struct wl_resource *resource,
+			  uint32_t serial,
+			  struct wl_resource *surface_resource,
+			  int32_t x, int32_t y)
+{
+	struct remote_seat *seat = resource->data;
+	struct weston_surface *surface;
+	struct remote_surface *remote_surface;
+
+	if (surface_resource == NULL) {
+		wl_pointer_set_cursor(seat->proxy_pointer,
+				      seat->enter_serial, NULL, x, y);
+		return;
+	}
+
+	surface = surface_resource->data;
+	remote_surface = get_remote_surface(surface_resource);
+	if (remote_surface == NULL)
+		remote_surface = remote_surface_create(seat->remote,
+						       surface, NULL);
+
+	wl_pointer_set_cursor(seat->proxy_pointer, seat->enter_serial,
+			      remote_surface->proxy, x, y);
+}
+
+static const struct wl_pointer_interface pointer_implementation = {
+	pointer_handle_set_cursor
+};
+
+static void
+pointer_handle_enter(void *data, struct wl_pointer *pointer,
+		     uint32_t serial, struct wl_surface *wl_surface,
+		     wl_fixed_t sx, wl_fixed_t sy)
+{
+	struct remote_seat *seat = data;
+	struct remote_surface *surface = wl_surface_get_user_data(wl_surface);
+
+	wl_pointer_set_focus(&seat->pointer,
+			     &surface->surface->surface, sx, sy);
+}
+
+static void
+pointer_handle_leave(void *data, struct wl_pointer *pointer,
+		     uint32_t serial, struct wl_surface *surface)
+{
+	struct remote_seat *seat = data;
+
+	wl_pointer_set_focus(&seat->pointer, NULL, 0, 0);
+}
+
+static void
+pointer_handle_motion(void *data, struct wl_pointer *pointer,
+		      uint32_t time, wl_fixed_t x, wl_fixed_t y)
+{
+	struct remote_seat *seat = data;
+	struct wl_resource *resource = seat->pointer.focus_resource;
+
+	if (resource)
+		wl_pointer_send_motion(resource, time, x, y);
+}
+
+static void
+pointer_handle_button(void *data, struct wl_pointer *pointer, uint32_t serial,
+		      uint32_t time, uint32_t button, uint32_t state)
+{
+	struct remote_seat *seat = data;
+	struct wl_resource *resource = seat->pointer.focus_resource;
+
+	/* FIXME: translate serials? */
+
+	if (resource)
+		wl_pointer_send_button(resource, serial, time, button, state);
+}
+
+static void
+pointer_handle_axis(void *data, struct wl_pointer *pointer,
+		    uint32_t time, uint32_t axis, wl_fixed_t value)
+{
+	struct remote_seat *seat = data;
+	struct wl_resource *resource = seat->pointer.focus_resource;
+
+	if (resource)
+		wl_pointer_send_axis(resource, time, axis, value);
+}
+
+static const struct wl_pointer_listener pointer_listener = {
+	pointer_handle_enter,
+	pointer_handle_leave,
+	pointer_handle_motion,
+	pointer_handle_button,
+	pointer_handle_axis,
+};
+
+static void
+keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
+		       uint32_t format, int fd, uint32_t size)
+{
+	/* We'll never get this event. */
+}
+
+static void
+keyboard_handle_enter(void *data, struct wl_keyboard *keyboard,
+		      uint32_t serial, struct wl_surface *wl_surface,
+		      struct wl_array *keys)
+{
+	struct remote_seat *seat = data;
+	struct remote_surface *surface = wl_surface_get_user_data(wl_surface);
+
+	wl_keyboard_set_focus(&seat->keyboard,
+			      &surface->surface->surface);
+}
+
+static void
+keyboard_handle_leave(void *data, struct wl_keyboard *keyboard,
+		      uint32_t serial, struct wl_surface *surface)
+{
+	struct remote_seat *seat = data;
+
+	wl_keyboard_set_focus(&seat->keyboard, NULL);
+}
+
+static void
+keyboard_handle_key(void *data, struct wl_keyboard *keyboard,
+		    uint32_t serial, uint32_t time, uint32_t key,
+		    uint32_t state)
+{
+	struct remote_seat *seat = data;
+	struct wl_resource *resource = seat->keyboard.focus_resource;
+
+	if (resource)
+		wl_keyboard_send_key(resource, serial, time, key, state);
+}
+
+static void
+keyboard_handle_modifiers(void *data, struct wl_keyboard *keyboard,
+			  uint32_t serial, uint32_t mods_depressed,
+			  uint32_t mods_latched, uint32_t mods_locked,
+			  uint32_t group)
+{
+	struct remote_seat *seat = data;
+	struct wl_resource *resource = seat->keyboard.focus_resource;
+
+	if (resource)
+		wl_keyboard_send_modifiers(resource, serial, mods_depressed,
+					   mods_latched, mods_locked, group);
+}
+
+static const struct wl_keyboard_listener keyboard_listener = {
+	keyboard_handle_keymap,
+	keyboard_handle_enter,
+	keyboard_handle_leave,
+	keyboard_handle_key,
+	keyboard_handle_modifiers,
+};
+
+static void
+seat_handle_capabilities(void *data, struct wl_seat *wl_seat,
+			 enum wl_seat_capability capabilities)
+{
+	struct remote_seat *seat = data;
+
+	if (capabilities & WL_SEAT_CAPABILITY_POINTER) {
+		seat->proxy_pointer = wl_seat_get_pointer(seat->proxy);
+		wl_pointer_add_listener(seat->proxy_pointer,
+					&pointer_listener, seat);
+
+		wl_pointer_init(&seat->pointer);
+		wl_seat_set_pointer(&seat->seat, &seat->pointer);
+
+	} else {
+		wl_pointer_destroy(seat->proxy_pointer);
+		seat->proxy_pointer = NULL;
+	}
+
+	if (capabilities & WL_SEAT_CAPABILITY_KEYBOARD) {
+		seat->proxy_keyboard = wl_seat_get_keyboard(seat->proxy);
+		wl_keyboard_add_listener(seat->proxy_keyboard,
+					 &keyboard_listener, seat);
+
+		wl_keyboard_init(&seat->keyboard);
+		wl_seat_set_keyboard(&seat->seat, &seat->keyboard);
+	} else {
+		wl_keyboard_destroy(seat->proxy_keyboard);
+		seat->proxy_keyboard = NULL;
+	}
+}
+
+static const struct wl_seat_listener seat_listener = {
+	seat_handle_capabilities,
+};
+
+static void unbind_resource(struct wl_resource *resource)
+{
+	wl_list_remove(&resource->link);
+	free(resource);
+}
+
+static void
+remote_seat_get_pointer(struct wl_client *client,
+			struct wl_resource *resource, uint32_t id)
+{
+	struct remote_seat *seat = resource->data;
+	struct wl_resource *cr;
+
+	if (!seat->proxy_pointer)
+		return;
+
+        cr = wl_client_add_object(client, &wl_pointer_interface,
+				  &pointer_implementation, id, seat);
+	wl_list_insert(&seat->pointer.resource_list, &cr->link);
+	cr->destroy = unbind_resource;
+}
+
+static void
+remote_seat_get_keyboard(struct wl_client *client,
+			 struct wl_resource *resource, uint32_t id)
+{
+	struct remote_seat *seat = resource->data;
+	struct wl_resource *cr;
+
+	if (!seat->proxy_keyboard)
+		return;
+
+        cr = wl_client_add_object(client, &wl_keyboard_interface,
+				  NULL, id, seat);
+	wl_list_insert(&seat->keyboard.resource_list, &cr->link);
+	cr->destroy = unbind_resource;
+
+	wl_keyboard_send_keymap(cr, WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1,
+				seat->keymap_fd,
+				seat->keymap_size);
+
+	if (seat->seat.keyboard->focus &&
+	    seat->seat.keyboard->focus->resource.client == client) {
+		wl_keyboard_set_focus(seat->seat.keyboard,
+				      seat->seat.keyboard->focus);
+	}
+}
+
+static void
+remote_seat_get_touch(struct wl_client *client,
+		      struct wl_resource *resource, uint32_t id)
+{
+}
+
+static const struct wl_seat_interface remote_seat_interface = {
+	remote_seat_get_pointer,
+	remote_seat_get_keyboard,
+	remote_seat_get_touch,
+};
+
+static struct remote_seat *
+is_remote_seat(struct wl_resource *resource)
+{
+	if (resource->object.implementation == (void *) &remote_seat_interface)
+		return resource->data;
+	else
+		return NULL;
+}
+
+static void
+bind_seat(struct wl_client *client, void *data, uint32_t version, uint32_t id)
+{
+	struct remote_seat *seat = data;
+	struct wl_resource *resource;
+	enum wl_seat_capability caps = 0;
+
+	resource = wl_client_add_object(client, &wl_seat_interface,
+					&remote_seat_interface, id, seat);
+	wl_list_insert(&seat->seat.base_resource_list, &resource->link);
+	resource->destroy = unbind_resource;
+
+	if (seat->proxy_pointer)
+		caps |= WL_SEAT_CAPABILITY_POINTER;
+	if (seat->proxy_keyboard)
+		caps |= WL_SEAT_CAPABILITY_KEYBOARD;
+
+	wl_seat_send_capabilities(resource, caps);
+}
+
+static void
+remote_add_seat(struct remote *remote, uint32_t id)
+{
+	struct remote_seat *seat;
+
+	seat = malloc(sizeof *seat);
+	if (seat == NULL)
+		return;
+
+	memset(seat, 0, sizeof *seat);
+
+	seat->remote = remote;
+	seat->proxy = wl_registry_bind(remote->registry, id,
+				       &wl_seat_interface, 1);
+	wl_seat_add_listener(seat->proxy, &seat_listener, seat);
+
+	wl_seat_init(&seat->seat);
+	wl_display_add_global(seat->remote->compositor->wl_display,
+			      &wl_seat_interface, seat, bind_seat);
+}
+
+static void
+output_handle_geometry(void *data,
+		       struct wl_output *wl_output,
+		       int32_t x, int32_t y,
+		       int32_t physical_width,
+		       int32_t physical_height,
+		       int subpixel,
+		       const char *make,
+		       const char *model,
+		       int transform)
+{
+	struct remote_output *output = data;
+
+	/* Discard x and y. */
+	output->output.make = strdup(make);
+	output->output.model = strdup(model);
+	output->output.mm_width = physical_width;
+	output->output.mm_height = physical_height;
+	output->output.subpixel = subpixel;
+	output->output.transform = transform;
+	wl_list_init(&output->output.mode_list);
+}
+
+struct remote_mode {
+	struct weston_mode base;
+};
+
+static void
+output_handle_mode(void *data,
+		   struct wl_output *wl_output,
+		   uint32_t flags,
+		   int width,
+		   int height,
+		   int refresh)
+{
+	struct remote_output *output = data;
+	struct remote_mode *mode;
+
+	mode = malloc(sizeof *mode);
+
+	mode->base.flags = flags;
+	mode->base.width = width;
+	mode->base.height = height;
+	mode->base.refresh = refresh;
+
+	if (flags & WL_OUTPUT_MODE_CURRENT)
+		output->output.current = &mode->base;
+
+	wl_list_insert(output->output.mode_list.prev, &mode->base.link);
+}
+
+static const struct wl_output_listener output_listener = {
+	output_handle_geometry,
+	output_handle_mode
+};
+
+static void
+output_callback_done(void *data, struct wl_callback *callback, uint32_t time)
+{
+	struct remote_output *output = data;
+	int x = 0, y = 0, width = 800, height = 600;
+
+	wl_callback_destroy(callback);
+	weston_output_init(&output->output, output->remote->compositor,
+			   x, y, width, height, WL_OUTPUT_TRANSFORM_NORMAL);
+}
+
+static const struct wl_callback_listener output_callback_listener = {
+	output_callback_done
+};
+
+static void
+remote_output_destroy(struct weston_output *output)
+{
+	free(output->make);
+	free(output->model);
+	weston_output_destroy(output);
+	wl_list_remove(&output->link);
+}
+
+static void
+remote_output_repaint(struct weston_output *output_base,
+		      pixman_region32_t *damage)
+{
+}
+
+static void
+remote_add_output(struct remote *remote, uint32_t id)
+{
+	struct remote_output *output;
+	struct wl_callback *callback;
+
+	output = malloc(sizeof *output);
+	if (output == NULL)
+		return;
+
+	memset(output, 0, sizeof *output);
+	output->remote = remote;
+	output->proxy = wl_registry_bind(remote->registry, id,
+					 &wl_output_interface, 1);
+
+	output->output.destroy = remote_output_destroy;
+	output->output.repaint = remote_output_repaint;
+
+	wl_output_add_listener(output->proxy, &output_listener, output);
+
+	callback = wl_display_sync(remote->display);
+	wl_callback_add_listener(callback, &output_callback_listener, output);
+}
+
+static void
+remote_handle_keymap(void *data, struct remote *proxy,
+		     struct wl_keyboard *keyboard, uint32_t format,
+		     uint32_t tag, uint32_t size)
+{
+	struct remote *remote = data;
+	struct remote_seat *seat = wl_keyboard_get_user_data(keyboard);
+
+	remote_stream_handle_tag(remote->stream, tag,
+				 keymap_tag_handler, seat);
+}
+
+static const struct remote_listener remote_listener = {
+	remote_handle_keymap
+};
+
+static void
+registry_handle_global(void *data, struct wl_registry *registry, uint32_t name,
+		       const char *interface, uint32_t version)
+{
+	struct remote *remote = data;
+
+	if (strcmp(interface, "wl_compositor") == 0) {
+		remote->remote_compositor =
+			wl_registry_bind(registry, name,
+					 &wl_compositor_interface, 1);
+	} else if (strcmp(interface, "wl_output") == 0) {
+		remote_add_output(remote, name);
+	} else if (strcmp(interface, "wl_seat") == 0) {
+		remote_add_seat(remote, name);
+	} else if (strcmp(interface, "wl_shell") == 0) {
+		remote->shell = wl_registry_bind(registry, name,
+						 &wl_shell_interface, 1);
+	} else if (strcmp(interface, "remote") == 0) {
+		remote->proxy_remote =
+			wl_registry_bind(registry, name, &remote_interface, 1);
+		remote_add_listener(remote->proxy_remote,
+				    &remote_listener, remote);
+	}
+}
+
+static const struct wl_registry_listener registry_listener = {
+	registry_handle_global
+};
+
+static void
+destroy_remote(struct wl_listener *listener, void *data)
+{
+	struct remote *remote =
+		container_of(listener, struct remote, destroy_listener);
+
+	/* FIXME: More clean up needed, unhook all forwarded surfaces,
+	 * for example. */
+
+	wl_registry_destroy(remote->registry);
+	wl_event_source_remove(remote->stream->source);
+	close(remote->stream->fd);
+	wl_event_source_remove(remote->source);
+	wl_event_source_remove(remote->protocol_source);
+	close(remote->protocol_fd[0]);
+	wl_display_disconnect(remote->display);
+	wl_list_remove(&remote->destroy_listener.link);
+	free(remote);
+}
+
+static int
+remote_handle_event(int fd, uint32_t mask, void *data)
+{
+	struct remote *remote = data;
+	int count = 0;
+
+	if (mask & (WL_EVENT_HANGUP | WL_EVENT_ERROR)) {
+		destroy_remote(&remote->destroy_listener, NULL);
+		return 0;
+	}
+
+	if (mask & WL_EVENT_READABLE)
+		count = wl_display_dispatch(remote->display);
+	if (mask & WL_EVENT_WRITABLE)
+		wl_display_flush(remote->display);
+
+	if (mask == 0) {
+		count = wl_display_dispatch_pending(remote->display);
+		wl_display_flush(remote->display);
+	}
+
+	return count;
+}
+
+WL_EXPORT int
+module_init(struct weston_compositor *compositor)
+{
+	struct remote *remote;
+	struct wl_event_loop *loop =
+		wl_display_get_event_loop(compositor->wl_display);
+	int port = 2222;
+	static const char *host = "localhost";
+
+	remote = malloc(sizeof *remote);
+	if (remote == NULL)
+		return -1;
+
+	memset(remote, 0, sizeof *remote);
+	remote->compositor = compositor;
+	remote->stream = remote_stream_connect(remote, host, port);
+	if (remote->stream == NULL)
+ 		return -1;
+
+	if (os_socketpair_cloexec(AF_UNIX, SOCK_STREAM, 0,
+				  remote->protocol_fd) < 0)
+		return -1;
+
+	remote->protocol_source =
+		wl_event_loop_add_fd(loop, remote->protocol_fd[0],
+				     WL_EVENT_READABLE,
+				     protocol_data, remote);
+
+	remote->display =
+		wl_display_connect_to_fd(remote->protocol_fd[1]);
+
+	if (remote->display == NULL) {
+		weston_log("failed to connect to remote display on %s:%d\n",
+			   host, port);
+		free(remote);
+		return -1;
+	}
+
+	remote->source = wl_event_loop_add_fd(loop, remote->protocol_fd[1],
+					      WL_EVENT_READABLE,
+					      remote_handle_event, remote);
+	if (remote->source == NULL) {
+		wl_display_disconnect(remote->display);
+		free(remote);
+		return -1;
+	}
+
+	wl_event_source_check(remote->source);
+
+	remote->registry = wl_display_get_registry(remote->display);
+	wl_registry_add_listener(remote->registry, &registry_listener, remote);
+
+	weston_compositor_add_key_binding(compositor, KEY_F, MODIFIER_SUPER,
+					  remote_binding, remote);
+
+	wl_list_init(&remote->surface_list);
+	remote->destroy_listener.notify = destroy_remote;
+	wl_signal_add(&compositor->destroy_signal, &remote->destroy_listener);
+
+	weston_log("connected to remote host %s:%d\n", host, port);
+
+	wl_display_flush(remote->display);
+
+	return 0;
+}
diff --git a/src/remote-server.c b/src/remote-server.c
new file mode 100644
index 0000000..5d3a019
--- /dev/null
+++ b/src/remote-server.c
@@ -0,0 +1,439 @@
+/*
+ * Copyright  2012 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of the copyright holders not be used in
+ * advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  The copyright holders make
+ * no representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#define _GNU_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <sys/uio.h>
+#include <assert.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "compositor.h"
+#include "../shared/os-compatibility.h"
+
+#include "remote-stream.h"
+#include "remote-server-protocol.h"
+
+
+struct remote_server {
+	struct weston_compositor *compositor;
+	int sock;
+	struct wl_event_source *sock_source;
+	struct wl_global *global;
+};
+
+struct remote_client {
+	struct remote_server *server;
+	int protocol_fd[2];
+	struct wl_event_source *protocol_source;
+	struct wl_client *client;
+	struct wl_listener destroy_listener;
+	struct wl_resource *remote_resource;
+
+	struct remote_stream *stream; 
+	struct remote_stream_block protocol_stream_block;
+	struct remote_stream_block keymap_stream_block;
+};
+
+static int
+buffer_data_tag_handler(struct remote_stream *stream,
+			size_t remain, void *data)
+{
+	struct wl_buffer *buffer = data;
+	char *buffer_data;
+	int len;
+
+	buffer_data = wl_shm_buffer_get_data(buffer);
+	len = read(stream->fd, buffer_data + stream->len, remain);
+	if (len < 0) {
+		weston_log("buffer data read failed: %m\n");
+		return -1;
+	}
+	stream->len += len;
+
+	return len;
+}
+
+static int
+stream_handle_event(int fd, uint32_t mask, void *data)
+{
+	struct remote_client *client = data;
+
+	if (mask & (WL_EVENT_HANGUP | WL_EVENT_ERROR)) {
+		fprintf(stderr, "stream_handle_event: hangup\n");
+		wl_client_destroy(client->client);
+		return 1;
+	}
+
+	remote_stream_read(client->stream);
+
+	return 1;
+}
+
+static int
+protocol_handle_event(int fd, uint32_t mask, void *data)
+{
+	struct remote_client *client = data;
+	struct remote_stream_block *block;
+	char buffer[4096];
+	int len;
+
+	if (mask & (WL_EVENT_HANGUP | WL_EVENT_ERROR))
+		fprintf(stderr, "protocol_handle_event: hangup\n");
+
+	len = read(fd, buffer, sizeof buffer);
+
+	block = &client->protocol_stream_block;
+	wl_list_insert(&client->stream->block_queue, &block->link);
+	block->tag = 0;
+	block->written = 0;
+	block->size = len;
+	block->data = buffer;
+
+	remote_stream_write(client->stream);
+
+	return 1;
+}
+
+static int
+protocol_tag_handler(struct remote_stream *stream, size_t remain, void *data)
+{
+	struct remote_client *client = data;
+	char buffer[4096];
+	int len;
+
+	if (remain > sizeof buffer)
+		len = sizeof buffer;
+	else
+		len = remain;
+
+	len = read(stream->fd, buffer, len);
+	if (len < 0)
+		return -1;
+	stream->len += len;
+	write(client->protocol_fd[0], buffer, len);
+
+	return len;
+}
+
+static struct remote_stream *
+remote_stream_accept(struct remote_server *server,
+		     struct remote_client *client)
+{
+	struct weston_compositor *compositor = server->compositor;
+	struct wl_event_loop *loop =
+		wl_display_get_event_loop(compositor->wl_display);
+	struct remote_stream *stream;
+	struct sockaddr_in name;
+	socklen_t length;
+	int fd;
+
+	length = sizeof name;
+	fd = accept4(server->sock,
+		     (struct sockaddr *) &name, &length, SOCK_CLOEXEC);
+	if (fd < 0) {
+		weston_log("failed to accept: %m\n");
+		return NULL;
+	}
+
+	stream = malloc(sizeof *stream);
+	if (stream == NULL)
+		return NULL;
+
+	memset(stream, 0, sizeof *stream);
+	stream->tag_handler[0].func = protocol_tag_handler;
+	stream->tag_handler[0].data = client;
+	stream->tag = 1;
+	stream->tag_handler_count = 1;
+	stream->fd = fd;
+	wl_list_init(&stream->block_queue);
+
+	stream->source =
+		wl_event_loop_add_fd(loop, stream->fd, WL_EVENT_READABLE,
+				     stream_handle_event, client);
+	if (stream->source == NULL) {
+		weston_log("failed to create remote client: %m\n");
+		close(fd);
+		free(stream);
+		return NULL;
+	}
+
+	return stream;
+}
+
+static void
+remote_stream_destroy(struct remote_stream *stream)
+{
+	wl_event_source_remove(stream->source);
+	close(stream->fd);
+	free(stream);
+}
+
+static void
+remote_client_destroy(struct wl_listener *listener, void *data)
+{
+	struct remote_client *client =
+		container_of(listener, struct remote_client, destroy_listener);
+
+	/* FIXME: Clean up objects */
+
+	remote_stream_destroy(client->stream);
+
+	wl_event_source_remove(client->protocol_source);
+	close(client->protocol_fd[0]);
+	close(client->protocol_fd[1]);
+
+	free(client);
+}
+
+static int
+sock_handle_event(int fd, uint32_t mask, void *data)
+{
+	struct remote_server *server = data;
+	struct weston_compositor *compositor = server->compositor;
+	struct remote_client *client;
+	struct wl_event_loop *loop =
+		wl_display_get_event_loop(compositor->wl_display);
+
+	client = malloc(sizeof *client);
+	if (client == NULL) {
+		weston_log("failed to create remote-server client: %m\n");
+		return 1;
+	}
+
+	memset(client, 0, sizeof *client);
+	client->server = server;
+	client->stream = remote_stream_accept(server, client);
+	if (client->stream == NULL) {
+		free(client);
+		return 1;
+	}
+
+	if (os_socketpair_cloexec(AF_UNIX, SOCK_STREAM, 0,
+				  client->protocol_fd) < 0) {
+		weston_log("failed to create socketpair: %m\n");
+		return 1;
+	}
+
+	client->protocol_source =
+		wl_event_loop_add_fd(loop, client->protocol_fd[0],
+				     WL_EVENT_READABLE,
+				     protocol_handle_event, client);
+	if (client->protocol_source == NULL) {
+		weston_log("failed to create remote client source: %m\n");
+		free(client);
+		return 1;
+	}
+
+	client->client = wl_client_create(compositor->wl_display,
+					  client->protocol_fd[1]);
+
+	client->destroy_listener.notify = remote_client_destroy;
+	wl_client_add_destroy_listener(client->client,
+				       &client->destroy_listener);
+
+	weston_log("remote client connected (%p)\n", client->client);
+
+	return 1;
+}
+
+static int
+remote_try_send_keymap(struct wl_client *client,
+		       struct weston_seat *seat, struct wl_resource *cr)
+{
+	struct wl_listener *listener;
+	struct remote_client *rc;
+
+	listener = wl_client_get_destroy_listener(client,
+						  remote_client_destroy);
+	if (listener == NULL)
+		return -1;
+
+	rc = container_of(listener, struct remote_client, destroy_listener);
+
+	remote_stream_queue_block(rc->stream, &rc->keymap_stream_block,
+				  seat->xkb_info.keymap_area,
+				  seat->xkb_info.keymap_size);
+	remote_send_keymap(rc->remote_resource, cr, 
+			   WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1,
+			   rc->keymap_stream_block.tag,
+			   seat->xkb_info.keymap_size);
+
+	return 0;
+}
+
+static int
+make_socket(uint16_t port)
+{
+	int sock, one = 1;
+	struct sockaddr_in name;
+
+	sock = socket(PF_INET, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK, 0);
+	if (sock < 0) {
+		weston_log("failed to create remote-server socket: %m\n");
+		return -1;
+	}
+
+	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &one, sizeof one);
+
+	name.sin_family = AF_INET;
+	name.sin_port = htons(port);
+	name.sin_addr.s_addr = htonl(INADDR_ANY);
+	if (bind(sock, (struct sockaddr *) &name, sizeof name) < 0) {
+		weston_log("failed to bind remote-server socket: %m\n");
+		close(sock);
+		return -1;
+	}
+
+	if (listen(sock, 1) < 0) {
+		weston_log("failed to listen on remote-server socket: %m\n");
+		close(sock);
+		return -1;
+	}
+
+	return sock;
+}
+
+static void
+remote_handle_create_buffer(struct wl_client *client,
+			    struct wl_resource *resource, uint32_t id,
+			    int32_t width, int32_t height, uint32_t format)
+{
+	switch (format) {
+	case REMOTE_FORMAT_ARGB8888:
+	case REMOTE_FORMAT_XRGB8888:
+		break;
+	default:
+		wl_resource_post_error(resource,
+				       WL_SHM_ERROR_INVALID_FORMAT,
+				       "invalid format");
+		return;
+	}
+
+	/* FIXME: check integer overflow */
+	if (width <= 0 || height <= 0) {
+		wl_resource_post_error(resource,
+				       WL_SHM_ERROR_INVALID_STRIDE,
+				       "invalid width, height or stride (%dx%d)",
+				       width, height);
+		return;
+	}
+
+	/* FIXME: This is going to send spurious buffer.release events
+	 * to the remote side... or is it just right? */
+
+	/* FIXME: Get wl_resource and set a destroy listener? */
+	wl_shm_buffer_create(client, id, width, height, width * 4, format);
+}
+
+static void
+remote_handle_update_buffer(struct wl_client *client,
+			    struct wl_resource *resource,
+			    struct wl_resource *buffer_resource,
+			    uint32_t tag,
+			    struct wl_resource *region)
+{
+	struct wl_listener *listener;
+	struct remote_client *rc;
+
+	listener = wl_client_get_destroy_listener(client,
+						  remote_client_destroy);
+	rc = container_of(listener, struct remote_client, destroy_listener);
+
+	remote_stream_handle_tag(rc->stream, tag,
+				 buffer_data_tag_handler,
+				 buffer_resource->data);
+}
+
+static const struct remote_interface remote_implementation = {
+	remote_handle_create_buffer,
+	remote_handle_update_buffer
+};
+
+static void
+bind_remote(struct wl_client *client,
+	    void *data, uint32_t version, uint32_t id)
+{
+	struct remove_server *server = data;
+	struct wl_listener *listener;
+	struct remote_client *rc;
+
+	/* Reject non-remote clients.  This interface only makes sense
+	 * for remote clients that can refer to out-of-band objects. */
+	listener = wl_client_get_destroy_listener(client,
+						  remote_client_destroy);
+	if (!listener)
+		return;
+
+	rc = container_of(listener, struct remote_client, destroy_listener);
+	rc->remote_resource =
+		wl_client_add_object(client, &remote_interface,
+				     &remote_implementation, id, server);
+}
+
+int
+module_init(struct weston_compositor *compositor);
+
+WL_EXPORT int
+module_init(struct weston_compositor *compositor)
+{
+	struct remote_server *server;
+	struct wl_event_loop *loop =
+		wl_display_get_event_loop(compositor->wl_display);
+	int port = 2222;
+
+	server = malloc(sizeof *server);
+	if (server == NULL)
+		return -1;
+
+	server->compositor = compositor;
+	server->sock = make_socket(port);
+	if (server->sock < 0) {
+		free(server);
+		return -1;
+	}
+
+	server->sock_source =
+		wl_event_loop_add_fd(loop, server->sock, WL_EVENT_READABLE,
+				     sock_handle_event, server);
+	if (server->sock_source == NULL) {
+		weston_log("failed to set up remote-server socket source\n");
+		free(server);
+		return -1;
+	}
+
+	server->global = wl_display_add_global(compositor->wl_display,
+					       &remote_interface,
+					       server, bind_remote);
+
+
+	compositor->try_send_keymap = remote_try_send_keymap;
+
+	weston_log("remote server listening on port %d\n", port);
+
+	return 0;
+}
diff --git a/src/remote-stream.c b/src/remote-stream.c
new file mode 100644
index 0000000..9bbeb94
--- /dev/null
+++ b/src/remote-stream.c
@@ -0,0 +1,138 @@
+/*
+ * Copyright  2012 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of the copyright holders not be used in
+ * advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  The copyright holders make
+ * no representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <assert.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <sys/uio.h>
+
+#include "compositor.h"
+#include "remote-stream.h"
+
+int
+remote_stream_write(struct remote_stream *stream)
+{
+	struct remote_stream_block *block, *next;
+	uint32_t header;
+	struct iovec iov[2];
+	int len;
+
+	wl_list_for_each_safe(block, next, &stream->block_queue, link) {
+		/* FIXME: Coalesce all this into one writev? */
+		if (block->written == 0) {
+			header = (block->tag << 24) | block->size;
+			iov[0].iov_base = &header;
+			iov[0].iov_len = sizeof header;
+			iov[1].iov_base = block->data;
+			iov[1].iov_len = block->size;
+
+			/* FIXME: async write this... */
+			len = writev(stream->fd, iov, 2);
+			if (len == -1)
+				return len;
+
+			assert(len >= (int) sizeof header);
+			len -= sizeof header;
+		} else {
+			len = write(stream->fd, block->data + block->written,
+				    block->size - block->written);
+		}
+
+		if (len < 0)
+			weston_log("write error: %m\n");
+
+		block->written += len;
+
+		if (block->written < block->size)
+			break;
+
+		wl_list_remove(&block->link);
+		wl_list_init(&block->link);
+ 	}
+ 
+	stream->tag = 1;
+
+	return 1;
+}
+
+int
+remote_stream_read(struct remote_stream *stream)
+{
+	size_t remain;
+	uint32_t tag;
+
+	if (stream->handler == NULL) {
+		if (stream->header == 0)
+			/* FIXME: Check this read... */
+			read(stream->fd,
+			     &stream->header, sizeof stream->header);
+		tag = stream->header >> 24;
+		if (tag == 0)
+			stream->tag_handler_count = 1;
+		if (tag >= stream->tag_handler_count)
+			/* If there's no handler for this tag yet,
+			 * return to the main loop to process protocol
+			 * events first. */
+			return 1;
+
+		stream->len = 0;
+		stream->total = stream->header & 0xffffff;
+		stream->handler = &stream->tag_handler[tag];
+		stream->header = 0;
+	} else {
+		remain = stream->total - stream->len;
+		stream->handler->func(stream, remain, stream->handler->data);
+		if (stream->len == stream->total)
+			stream->handler = NULL;
+	}
+
+	return 1;
+}
+
+void
+remote_stream_handle_tag(struct remote_stream *stream, uint32_t tag,
+			 remote_stream_handler_func_t func, void *data)
+{
+	/* FIXME: Bad assert */
+	assert(tag < ARRAY_LENGTH(stream->tag_handler));
+
+	if (tag != stream->tag_handler_count)
+		assert("tags out of sync");
+	stream->tag_handler[tag].func = func;
+	stream->tag_handler[tag].data = data;
+	stream->tag_handler_count++;
+}
+
+void
+remote_stream_queue_block(struct remote_stream *stream,
+			  struct remote_stream_block *block,
+			  void *data, size_t size)
+{
+	if (!wl_list_empty(&block->link))
+		return;
+
+	wl_list_insert(stream->block_queue.prev, &block->link);
+	block->tag = stream->tag++;
+	block->written = 0;
+	block->data = data;
+	block->size = size;
+}
diff --git a/src/remote-stream.h b/src/remote-stream.h
new file mode 100644
index 0000000..438c4a4
--- /dev/null
+++ b/src/remote-stream.h
@@ -0,0 +1,48 @@
+#include <stdlib.h>
+#include <stdint.h>
+
+#include <wayland-util.h>
+
+struct remote_stream;
+
+typedef int (*remote_stream_handler_func_t)(struct remote_stream *stream,
+					    size_t remain, void *data);
+
+struct remote_stream_handler {
+	remote_stream_handler_func_t func;
+	void *data;
+};
+
+struct remote_stream {
+	uint32_t tag, header;
+	int len, total;
+	int fd, protocol_fd;
+	uint32_t tag_handler_count;
+	struct remote_stream_handler tag_handler[10];
+	struct remote_stream_handler *handler;
+	struct wl_event_source *source;
+	struct wl_list block_queue;
+};
+
+struct remote_stream_block {
+	struct wl_list link;
+	void *data;
+	size_t size;
+	size_t written;
+	uint32_t tag;
+};
+
+int
+remote_stream_write(struct remote_stream *stream);
+
+int
+remote_stream_read(struct remote_stream *stream);
+
+void
+remote_stream_handle_tag(struct remote_stream *stream, uint32_t tag,
+			 remote_stream_handler_func_t func, void *data);
+
+void
+remote_stream_queue_block(struct remote_stream *stream,
+			  struct remote_stream_block *block,
+			  void *data, size_t size);
