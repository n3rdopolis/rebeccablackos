diff --git a/src/weston-launch.c b/src/weston-launch.c
index 36f9c6b..7238128 100644
--- a/src/weston-launch.c
+++ b/src/weston-launch.c
@@ -109,7 +109,7 @@ weston_launch_allowed(struct weston_launch *wl)
 	if (getuid() == 0)
 		return 1;
 
-	gr = getgrnam("weston-launch");
+	gr = getgrnam("plugdev");
 	if (gr) {
 		groups = read_groups();
 		if (groups) {
@@ -550,7 +550,7 @@ main(int argc, char *argv[])
 #else
 		      " - enable systemd session support for weston-launch.\n"
 #endif
-		      " - or add yourself to the 'weston-launch' group.");
+		      " - or add yourself to the 'plugdev' group.");
 
 	if (setup_tty(&wl, tty) < 0)
 		return 1;







diff --git a/clients/desktop-shell.c b/clients/desktop-shell.c
index 1cae789..f52a4f9 100644
--- a/clients/desktop-shell.c
+++ b/clients/desktop-shell.c
@@ -36,6 +36,7 @@
 #include <libgen.h>
 #include <ctype.h>
 #include <time.h>
+#include <stdbool.h>
 
 #include <wayland-client.h>
 #include "window.h"
@@ -44,6 +45,8 @@
 
 #include "desktop-shell-client-protocol.h"
 
+#define MIN(x, y) (((x) < (y)) ? (x) : (y))
+
 extern char **environ; /* defined by libc */
 
 struct desktop {
@@ -51,37 +54,62 @@ struct desktop {
 	struct desktop_shell *shell;
 	struct unlock_dialog *unlock_dialog;
 	struct task unlock_task;
+	struct wl_list surfaces;
 	struct wl_list outputs;
+	uint32_t output_count;
 
 	struct window *grab_window;
 	struct widget *grab_widget;
 
 	enum cursor_type grab_cursor;
+
+	struct surface_data_manager *surface_data_manager;
 };
 
 struct surface {
+	struct desktop *desktop;
+	struct surface_data *surface_data;
+	struct wl_list item_list;
+	uint32_t output_mask;
+	char *title;
+	bool maximized, minimized;
+	bool focused;
+
+	struct wl_list link;
+};
+
+struct resize {
 	void (*configure)(void *data,
 			  struct desktop_shell *desktop_shell,
 			  uint32_t edges, struct window *window,
 			  int32_t width, int32_t height);
 };
 
+struct rgba {
+	float r, g, b, a;
+};
+
 struct panel {
-	struct surface base;
+	struct resize base;
 	struct window *window;
 	struct widget *widget;
 	struct wl_list launcher_list;
+	struct wl_list window_list;
+	struct rectangle window_list_rect;
+	uint32_t surface_count;
+	struct rgba focused_item;
 	struct panel_clock *clock;
 };
 
 struct background {
-	struct surface base;
+	struct resize base;
 	struct window *window;
 	struct widget *widget;
 };
 
 struct output {
 	struct wl_output *output;
+	uint32_t id;
 	struct wl_list link;
 
 	struct panel *panel;
@@ -99,6 +127,18 @@ struct panel_launcher {
 	struct wl_array argv;
 };
 
+struct list_item {
+	struct surface *surface;
+	struct widget *widget;
+	struct panel *panel;
+	cairo_surface_t *icon;
+	int focused, highlight;
+	float x, y;
+	struct wl_list link;
+	struct wl_list surface_link;
+	struct wl_list reorder_link;
+};
+
 struct panel_clock {
 	struct widget *widget;
 	struct panel *panel;
@@ -156,13 +196,13 @@ sigchild_handler(int s)
 }
 
 static void
-menu_func(struct window *window, int index, void *data)
+panel_menu_func(struct window *window, int index, void *data)
 {
 	printf("Selected index %d from a panel menu.\n", index);
 }
 
 static void
-show_menu(struct panel *panel, struct input *input, uint32_t time)
+panel_show_menu(struct panel *panel, struct input *input, uint32_t time)
 {
 	int32_t x, y;
 	static const char *entries[] = {
@@ -172,7 +212,7 @@ show_menu(struct panel *panel, struct input *input, uint32_t time)
 	input_get_position(input, &x, &y);
 	window_show_menu(window_get_display(panel->window),
 			 input, time, panel->window,
-			 x - 10, y - 10, menu_func, entries, 4);
+			 x - 10, y - 10, panel_menu_func, entries, 4);
 }
 
 static void
@@ -249,6 +289,15 @@ set_hex_color(cairo_t *cr, uint32_t color)
 }
 
 static void
+get_hex_color_rgba(uint32_t color, float *r, float *g, float *b, float *a)
+{
+	*r = ((color >> 16) & 0xff) / 255.0;
+	*g = ((color >>  8) & 0xff) / 255.0;
+	*b = ((color >>  0) & 0xff) / 255.0;
+	*a = ((color >> 24) & 0xff) / 255.0;
+}
+
+static void
 panel_redraw_handler(struct widget *widget, void *data)
 {
 	cairo_surface_t *surface;
@@ -337,7 +386,7 @@ panel_clock_redraw_handler(struct widget *widget, void *data)
 
 	surface = window_get_surface(clock->panel->window);
 	cr = cairo_create(surface);
-	cairo_select_font_face(cr, "sans",
+	cairo_select_font_face(cr, "helvetica",
 			       CAIRO_FONT_SLANT_NORMAL,
 			       CAIRO_FONT_WEIGHT_NORMAL);
 	cairo_set_font_size(cr, 14);
@@ -417,7 +466,36 @@ panel_button_handler(struct widget *widget,
 	struct panel *panel = data;
 
 	if (button == BTN_RIGHT && state == WL_POINTER_BUTTON_STATE_PRESSED)
-		show_menu(panel, input, time);
+		panel_show_menu(panel, input, time);
+}
+
+static void
+panel_window_list_schedule_redraw(struct panel *panel)
+{
+	struct list_item *item;
+	float x, y, w, h;
+	float item_width, padding;
+
+	/* If there are no window list items, redraw the panel to clear it */
+	if (wl_list_empty(&panel->window_list)) {
+		widget_schedule_redraw(panel->widget);
+		return;
+	}
+
+	item_width = ((float) panel->window_list_rect.width /
+							panel->surface_count);
+	padding = MIN(item_width * 0.1f, 10.0f);
+
+	x = panel->window_list_rect.x + padding;
+	y = 16;
+	w = MIN(item_width - padding, 200);
+	h = 24;
+
+	wl_list_for_each(item, &panel->window_list, link) {
+		widget_set_allocation(item->widget, x, y - h / 2, w + 1, h + 1);
+		x += w + padding;
+		widget_schedule_redraw(item->widget);
+	}
 }
 
 static void
@@ -425,11 +503,16 @@ panel_resize_handler(struct widget *widget,
 		     int32_t width, int32_t height, void *data)
 {
 	struct panel_launcher *launcher;
+	struct rectangle launcher_rect;
+	struct rectangle clock_rect;
 	struct panel *panel = data;
 	int x, y, w, h;
-	
+
 	x = 10;
 	y = 16;
+
+	launcher_rect.x = x;
+
 	wl_list_for_each(launcher, &panel->launcher_list, link) {
 		w = cairo_image_surface_get_width(launcher->icon);
 		h = cairo_image_surface_get_height(launcher->icon);
@@ -437,12 +520,25 @@ panel_resize_handler(struct widget *widget,
 				      x, y - h / 2, w + 1, h + 1);
 		x += w + 10;
 	}
-	h=20;
+
+	launcher_rect.width = x - launcher_rect.x;
+
 	w=170;
+	h=20;
 
 	if (panel->clock)
 		widget_set_allocation(panel->clock->widget,
 				      width - w - 8, y - h / 2, w + 1, h + 1);
+
+	widget_get_allocation(panel->clock->widget, &clock_rect);
+
+	panel->window_list_rect.x = launcher_rect.x + launcher_rect.width;
+	panel->window_list_rect.y = 2;
+	panel->window_list_rect.width = width -
+					panel->window_list_rect.x -
+					(clock_rect.width + 20);
+	panel->window_list_rect.height = 28;
+	panel_window_list_schedule_redraw(panel);
 }
 
 static void
@@ -451,7 +547,7 @@ panel_configure(void *data,
 		uint32_t edges, struct window *window,
 		int32_t width, int32_t height)
 {
-	struct surface *surface = window_get_user_data(window);
+	struct resize *surface = window_get_user_data(window);
 	struct panel *panel = container_of(surface, struct panel, base);
 
 	window_schedule_resize(panel->window, width, 32);
@@ -490,6 +586,25 @@ panel_destroy(struct panel *panel)
 	free(panel);
 }
 
+static void
+panel_set_list_item_focus_color(struct panel *panel)
+{
+	float r, g, b, a;
+
+	/* Consider panel color when choosing item highlight color */
+	get_hex_color_rgba(key_panel_color, &r, &b, &g, &a);
+	if (r += 0.2, g += 0.2, b += 0.2, r > 1.0 || g > 1.0 || b > 1.0) {
+		panel->focused_item.r = 0.6;
+		panel->focused_item.g = 0.6;
+		panel->focused_item.b = 0.6;
+	} else {
+		panel->focused_item.r = r;
+		panel->focused_item.g = g;
+		panel->focused_item.b = b;
+	}
+	panel->focused_item.a = 0.75;
+}
+
 static struct panel *
 panel_create(struct display *display)
 {
@@ -502,6 +617,7 @@ panel_create(struct display *display)
 	panel->window = window_create_custom(display);
 	panel->widget = window_add_widget(panel->window, panel);
 	wl_list_init(&panel->launcher_list);
+	wl_list_init(&panel->window_list);
 
 	window_set_title(panel->window, "panel");
 	window_set_user_data(panel->window, panel);
@@ -509,7 +625,9 @@ panel_create(struct display *display)
 	widget_set_redraw_handler(panel->widget, panel_redraw_handler);
 	widget_set_resize_handler(panel->widget, panel_resize_handler);
 	widget_set_button_handler(panel->widget, panel_button_handler);
-	
+
+	panel->surface_count = 0;
+	panel_set_list_item_focus_color(panel);
 	panel_add_clock(panel);
 
 	return panel;
@@ -518,18 +636,21 @@ panel_create(struct display *display)
 static cairo_surface_t *
 load_icon_or_fallback(const char *icon)
 {
-	cairo_surface_t *surface = cairo_image_surface_create_from_png(icon);
+	cairo_surface_t *surface;
 	cairo_t *cr;
-
-	if (cairo_surface_status(surface) == CAIRO_STATUS_SUCCESS)
-		return surface;
-
-	cairo_surface_destroy(surface);
-	fprintf(stderr, "ERROR loading icon from file '%s'\n", icon);
+#ifdef CAIRO_HAS_PNG_FUNCTIONS
+	if (icon) {
+		surface = cairo_image_surface_create_from_png(icon);
+		if (cairo_surface_status(surface) == CAIRO_STATUS_SUCCESS)
+			return surface;
+
+		cairo_surface_destroy(surface);
+		fprintf(stderr, "ERROR loading icon from file '%s'\n", icon);
+	}
+#endif
 
 	/* draw fallback icon */
-	surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32,
-					     20, 20);
+	surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 20, 20);
 	cr = cairo_create(surface);
 
 	cairo_set_source_rgba(cr, 0.8, 0.8, 0.8, 1);
@@ -862,7 +983,7 @@ desktop_shell_configure(void *data,
 			int32_t width, int32_t height)
 {
 	struct window *window = wl_surface_get_user_data(surface);
-	struct surface *s = window_get_user_data(window);
+	struct resize *s = window_get_user_data(window);
 
 	s->configure(data, desktop_shell, edges, window, width, height);
 }
@@ -946,6 +1067,621 @@ background_destroy(struct background *background)
 	free(background);
 }
 
+static void
+panel_list_item_redraw_handler(struct widget *widget, void *data)
+{
+	cairo_t *cr;
+	cairo_surface_t *surface;
+	struct list_item *item = data;
+	struct rectangle rect;
+	cairo_text_extents_t extents;
+	cairo_font_extents_t font_extents;
+	int icon_width;
+	unsigned int dots = 3;
+	char title[128];
+
+	widget_get_allocation(widget, &rect);
+	if (rect.width == 0)
+		return;
+
+	surface = window_get_surface(item->panel->window);
+	cr = cairo_create(surface);
+
+	if (item->highlight || item->surface->focused) {
+		cairo_set_source_rgba(cr,
+					item->panel->focused_item.r,
+					item->panel->focused_item.g,
+					item->panel->focused_item.b,
+					item->panel->focused_item.a);
+		cairo_move_to(cr, rect.x, rect.y);
+		cairo_line_to(cr, rect.x + rect.width, rect.y);
+		cairo_line_to(cr, rect.x + rect.width, rect.y + rect.height);
+		cairo_line_to(cr, rect.x, rect.y + rect.height);
+		cairo_line_to(cr, rect.x, rect.y);
+		cairo_fill(cr);
+	}
+
+	icon_width = cairo_image_surface_get_width(item->icon);
+	if (rect.width > icon_width * 2) {
+		cairo_set_source_surface(cr, item->icon,
+					 rect.x, rect.y);
+		cairo_paint(cr);
+	} else
+		icon_width = 0;
+
+	strcpy(title, item->surface->title);
+	cairo_select_font_face(cr, "helvetica",
+			       CAIRO_FONT_SLANT_NORMAL,
+			       CAIRO_FONT_WEIGHT_NORMAL);
+	cairo_set_font_size(cr, 14);
+	cairo_text_extents(cr, title, &extents);
+
+	/* If the string is too long, clip text to button width */
+	while (extents.width > (rect.width - (10 + icon_width))) {
+		title[strlen(title) - 1] = '\0';
+		cairo_text_extents(cr, title, &extents);
+		if (extents.width <= 0) {
+			title[0] = '\0';
+			break;
+		}
+	}
+
+	/* If the text is clipped, add an ellipsis */
+	if (strlen(title) < dots)
+		dots = strlen(title) + 1;
+	if (strlen(title) != strlen(item->surface->title))
+		while (dots-- > 0)
+			title[strlen(title) - dots] = '.';
+
+	cairo_font_extents (cr, &font_extents);
+	cairo_move_to(cr, rect.x + 10 + icon_width,
+		      rect.y + 3 * (rect.height >> 2) + 1);
+	cairo_set_source_rgb(cr, 0, 0, 0);
+	cairo_show_text(cr, title);
+	cairo_move_to(cr, rect.x + 9 + icon_width,
+		      rect.y + 3 * (rect.height >> 2));
+	if (item->highlight)
+		cairo_set_source_rgb(cr, 1, 1, 1);
+	else
+		cairo_set_source_rgb(cr, 0.85, 0.85, 0.85);
+	cairo_show_text(cr, title);
+	cairo_destroy(cr);
+}
+
+static int
+panel_list_item_motion_handler(struct widget *widget, struct input *input,
+			      uint32_t time, float x, float y, void *data)
+{
+	struct list_item *item = data;
+
+	item->x = x;
+	item->y = y;
+	widget_set_tooltip(widget, basename((char *)item->surface->title), x, y);
+
+	return CURSOR_LEFT_PTR;
+}
+
+static int
+panel_list_item_enter_handler(struct widget *widget, struct input *input,
+			     float x, float y, void *data)
+{
+	struct list_item *item = data;
+
+	item->x = x;
+	item->y = y;
+	item->highlight = true;
+	item->focused = true;
+	widget_schedule_redraw(widget);
+
+	return CURSOR_LEFT_PTR;
+}
+
+static void
+panel_list_item_leave_handler(struct widget *widget,
+			     struct input *input, void *data)
+{
+	struct list_item *item = data;
+
+	item->highlight = false;
+	item->focused = false;
+	widget_destroy_tooltip(widget);
+	widget_schedule_redraw(widget);
+}
+
+static void
+desktop_update_list_items(struct desktop *desktop, struct surface *surface);
+
+static void
+list_item_menu_handle_button(struct list_item *item, int index)
+{
+	struct surface *surface = item->surface;
+
+	switch (index) {
+	case 0: /* (Un)Minimize */
+		if (surface->minimized) {
+			surface_data_unminimize(surface->surface_data);
+			surface->minimized = false;
+		}
+		else {
+			surface_data_minimize(surface->surface_data);
+			surface->minimized = true;
+		}
+		break;
+	case 1: /* (Un)Maximize */
+		if (surface->maximized) {
+			surface_data_unmaximize(surface->surface_data);
+			surface->maximized = false;
+		}
+		else {
+			surface_data_maximize(surface->surface_data);
+			surface->maximized = true;
+		}
+		break;
+	case 2: /* Close */
+		surface_data_close(surface->surface_data);
+		break;
+	default:
+		item->highlight = false;
+		break;
+	}
+
+	desktop_update_list_items(surface->desktop, surface);
+	widget_destroy_tooltip(item->widget);
+	widget_schedule_redraw(item->widget);
+}
+
+static void
+list_item_menu_func(struct window *window, int index, void *data)
+{
+	struct list_item *item;
+	struct panel *panel;
+
+	panel = data;
+
+	wl_list_for_each(item, &panel->window_list, link)
+		if (item->focused) {
+			list_item_menu_handle_button(item, index);
+			return;
+		}
+}
+
+#define NUM_ENTRIES 3
+
+static void
+list_item_show_menu(struct list_item *item, struct input *input, uint32_t time)
+{
+	struct panel *panel;
+	int32_t x, y;
+	static const char *entries[NUM_ENTRIES];
+
+	entries[0] = item->surface->minimized ? "Unminimize" : "Minimize";
+	entries[1] = item->surface->maximized ? "Unmaximize" : "Maximize";
+	entries[2] = "Close";
+
+	panel = item->panel;
+	input_get_position(input, &x, &y);
+	window_show_menu(window_get_display(panel->window), input,
+				time, panel->window, x - 10, y - 10,
+				list_item_menu_func, entries, NUM_ENTRIES);
+}
+
+static bool
+rect_contains_point(struct rectangle rect, int x, int y)
+{
+	int x1, y1, x2, y2;
+
+	x1 = rect.x;
+	y1 = rect.y;
+	x2 = rect.x + rect.width;
+	y2 = rect.y + rect.height;
+
+	if (x > x1 && x < x2 && y > y1 && y < y2)
+		return true;
+
+	return false;
+}
+
+static bool
+item_contains_point(struct list_item *item, int x, int y)
+{
+	struct rectangle item_rect;
+
+	widget_get_allocation(item->widget, &item_rect);
+
+	return rect_contains_point(item_rect, x, y);
+}
+
+static bool
+list_contains_point(struct list_item *item, int x, int y)
+{
+	struct rectangle list_rect;
+
+	list_rect = item->panel->window_list_rect;
+
+	return rect_contains_point(list_rect, x, y);
+}
+
+static void
+panel_item_list_reorder(struct panel *panel,
+			struct list_item *current, struct list_item *item)
+{
+	struct rectangle current_rect, item_rect;
+
+	if (current == item)
+		return;
+
+	widget_get_allocation(current->widget, &current_rect);
+	widget_get_allocation(item->widget, &item_rect);
+
+	wl_list_remove(&current->link);
+
+	if (item_rect.x < current_rect.x)
+		wl_list_insert(item->link.prev, &current->link);
+	else
+		wl_list_insert(&item->link, &current->link);
+
+	panel_window_list_schedule_redraw(item->panel);
+}
+
+static void
+list_item_move(struct list_item *current, int x, int y)
+{
+	struct list_item *item;
+
+	wl_list_for_each(item, &current->panel->window_list, link) {
+		if (item == current)
+			continue;
+		if (item_contains_point(item, x, y)) {
+			panel_item_list_reorder(item->panel, current, item);
+			return;
+		}
+	}
+}
+
+static void
+panel_list_item_button_handler(struct widget *widget,
+			      struct input *input, uint32_t time,
+			      uint32_t button,
+			      enum wl_pointer_button_state state, void *data)
+{
+	struct list_item *item;
+	struct surface *surface;
+
+	item = data;
+
+	widget_schedule_redraw(widget);
+
+	if (button == BTN_RIGHT && state == WL_POINTER_BUTTON_STATE_PRESSED) {
+		widget_destroy_tooltip(item->widget);
+		widget_schedule_redraw(item->widget);
+		list_item_show_menu(item, input, time);
+		return;
+	}
+
+	if ((button != BTN_LEFT) || (state != WL_POINTER_BUTTON_STATE_RELEASED))
+		return;
+
+	surface = item->surface;
+	if (!item_contains_point(item, item->x, item->y)) {
+		if (list_contains_point(item, item->x, item->y))
+			list_item_move(item, item->x, item->y);
+		return;
+	}
+	if (!surface->focused && !surface->minimized) {
+		surface_data_focus(surface->surface_data);
+		surface->focused = true;
+		return;
+	}
+	if (surface->minimized) {
+		surface_data_unminimize(surface->surface_data);
+		surface->minimized = false;
+	}
+	else {
+		surface_data_minimize(surface->surface_data);
+		surface->minimized = true;
+	}
+}
+
+static struct list_item *
+panel_list_item_add(struct panel *panel, const char *icon, const char *text)
+{
+	struct list_item *item;
+	item = malloc(sizeof *item);
+	memset(item, 0, sizeof *item);
+
+	item->icon = load_icon_or_fallback(icon);
+
+	item->panel = panel;
+	wl_list_insert(panel->window_list.prev, &item->link);
+	panel->surface_count++;
+
+	item->widget = widget_add_widget(panel->widget, item);
+	widget_set_enter_handler(item->widget, panel_list_item_enter_handler);
+	widget_set_leave_handler(item->widget, panel_list_item_leave_handler);
+	widget_set_button_handler(item->widget, panel_list_item_button_handler);
+	widget_set_redraw_handler(item->widget, panel_list_item_redraw_handler);
+	widget_set_motion_handler(item->widget, panel_list_item_motion_handler);
+
+	return item;
+}
+
+static void
+panel_list_item_remove(struct list_item *item)
+{
+	item->panel->surface_count--;
+	wl_list_remove(&item->link);
+	wl_list_remove(&item->surface_link);
+	widget_destroy(item->widget);
+	panel_window_list_schedule_redraw(item->panel);
+	free(item);
+}
+
+static int
+panel_list_item_exists(struct panel *panel, struct surface *surface)
+{
+	struct list_item *p_item, *s_item;
+
+	wl_list_for_each(p_item, &panel->window_list, link) {
+		wl_list_for_each(s_item, &surface->item_list, surface_link) {
+			if (p_item == s_item)
+				return 1;
+		}
+	}
+
+	return 0;
+}
+
+static void
+output_update_window_list(struct output *output, struct surface *surface)
+{
+	struct list_item *item, *next;
+	struct panel *panel;
+
+	panel = output->panel;
+
+	/* Make a list item for each panel of the surfaces output mask */
+	if ((1 << output->id) & surface->output_mask) {
+		if (!panel_list_item_exists(panel, surface)) {
+			/* TODO: Use a real icon instead of
+			 * passing NULL for the fallback */
+			item = panel_list_item_add(panel, NULL, surface->title);
+			wl_list_insert(surface->item_list.prev,
+							&item->surface_link);
+			item->surface = surface;
+		}
+	} else {
+		/* Remove item from panel if surface
+		 * is no longer on the output */
+		wl_list_for_each_safe(item, next, &surface->item_list,
+								surface_link) {
+			if (item->panel == panel)
+				panel_list_item_remove(item);
+		}
+	}
+
+	panel_window_list_schedule_redraw(panel);
+}
+
+static struct surface*
+desktop_create_surface(struct desktop *desktop,
+			struct surface_data *surface_data)
+{
+	struct surface *surface;
+
+	surface = calloc(1, sizeof *surface);
+
+	if (!surface) {
+		fprintf(stderr, "ERROR: Failed to allocate memory!\n");
+		exit(EXIT_FAILURE);
+	}
+
+	surface->desktop = desktop;
+	surface->surface_data = surface_data;
+	surface->title = strdup("unknown");
+	surface->output_mask = 1;
+	surface->maximized = false;
+	surface->minimized = false;
+	surface->focused = false;
+	wl_list_init(&surface->item_list);
+	wl_list_insert(&desktop->surfaces, &surface->link);
+
+	return surface;
+}
+
+static void
+desktop_destroy_surface(struct surface *surface)
+{
+	struct list_item *item, *next;
+
+	wl_list_for_each_safe(item, next, &surface->item_list, surface_link)
+		panel_list_item_remove(item);
+
+	wl_list_remove(&surface->link);
+	free(surface->title);
+	free(surface);
+}
+
+static struct surface *
+desktop_get_surface(struct desktop *desktop, struct surface_data *surface_data)
+{
+	struct output *output;
+	struct list_item *item;
+
+	wl_list_for_each(output, &desktop->outputs, link) {
+		wl_list_for_each(item, &output->panel->window_list, link) {
+			if (surface_data == item->surface->surface_data)
+				return item->surface;
+		}
+	}
+
+	return NULL;
+}
+
+static void
+desktop_update_list_items(struct desktop *desktop, struct surface *surface)
+{
+	struct output *output;
+
+	wl_list_for_each(output, &desktop->outputs, link)
+		output_update_window_list(output, surface);
+}
+
+static void
+surface_data_set_output_mask(void *data,
+				struct surface_data *surface_data,
+				uint32_t output_mask)
+{
+	struct desktop *desktop;
+	struct surface *surface;
+
+	desktop = data;
+
+	surface = desktop_get_surface(desktop, surface_data);
+
+	if (!surface)
+		surface = desktop_create_surface(desktop, surface_data);
+
+	surface->output_mask = output_mask;
+
+	desktop_update_list_items(desktop, surface);
+}
+
+static void
+surface_data_set_title(void *data,
+				struct surface_data *surface_data,
+				const char *title)
+{
+	struct desktop *desktop;
+	struct surface *surface;
+
+	desktop = data;
+
+	surface = desktop_get_surface(desktop, surface_data);
+
+	if (!surface)
+		surface = desktop_create_surface(desktop, surface_data);
+
+	if (surface->title)
+		free(surface->title);
+	surface->title = strdup(title);
+
+	desktop_update_list_items(desktop, surface);
+}
+
+static void
+surface_data_set_maximized_state(void *data,
+				struct surface_data *surface_data,
+				int maximized)
+{
+	struct desktop *desktop;
+	struct surface *surface;
+
+	desktop = data;
+
+	surface = desktop_get_surface(desktop, surface_data);
+
+	if (!surface)
+		surface = desktop_create_surface(desktop, surface_data);
+
+	surface->maximized = maximized;
+
+	desktop_update_list_items(desktop, surface);
+}
+
+static void
+surface_data_set_minimized_state(void *data,
+				struct surface_data *surface_data,
+				int minimized)
+{
+	struct desktop *desktop;
+	struct surface *surface;
+
+	desktop = data;
+
+	surface = desktop_get_surface(desktop, surface_data);
+
+	if (!surface)
+		surface = desktop_create_surface(desktop, surface_data);
+
+	surface->minimized = minimized;
+
+	desktop_update_list_items(desktop, surface);
+}
+
+static void
+surface_data_set_focused_state(void *data,
+				struct surface_data *surface_data,
+				int focused)
+{
+	struct desktop *desktop;
+	struct surface *surface;
+	struct list_item *item;
+
+	desktop = data;
+
+	wl_list_for_each(surface, &desktop->surfaces, link)
+		if (surface->surface_data != surface_data && focused) {
+			surface->focused = false;
+			wl_list_for_each(item, &surface->item_list, surface_link)
+				if (!item->focused)
+					item->highlight = false;
+		}
+
+	surface = desktop_get_surface(desktop, surface_data);
+
+	if (!surface)
+		surface = desktop_create_surface(desktop, surface_data);
+
+	surface->focused = focused;
+
+	desktop_update_list_items(desktop, surface);
+}
+
+static void
+surface_data_destroy_handler(void *data, struct surface_data *surface_data)
+{
+	struct list_item *item, *next;
+	struct desktop *desktop;
+	struct output *output;
+	struct panel *panel;
+
+	desktop = data;
+
+	surface_data_destroy(surface_data);
+
+	wl_list_for_each(output, &desktop->outputs, link) {
+		panel = output->panel;
+		wl_list_for_each_safe(item, next, &panel->window_list, link) {
+			if (surface_data == item->surface->surface_data) {
+				desktop_destroy_surface(item->surface);
+				return;
+			}
+		}
+	}
+}
+
+static const struct surface_data_listener surface_data_listener = {
+	surface_data_set_output_mask,
+	surface_data_set_title,
+	surface_data_set_maximized_state,
+	surface_data_set_minimized_state,
+	surface_data_set_focused_state,
+	surface_data_destroy_handler
+};
+
+static void
+surface_data_receive_surface_object(void *data,
+				struct surface_data_manager *manager,
+				struct surface_data *surface_data)
+{
+	surface_data_add_listener(surface_data,
+				   &surface_data_listener, data);
+}
+
+static const struct surface_data_manager_listener surface_data_manager_listener = {
+	surface_data_receive_surface_object
+};
+
 static struct background *
 background_create(struct desktop *desktop)
 {
@@ -1022,6 +1758,15 @@ desktop_destroy_outputs(struct desktop *desktop)
 }
 
 static void
+desktop_destroy_surfaces(struct desktop *desktop)
+{
+	struct surface *surface, *next;
+
+	wl_list_for_each_safe(surface, next, &desktop->surfaces, link)
+		desktop_destroy_surface(surface);
+}
+
+static void
 create_output(struct desktop *desktop, uint32_t id)
 {
 	struct output *output;
@@ -1033,7 +1778,9 @@ create_output(struct desktop *desktop, uint32_t id)
 	output->output =
 		display_bind(desktop->display, id, &wl_output_interface, 1);
 
-	wl_list_insert(&desktop->outputs, &output->link);
+	output->id = desktop->output_count++;
+
+	wl_list_insert(desktop->outputs.prev, &output->link);
 }
 
 static void
@@ -1046,6 +1793,12 @@ global_handler(struct display *display, uint32_t id,
 		desktop->shell = display_bind(desktop->display,
 					      id, &desktop_shell_interface, 1);
 		desktop_shell_add_listener(desktop->shell, &listener, desktop);
+	} else if (strcmp(interface, "surface_data_manager") == 0) {
+		desktop->surface_data_manager =
+				display_bind(display, id,
+					&surface_data_manager_interface, 1);
+		surface_data_manager_add_listener(desktop->surface_data_manager,
+					&surface_data_manager_listener, desktop);
 	} else if (!strcmp(interface, "wl_output")) {
 		create_output(desktop, id);
 	}
@@ -1100,6 +1853,9 @@ int main(int argc, char *argv[])
 		return -1;
 	}
 
+	wl_list_init(&desktop.surfaces);
+	desktop.output_count = 0;
+
 	display_set_user_data(desktop.display, &desktop);
 	display_set_global_handler(desktop.display, global_handler);
 
@@ -1133,6 +1889,7 @@ int main(int argc, char *argv[])
 
 	/* Cleanup */
 	grab_surface_destroy(&desktop);
+	desktop_destroy_surfaces(&desktop);
 	desktop_destroy_outputs(&desktop);
 	if (desktop.unlock_dialog)
 		unlock_dialog_destroy(desktop.unlock_dialog);
diff --git a/clients/simple-egl.c b/clients/simple-egl.c
index fcbea75..273159b 100644
--- a/clients/simple-egl.c
+++ b/clients/simple-egl.c
@@ -250,10 +250,34 @@ handle_popup_done(void *data, struct wl_shell_surface *shell_surface)
 {
 }
 
+static void
+handle_maximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unmaximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_minimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unminimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
 static const struct wl_shell_surface_listener shell_surface_listener = {
 	handle_ping,
 	handle_configure,
-	handle_popup_done
+	handle_popup_done,
+	handle_maximize,
+	handle_unmaximize,
+	handle_minimize,
+	handle_unminimize
 };
 
 static void
diff --git a/clients/simple-shm.c b/clients/simple-shm.c
index a09ec91..7f8809a 100644
--- a/clients/simple-shm.c
+++ b/clients/simple-shm.c
@@ -107,10 +107,34 @@ handle_popup_done(void *data, struct wl_shell_surface *shell_surface)
 {
 }
 
+static void
+handle_maximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unmaximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_minimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unminimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
 static const struct wl_shell_surface_listener shell_surface_listener = {
 	handle_ping,
 	handle_configure,
-	handle_popup_done
+	handle_popup_done,
+	handle_maximize,
+	handle_unmaximize,
+	handle_minimize,
+	handle_unminimize
 };
 
 static struct window *
diff --git a/clients/simple-touch.c b/clients/simple-touch.c
index cbe3877..c9b594b 100644
--- a/clients/simple-touch.c
+++ b/clients/simple-touch.c
@@ -233,10 +233,34 @@ handle_popup_done(void *data, struct wl_shell_surface *shell_surface)
 {
 }
 
+static void
+handle_maximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unmaximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_minimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unminimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
 static const struct wl_shell_surface_listener shell_surface_listener = {
 	handle_ping,
 	handle_configure,
-	handle_popup_done
+	handle_popup_done,
+	handle_maximize,
+	handle_unmaximize,
+	handle_minimize,
+	handle_unminimize
 };
 
 static void
diff --git a/clients/window.c b/clients/window.c
index fe968ed..9a11571 100644
--- a/clients/window.c
+++ b/clients/window.c
@@ -163,6 +163,7 @@ struct window {
 	int type;
 	int transparent;
 	int focus_count;
+	int minimized;
 
 	enum window_buffer_type buffer_type;
 
@@ -1564,7 +1565,7 @@ frame_button_button_handler(struct widget *widget,
 			display_exit(window->display);
 		break;
 	case FRAME_BUTTON_MINIMIZE:
-		fprintf(stderr,"Minimize stub\n");
+		window_set_minimized(window, !window->minimized);
 		break;
 	case FRAME_BUTTON_MAXIMIZE:
 		window_set_maximized(window, window->type != TYPE_MAXIMIZED);
@@ -2932,10 +2933,48 @@ handle_popup_done(void *data, struct wl_shell_surface *shell_surface)
 	menu_destroy(menu);
 }
 
+static void
+handle_maximize(void *data, struct wl_shell_surface *shell_surface)
+{
+	struct window *window = data;
+
+	window_set_maximized(window, 1);
+}
+
+static void
+handle_unmaximize(void *data, struct wl_shell_surface *shell_surface)
+{
+	struct window *window = data;
+
+	window_set_maximized(window, 0);
+}
+
+static void
+handle_minimize(void *data, struct wl_shell_surface *shell_surface)
+{
+	struct window *window = data;
+
+	if (!window->minimized)
+		window->minimized = 1;
+}
+
+static void
+handle_unminimize(void *data, struct wl_shell_surface *shell_surface)
+{
+	struct window *window = data;
+
+	if (window->minimized)
+		window->minimized = 0;
+}
+
 static const struct wl_shell_surface_listener shell_surface_listener = {
 	handle_ping,
 	handle_configure,
-	handle_popup_done
+	handle_popup_done,
+	handle_maximize,
+	handle_unmaximize,
+	handle_minimize,
+	handle_unminimize
 };
 
 void
@@ -3048,6 +3087,8 @@ window_set_maximized(struct window *window, int maximized)
 		return;
 
 	if (window->type == TYPE_TOPLEVEL) {
+		if (window->resize_needed)
+			return;
 		window->saved_allocation = window->allocation;
 		wl_shell_surface_set_maximized(window->shell_surface, NULL);
 		window->type = TYPE_MAXIMIZED;
@@ -3061,6 +3102,22 @@ window_set_maximized(struct window *window, int maximized)
 }
 
 void
+window_set_minimized(struct window *window, int minimized)
+{
+	if (!window->display->shell)
+		return;
+
+	if ((window->minimized) == minimized)
+		return;
+
+	if (!window->minimized) {
+		wl_shell_surface_set_minimized(window->shell_surface);
+		window->minimized = 1;
+	} else
+		window->minimized = 0;
+}
+
+void
 window_set_user_data(struct window *window, void *data)
 {
 	window->user_data = data;
diff --git a/clients/window.h b/clients/window.h
index 84846ff..81fd1ea 100644
--- a/clients/window.h
+++ b/clients/window.h
@@ -304,6 +304,9 @@ void
 window_set_maximized(struct window *window, int maximized);
 
 void
+window_set_minimized(struct window *window, int minimized);
+
+void
 window_set_user_data(struct window *window, void *data);
 
 void *
diff --git a/protocol/desktop-shell.xml b/protocol/desktop-shell.xml
index 2b6afbd..2af3b85 100644
--- a/protocol/desktop-shell.xml
+++ b/protocol/desktop-shell.xml
@@ -82,6 +82,78 @@
     </enum>
   </interface>
 
+  <interface name="surface_data" version="1">
+    <description summary="the surface data offer object">
+	The shell can use this interface to receive surface information or make
+	requests for this surface.
+    </description>
+    <request name="maximize">
+      <description summary="ask the compositor to maximize the surface"/>
+    </request>
+    <request name="unmaximize">
+      <description summary="ask the compositor to unmaximize the surface"/>
+    </request>
+    <request name="minimize">
+      <description summary="ask the compositor to minimize the surface"/>
+    </request>
+    <request name="unminimize">
+      <description summary="ask the compositor to unminimize the surface"/>
+    </request>
+    <request name="focus">
+      <description summary="ask the compositor to focus the surface"/>
+    </request>
+    <request name="close">
+      <description summary="ask the compositor to close the surface"/>
+    </request>
+    <request name="destroy" type="destructor">
+      <description summary="destroy surface request">
+	The shell must send this request in response to a gone event so	the
+	compositor can destroy the object properly.
+      </description>
+    </request>
+    <event name="output_mask">
+      <description summary="send the surface object output_mask to the shell"/>
+      <arg name="output_mask" type="uint"/>
+    </event>
+    <event name="title">
+      <description summary="send the surface object title to the shell"/>
+      <arg name="title" type="string"/>
+    </event>
+    <event name="maximized">
+      <description summary="send the surface object maximize state to the shell"/>
+      <arg name="maximized" type="int"/>
+    </event>
+    <event name="minimized">
+      <description summary="send the surface object minimize state to the shell"/>
+      <arg name="minimized" type="int"/>
+    </event>
+    <event name="focused">
+      <description summary="send the surface object focus state to the shell"/>
+      <arg name="focused" type="int"/>
+    </event>
+    <event name="gone">
+      <description summary="destroy surface notification">
+	The compositor should send this event to notify the shell that a
+	surface has been destroyed. The client must respond with a destroy
+	request.
+      </description>
+    </event>
+  </interface>
+
+  <interface name="surface_data_manager" version="1">
+    <description summary="send surface object to shell">
+	The compositor can offer surface data to a shell. The client can use
+	this interface as a way to receive special surface_data objects.
+    </description>
+    <event name="surface_object">
+      <description summary="surface object">
+	Surface object sent to a shell. This object is intended to allow the
+	shell to initiate a surface_data object interface.
+      </description>
+      <arg name="id" type="new_id" interface="surface_data"/>
+    </event>
+  </interface>
+
   <interface name="screensaver" version="1">
     <description summary="interface for implementing screensavers">
       Only one client can bind this interface at a time.
diff --git a/src/compositor.c b/src/compositor.c
index 2d5b263..403f910 100644
--- a/src/compositor.c
+++ b/src/compositor.c
@@ -374,6 +374,8 @@ weston_surface_update_output_mask(struct weston_surface *es, uint32_t mask)
 		if (1 << output->id & left)
 			wl_surface_send_leave(&es->surface.resource, resource);
 	}
+
+	es->compositor->shell_interface.send_output_mask(es);
 }
 
 static void
@@ -1056,6 +1058,7 @@ WL_EXPORT void
 weston_layer_init(struct weston_layer *layer, struct wl_list *below)
 {
 	wl_list_init(&layer->surface_list);
+	wl_list_init(&layer->minimized_list);
 	if (below != NULL)
 		wl_list_insert(below, &layer->link);
 }
diff --git a/src/compositor.h b/src/compositor.h
index 121f6bf..31f1949 100644
--- a/src/compositor.h
+++ b/src/compositor.h
@@ -94,6 +94,7 @@ struct weston_shell_interface {
 	int (*move)(struct shell_surface *shsurf, struct weston_seat *ws);
 	int (*resize)(struct shell_surface *shsurf,
 		      struct weston_seat *ws, uint32_t edges);
+	void (*send_output_mask)(struct weston_surface *surface);
 
 };
 
@@ -265,6 +266,7 @@ enum {
 
 struct weston_layer {
 	struct wl_list surface_list;
+	struct wl_list minimized_list;
 	struct wl_list link;
 };
 
diff --git a/src/shell.c b/src/shell.c
index b28353e..26068cd 100644
--- a/src/shell.c
+++ b/src/shell.c
@@ -97,6 +97,8 @@ struct desktop_shell {
 		uint32_t deathstamp;
 	} child;
 
+	struct wl_resource *surface_data_manager;
+
 	bool locked;
 	bool showing_input_panels;
 	bool prepare_event_sent;
@@ -152,6 +154,11 @@ struct ping_timer {
 	uint32_t serial;
 };
 
+struct surface_data {
+	struct shell_surface *shsurf;
+	struct wl_resource resource;
+};
+
 struct shell_surface {
 	struct wl_resource resource;
 
@@ -160,11 +167,12 @@ struct shell_surface {
 	struct weston_surface *parent;
 	struct desktop_shell *shell;
 
-	enum shell_surface_type type, next_type;
+	enum shell_surface_type type, next_type, saved_type;
 	char *title, *class;
 	int32_t saved_x, saved_y;
 	bool saved_position_valid;
 	bool saved_rotation_valid;
+	bool minimized;
 	int unresponsive;
 
 	struct {
@@ -202,6 +210,7 @@ struct shell_surface {
 	struct wl_list link;
 
 	const struct weston_shell_client *client;
+	struct surface_data *surface_data;
 };
 
 struct shell_grab {
@@ -1397,6 +1406,339 @@ shell_surface_pong(struct wl_client *client, struct wl_resource *resource,
 }
 
 static void
+surface_data_destroy_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	wl_resource_destroy(resource);
+}
+
+static void
+send_surface_data_focused_state(struct weston_surface *surface);
+
+static void
+activate(struct desktop_shell *shell, struct weston_surface *es,
+	 struct weston_seat *seat);
+
+static void
+shell_surface_focus(struct shell_surface *shsurf)
+{
+	struct desktop_shell *shell;
+	struct weston_compositor *compositor;
+	struct weston_surface *surface;
+	struct weston_seat *seat;
+
+	shell = shsurf->shell;
+	compositor = shell->compositor;
+	surface = shsurf->surface;
+
+	wl_list_for_each(seat, &surface->compositor->seat_list, link)
+		if (seat->seat.keyboard) {
+			wl_keyboard_set_focus(seat->seat.keyboard,
+							&surface->surface);
+			activate(shell, surface, seat);
+		}
+
+	weston_compositor_damage_all(compositor);
+}
+
+static void
+shell_surface_minimize(struct shell_surface *shsurf)
+{
+	struct desktop_shell *shell;
+	struct weston_compositor *compositor;
+	struct weston_surface *surface;
+	struct workspace *ws;
+	struct weston_seat *seat;
+	struct weston_surface *focus;
+
+	shell = shsurf->shell;
+	compositor = shell->compositor;
+	surface = shsurf->surface;
+	ws = get_current_workspace(shell);
+
+	wl_list_remove(&surface->layer_link);
+	wl_list_insert(ws->layer.minimized_list.prev, &surface->layer_link);
+	shsurf->saved_type = shsurf->type;
+	shsurf->minimized = true;
+
+	/* Focus next surface in stack */
+	if (!wl_list_empty(&ws->layer.surface_list)) {
+		focus = container_of(ws->layer.surface_list.next,
+					 struct weston_surface,
+					 layer_link);
+		wl_list_for_each(seat, &compositor->seat_list, link)
+			if (seat->seat.keyboard &&
+			    seat->keyboard.focus == &surface->surface) {
+				shsurf = get_shell_surface(focus);
+				if (!shsurf)
+					break;
+				shell_surface_focus(shsurf);
+			}
+	}
+
+	send_surface_data_focused_state(surface);
+	wl_shell_surface_send_minimize(&shsurf->resource);
+
+	weston_compositor_damage_all(compositor);
+}
+
+static void
+surface_unminimize(struct shell_surface *shsurf, struct workspace *ws)
+{
+	struct desktop_shell *shell;
+	struct weston_compositor *compositor;
+	struct weston_surface *surface;
+
+	shell = shsurf->shell;
+	compositor = shell->compositor;
+	surface = shsurf->surface;
+
+	wl_list_remove(&surface->layer_link);
+	wl_list_insert(ws->layer.surface_list.prev, &surface->layer_link);
+	shell_surface_focus(shsurf);
+	send_surface_data_focused_state(surface);
+	wl_shell_surface_send_unminimize(&shsurf->resource);
+	shsurf->minimized = false;
+	weston_compositor_damage_all(compositor);
+}
+
+static void
+shell_surface_unminimize(struct shell_surface *shsurf)
+{
+	struct weston_surface *surface;
+	struct workspace *ws = get_current_workspace(shsurf->shell);
+
+	wl_list_for_each(surface, &ws->layer.minimized_list, layer_link)
+		if (surface == shsurf->surface) {
+			surface_unminimize(shsurf, ws);
+			return;
+		}
+}
+
+static void
+surface_data_maximize_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data = resource->data;
+
+	wl_shell_surface_send_maximize(&surface_data->shsurf->resource);
+}
+
+static void
+surface_data_unmaximize_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data = resource->data;
+
+	wl_shell_surface_send_unmaximize(&surface_data->shsurf->resource);
+}
+
+static void
+surface_data_minimize_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data = resource->data;
+
+	shell_surface_minimize(surface_data->shsurf);
+}
+
+static void
+surface_data_unminimize_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data = resource->data;
+
+	shell_surface_unminimize(surface_data->shsurf);
+}
+
+static void
+surface_data_focus_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data = resource->data;
+
+	shell_surface_focus(surface_data->shsurf);
+}
+
+static void
+surface_data_close_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data;
+	struct shell_surface *shsurf;
+	struct wl_surface *target_surface;
+	struct wl_client *target_client;
+	struct desktop_shell *shell;
+	struct weston_compositor *compositor;
+	pid_t pid;
+
+	surface_data = resource->data;
+	shsurf = surface_data->shsurf;
+	target_surface = &shsurf->surface->surface;
+	shell = shsurf->shell;
+	compositor = shell->compositor;
+
+	if (!target_surface)
+		return;
+
+	wl_signal_emit(&compositor->kill_signal, target_surface);
+
+	target_client = target_surface->resource.client;
+	wl_client_get_credentials(target_client, &pid, NULL, NULL);
+
+	/* Skip clients that we launched ourselves (the credentials of
+	 * the socketpair is ours) */
+	if (pid == getpid())
+		return;
+
+	kill(pid, SIGTERM);
+}
+
+static const struct surface_data_interface
+					surface_data_implementation = {
+	surface_data_maximize_handler,
+	surface_data_unmaximize_handler,
+	surface_data_minimize_handler,
+	surface_data_unminimize_handler,
+	surface_data_focus_handler,
+	surface_data_close_handler,
+	surface_data_destroy_handler
+};
+
+static void
+surface_data_object_destroy(struct wl_resource *resource)
+{
+	struct shell_surface *shsurf;
+	struct surface_data *surface_data = resource->data;
+
+	shsurf = surface_data->shsurf;
+
+	free(surface_data);
+
+	if (!shsurf)
+		return;
+
+	shsurf->surface_data = NULL;
+}
+
+static int
+create_surface_data(struct desktop_shell *shell, struct shell_surface *shsurf)
+{
+	struct surface_data *surface_data;
+
+	surface_data = malloc(sizeof *surface_data);
+	if (surface_data == NULL)
+		return -1;
+
+	surface_data->resource.data = surface_data;
+	surface_data->resource.object.id = 0;
+	surface_data->resource.object.interface = &surface_data_interface;
+	surface_data->resource.destroy = surface_data_object_destroy;
+	surface_data->resource.object.implementation =
+			(void (**)(void)) &surface_data_implementation;
+	surface_data->shsurf = shsurf;
+	wl_signal_init(&surface_data->resource.destroy_signal);
+
+	wl_client_add_resource(shell->surface_data_manager->client,
+					&surface_data->resource);
+
+	shsurf->surface_data = surface_data;
+
+	return 0;
+}
+
+static void
+send_surface_data_object(struct desktop_shell *shell, struct shell_surface *shsurf)
+{
+	surface_data_manager_send_surface_object(shell->surface_data_manager,
+					&shsurf->surface_data->resource);
+}
+
+static bool
+surface_is_window_list_candidate(struct weston_surface *surface,
+					struct shell_surface *out)
+{
+	struct desktop_shell *shell;
+	struct shell_surface *shsurf;
+
+	shsurf = get_shell_surface(surface);
+	if (!shsurf)
+		return false;
+
+	shell = shsurf->shell;
+
+	if (!shell->surface_data_manager)
+		return false;
+
+	switch (shsurf->type) {
+	default:
+	case SHELL_SURFACE_TRANSIENT:
+	case SHELL_SURFACE_POPUP:
+	case SHELL_SURFACE_NONE:
+		return false;
+	case SHELL_SURFACE_FULLSCREEN:
+	case SHELL_SURFACE_MAXIMIZED:
+	case SHELL_SURFACE_TOPLEVEL:
+		if (!shsurf->surface_data) {
+			if (create_surface_data(shell, shsurf))
+				return 0;
+			send_surface_data_object(shell, shsurf);
+		}
+		*out = *shsurf;
+		return true;
+	}
+}
+
+static void
+send_surface_data_output_mask(struct weston_surface *surface)
+{
+	struct shell_surface shsurf;
+
+	if (surface_is_window_list_candidate(surface, &shsurf))
+		surface_data_send_output_mask(&shsurf.surface_data->resource,
+						surface->output_mask);
+}
+
+static void
+send_surface_data_title(struct weston_surface *surface)
+{
+	struct shell_surface shsurf;
+
+	if (surface_is_window_list_candidate(surface, &shsurf))
+		surface_data_send_title(&shsurf.surface_data->resource,
+						shsurf.title == NULL ?
+						"Surface" : shsurf.title);
+}
+
+static void
+send_surface_data_minimized_state(struct weston_surface *surface)
+{
+	struct shell_surface shsurf;
+
+	if (surface_is_window_list_candidate(surface, &shsurf))
+		surface_data_send_minimized(&shsurf.surface_data->resource,
+					shsurf.minimized ? true : false);
+}
+
+static void
+send_surface_data_focused_state(struct weston_surface *surface)
+{
+	struct shell_surface shsurf;
+	struct focus_state *state;
+	struct workspace *ws;
+	bool focused = false;
+
+	if (surface_is_window_list_candidate(surface, &shsurf)) {
+		ws = get_current_workspace(shsurf.shell);
+		wl_list_for_each(state, &ws->focus_list, link)
+			if (state->keyboard_focus == shsurf.surface)
+				focused = true;
+		surface_data_send_focused(&shsurf.surface_data->resource,
+					focused);
+	}
+}
+
+static void
 shell_surface_set_title(struct wl_client *client,
 			struct wl_resource *resource, const char *title)
 {
@@ -1404,6 +1746,7 @@ shell_surface_set_title(struct wl_client *client,
 
 	free(shsurf->title);
 	shsurf->title = strdup(title);
+	send_surface_data_title(shsurf->surface);
 }
 
 static void
@@ -1466,6 +1809,7 @@ reset_shell_surface_type(struct shell_surface *surface)
 		weston_surface_set_position(surface->surface,
 					    surface->saved_x,
 					    surface->saved_y);
+		surface_data_send_maximized(&surface->surface_data->resource, false);
 		break;
 	case SHELL_SURFACE_NONE:
 	case SHELL_SURFACE_TOPLEVEL:
@@ -1502,6 +1846,7 @@ set_surface_type(struct shell_surface *shsurf)
 		shsurf->saved_x = surface->geometry.x;
 		shsurf->saved_y = surface->geometry.y;
 		shsurf->saved_position_valid = true;
+		surface_data_send_maximized(&shsurf->surface_data->resource, true);
 		break;
 
 	case SHELL_SURFACE_FULLSCREEN:
@@ -1520,6 +1865,8 @@ set_surface_type(struct shell_surface *shsurf)
 	default:
 		break;
 	}
+
+	send_surface_data_title(surface);
 }
 
 static void
@@ -1618,6 +1965,16 @@ shell_surface_set_maximized(struct wl_client *client,
 }
 
 static void
+shell_surface_set_minimized(struct wl_client *client,
+			    struct wl_resource *resource)
+{
+	struct shell_surface *shsurf = resource->data;
+
+	shell_surface_minimize(shsurf);
+	send_surface_data_minimized_state(shsurf->surface);
+}
+
+static void
 black_surface_configure(struct weston_surface *es, int32_t sx, int32_t sy);
 
 static struct weston_surface *
@@ -1924,6 +2281,7 @@ static const struct wl_shell_surface_interface shell_surface_implementation = {
 	shell_surface_set_fullscreen,
 	shell_surface_set_popup,
 	shell_surface_set_maximized,
+	shell_surface_set_minimized,
 	shell_surface_set_title,
 	shell_surface_set_class
 };
@@ -1931,6 +2289,10 @@ static const struct wl_shell_surface_interface shell_surface_implementation = {
 static void
 destroy_shell_surface(struct shell_surface *shsurf)
 {
+	if (shsurf->surface_data) {
+		shsurf->surface_data->shsurf = NULL;
+		surface_data_send_gone(&shsurf->surface_data->resource);
+	}
 	if (shsurf->popup.grab.pointer)
 		wl_pointer_end_grab(shsurf->popup.grab.pointer);
 
@@ -2012,6 +2374,7 @@ create_shell_surface(void *shell, struct weston_surface *surface,
 
 	shsurf->shell = (struct desktop_shell *) shell;
 	shsurf->unresponsive = 0;
+	shsurf->minimized = false;
 	shsurf->saved_position_valid = false;
 	shsurf->saved_rotation_valid = false;
 	shsurf->surface = surface;
@@ -2315,6 +2678,28 @@ static const struct desktop_shell_interface desktop_shell_implementation = {
 	desktop_shell_set_grab_surface
 };
 
+static void
+surface_data_send_all_info(struct desktop_shell *shell)
+{
+	struct weston_surface *surface;
+	struct workspace *ws;
+
+	ws = get_current_workspace(shell);
+
+	wl_list_for_each(surface, &ws->layer.surface_list, layer_link) {
+		send_surface_data_minimized_state(surface);
+		send_surface_data_focused_state(surface);
+		send_surface_data_output_mask(surface);
+		send_surface_data_title(surface);
+	}
+	wl_list_for_each(surface, &ws->layer.minimized_list, layer_link) {
+		send_surface_data_minimized_state(surface);
+		send_surface_data_focused_state(surface);
+		send_surface_data_output_mask(surface);
+		send_surface_data_title(surface);
+	}
+}
+
 static enum shell_surface_type
 get_shell_surface_type(struct weston_surface *surface)
 {
@@ -2650,6 +3035,7 @@ activate(struct desktop_shell *shell, struct weston_surface *es,
 		return;
 
 	state->keyboard_focus = es;
+	send_surface_data_focused_state(es);
 	wl_list_remove(&state->surface_destroy_listener.link);
 	wl_signal_add(&es->surface.resource.destroy_signal,
 		      &state->surface_destroy_listener);
@@ -2674,7 +3060,7 @@ black_surface_configure(struct weston_surface *es, int32_t sx, int32_t sy)
 {
 }
 
-static bool 
+static bool
 is_black_surface (struct weston_surface *es, struct weston_surface **fs_surface)
 {
 	if (es->configure == black_surface_configure) {
@@ -3143,6 +3529,37 @@ bind_desktop_shell(struct wl_client *client,
 }
 
 static void
+unbind_surface_data_manager(struct wl_resource *resource)
+{
+	struct desktop_shell *shell = resource->data;
+
+	shell->surface_data_manager = NULL;
+	free(resource);
+}
+
+static void
+bind_surface_data_manager(struct wl_client *client,
+		   void *data, uint32_t version, uint32_t id)
+{
+	struct desktop_shell *shell = data;
+	struct wl_resource *resource;
+
+	resource = wl_client_add_object(client, &surface_data_manager_interface,
+					NULL, id, shell);
+
+	if (client == shell->child.client) {
+		resource->destroy = unbind_surface_data_manager;
+		shell->surface_data_manager = resource;
+		surface_data_send_all_info(shell);
+		return;
+	}
+
+	wl_resource_post_error(resource, WL_DISPLAY_ERROR_INVALID_OBJECT,
+			       "permission to bind desktop_shell denied");
+	wl_resource_destroy(resource);
+}
+
+static void
 screensaver_configure(struct weston_surface *surface, int32_t sx, int32_t sy)
 {
 	struct desktop_shell *shell = surface->private;
@@ -3757,6 +4174,7 @@ module_init(struct weston_compositor *ec)
 	ec->shell_interface.set_transient = set_transient;
 	ec->shell_interface.move = surface_move;
 	ec->shell_interface.resize = surface_resize;
+	ec->shell_interface.send_output_mask = send_surface_data_output_mask;
 
 	wl_list_init(&shell->screensaver.surfaces);
 	wl_list_init(&shell->input_panel.surfaces);
@@ -3808,6 +4226,10 @@ module_init(struct weston_compositor *ec)
 				  shell, bind_workspace_manager) == NULL)
 		return -1;
 
+	if (wl_display_add_global(ec->wl_display, &surface_data_manager_interface,
+				  shell, bind_surface_data_manager) == NULL)
+		return -1;
+
 	shell->child.deathstamp = weston_compositor_get_time();
 
 	loop = wl_display_get_event_loop(ec->wl_display);







































diff --git a/configure.ac b/configure.ac
index 64505dd..57a444b 100644
--- a/configure.ac
+++ b/configure.ac
@@ -154,6 +154,16 @@ fi
 AM_CONDITIONAL(INSTALL_RPI_COMPOSITOR, test "x$have_bcm_host" = "xyes")
 
 
+AC_ARG_ENABLE([fbdev-compositor], [  --enable-fbdev-compositor],,
+              enable_fbdev_compositor=yes)
+AM_CONDITIONAL([ENABLE_FBDEV_COMPOSITOR],
+               [test x$enable_fbdev_compositor = xyes])
+AS_IF([test x$enable_fbdev_compositor = xyes], [
+  AC_DEFINE([BUILD_FBDEV_COMPOSITOR], [1], [Build the fbdev compositor])
+  PKG_CHECK_MODULES([FBDEV_COMPOSITOR], [libudev >= 136 mtdev >= 1.1.0])
+])
+
+
 AC_ARG_WITH(cairo-glesv2,
             AS_HELP_STRING([--with-cairo-glesv2],
                            [Use GLESv2 cairo instead of full GL]))
diff --git a/src/Makefile.am b/src/Makefile.am
index cbfa911..efa819d 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -84,7 +84,8 @@ module_LTLIBRARIES =				\
 	$(x11_backend)				\
 	$(drm_backend)				\
 	$(wayland_backend)			\
-	$(headless_backend)
+	$(headless_backend)			\
+	$(fbdev_backend)
 
 # Do not install, since the binary produced via autotools is unusable.
 # The real backend is built by the Android build system.
@@ -195,6 +196,29 @@ headless_backend_la_CFLAGS =			\
 headless_backend_la_SOURCES = compositor-headless.c
 endif
 
+if ENABLE_FBDEV_COMPOSITOR
+fbdev_backend = fbdev-backend.la
+fbdev_backend_la_LDFLAGS = -module -avoid-version
+fbdev_backend_la_LIBADD = \
+	$(COMPOSITOR_LIBS) \
+	$(FBDEV_COMPOSITOR_LIBS) \
+	../shared/libshared.la \
+	$(NULL)
+fbdev_backend_la_CFLAGS = \
+	$(COMPOSITOR_CFLAGS) \
+	$(FBDEV_COMPOSITOR_CFLAGS) \
+	$(PIXMAN_CFLAGS) \
+	$(GCC_CFLAGS) \
+	$(NULL)
+fbdev_backend_la_SOURCES = \
+	compositor-fbdev.c \
+	tty.c \
+	evdev.c \
+	evdev.h \
+	evdev-touchpad.c \
+	$(NULL)
+endif
+
 if ENABLE_DESKTOP_SHELL
 desktop_shell = desktop-shell.la
 desktop_shell_la_LDFLAGS = -module -avoid-version
diff --git a/src/compositor-fbdev.c b/src/compositor-fbdev.c
new file mode 100644
index 0000000..891a4db
--- /dev/null
+++ b/src/compositor-fbdev.c
@@ -0,0 +1,957 @@
+/*
+ * Copyright  2008-2011 Kristian Hgsberg
+ * Copyright  2011 Intel Corporation
+ * Copyright  2012 Raspberry Pi Foundation
+ * Copyright  2013 Philip Withnall
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of the copyright holders not be used in
+ * advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  The copyright holders make
+ * no representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#define _GNU_SOURCE
+
+#include <errno.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <sys/mman.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <linux/fb.h>
+
+#include <libudev.h>
+
+#include "config.h"
+
+#include "compositor.h"
+#include "pixman-renderer.h"
+#include "evdev.h"
+
+struct fbdev_compositor {
+	struct weston_compositor base;
+	uint32_t prev_state;
+
+	struct udev *udev;
+	struct tty *tty;
+};
+
+struct fbdev_output {
+	struct fbdev_compositor *compositor;
+	struct weston_output base;
+
+	struct weston_mode mode;
+	struct wl_event_source *finish_frame_timer;
+
+	/* Frame buffer details. */
+	struct fb_fix_screeninfo fixed_info;
+	struct fb_var_screeninfo variable_info;
+	void *fb;
+	size_t fb_len;
+
+	/* pixman details. */
+	pixman_image_t *hw_surface;
+	pixman_image_t *shadow_surface;
+	void *shadow_buf;
+	uint8_t depth;
+};
+
+struct fbdev_seat {
+	struct weston_seat base;
+	struct wl_list devices_list;
+
+	struct udev_monitor *udev_monitor;
+	struct wl_event_source *udev_monitor_source;
+	char *seat_id;
+};
+
+struct fbdev_parameters {
+	int tty;
+	char *device;
+};
+
+static inline struct fbdev_output *
+to_fbdev_output(struct weston_output *base)
+{
+	return container_of(base, struct fbdev_output, base);
+}
+
+static inline struct fbdev_seat *
+to_fbdev_seat(struct weston_seat *base)
+{
+	return container_of(base, struct fbdev_seat, base);
+}
+
+static inline struct fbdev_compositor *
+to_fbdev_compositor(struct weston_compositor *base)
+{
+	return container_of(base, struct fbdev_compositor, base);
+}
+
+static void
+fbdev_output_repaint(struct weston_output *base, pixman_region32_t *damage)
+{
+	struct fbdev_output *output = to_fbdev_output(base);
+	struct weston_compositor *ec = output->base.compositor;
+	pixman_box32_t *rects;
+	int nrects, i, src_x, src_y, x1, y1, x2, y2, width, height;
+
+	/* Repaint the damaged region onto the back buffer. */
+	pixman_renderer_output_set_buffer(base, output->shadow_surface);
+	ec->renderer->repaint_output(base, damage);
+
+	/* Transform and composite onto the frame buffer. */
+	width = pixman_image_get_width(output->shadow_surface);
+	height = pixman_image_get_height(output->shadow_surface);
+	rects = pixman_region32_rectangles(damage, &nrects);
+
+	for (i = 0; i < nrects; i++) {
+		switch (base->transform) {
+		default:
+		case WL_OUTPUT_TRANSFORM_NORMAL:
+			x1 = rects[i].x1;
+			x2 = rects[i].x2;
+			y1 = rects[i].y1;
+			y2 = rects[i].y2;
+			break;
+		case WL_OUTPUT_TRANSFORM_180:
+			x1 = width - rects[i].x2;
+			x2 = width - rects[i].x1;
+			y1 = height - rects[i].y2;
+			y2 = height - rects[i].y1;
+			break;
+		case WL_OUTPUT_TRANSFORM_90:
+			x1 = height - rects[i].y2;
+			x2 = height - rects[i].y1;
+			y1 = rects[i].x1;
+			y2 = rects[i].x2;
+			break;
+		case WL_OUTPUT_TRANSFORM_270:
+			x1 = rects[i].y1;
+			x2 = rects[i].y2;
+			y1 = width - rects[i].x2;
+			y2 = width - rects[i].x1;
+			break;
+		}
+		src_x = x1;
+		src_y = y1;
+
+		pixman_image_composite32(PIXMAN_OP_SRC,
+			output->shadow_surface, /* src */
+			NULL /* mask */,
+			output->hw_surface, /* dest */
+			src_x, src_y, /* src_x, src_y */
+			0, 0, /* mask_x, mask_y */
+			x1, y1, /* dest_x, dest_y */
+			x2 - x1, /* width */
+			y2 - y1 /* height */);
+	}
+
+	/* Update the damage region. */
+	pixman_region32_subtract(&ec->primary_plane.damage,
+	                         &ec->primary_plane.damage, damage);
+
+	/* Schedule the end of the frame. We do not sync this to the frame
+	 * buffer clock because users who want that should be using the DRM
+	 * compositor. FBIO_WAITFORVSYNC blocks and FB_ACTIVATE_VBL requires
+	 * panning, which is broken in most kernel drivers.
+	 *
+	 * Finish the frame synchronised to the specified refresh rate. The
+	 * refresh rate is given in mHz and the interval in ms. */
+	wl_event_source_timer_update(output->finish_frame_timer,
+	                             1000000 / output->mode.refresh);
+}
+
+static int
+finish_frame_handler(void *data)
+{
+	struct fbdev_output *output = data;
+	uint32_t msec;
+	struct timeval tv;
+
+	gettimeofday(&tv, NULL);
+	msec = tv.tv_sec * 1000 + tv.tv_usec / 1000;
+	weston_output_finish_frame(&output->base, msec);
+
+	return 1;
+}
+
+static int
+fbdev_frame_buffer_create(struct fbdev_output *output, const char *fb_dev)
+{
+	int retval = -1;
+	int fd = -1;
+
+	/* Open the frame buffer device. */
+	fd = open (fb_dev, O_RDWR | O_CLOEXEC);
+	if (fd < 0) {
+		weston_log("Failed to open frame buffer device %s: %s\n",
+		           fb_dev, strerror(errno));
+		goto err;
+	}
+
+	/* Grab the screen info. */
+	if (ioctl(fd, FBIOGET_FSCREENINFO, &output->fixed_info) < 0 ||
+	    ioctl(fd, FBIOGET_VSCREENINFO, &output->variable_info) < 0) {
+		weston_log("Failed to get frame buffer info: %s\n",
+		           strerror(errno));
+		goto err;
+	}
+
+	/* Map the frame buffer. Write-only mode, since we don't want to read
+	 * anything back (because it's slow). */
+	output->fb = mmap (NULL, output->fixed_info.smem_len,
+	                   PROT_WRITE, MAP_SHARED, fd, 0);
+	if (output->fb == MAP_FAILED) {
+		weston_log("Failed to mmap frame buffer: %s\n",
+		           strerror(errno));
+		goto err;
+	}
+
+	/* Success! */
+	output->fb_len = output->fixed_info.smem_len;
+	retval = 0;
+
+err:
+	if (fd >= 0)
+		close (fd);
+
+	return retval;
+}
+
+static void
+fbdev_frame_buffer_destroy(struct fbdev_output *output)
+{
+	if (munmap(output->fb, output->fb_len) < 0)
+		weston_log("Failed to munmap frame buffer: %s\n",
+		           strerror(errno));
+
+	output->fb = NULL;
+	output->fb_len = 0;
+}
+
+static pixman_format_code_t
+calculate_pixman_format(struct fb_var_screeninfo *vinfo,
+                        struct fb_fix_screeninfo *finfo)
+{
+	/* Calculate the pixman format supported by the frame buffer from the
+	 * buffer's metadata. Return 0 if no known pixman format is supported
+	 * (since this has depth 0 it's guaranteed to not conflict with any
+	 * actual pixman format).
+	 *
+	 * Documentation on the vinfo and finfo structures:
+	 *    http://www.mjmwired.net/kernel/Documentation/fb/api.txt
+	 *
+	 * TODO: Try a bit harder to support other formats, including setting
+	 * the preferred format in the hardware. */
+	int type;
+
+	weston_log("Calculating pixman format from:\n"
+	           STAMP_SPACE " - type: %i (aux: %i)\n"
+	           STAMP_SPACE " - visual: %i\n"
+	           STAMP_SPACE " - bpp: %i (grayscale: %i)\n"
+	           STAMP_SPACE " - red: offset: %i, length: %i, MSB: %i\n"
+	           STAMP_SPACE " - green: offset: %i, length: %i, MSB: %i\n"
+	           STAMP_SPACE " - blue: offset: %i, length: %i, MSB: %i\n"
+	           STAMP_SPACE " - transp: offset: %i, length: %i, MSB: %i\n",
+	           finfo->type, finfo->type_aux, finfo->visual,
+	           vinfo->bits_per_pixel, vinfo->grayscale,
+	           vinfo->red.offset, vinfo->red.length, vinfo->red.msb_right,
+	           vinfo->green.offset, vinfo->green.length,
+	           vinfo->green.msb_right,
+	           vinfo->blue.offset, vinfo->blue.length,
+	           vinfo->blue.msb_right,
+	           vinfo->transp.offset, vinfo->transp.length,
+	           vinfo->transp.msb_right);
+
+	/* We only handle packed formats at the moment. */
+	if (finfo->type != FB_TYPE_PACKED_PIXELS)
+		return 0;
+
+	/* We only handle true-colour frame buffers at the moment. */
+	if (finfo->visual != FB_VISUAL_TRUECOLOR || vinfo->grayscale != 0)
+		return 0;
+
+	/* We only support formats with MSBs on the left. */
+	if (vinfo->red.msb_right != 0 || vinfo->green.msb_right != 0 ||
+	    vinfo->blue.msb_right != 0)
+		return 0;
+
+	/* Work out the format type from the offsets. We only support RGBA and
+	 * ARGB at the moment. */
+	type = PIXMAN_TYPE_OTHER;
+
+	if ((vinfo->transp.offset >= vinfo->red.offset ||
+	     vinfo->transp.length == 0) &&
+	    vinfo->red.offset >= vinfo->green.offset &&
+	    vinfo->green.offset >= vinfo->blue.offset)
+		type = PIXMAN_TYPE_ARGB;
+	else if (vinfo->red.offset >= vinfo->green.offset &&
+	         vinfo->green.offset >= vinfo->blue.offset &&
+	         vinfo->blue.offset >= vinfo->transp.offset)
+		type = PIXMAN_TYPE_RGBA;
+
+	if (type == PIXMAN_TYPE_OTHER)
+		return 0;
+
+	/* Build the format. */
+	return PIXMAN_FORMAT(vinfo->bits_per_pixel, type,
+	                     vinfo->transp.length,
+	                     vinfo->red.length,
+	                     vinfo->green.length,
+	                     vinfo->blue.length);
+}
+
+static int
+calculate_refresh_rate(struct fb_var_screeninfo *vinfo)
+{
+	uint64_t quot;
+
+	/* Calculate monitor refresh rate. Default is 60 Hz. Units are mHz. */
+	quot = (vinfo->upper_margin + vinfo->lower_margin + vinfo->yres);
+	quot *= (vinfo->left_margin + vinfo->right_margin + vinfo->xres);
+	quot *= vinfo->pixclock;
+
+	if (quot > 0) {
+		uint64_t refresh_rate;
+
+		refresh_rate = 1000000000000000LLU / quot;
+		if (refresh_rate > 200000)
+			refresh_rate = 200000; /* cap at 200 Hz */
+
+		return refresh_rate;
+	}
+
+	return 60 * 1000; /* default to 60 Hz */
+}
+
+static void fbdev_output_destroy(struct weston_output *base);
+
+static int
+fbdev_output_create(struct fbdev_compositor *compositor,
+                    struct fbdev_parameters *param)
+{
+	struct fbdev_output *output;
+	pixman_transform_t transform;
+	int shadow_width, shadow_height;
+	int width, height;
+	pixman_format_code_t pixman_format;
+	struct wl_event_loop *loop;
+
+	output = calloc(1, sizeof *output);
+	if (!output)
+		return -1;
+
+	output->compositor = compositor;
+
+	/* Create the frame buffer. */
+	if (fbdev_frame_buffer_create(output, param->device) < 0) {
+		weston_log("Creating frame buffer failed.\n");
+		goto out_free;
+	}
+
+	pixman_format = calculate_pixman_format(&output->variable_info, &output->fixed_info);
+	if (pixman_format == 0) {
+		weston_log("Frame buffer uses an unsupported format.\n");
+		goto out_fb;
+	}
+
+	output->base.repaint = fbdev_output_repaint;
+	output->base.destroy = fbdev_output_destroy;
+	output->base.assign_planes = NULL;
+	output->base.set_backlight = NULL;
+	output->base.set_dpms = NULL;
+	output->base.switch_mode = NULL;
+
+	/* only one static mode in list */
+	output->mode.flags =
+		WL_OUTPUT_MODE_CURRENT | WL_OUTPUT_MODE_PREFERRED;
+	output->mode.width = output->variable_info.xres;
+	output->mode.height = output->variable_info.yres;
+	output->mode.refresh = calculate_refresh_rate(&output->variable_info);
+	wl_list_init(&output->base.mode_list);
+	wl_list_insert(&output->base.mode_list, &output->mode.link);
+
+	output->base.current = &output->mode;
+	output->base.origin = &output->mode;
+	output->base.subpixel = WL_OUTPUT_SUBPIXEL_UNKNOWN;
+	output->base.make = "fbdev";
+	output->base.model = output->fixed_info.id;
+
+	weston_output_init(&output->base, &compositor->base,
+	                   0, 0, output->variable_info.width,
+	                   output->variable_info.height,
+	                   WL_OUTPUT_TRANSFORM_NORMAL);
+
+	/* Create a pixman image to wrap the memory mapped frame buffer. */
+	width = output->variable_info.xres;
+	height = output->variable_info.yres;
+
+	output->hw_surface =
+		pixman_image_create_bits(pixman_format, width, height,
+		                         output->fb,
+		                         output->fixed_info.line_length);
+	if (output->hw_surface == NULL) {
+		weston_log("Failed to create surface for frame buffer.\n");
+		goto out_output;
+	}
+
+	pixman_transform_init_identity(&transform);
+	switch (output->base.transform) {
+	default:
+	case WL_OUTPUT_TRANSFORM_NORMAL:
+		shadow_width = width;
+		shadow_height = height;
+		pixman_transform_rotate(&transform,
+			NULL, 0, 0);
+		pixman_transform_translate(&transform, NULL,
+			0, 0);
+		break;
+	case WL_OUTPUT_TRANSFORM_180:
+		shadow_width = width;
+		shadow_height = height;
+		pixman_transform_rotate(&transform,
+			NULL, -pixman_fixed_1, 0);
+		pixman_transform_translate(NULL, &transform,
+			pixman_int_to_fixed(shadow_width),
+			pixman_int_to_fixed(shadow_height));
+		break;
+	case WL_OUTPUT_TRANSFORM_270:
+		shadow_width = height;
+		shadow_height = width;
+		pixman_transform_rotate(&transform,
+			NULL, 0, pixman_fixed_1);
+		pixman_transform_translate(&transform,
+			NULL,
+			pixman_int_to_fixed(shadow_width),
+			0);
+		break;
+	case WL_OUTPUT_TRANSFORM_90:
+		shadow_width = height;
+		shadow_height = width;
+		pixman_transform_rotate(&transform,
+			NULL, 0, -pixman_fixed_1);
+		pixman_transform_translate(&transform,
+			NULL,
+			0,
+			pixman_int_to_fixed(shadow_height));
+		break;
+	}
+
+	output->shadow_buf = malloc(width * height * (output->variable_info.bits_per_pixel / 8));
+	output->shadow_surface =
+		pixman_image_create_bits(pixman_format, shadow_width,
+		                         shadow_height, output->shadow_buf,
+		                         shadow_width * (output->variable_info.bits_per_pixel / 8));
+	if (output->shadow_buf == NULL || output->shadow_surface == NULL) {
+		weston_log("Failed to create surface for frame buffer.\n");
+		goto out_hw_surface;
+	}
+
+	/* No need in transform for normal output */
+	if (output->base.transform != WL_OUTPUT_TRANSFORM_NORMAL)
+		pixman_image_set_transform(output->shadow_surface, &transform);
+
+	if (pixman_renderer_output_create(&output->base) < 0)
+		goto out_shadow_surface;
+
+	loop = wl_display_get_event_loop(compositor->base.wl_display);
+	output->finish_frame_timer =
+		wl_event_loop_add_timer(loop, finish_frame_handler, output);
+
+	wl_list_insert(compositor->base.output_list.prev, &output->base.link);
+
+	weston_log("fbdev output %d%d px\n",
+	           output->mode.width, output->mode.height);
+	weston_log_continue(STAMP_SPACE "guessing %d Hz and 96 dpi\n",
+	                    output->mode.refresh / 1000);
+
+	return 0;
+
+out_shadow_surface:
+	pixman_image_unref(output->shadow_surface);
+out_hw_surface:
+	free(output->shadow_buf);
+	pixman_image_unref(output->hw_surface);
+out_output:
+	weston_output_destroy(&output->base);
+out_fb:
+	fbdev_frame_buffer_destroy(output);
+out_free:
+	free(output);
+
+	return -1;
+}
+
+static void
+fbdev_output_destroy(struct weston_output *base)
+{
+	struct fbdev_output *output = to_fbdev_output(base);
+
+	weston_log("%s\n", __func__);
+
+	pixman_renderer_output_destroy(base);
+
+	pixman_image_unref(output->hw_surface);
+	output->hw_surface = NULL;
+
+	pixman_image_unref(output->shadow_surface);
+	output->shadow_surface = NULL;
+
+	free(output->shadow_buf);
+	output->shadow_buf = NULL;
+
+	fbdev_frame_buffer_destroy(output);
+
+	wl_list_remove(&output->base.link);
+	weston_output_destroy(&output->base);
+
+	free(output);
+}
+
+static void
+fbdev_led_update(struct weston_seat *seat_base, enum weston_led leds)
+{
+	struct fbdev_seat *seat = to_fbdev_seat(seat_base);
+	struct evdev_device *device;
+
+	wl_list_for_each(device, &seat->devices_list, link)
+		evdev_led_update(device, leds);
+}
+
+static const char default_seat[] = "seat0";
+
+static void
+device_added(struct udev_device *udev_device, struct fbdev_seat *master)
+{
+	struct evdev_device *device;
+	const char *devnode;
+	const char *device_seat;
+	int fd;
+
+	device_seat = udev_device_get_property_value(udev_device, "ID_SEAT");
+	if (!device_seat)
+		device_seat = default_seat;
+
+	if (strcmp(device_seat, master->seat_id))
+		return;
+
+	devnode = udev_device_get_devnode(udev_device);
+	if (devnode == NULL) {
+		weston_log("Getting devnode for device on seat %s failed.\n",
+		           device_seat);
+		return;
+	}
+
+	/* Use non-blocking mode so that we can loop on read on
+	 * evdev_device_data() until all events on the fd are
+	 * read.  mtdev_get() also expects this. */
+	fd = open(devnode, O_RDWR | O_NONBLOCK | O_CLOEXEC);
+	if (fd < 0) {
+		weston_log("opening input device '%s' failed.\n", devnode);
+		return;
+	}
+
+	device = evdev_device_create(&master->base, devnode, fd);
+	if (!device) {
+		close(fd);
+		weston_log("not using input device '%s'.\n", devnode);
+		return;
+	}
+
+	wl_list_insert(master->devices_list.prev, &device->link);
+}
+
+static void
+evdev_add_devices(struct udev *udev, struct weston_seat *seat_base)
+{
+	struct fbdev_seat *seat = to_fbdev_seat(seat_base);
+	struct udev_enumerate *e;
+	struct udev_list_entry *entry;
+	struct udev_device *device;
+	const char *path, *sysname;
+
+	e = udev_enumerate_new(udev);
+	if (e == NULL)
+		return;
+
+	if (udev_enumerate_add_match_subsystem(e, "input") < 0 ||
+	    udev_enumerate_scan_devices(e) < 0)
+		goto out_enumerate;
+
+	udev_list_entry_foreach(entry, udev_enumerate_get_list_entry(e)) {
+		path = udev_list_entry_get_name(entry);
+		device = udev_device_new_from_syspath(udev, path);
+
+		if (device == NULL)
+			continue;
+
+		sysname = udev_device_get_sysname(device);
+		if (strncmp("event", sysname, 5) != 0) {
+			udev_device_unref(device);
+			continue;
+		}
+
+		device_added(device, seat);
+
+		udev_device_unref(device);
+	}
+	udev_enumerate_unref(e);
+
+	evdev_notify_keyboard_focus(&seat->base, &seat->devices_list);
+
+	if (wl_list_empty(&seat->devices_list)) {
+		weston_log(
+			"warning: no input devices on entering Weston. "
+			"Possible causes:\n"
+			"\t- no permissions to read /dev/input/event*\n"
+			"\t- seats misconfigured "
+			"(Weston backend option 'seat', "
+			"udev device property ID_SEAT)\n");
+	}
+
+	return;
+
+out_enumerate:
+	udev_enumerate_unref(e);
+
+	weston_log ("Failed to enumerate and add evdev devices.\n");
+}
+
+static int
+evdev_udev_handler(int fd, uint32_t mask, void *data)
+{
+	struct fbdev_seat *seat = data;
+	struct udev_device *udev_device;
+	struct evdev_device *device, *next;
+	const char *action;
+	const char *devnode;
+
+	udev_device = udev_monitor_receive_device(seat->udev_monitor);
+	if (!udev_device)
+		return 1;
+
+	action = udev_device_get_action(udev_device);
+	if (!action)
+		goto out;
+
+	if (strncmp("event", udev_device_get_sysname(udev_device), 5) != 0)
+		goto out;
+
+	if (!strcmp(action, "add")) {
+		device_added(udev_device, seat);
+	}
+	else if (!strcmp(action, "remove")) {
+		devnode = udev_device_get_devnode(udev_device);
+		wl_list_for_each_safe(device, next, &seat->devices_list, link)
+			if (!strcmp(device->devnode, devnode)) {
+				weston_log("input device %s, %s removed\n",
+				           device->devname, device->devnode);
+				evdev_device_destroy(device);
+				break;
+			}
+	}
+
+out:
+	udev_device_unref(udev_device);
+
+	return 0;
+}
+
+static int
+evdev_enable_udev_monitor(struct udev *udev, struct weston_seat *seat_base)
+{
+	struct fbdev_seat *master = to_fbdev_seat(seat_base);
+	struct wl_event_loop *loop;
+	struct weston_compositor *c = master->base.compositor;
+	int fd;
+
+	master->udev_monitor = udev_monitor_new_from_netlink(udev, "udev");
+	if (!master->udev_monitor) {
+		weston_log("udev: failed to create the udev monitor\n");
+		goto out;
+	}
+
+	if (udev_monitor_filter_add_match_subsystem_devtype(master->udev_monitor,
+	                                                    "input",
+	                                                    NULL) < 0) {
+		weston_log("udev: failed to add filter\n");
+		goto out_monitor;
+	}
+
+	if (udev_monitor_enable_receiving(master->udev_monitor)) {
+		weston_log("udev: failed to bind the udev monitor\n");
+		goto out_monitor;
+	}
+
+	loop = wl_display_get_event_loop(c->wl_display);
+	fd = udev_monitor_get_fd(master->udev_monitor);
+	master->udev_monitor_source =
+		wl_event_loop_add_fd(loop, fd, WL_EVENT_READABLE,
+		                     evdev_udev_handler, master);
+	if (!master->udev_monitor_source)
+		goto out_monitor;
+
+	return 1;
+
+out_monitor:
+	udev_monitor_unref(master->udev_monitor);
+out:
+	return 0;
+}
+
+static void
+evdev_disable_udev_monitor(struct weston_seat *seat_base)
+{
+	struct fbdev_seat *seat = to_fbdev_seat(seat_base);
+
+	if (!seat->udev_monitor)
+		return;
+
+	udev_monitor_unref(seat->udev_monitor);
+	seat->udev_monitor = NULL;
+	wl_event_source_remove(seat->udev_monitor_source);
+	seat->udev_monitor_source = NULL;
+}
+
+static void
+evdev_input_create(struct weston_compositor *c, struct udev *udev,
+                   const char *seat_id)
+{
+	struct fbdev_seat *seat;
+
+	seat = malloc(sizeof *seat);
+	if (seat == NULL)
+		return;
+
+	memset(seat, 0, sizeof *seat);
+	weston_seat_init(&seat->base, c);
+	seat->base.led_update = fbdev_led_update;
+
+	wl_list_init(&seat->devices_list);
+	seat->seat_id = strdup(seat_id);
+	if (seat->seat_id == NULL ||
+	    !evdev_enable_udev_monitor(udev, &seat->base)) {
+		free(seat->seat_id);
+		free(seat);
+		return;
+	}
+
+	evdev_add_devices(udev, &seat->base);
+}
+
+static void
+evdev_remove_devices(struct weston_seat *seat_base)
+{
+	struct fbdev_seat *seat = to_fbdev_seat(seat_base);
+	struct evdev_device *device, *next;
+
+	wl_list_for_each_safe(device, next, &seat->devices_list, link)
+		evdev_device_destroy(device);
+
+	if (seat->base.seat.keyboard)
+		notify_keyboard_focus_out(&seat->base);
+}
+
+static void
+evdev_input_destroy(struct weston_seat *seat_base)
+{
+	struct fbdev_seat *seat = to_fbdev_seat(seat_base);
+
+	evdev_remove_devices(seat_base);
+	evdev_disable_udev_monitor(&seat->base);
+
+	weston_seat_release(seat_base);
+	free(seat->seat_id);
+	free(seat);
+}
+
+static void
+fbdev_compositor_destroy(struct weston_compositor *base)
+{
+	struct fbdev_compositor *compositor = to_fbdev_compositor(base);
+	struct weston_seat *seat, *next;
+
+	/* Destroy all inputs. */
+	wl_list_for_each_safe(seat, next, &compositor->base.seat_list, link)
+		evdev_input_destroy(seat);
+
+	/* Destroy the output. */
+	weston_compositor_shutdown(&compositor->base);
+
+	/* Chain up. */
+	compositor->base.renderer->destroy(&compositor->base);
+	tty_destroy(compositor->tty);
+
+	free(compositor);
+}
+
+static void
+vt_func(struct weston_compositor *base, int event)
+{
+	struct fbdev_compositor *compositor = to_fbdev_compositor(base);
+	struct weston_seat *seat;
+	struct weston_output *output;
+
+	switch (event) {
+	case TTY_ENTER_VT:
+		weston_log("entering VT\n");
+		compositor->base.focus = 1;
+		compositor->base.state = compositor->prev_state;
+		weston_compositor_damage_all(&compositor->base);
+		wl_list_for_each(seat, &compositor->base.seat_list, link) {
+			evdev_add_devices(compositor->udev, seat);
+			evdev_enable_udev_monitor(compositor->udev, seat);
+		}
+		break;
+	case TTY_LEAVE_VT:
+		weston_log("leaving VT\n");
+		wl_list_for_each(seat, &compositor->base.seat_list, link) {
+			evdev_disable_udev_monitor(seat);
+			evdev_remove_devices(seat);
+		}
+
+		compositor->base.focus = 0;
+		compositor->prev_state = compositor->base.state;
+		compositor->base.state = WESTON_COMPOSITOR_SLEEPING;
+
+		/* If we have a repaint scheduled (from the idle handler), make
+		 * sure we cancel that so we don't try to pageflip when we're
+		 * vt switched away.  The SLEEPING state will prevent
+		 * further attemps at repainting.  When we switch
+		 * back, we schedule a repaint, which will process
+		 * pending frame callbacks. */
+
+		wl_list_for_each(output,
+				 &compositor->base.output_list, link) {
+			output->repaint_needed = 0;
+		}
+
+		break;
+	};
+}
+
+static void
+fbdev_restore(struct weston_compositor *base)
+{
+	struct fbdev_compositor *compositor = to_fbdev_compositor(base);
+
+	tty_reset(compositor->tty);
+}
+
+static void
+switch_vt_binding(struct wl_seat *seat, uint32_t time, uint32_t key, void *data)
+{
+	struct fbdev_compositor *ec = data;
+
+	tty_activate_vt(ec->tty, key - KEY_F1 + 1);
+}
+
+static struct weston_compositor *
+fbdev_compositor_create(struct wl_display *display, int argc, char *argv[],
+                        const char *config_file, struct fbdev_parameters *param)
+{
+	struct fbdev_compositor *compositor;
+	const char *seat = default_seat;
+	uint32_t key;
+
+	weston_log("initializing fbdev backend\n");
+
+	compositor = calloc(1, sizeof *compositor);
+	if (compositor == NULL)
+		return NULL;
+
+	if (weston_compositor_init(&compositor->base, display, argc, argv,
+	                           config_file) < 0)
+		goto out_free;
+
+	compositor->udev = udev_new();
+	if (compositor->udev == NULL) {
+		weston_log("Failed to initialize udev context.\n");
+		goto out_compositor;
+	}
+
+	/* Set up the TTY. */
+	compositor->tty = tty_create(&compositor->base, vt_func, param->tty);
+	if (!compositor->tty) {
+		weston_log("Failed to initialize tty.\n");
+		goto out_udev;
+	}
+
+	compositor->base.destroy = fbdev_compositor_destroy;
+	compositor->base.restore = fbdev_restore;
+
+	compositor->base.focus = 1;
+	compositor->prev_state = WESTON_COMPOSITOR_ACTIVE;
+
+	for (key = KEY_F1; key < KEY_F9; key++)
+		weston_compositor_add_key_binding(&compositor->base, key,
+		                                  MODIFIER_CTRL | MODIFIER_ALT,
+		                                  switch_vt_binding,
+		                                  compositor);
+
+	if (pixman_renderer_init(&compositor->base) < 0)
+		goto out_tty;
+
+	if (fbdev_output_create(compositor, param) < 0)
+		goto out_pixman;
+
+	evdev_input_create(&compositor->base, compositor->udev, seat);
+
+	return &compositor->base;
+
+out_pixman:
+	compositor->base.renderer->destroy(&compositor->base);
+
+out_tty:
+	tty_destroy(compositor->tty);
+
+out_udev:
+	udev_unref(compositor->udev);
+
+out_compositor:
+	weston_compositor_shutdown(&compositor->base);
+
+out_free:
+	free(compositor);
+
+	return NULL;
+}
+
+WL_EXPORT struct weston_compositor *
+backend_init(struct wl_display *display, int argc, char *argv[],
+	     const char *config_file)
+{
+	/* TODO: Ideally, available frame buffers should be enumerated using
+	 * udev, rather than passing a device node in as a parameter. */
+	struct fbdev_parameters param = {
+		.tty = 0, /* default to current tty */
+		.device = "/dev/fb0", /* default frame buffer */
+	};
+
+	const struct weston_option fbdev_options[] = {
+		{ WESTON_OPTION_INTEGER, "tty", 0, &param.tty },
+		{ WESTON_OPTION_STRING, "device", 0, &param.device },
+	};
+
+	parse_options(fbdev_options, ARRAY_LENGTH(fbdev_options), argc, argv);
+
+	return fbdev_compositor_create(display, argc, argv, config_file,
+	                               &param);
+}

