diff --git a/src/weston-launch.c b/src/weston-launch.c
index 36f9c6b..7238128 100644
--- a/src/weston-launch.c
+++ b/src/weston-launch.c
@@ -109,7 +109,7 @@ weston_launch_allowed(struct weston_launch *wl)
 	if (getuid() == 0)
 		return 1;
 
-	gr = getgrnam("weston-launch");
+	gr = getgrnam("plugdev");
 	if (gr) {
 		groups = read_groups();
 		if (groups) {
@@ -550,7 +550,7 @@ main(int argc, char *argv[])
 #else
 		      " - enable systemd session support for weston-launch.\n"
 #endif
-		      " - or add yourself to the 'weston-launch' group.");
+		      " - or add yourself to the 'plugdev' group.");
 
 	if (setup_tty(&wl, tty) < 0)
 		return 1;







diff --git a/clients/desktop-shell.c b/clients/desktop-shell.c
index 1cae789..f52a4f9 100644
--- a/clients/desktop-shell.c
+++ b/clients/desktop-shell.c
@@ -36,6 +36,7 @@
 #include <libgen.h>
 #include <ctype.h>
 #include <time.h>
+#include <stdbool.h>
 
 #include <wayland-client.h>
 #include "window.h"
@@ -44,6 +45,8 @@
 
 #include "desktop-shell-client-protocol.h"
 
+#define MIN(x, y) (((x) < (y)) ? (x) : (y))
+
 extern char **environ; /* defined by libc */
 
 struct desktop {
@@ -51,37 +54,62 @@ struct desktop {
 	struct desktop_shell *shell;
 	struct unlock_dialog *unlock_dialog;
 	struct task unlock_task;
+	struct wl_list surfaces;
 	struct wl_list outputs;
+	uint32_t output_count;
 
 	struct window *grab_window;
 	struct widget *grab_widget;
 
 	enum cursor_type grab_cursor;
+
+	struct surface_data_manager *surface_data_manager;
 };
 
 struct surface {
+	struct desktop *desktop;
+	struct surface_data *surface_data;
+	struct wl_list item_list;
+	uint32_t output_mask;
+	char *title;
+	bool maximized, minimized;
+	bool focused;
+
+	struct wl_list link;
+};
+
+struct resize {
 	void (*configure)(void *data,
 			  struct desktop_shell *desktop_shell,
 			  uint32_t edges, struct window *window,
 			  int32_t width, int32_t height);
 };
 
+struct rgba {
+	float r, g, b, a;
+};
+
 struct panel {
-	struct surface base;
+	struct resize base;
 	struct window *window;
 	struct widget *widget;
 	struct wl_list launcher_list;
+	struct wl_list window_list;
+	struct rectangle window_list_rect;
+	uint32_t surface_count;
+	struct rgba focused_item;
 	struct panel_clock *clock;
 };
 
 struct background {
-	struct surface base;
+	struct resize base;
 	struct window *window;
 	struct widget *widget;
 };
 
 struct output {
 	struct wl_output *output;
+	uint32_t id;
 	struct wl_list link;
 
 	struct panel *panel;
@@ -99,6 +127,18 @@ struct panel_launcher {
 	struct wl_array argv;
 };
 
+struct list_item {
+	struct surface *surface;
+	struct widget *widget;
+	struct panel *panel;
+	cairo_surface_t *icon;
+	int focused, highlight;
+	float x, y;
+	struct wl_list link;
+	struct wl_list surface_link;
+	struct wl_list reorder_link;
+};
+
 struct panel_clock {
 	struct widget *widget;
 	struct panel *panel;
@@ -156,13 +196,13 @@ sigchild_handler(int s)
 }
 
 static void
-menu_func(struct window *window, int index, void *data)
+panel_menu_func(struct window *window, int index, void *data)
 {
 	printf("Selected index %d from a panel menu.\n", index);
 }
 
 static void
-show_menu(struct panel *panel, struct input *input, uint32_t time)
+panel_show_menu(struct panel *panel, struct input *input, uint32_t time)
 {
 	int32_t x, y;
 	static const char *entries[] = {
@@ -172,7 +212,7 @@ show_menu(struct panel *panel, struct input *input, uint32_t time)
 	input_get_position(input, &x, &y);
 	window_show_menu(window_get_display(panel->window),
 			 input, time, panel->window,
-			 x - 10, y - 10, menu_func, entries, 4);
+			 x - 10, y - 10, panel_menu_func, entries, 4);
 }
 
 static void
@@ -249,6 +289,15 @@ set_hex_color(cairo_t *cr, uint32_t color)
 }
 
 static void
+get_hex_color_rgba(uint32_t color, float *r, float *g, float *b, float *a)
+{
+	*r = ((color >> 16) & 0xff) / 255.0;
+	*g = ((color >>  8) & 0xff) / 255.0;
+	*b = ((color >>  0) & 0xff) / 255.0;
+	*a = ((color >> 24) & 0xff) / 255.0;
+}
+
+static void
 panel_redraw_handler(struct widget *widget, void *data)
 {
 	cairo_surface_t *surface;
@@ -337,7 +386,7 @@ panel_clock_redraw_handler(struct widget *widget, void *data)
 
 	surface = window_get_surface(clock->panel->window);
 	cr = cairo_create(surface);
-	cairo_select_font_face(cr, "sans",
+	cairo_select_font_face(cr, "helvetica",
 			       CAIRO_FONT_SLANT_NORMAL,
 			       CAIRO_FONT_WEIGHT_NORMAL);
 	cairo_set_font_size(cr, 14);
@@ -417,7 +466,36 @@ panel_button_handler(struct widget *widget,
 	struct panel *panel = data;
 
 	if (button == BTN_RIGHT && state == WL_POINTER_BUTTON_STATE_PRESSED)
-		show_menu(panel, input, time);
+		panel_show_menu(panel, input, time);
+}
+
+static void
+panel_window_list_schedule_redraw(struct panel *panel)
+{
+	struct list_item *item;
+	float x, y, w, h;
+	float item_width, padding;
+
+	/* If there are no window list items, redraw the panel to clear it */
+	if (wl_list_empty(&panel->window_list)) {
+		widget_schedule_redraw(panel->widget);
+		return;
+	}
+
+	item_width = ((float) panel->window_list_rect.width /
+							panel->surface_count);
+	padding = MIN(item_width * 0.1f, 10.0f);
+
+	x = panel->window_list_rect.x + padding;
+	y = 16;
+	w = MIN(item_width - padding, 200);
+	h = 24;
+
+	wl_list_for_each(item, &panel->window_list, link) {
+		widget_set_allocation(item->widget, x, y - h / 2, w + 1, h + 1);
+		x += w + padding;
+		widget_schedule_redraw(item->widget);
+	}
 }
 
 static void
@@ -425,11 +503,16 @@ panel_resize_handler(struct widget *widget,
 		     int32_t width, int32_t height, void *data)
 {
 	struct panel_launcher *launcher;
+	struct rectangle launcher_rect;
+	struct rectangle clock_rect;
 	struct panel *panel = data;
 	int x, y, w, h;
-	
+
 	x = 10;
 	y = 16;
+
+	launcher_rect.x = x;
+
 	wl_list_for_each(launcher, &panel->launcher_list, link) {
 		w = cairo_image_surface_get_width(launcher->icon);
 		h = cairo_image_surface_get_height(launcher->icon);
@@ -437,12 +520,25 @@ panel_resize_handler(struct widget *widget,
 				      x, y - h / 2, w + 1, h + 1);
 		x += w + 10;
 	}
-	h=20;
+
+	launcher_rect.width = x - launcher_rect.x;
+
 	w=170;
+	h=20;
 
 	if (panel->clock)
 		widget_set_allocation(panel->clock->widget,
 				      width - w - 8, y - h / 2, w + 1, h + 1);
+
+	widget_get_allocation(panel->clock->widget, &clock_rect);
+
+	panel->window_list_rect.x = launcher_rect.x + launcher_rect.width;
+	panel->window_list_rect.y = 2;
+	panel->window_list_rect.width = width -
+					panel->window_list_rect.x -
+					(clock_rect.width + 20);
+	panel->window_list_rect.height = 28;
+	panel_window_list_schedule_redraw(panel);
 }
 
 static void
@@ -451,7 +547,7 @@ panel_configure(void *data,
 		uint32_t edges, struct window *window,
 		int32_t width, int32_t height)
 {
-	struct surface *surface = window_get_user_data(window);
+	struct resize *surface = window_get_user_data(window);
 	struct panel *panel = container_of(surface, struct panel, base);
 
 	window_schedule_resize(panel->window, width, 32);
@@ -490,6 +586,25 @@ panel_destroy(struct panel *panel)
 	free(panel);
 }
 
+static void
+panel_set_list_item_focus_color(struct panel *panel)
+{
+	float r, g, b, a;
+
+	/* Consider panel color when choosing item highlight color */
+	get_hex_color_rgba(key_panel_color, &r, &b, &g, &a);
+	if (r += 0.2, g += 0.2, b += 0.2, r > 1.0 || g > 1.0 || b > 1.0) {
+		panel->focused_item.r = 0.6;
+		panel->focused_item.g = 0.6;
+		panel->focused_item.b = 0.6;
+	} else {
+		panel->focused_item.r = r;
+		panel->focused_item.g = g;
+		panel->focused_item.b = b;
+	}
+	panel->focused_item.a = 0.75;
+}
+
 static struct panel *
 panel_create(struct display *display)
 {
@@ -502,6 +617,7 @@ panel_create(struct display *display)
 	panel->window = window_create_custom(display);
 	panel->widget = window_add_widget(panel->window, panel);
 	wl_list_init(&panel->launcher_list);
+	wl_list_init(&panel->window_list);
 
 	window_set_title(panel->window, "panel");
 	window_set_user_data(panel->window, panel);
@@ -509,7 +625,9 @@ panel_create(struct display *display)
 	widget_set_redraw_handler(panel->widget, panel_redraw_handler);
 	widget_set_resize_handler(panel->widget, panel_resize_handler);
 	widget_set_button_handler(panel->widget, panel_button_handler);
-	
+
+	panel->surface_count = 0;
+	panel_set_list_item_focus_color(panel);
 	panel_add_clock(panel);
 
 	return panel;
@@ -518,18 +636,21 @@ panel_create(struct display *display)
 static cairo_surface_t *
 load_icon_or_fallback(const char *icon)
 {
-	cairo_surface_t *surface = cairo_image_surface_create_from_png(icon);
+	cairo_surface_t *surface;
 	cairo_t *cr;
-
-	if (cairo_surface_status(surface) == CAIRO_STATUS_SUCCESS)
-		return surface;
-
-	cairo_surface_destroy(surface);
-	fprintf(stderr, "ERROR loading icon from file '%s'\n", icon);
+#ifdef CAIRO_HAS_PNG_FUNCTIONS
+	if (icon) {
+		surface = cairo_image_surface_create_from_png(icon);
+		if (cairo_surface_status(surface) == CAIRO_STATUS_SUCCESS)
+			return surface;
+
+		cairo_surface_destroy(surface);
+		fprintf(stderr, "ERROR loading icon from file '%s'\n", icon);
+	}
+#endif
 
 	/* draw fallback icon */
-	surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32,
-					     20, 20);
+	surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 20, 20);
 	cr = cairo_create(surface);
 
 	cairo_set_source_rgba(cr, 0.8, 0.8, 0.8, 1);
@@ -862,7 +983,7 @@ desktop_shell_configure(void *data,
 			int32_t width, int32_t height)
 {
 	struct window *window = wl_surface_get_user_data(surface);
-	struct surface *s = window_get_user_data(window);
+	struct resize *s = window_get_user_data(window);
 
 	s->configure(data, desktop_shell, edges, window, width, height);
 }
@@ -946,6 +1067,621 @@ background_destroy(struct background *background)
 	free(background);
 }
 
+static void
+panel_list_item_redraw_handler(struct widget *widget, void *data)
+{
+	cairo_t *cr;
+	cairo_surface_t *surface;
+	struct list_item *item = data;
+	struct rectangle rect;
+	cairo_text_extents_t extents;
+	cairo_font_extents_t font_extents;
+	int icon_width;
+	unsigned int dots = 3;
+	char title[128];
+
+	widget_get_allocation(widget, &rect);
+	if (rect.width == 0)
+		return;
+
+	surface = window_get_surface(item->panel->window);
+	cr = cairo_create(surface);
+
+	if (item->highlight || item->surface->focused) {
+		cairo_set_source_rgba(cr,
+					item->panel->focused_item.r,
+					item->panel->focused_item.g,
+					item->panel->focused_item.b,
+					item->panel->focused_item.a);
+		cairo_move_to(cr, rect.x, rect.y);
+		cairo_line_to(cr, rect.x + rect.width, rect.y);
+		cairo_line_to(cr, rect.x + rect.width, rect.y + rect.height);
+		cairo_line_to(cr, rect.x, rect.y + rect.height);
+		cairo_line_to(cr, rect.x, rect.y);
+		cairo_fill(cr);
+	}
+
+	icon_width = cairo_image_surface_get_width(item->icon);
+	if (rect.width > icon_width * 2) {
+		cairo_set_source_surface(cr, item->icon,
+					 rect.x, rect.y);
+		cairo_paint(cr);
+	} else
+		icon_width = 0;
+
+	strcpy(title, item->surface->title);
+	cairo_select_font_face(cr, "helvetica",
+			       CAIRO_FONT_SLANT_NORMAL,
+			       CAIRO_FONT_WEIGHT_NORMAL);
+	cairo_set_font_size(cr, 14);
+	cairo_text_extents(cr, title, &extents);
+
+	/* If the string is too long, clip text to button width */
+	while (extents.width > (rect.width - (10 + icon_width))) {
+		title[strlen(title) - 1] = '\0';
+		cairo_text_extents(cr, title, &extents);
+		if (extents.width <= 0) {
+			title[0] = '\0';
+			break;
+		}
+	}
+
+	/* If the text is clipped, add an ellipsis */
+	if (strlen(title) < dots)
+		dots = strlen(title) + 1;
+	if (strlen(title) != strlen(item->surface->title))
+		while (dots-- > 0)
+			title[strlen(title) - dots] = '.';
+
+	cairo_font_extents (cr, &font_extents);
+	cairo_move_to(cr, rect.x + 10 + icon_width,
+		      rect.y + 3 * (rect.height >> 2) + 1);
+	cairo_set_source_rgb(cr, 0, 0, 0);
+	cairo_show_text(cr, title);
+	cairo_move_to(cr, rect.x + 9 + icon_width,
+		      rect.y + 3 * (rect.height >> 2));
+	if (item->highlight)
+		cairo_set_source_rgb(cr, 1, 1, 1);
+	else
+		cairo_set_source_rgb(cr, 0.85, 0.85, 0.85);
+	cairo_show_text(cr, title);
+	cairo_destroy(cr);
+}
+
+static int
+panel_list_item_motion_handler(struct widget *widget, struct input *input,
+			      uint32_t time, float x, float y, void *data)
+{
+	struct list_item *item = data;
+
+	item->x = x;
+	item->y = y;
+	widget_set_tooltip(widget, basename((char *)item->surface->title), x, y);
+
+	return CURSOR_LEFT_PTR;
+}
+
+static int
+panel_list_item_enter_handler(struct widget *widget, struct input *input,
+			     float x, float y, void *data)
+{
+	struct list_item *item = data;
+
+	item->x = x;
+	item->y = y;
+	item->highlight = true;
+	item->focused = true;
+	widget_schedule_redraw(widget);
+
+	return CURSOR_LEFT_PTR;
+}
+
+static void
+panel_list_item_leave_handler(struct widget *widget,
+			     struct input *input, void *data)
+{
+	struct list_item *item = data;
+
+	item->highlight = false;
+	item->focused = false;
+	widget_destroy_tooltip(widget);
+	widget_schedule_redraw(widget);
+}
+
+static void
+desktop_update_list_items(struct desktop *desktop, struct surface *surface);
+
+static void
+list_item_menu_handle_button(struct list_item *item, int index)
+{
+	struct surface *surface = item->surface;
+
+	switch (index) {
+	case 0: /* (Un)Minimize */
+		if (surface->minimized) {
+			surface_data_unminimize(surface->surface_data);
+			surface->minimized = false;
+		}
+		else {
+			surface_data_minimize(surface->surface_data);
+			surface->minimized = true;
+		}
+		break;
+	case 1: /* (Un)Maximize */
+		if (surface->maximized) {
+			surface_data_unmaximize(surface->surface_data);
+			surface->maximized = false;
+		}
+		else {
+			surface_data_maximize(surface->surface_data);
+			surface->maximized = true;
+		}
+		break;
+	case 2: /* Close */
+		surface_data_close(surface->surface_data);
+		break;
+	default:
+		item->highlight = false;
+		break;
+	}
+
+	desktop_update_list_items(surface->desktop, surface);
+	widget_destroy_tooltip(item->widget);
+	widget_schedule_redraw(item->widget);
+}
+
+static void
+list_item_menu_func(struct window *window, int index, void *data)
+{
+	struct list_item *item;
+	struct panel *panel;
+
+	panel = data;
+
+	wl_list_for_each(item, &panel->window_list, link)
+		if (item->focused) {
+			list_item_menu_handle_button(item, index);
+			return;
+		}
+}
+
+#define NUM_ENTRIES 3
+
+static void
+list_item_show_menu(struct list_item *item, struct input *input, uint32_t time)
+{
+	struct panel *panel;
+	int32_t x, y;
+	static const char *entries[NUM_ENTRIES];
+
+	entries[0] = item->surface->minimized ? "Unminimize" : "Minimize";
+	entries[1] = item->surface->maximized ? "Unmaximize" : "Maximize";
+	entries[2] = "Close";
+
+	panel = item->panel;
+	input_get_position(input, &x, &y);
+	window_show_menu(window_get_display(panel->window), input,
+				time, panel->window, x - 10, y - 10,
+				list_item_menu_func, entries, NUM_ENTRIES);
+}
+
+static bool
+rect_contains_point(struct rectangle rect, int x, int y)
+{
+	int x1, y1, x2, y2;
+
+	x1 = rect.x;
+	y1 = rect.y;
+	x2 = rect.x + rect.width;
+	y2 = rect.y + rect.height;
+
+	if (x > x1 && x < x2 && y > y1 && y < y2)
+		return true;
+
+	return false;
+}
+
+static bool
+item_contains_point(struct list_item *item, int x, int y)
+{
+	struct rectangle item_rect;
+
+	widget_get_allocation(item->widget, &item_rect);
+
+	return rect_contains_point(item_rect, x, y);
+}
+
+static bool
+list_contains_point(struct list_item *item, int x, int y)
+{
+	struct rectangle list_rect;
+
+	list_rect = item->panel->window_list_rect;
+
+	return rect_contains_point(list_rect, x, y);
+}
+
+static void
+panel_item_list_reorder(struct panel *panel,
+			struct list_item *current, struct list_item *item)
+{
+	struct rectangle current_rect, item_rect;
+
+	if (current == item)
+		return;
+
+	widget_get_allocation(current->widget, &current_rect);
+	widget_get_allocation(item->widget, &item_rect);
+
+	wl_list_remove(&current->link);
+
+	if (item_rect.x < current_rect.x)
+		wl_list_insert(item->link.prev, &current->link);
+	else
+		wl_list_insert(&item->link, &current->link);
+
+	panel_window_list_schedule_redraw(item->panel);
+}
+
+static void
+list_item_move(struct list_item *current, int x, int y)
+{
+	struct list_item *item;
+
+	wl_list_for_each(item, &current->panel->window_list, link) {
+		if (item == current)
+			continue;
+		if (item_contains_point(item, x, y)) {
+			panel_item_list_reorder(item->panel, current, item);
+			return;
+		}
+	}
+}
+
+static void
+panel_list_item_button_handler(struct widget *widget,
+			      struct input *input, uint32_t time,
+			      uint32_t button,
+			      enum wl_pointer_button_state state, void *data)
+{
+	struct list_item *item;
+	struct surface *surface;
+
+	item = data;
+
+	widget_schedule_redraw(widget);
+
+	if (button == BTN_RIGHT && state == WL_POINTER_BUTTON_STATE_PRESSED) {
+		widget_destroy_tooltip(item->widget);
+		widget_schedule_redraw(item->widget);
+		list_item_show_menu(item, input, time);
+		return;
+	}
+
+	if ((button != BTN_LEFT) || (state != WL_POINTER_BUTTON_STATE_RELEASED))
+		return;
+
+	surface = item->surface;
+	if (!item_contains_point(item, item->x, item->y)) {
+		if (list_contains_point(item, item->x, item->y))
+			list_item_move(item, item->x, item->y);
+		return;
+	}
+	if (!surface->focused && !surface->minimized) {
+		surface_data_focus(surface->surface_data);
+		surface->focused = true;
+		return;
+	}
+	if (surface->minimized) {
+		surface_data_unminimize(surface->surface_data);
+		surface->minimized = false;
+	}
+	else {
+		surface_data_minimize(surface->surface_data);
+		surface->minimized = true;
+	}
+}
+
+static struct list_item *
+panel_list_item_add(struct panel *panel, const char *icon, const char *text)
+{
+	struct list_item *item;
+	item = malloc(sizeof *item);
+	memset(item, 0, sizeof *item);
+
+	item->icon = load_icon_or_fallback(icon);
+
+	item->panel = panel;
+	wl_list_insert(panel->window_list.prev, &item->link);
+	panel->surface_count++;
+
+	item->widget = widget_add_widget(panel->widget, item);
+	widget_set_enter_handler(item->widget, panel_list_item_enter_handler);
+	widget_set_leave_handler(item->widget, panel_list_item_leave_handler);
+	widget_set_button_handler(item->widget, panel_list_item_button_handler);
+	widget_set_redraw_handler(item->widget, panel_list_item_redraw_handler);
+	widget_set_motion_handler(item->widget, panel_list_item_motion_handler);
+
+	return item;
+}
+
+static void
+panel_list_item_remove(struct list_item *item)
+{
+	item->panel->surface_count--;
+	wl_list_remove(&item->link);
+	wl_list_remove(&item->surface_link);
+	widget_destroy(item->widget);
+	panel_window_list_schedule_redraw(item->panel);
+	free(item);
+}
+
+static int
+panel_list_item_exists(struct panel *panel, struct surface *surface)
+{
+	struct list_item *p_item, *s_item;
+
+	wl_list_for_each(p_item, &panel->window_list, link) {
+		wl_list_for_each(s_item, &surface->item_list, surface_link) {
+			if (p_item == s_item)
+				return 1;
+		}
+	}
+
+	return 0;
+}
+
+static void
+output_update_window_list(struct output *output, struct surface *surface)
+{
+	struct list_item *item, *next;
+	struct panel *panel;
+
+	panel = output->panel;
+
+	/* Make a list item for each panel of the surfaces output mask */
+	if ((1 << output->id) & surface->output_mask) {
+		if (!panel_list_item_exists(panel, surface)) {
+			/* TODO: Use a real icon instead of
+			 * passing NULL for the fallback */
+			item = panel_list_item_add(panel, NULL, surface->title);
+			wl_list_insert(surface->item_list.prev,
+							&item->surface_link);
+			item->surface = surface;
+		}
+	} else {
+		/* Remove item from panel if surface
+		 * is no longer on the output */
+		wl_list_for_each_safe(item, next, &surface->item_list,
+								surface_link) {
+			if (item->panel == panel)
+				panel_list_item_remove(item);
+		}
+	}
+
+	panel_window_list_schedule_redraw(panel);
+}
+
+static struct surface*
+desktop_create_surface(struct desktop *desktop,
+			struct surface_data *surface_data)
+{
+	struct surface *surface;
+
+	surface = calloc(1, sizeof *surface);
+
+	if (!surface) {
+		fprintf(stderr, "ERROR: Failed to allocate memory!\n");
+		exit(EXIT_FAILURE);
+	}
+
+	surface->desktop = desktop;
+	surface->surface_data = surface_data;
+	surface->title = strdup("unknown");
+	surface->output_mask = 1;
+	surface->maximized = false;
+	surface->minimized = false;
+	surface->focused = false;
+	wl_list_init(&surface->item_list);
+	wl_list_insert(&desktop->surfaces, &surface->link);
+
+	return surface;
+}
+
+static void
+desktop_destroy_surface(struct surface *surface)
+{
+	struct list_item *item, *next;
+
+	wl_list_for_each_safe(item, next, &surface->item_list, surface_link)
+		panel_list_item_remove(item);
+
+	wl_list_remove(&surface->link);
+	free(surface->title);
+	free(surface);
+}
+
+static struct surface *
+desktop_get_surface(struct desktop *desktop, struct surface_data *surface_data)
+{
+	struct output *output;
+	struct list_item *item;
+
+	wl_list_for_each(output, &desktop->outputs, link) {
+		wl_list_for_each(item, &output->panel->window_list, link) {
+			if (surface_data == item->surface->surface_data)
+				return item->surface;
+		}
+	}
+
+	return NULL;
+}
+
+static void
+desktop_update_list_items(struct desktop *desktop, struct surface *surface)
+{
+	struct output *output;
+
+	wl_list_for_each(output, &desktop->outputs, link)
+		output_update_window_list(output, surface);
+}
+
+static void
+surface_data_set_output_mask(void *data,
+				struct surface_data *surface_data,
+				uint32_t output_mask)
+{
+	struct desktop *desktop;
+	struct surface *surface;
+
+	desktop = data;
+
+	surface = desktop_get_surface(desktop, surface_data);
+
+	if (!surface)
+		surface = desktop_create_surface(desktop, surface_data);
+
+	surface->output_mask = output_mask;
+
+	desktop_update_list_items(desktop, surface);
+}
+
+static void
+surface_data_set_title(void *data,
+				struct surface_data *surface_data,
+				const char *title)
+{
+	struct desktop *desktop;
+	struct surface *surface;
+
+	desktop = data;
+
+	surface = desktop_get_surface(desktop, surface_data);
+
+	if (!surface)
+		surface = desktop_create_surface(desktop, surface_data);
+
+	if (surface->title)
+		free(surface->title);
+	surface->title = strdup(title);
+
+	desktop_update_list_items(desktop, surface);
+}
+
+static void
+surface_data_set_maximized_state(void *data,
+				struct surface_data *surface_data,
+				int maximized)
+{
+	struct desktop *desktop;
+	struct surface *surface;
+
+	desktop = data;
+
+	surface = desktop_get_surface(desktop, surface_data);
+
+	if (!surface)
+		surface = desktop_create_surface(desktop, surface_data);
+
+	surface->maximized = maximized;
+
+	desktop_update_list_items(desktop, surface);
+}
+
+static void
+surface_data_set_minimized_state(void *data,
+				struct surface_data *surface_data,
+				int minimized)
+{
+	struct desktop *desktop;
+	struct surface *surface;
+
+	desktop = data;
+
+	surface = desktop_get_surface(desktop, surface_data);
+
+	if (!surface)
+		surface = desktop_create_surface(desktop, surface_data);
+
+	surface->minimized = minimized;
+
+	desktop_update_list_items(desktop, surface);
+}
+
+static void
+surface_data_set_focused_state(void *data,
+				struct surface_data *surface_data,
+				int focused)
+{
+	struct desktop *desktop;
+	struct surface *surface;
+	struct list_item *item;
+
+	desktop = data;
+
+	wl_list_for_each(surface, &desktop->surfaces, link)
+		if (surface->surface_data != surface_data && focused) {
+			surface->focused = false;
+			wl_list_for_each(item, &surface->item_list, surface_link)
+				if (!item->focused)
+					item->highlight = false;
+		}
+
+	surface = desktop_get_surface(desktop, surface_data);
+
+	if (!surface)
+		surface = desktop_create_surface(desktop, surface_data);
+
+	surface->focused = focused;
+
+	desktop_update_list_items(desktop, surface);
+}
+
+static void
+surface_data_destroy_handler(void *data, struct surface_data *surface_data)
+{
+	struct list_item *item, *next;
+	struct desktop *desktop;
+	struct output *output;
+	struct panel *panel;
+
+	desktop = data;
+
+	surface_data_destroy(surface_data);
+
+	wl_list_for_each(output, &desktop->outputs, link) {
+		panel = output->panel;
+		wl_list_for_each_safe(item, next, &panel->window_list, link) {
+			if (surface_data == item->surface->surface_data) {
+				desktop_destroy_surface(item->surface);
+				return;
+			}
+		}
+	}
+}
+
+static const struct surface_data_listener surface_data_listener = {
+	surface_data_set_output_mask,
+	surface_data_set_title,
+	surface_data_set_maximized_state,
+	surface_data_set_minimized_state,
+	surface_data_set_focused_state,
+	surface_data_destroy_handler
+};
+
+static void
+surface_data_receive_surface_object(void *data,
+				struct surface_data_manager *manager,
+				struct surface_data *surface_data)
+{
+	surface_data_add_listener(surface_data,
+				   &surface_data_listener, data);
+}
+
+static const struct surface_data_manager_listener surface_data_manager_listener = {
+	surface_data_receive_surface_object
+};
+
 static struct background *
 background_create(struct desktop *desktop)
 {
@@ -1022,6 +1758,15 @@ desktop_destroy_outputs(struct desktop *desktop)
 }
 
 static void
+desktop_destroy_surfaces(struct desktop *desktop)
+{
+	struct surface *surface, *next;
+
+	wl_list_for_each_safe(surface, next, &desktop->surfaces, link)
+		desktop_destroy_surface(surface);
+}
+
+static void
 create_output(struct desktop *desktop, uint32_t id)
 {
 	struct output *output;
@@ -1033,7 +1778,9 @@ create_output(struct desktop *desktop, uint32_t id)
 	output->output =
 		display_bind(desktop->display, id, &wl_output_interface, 1);
 
-	wl_list_insert(&desktop->outputs, &output->link);
+	output->id = desktop->output_count++;
+
+	wl_list_insert(desktop->outputs.prev, &output->link);
 }
 
 static void
@@ -1046,6 +1793,12 @@ global_handler(struct display *display, uint32_t id,
 		desktop->shell = display_bind(desktop->display,
 					      id, &desktop_shell_interface, 1);
 		desktop_shell_add_listener(desktop->shell, &listener, desktop);
+	} else if (strcmp(interface, "surface_data_manager") == 0) {
+		desktop->surface_data_manager =
+				display_bind(display, id,
+					&surface_data_manager_interface, 1);
+		surface_data_manager_add_listener(desktop->surface_data_manager,
+					&surface_data_manager_listener, desktop);
 	} else if (!strcmp(interface, "wl_output")) {
 		create_output(desktop, id);
 	}
@@ -1100,6 +1853,9 @@ int main(int argc, char *argv[])
 		return -1;
 	}
 
+	wl_list_init(&desktop.surfaces);
+	desktop.output_count = 0;
+
 	display_set_user_data(desktop.display, &desktop);
 	display_set_global_handler(desktop.display, global_handler);
 
@@ -1133,6 +1889,7 @@ int main(int argc, char *argv[])
 
 	/* Cleanup */
 	grab_surface_destroy(&desktop);
+	desktop_destroy_surfaces(&desktop);
 	desktop_destroy_outputs(&desktop);
 	if (desktop.unlock_dialog)
 		unlock_dialog_destroy(desktop.unlock_dialog);
diff --git a/clients/simple-egl.c b/clients/simple-egl.c
index fcbea75..273159b 100644
--- a/clients/simple-egl.c
+++ b/clients/simple-egl.c
@@ -250,10 +250,34 @@ handle_popup_done(void *data, struct wl_shell_surface *shell_surface)
 {
 }
 
+static void
+handle_maximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unmaximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_minimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unminimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
 static const struct wl_shell_surface_listener shell_surface_listener = {
 	handle_ping,
 	handle_configure,
-	handle_popup_done
+	handle_popup_done,
+	handle_maximize,
+	handle_unmaximize,
+	handle_minimize,
+	handle_unminimize
 };
 
 static void
diff --git a/clients/simple-shm.c b/clients/simple-shm.c
index a09ec91..7f8809a 100644
--- a/clients/simple-shm.c
+++ b/clients/simple-shm.c
@@ -107,10 +107,34 @@ handle_popup_done(void *data, struct wl_shell_surface *shell_surface)
 {
 }
 
+static void
+handle_maximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unmaximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_minimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unminimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
 static const struct wl_shell_surface_listener shell_surface_listener = {
 	handle_ping,
 	handle_configure,
-	handle_popup_done
+	handle_popup_done,
+	handle_maximize,
+	handle_unmaximize,
+	handle_minimize,
+	handle_unminimize
 };
 
 static struct window *
diff --git a/clients/simple-touch.c b/clients/simple-touch.c
index cbe3877..c9b594b 100644
--- a/clients/simple-touch.c
+++ b/clients/simple-touch.c
@@ -233,10 +233,34 @@ handle_popup_done(void *data, struct wl_shell_surface *shell_surface)
 {
 }
 
+static void
+handle_maximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unmaximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_minimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unminimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
 static const struct wl_shell_surface_listener shell_surface_listener = {
 	handle_ping,
 	handle_configure,
-	handle_popup_done
+	handle_popup_done,
+	handle_maximize,
+	handle_unmaximize,
+	handle_minimize,
+	handle_unminimize
 };
 
 static void
diff --git a/clients/window.c b/clients/window.c
index fe968ed..9a11571 100644
--- a/clients/window.c
+++ b/clients/window.c
@@ -163,6 +163,7 @@ struct window {
 	int type;
 	int transparent;
 	int focus_count;
+	int minimized;
 
 	enum window_buffer_type buffer_type;
 
@@ -1564,7 +1565,7 @@ frame_button_button_handler(struct widget *widget,
 			display_exit(window->display);
 		break;
 	case FRAME_BUTTON_MINIMIZE:
-		fprintf(stderr,"Minimize stub\n");
+		window_set_minimized(window, !window->minimized);
 		break;
 	case FRAME_BUTTON_MAXIMIZE:
 		window_set_maximized(window, window->type != TYPE_MAXIMIZED);
@@ -2932,10 +2933,48 @@ handle_popup_done(void *data, struct wl_shell_surface *shell_surface)
 	menu_destroy(menu);
 }
 
+static void
+handle_maximize(void *data, struct wl_shell_surface *shell_surface)
+{
+	struct window *window = data;
+
+	window_set_maximized(window, 1);
+}
+
+static void
+handle_unmaximize(void *data, struct wl_shell_surface *shell_surface)
+{
+	struct window *window = data;
+
+	window_set_maximized(window, 0);
+}
+
+static void
+handle_minimize(void *data, struct wl_shell_surface *shell_surface)
+{
+	struct window *window = data;
+
+	if (!window->minimized)
+		window->minimized = 1;
+}
+
+static void
+handle_unminimize(void *data, struct wl_shell_surface *shell_surface)
+{
+	struct window *window = data;
+
+	if (window->minimized)
+		window->minimized = 0;
+}
+
 static const struct wl_shell_surface_listener shell_surface_listener = {
 	handle_ping,
 	handle_configure,
-	handle_popup_done
+	handle_popup_done,
+	handle_maximize,
+	handle_unmaximize,
+	handle_minimize,
+	handle_unminimize
 };
 
 void
@@ -3048,6 +3087,8 @@ window_set_maximized(struct window *window, int maximized)
 		return;
 
 	if (window->type == TYPE_TOPLEVEL) {
+		if (window->resize_needed)
+			return;
 		window->saved_allocation = window->allocation;
 		wl_shell_surface_set_maximized(window->shell_surface, NULL);
 		window->type = TYPE_MAXIMIZED;
@@ -3061,6 +3102,22 @@ window_set_maximized(struct window *window, int maximized)
 }
 
 void
+window_set_minimized(struct window *window, int minimized)
+{
+	if (!window->display->shell)
+		return;
+
+	if ((window->minimized) == minimized)
+		return;
+
+	if (!window->minimized) {
+		wl_shell_surface_set_minimized(window->shell_surface);
+		window->minimized = 1;
+	} else
+		window->minimized = 0;
+}
+
+void
 window_set_user_data(struct window *window, void *data)
 {
 	window->user_data = data;
diff --git a/clients/window.h b/clients/window.h
index 84846ff..81fd1ea 100644
--- a/clients/window.h
+++ b/clients/window.h
@@ -304,6 +304,9 @@ void
 window_set_maximized(struct window *window, int maximized);
 
 void
+window_set_minimized(struct window *window, int minimized);
+
+void
 window_set_user_data(struct window *window, void *data);
 
 void *
diff --git a/protocol/desktop-shell.xml b/protocol/desktop-shell.xml
index 2b6afbd..2af3b85 100644
--- a/protocol/desktop-shell.xml
+++ b/protocol/desktop-shell.xml
@@ -82,6 +82,78 @@
     </enum>
   </interface>
 
+  <interface name="surface_data" version="1">
+    <description summary="the surface data offer object">
+	The shell can use this interface to receive surface information or make
+	requests for this surface.
+    </description>
+    <request name="maximize">
+      <description summary="ask the compositor to maximize the surface"/>
+    </request>
+    <request name="unmaximize">
+      <description summary="ask the compositor to unmaximize the surface"/>
+    </request>
+    <request name="minimize">
+      <description summary="ask the compositor to minimize the surface"/>
+    </request>
+    <request name="unminimize">
+      <description summary="ask the compositor to unminimize the surface"/>
+    </request>
+    <request name="focus">
+      <description summary="ask the compositor to focus the surface"/>
+    </request>
+    <request name="close">
+      <description summary="ask the compositor to close the surface"/>
+    </request>
+    <request name="destroy" type="destructor">
+      <description summary="destroy surface request">
+	The shell must send this request in response to a gone event so	the
+	compositor can destroy the object properly.
+      </description>
+    </request>
+    <event name="output_mask">
+      <description summary="send the surface object output_mask to the shell"/>
+      <arg name="output_mask" type="uint"/>
+    </event>
+    <event name="title">
+      <description summary="send the surface object title to the shell"/>
+      <arg name="title" type="string"/>
+    </event>
+    <event name="maximized">
+      <description summary="send the surface object maximize state to the shell"/>
+      <arg name="maximized" type="int"/>
+    </event>
+    <event name="minimized">
+      <description summary="send the surface object minimize state to the shell"/>
+      <arg name="minimized" type="int"/>
+    </event>
+    <event name="focused">
+      <description summary="send the surface object focus state to the shell"/>
+      <arg name="focused" type="int"/>
+    </event>
+    <event name="gone">
+      <description summary="destroy surface notification">
+	The compositor should send this event to notify the shell that a
+	surface has been destroyed. The client must respond with a destroy
+	request.
+      </description>
+    </event>
+  </interface>
+
+  <interface name="surface_data_manager" version="1">
+    <description summary="send surface object to shell">
+	The compositor can offer surface data to a shell. The client can use
+	this interface as a way to receive special surface_data objects.
+    </description>
+    <event name="surface_object">
+      <description summary="surface object">
+	Surface object sent to a shell. This object is intended to allow the
+	shell to initiate a surface_data object interface.
+      </description>
+      <arg name="id" type="new_id" interface="surface_data"/>
+    </event>
+  </interface>
+
   <interface name="screensaver" version="1">
     <description summary="interface for implementing screensavers">
       Only one client can bind this interface at a time.
diff --git a/src/compositor.c b/src/compositor.c
index 2d5b263..403f910 100644
--- a/src/compositor.c
+++ b/src/compositor.c
@@ -374,6 +374,8 @@ weston_surface_update_output_mask(struct weston_surface *es, uint32_t mask)
 		if (1 << output->id & left)
 			wl_surface_send_leave(&es->surface.resource, resource);
 	}
+
+	es->compositor->shell_interface.send_output_mask(es);
 }
 
 static void
@@ -1056,6 +1058,7 @@ WL_EXPORT void
 weston_layer_init(struct weston_layer *layer, struct wl_list *below)
 {
 	wl_list_init(&layer->surface_list);
+	wl_list_init(&layer->minimized_list);
 	if (below != NULL)
 		wl_list_insert(below, &layer->link);
 }
diff --git a/src/compositor.h b/src/compositor.h
index 121f6bf..31f1949 100644
--- a/src/compositor.h
+++ b/src/compositor.h
@@ -94,6 +94,7 @@ struct weston_shell_interface {
 	int (*move)(struct shell_surface *shsurf, struct weston_seat *ws);
 	int (*resize)(struct shell_surface *shsurf,
 		      struct weston_seat *ws, uint32_t edges);
+	void (*send_output_mask)(struct weston_surface *surface);
 
 };
 
@@ -265,6 +266,7 @@ enum {
 
 struct weston_layer {
 	struct wl_list surface_list;
+	struct wl_list minimized_list;
 	struct wl_list link;
 };
 
diff --git a/src/shell.c b/src/shell.c
index b28353e..26068cd 100644
--- a/src/shell.c
+++ b/src/shell.c
@@ -97,6 +97,8 @@ struct desktop_shell {
 		uint32_t deathstamp;
 	} child;
 
+	struct wl_resource *surface_data_manager;
+
 	bool locked;
 	bool showing_input_panels;
 	bool prepare_event_sent;
@@ -152,6 +154,11 @@ struct ping_timer {
 	uint32_t serial;
 };
 
+struct surface_data {
+	struct shell_surface *shsurf;
+	struct wl_resource resource;
+};
+
 struct shell_surface {
 	struct wl_resource resource;
 
@@ -160,11 +167,12 @@ struct shell_surface {
 	struct weston_surface *parent;
 	struct desktop_shell *shell;
 
-	enum shell_surface_type type, next_type;
+	enum shell_surface_type type, next_type, saved_type;
 	char *title, *class;
 	int32_t saved_x, saved_y;
 	bool saved_position_valid;
 	bool saved_rotation_valid;
+	bool minimized;
 	int unresponsive;
 
 	struct {
@@ -202,6 +210,7 @@ struct shell_surface {
 	struct wl_list link;
 
 	const struct weston_shell_client *client;
+	struct surface_data *surface_data;
 };
 
 struct shell_grab {
@@ -1397,6 +1406,339 @@ shell_surface_pong(struct wl_client *client, struct wl_resource *resource,
 }
 
 static void
+surface_data_destroy_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	wl_resource_destroy(resource);
+}
+
+static void
+send_surface_data_focused_state(struct weston_surface *surface);
+
+static void
+activate(struct desktop_shell *shell, struct weston_surface *es,
+	 struct weston_seat *seat);
+
+static void
+shell_surface_focus(struct shell_surface *shsurf)
+{
+	struct desktop_shell *shell;
+	struct weston_compositor *compositor;
+	struct weston_surface *surface;
+	struct weston_seat *seat;
+
+	shell = shsurf->shell;
+	compositor = shell->compositor;
+	surface = shsurf->surface;
+
+	wl_list_for_each(seat, &surface->compositor->seat_list, link)
+		if (seat->seat.keyboard) {
+			wl_keyboard_set_focus(seat->seat.keyboard,
+							&surface->surface);
+			activate(shell, surface, seat);
+		}
+
+	weston_compositor_damage_all(compositor);
+}
+
+static void
+shell_surface_minimize(struct shell_surface *shsurf)
+{
+	struct desktop_shell *shell;
+	struct weston_compositor *compositor;
+	struct weston_surface *surface;
+	struct workspace *ws;
+	struct weston_seat *seat;
+	struct weston_surface *focus;
+
+	shell = shsurf->shell;
+	compositor = shell->compositor;
+	surface = shsurf->surface;
+	ws = get_current_workspace(shell);
+
+	wl_list_remove(&surface->layer_link);
+	wl_list_insert(ws->layer.minimized_list.prev, &surface->layer_link);
+	shsurf->saved_type = shsurf->type;
+	shsurf->minimized = true;
+
+	/* Focus next surface in stack */
+	if (!wl_list_empty(&ws->layer.surface_list)) {
+		focus = container_of(ws->layer.surface_list.next,
+					 struct weston_surface,
+					 layer_link);
+		wl_list_for_each(seat, &compositor->seat_list, link)
+			if (seat->seat.keyboard &&
+			    seat->keyboard.focus == &surface->surface) {
+				shsurf = get_shell_surface(focus);
+				if (!shsurf)
+					break;
+				shell_surface_focus(shsurf);
+			}
+	}
+
+	send_surface_data_focused_state(surface);
+	wl_shell_surface_send_minimize(&shsurf->resource);
+
+	weston_compositor_damage_all(compositor);
+}
+
+static void
+surface_unminimize(struct shell_surface *shsurf, struct workspace *ws)
+{
+	struct desktop_shell *shell;
+	struct weston_compositor *compositor;
+	struct weston_surface *surface;
+
+	shell = shsurf->shell;
+	compositor = shell->compositor;
+	surface = shsurf->surface;
+
+	wl_list_remove(&surface->layer_link);
+	wl_list_insert(ws->layer.surface_list.prev, &surface->layer_link);
+	shell_surface_focus(shsurf);
+	send_surface_data_focused_state(surface);
+	wl_shell_surface_send_unminimize(&shsurf->resource);
+	shsurf->minimized = false;
+	weston_compositor_damage_all(compositor);
+}
+
+static void
+shell_surface_unminimize(struct shell_surface *shsurf)
+{
+	struct weston_surface *surface;
+	struct workspace *ws = get_current_workspace(shsurf->shell);
+
+	wl_list_for_each(surface, &ws->layer.minimized_list, layer_link)
+		if (surface == shsurf->surface) {
+			surface_unminimize(shsurf, ws);
+			return;
+		}
+}
+
+static void
+surface_data_maximize_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data = resource->data;
+
+	wl_shell_surface_send_maximize(&surface_data->shsurf->resource);
+}
+
+static void
+surface_data_unmaximize_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data = resource->data;
+
+	wl_shell_surface_send_unmaximize(&surface_data->shsurf->resource);
+}
+
+static void
+surface_data_minimize_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data = resource->data;
+
+	shell_surface_minimize(surface_data->shsurf);
+}
+
+static void
+surface_data_unminimize_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data = resource->data;
+
+	shell_surface_unminimize(surface_data->shsurf);
+}
+
+static void
+surface_data_focus_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data = resource->data;
+
+	shell_surface_focus(surface_data->shsurf);
+}
+
+static void
+surface_data_close_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data;
+	struct shell_surface *shsurf;
+	struct wl_surface *target_surface;
+	struct wl_client *target_client;
+	struct desktop_shell *shell;
+	struct weston_compositor *compositor;
+	pid_t pid;
+
+	surface_data = resource->data;
+	shsurf = surface_data->shsurf;
+	target_surface = &shsurf->surface->surface;
+	shell = shsurf->shell;
+	compositor = shell->compositor;
+
+	if (!target_surface)
+		return;
+
+	wl_signal_emit(&compositor->kill_signal, target_surface);
+
+	target_client = target_surface->resource.client;
+	wl_client_get_credentials(target_client, &pid, NULL, NULL);
+
+	/* Skip clients that we launched ourselves (the credentials of
+	 * the socketpair is ours) */
+	if (pid == getpid())
+		return;
+
+	kill(pid, SIGTERM);
+}
+
+static const struct surface_data_interface
+					surface_data_implementation = {
+	surface_data_maximize_handler,
+	surface_data_unmaximize_handler,
+	surface_data_minimize_handler,
+	surface_data_unminimize_handler,
+	surface_data_focus_handler,
+	surface_data_close_handler,
+	surface_data_destroy_handler
+};
+
+static void
+surface_data_object_destroy(struct wl_resource *resource)
+{
+	struct shell_surface *shsurf;
+	struct surface_data *surface_data = resource->data;
+
+	shsurf = surface_data->shsurf;
+
+	free(surface_data);
+
+	if (!shsurf)
+		return;
+
+	shsurf->surface_data = NULL;
+}
+
+static int
+create_surface_data(struct desktop_shell *shell, struct shell_surface *shsurf)
+{
+	struct surface_data *surface_data;
+
+	surface_data = malloc(sizeof *surface_data);
+	if (surface_data == NULL)
+		return -1;
+
+	surface_data->resource.data = surface_data;
+	surface_data->resource.object.id = 0;
+	surface_data->resource.object.interface = &surface_data_interface;
+	surface_data->resource.destroy = surface_data_object_destroy;
+	surface_data->resource.object.implementation =
+			(void (**)(void)) &surface_data_implementation;
+	surface_data->shsurf = shsurf;
+	wl_signal_init(&surface_data->resource.destroy_signal);
+
+	wl_client_add_resource(shell->surface_data_manager->client,
+					&surface_data->resource);
+
+	shsurf->surface_data = surface_data;
+
+	return 0;
+}
+
+static void
+send_surface_data_object(struct desktop_shell *shell, struct shell_surface *shsurf)
+{
+	surface_data_manager_send_surface_object(shell->surface_data_manager,
+					&shsurf->surface_data->resource);
+}
+
+static bool
+surface_is_window_list_candidate(struct weston_surface *surface,
+					struct shell_surface *out)
+{
+	struct desktop_shell *shell;
+	struct shell_surface *shsurf;
+
+	shsurf = get_shell_surface(surface);
+	if (!shsurf)
+		return false;
+
+	shell = shsurf->shell;
+
+	if (!shell->surface_data_manager)
+		return false;
+
+	switch (shsurf->type) {
+	default:
+	case SHELL_SURFACE_TRANSIENT:
+	case SHELL_SURFACE_POPUP:
+	case SHELL_SURFACE_NONE:
+		return false;
+	case SHELL_SURFACE_FULLSCREEN:
+	case SHELL_SURFACE_MAXIMIZED:
+	case SHELL_SURFACE_TOPLEVEL:
+		if (!shsurf->surface_data) {
+			if (create_surface_data(shell, shsurf))
+				return 0;
+			send_surface_data_object(shell, shsurf);
+		}
+		*out = *shsurf;
+		return true;
+	}
+}
+
+static void
+send_surface_data_output_mask(struct weston_surface *surface)
+{
+	struct shell_surface shsurf;
+
+	if (surface_is_window_list_candidate(surface, &shsurf))
+		surface_data_send_output_mask(&shsurf.surface_data->resource,
+						surface->output_mask);
+}
+
+static void
+send_surface_data_title(struct weston_surface *surface)
+{
+	struct shell_surface shsurf;
+
+	if (surface_is_window_list_candidate(surface, &shsurf))
+		surface_data_send_title(&shsurf.surface_data->resource,
+						shsurf.title == NULL ?
+						"Surface" : shsurf.title);
+}
+
+static void
+send_surface_data_minimized_state(struct weston_surface *surface)
+{
+	struct shell_surface shsurf;
+
+	if (surface_is_window_list_candidate(surface, &shsurf))
+		surface_data_send_minimized(&shsurf.surface_data->resource,
+					shsurf.minimized ? true : false);
+}
+
+static void
+send_surface_data_focused_state(struct weston_surface *surface)
+{
+	struct shell_surface shsurf;
+	struct focus_state *state;
+	struct workspace *ws;
+	bool focused = false;
+
+	if (surface_is_window_list_candidate(surface, &shsurf)) {
+		ws = get_current_workspace(shsurf.shell);
+		wl_list_for_each(state, &ws->focus_list, link)
+			if (state->keyboard_focus == shsurf.surface)
+				focused = true;
+		surface_data_send_focused(&shsurf.surface_data->resource,
+					focused);
+	}
+}
+
+static void
 shell_surface_set_title(struct wl_client *client,
 			struct wl_resource *resource, const char *title)
 {
@@ -1404,6 +1746,7 @@ shell_surface_set_title(struct wl_client *client,
 
 	free(shsurf->title);
 	shsurf->title = strdup(title);
+	send_surface_data_title(shsurf->surface);
 }
 
 static void
@@ -1466,6 +1809,7 @@ reset_shell_surface_type(struct shell_surface *surface)
 		weston_surface_set_position(surface->surface,
 					    surface->saved_x,
 					    surface->saved_y);
+		surface_data_send_maximized(&surface->surface_data->resource, false);
 		break;
 	case SHELL_SURFACE_NONE:
 	case SHELL_SURFACE_TOPLEVEL:
@@ -1502,6 +1846,7 @@ set_surface_type(struct shell_surface *shsurf)
 		shsurf->saved_x = surface->geometry.x;
 		shsurf->saved_y = surface->geometry.y;
 		shsurf->saved_position_valid = true;
+		surface_data_send_maximized(&shsurf->surface_data->resource, true);
 		break;
 
 	case SHELL_SURFACE_FULLSCREEN:
@@ -1520,6 +1865,8 @@ set_surface_type(struct shell_surface *shsurf)
 	default:
 		break;
 	}
+
+	send_surface_data_title(surface);
 }
 
 static void
@@ -1618,6 +1965,16 @@ shell_surface_set_maximized(struct wl_client *client,
 }
 
 static void
+shell_surface_set_minimized(struct wl_client *client,
+			    struct wl_resource *resource)
+{
+	struct shell_surface *shsurf = resource->data;
+
+	shell_surface_minimize(shsurf);
+	send_surface_data_minimized_state(shsurf->surface);
+}
+
+static void
 black_surface_configure(struct weston_surface *es, int32_t sx, int32_t sy);
 
 static struct weston_surface *
@@ -1924,6 +2281,7 @@ static const struct wl_shell_surface_interface shell_surface_implementation = {
 	shell_surface_set_fullscreen,
 	shell_surface_set_popup,
 	shell_surface_set_maximized,
+	shell_surface_set_minimized,
 	shell_surface_set_title,
 	shell_surface_set_class
 };
@@ -1931,6 +2289,10 @@ static const struct wl_shell_surface_interface shell_surface_implementation = {
 static void
 destroy_shell_surface(struct shell_surface *shsurf)
 {
+	if (shsurf->surface_data) {
+		shsurf->surface_data->shsurf = NULL;
+		surface_data_send_gone(&shsurf->surface_data->resource);
+	}
 	if (shsurf->popup.grab.pointer)
 		wl_pointer_end_grab(shsurf->popup.grab.pointer);
 
@@ -2012,6 +2374,7 @@ create_shell_surface(void *shell, struct weston_surface *surface,
 
 	shsurf->shell = (struct desktop_shell *) shell;
 	shsurf->unresponsive = 0;
+	shsurf->minimized = false;
 	shsurf->saved_position_valid = false;
 	shsurf->saved_rotation_valid = false;
 	shsurf->surface = surface;
@@ -2315,6 +2678,28 @@ static const struct desktop_shell_interface desktop_shell_implementation = {
 	desktop_shell_set_grab_surface
 };
 
+static void
+surface_data_send_all_info(struct desktop_shell *shell)
+{
+	struct weston_surface *surface;
+	struct workspace *ws;
+
+	ws = get_current_workspace(shell);
+
+	wl_list_for_each(surface, &ws->layer.surface_list, layer_link) {
+		send_surface_data_minimized_state(surface);
+		send_surface_data_focused_state(surface);
+		send_surface_data_output_mask(surface);
+		send_surface_data_title(surface);
+	}
+	wl_list_for_each(surface, &ws->layer.minimized_list, layer_link) {
+		send_surface_data_minimized_state(surface);
+		send_surface_data_focused_state(surface);
+		send_surface_data_output_mask(surface);
+		send_surface_data_title(surface);
+	}
+}
+
 static enum shell_surface_type
 get_shell_surface_type(struct weston_surface *surface)
 {
@@ -2650,6 +3035,7 @@ activate(struct desktop_shell *shell, struct weston_surface *es,
 		return;
 
 	state->keyboard_focus = es;
+	send_surface_data_focused_state(es);
 	wl_list_remove(&state->surface_destroy_listener.link);
 	wl_signal_add(&es->surface.resource.destroy_signal,
 		      &state->surface_destroy_listener);
@@ -2674,7 +3060,7 @@ black_surface_configure(struct weston_surface *es, int32_t sx, int32_t sy)
 {
 }
 
-static bool 
+static bool
 is_black_surface (struct weston_surface *es, struct weston_surface **fs_surface)
 {
 	if (es->configure == black_surface_configure) {
@@ -3143,6 +3529,37 @@ bind_desktop_shell(struct wl_client *client,
 }
 
 static void
+unbind_surface_data_manager(struct wl_resource *resource)
+{
+	struct desktop_shell *shell = resource->data;
+
+	shell->surface_data_manager = NULL;
+	free(resource);
+}
+
+static void
+bind_surface_data_manager(struct wl_client *client,
+		   void *data, uint32_t version, uint32_t id)
+{
+	struct desktop_shell *shell = data;
+	struct wl_resource *resource;
+
+	resource = wl_client_add_object(client, &surface_data_manager_interface,
+					NULL, id, shell);
+
+	if (client == shell->child.client) {
+		resource->destroy = unbind_surface_data_manager;
+		shell->surface_data_manager = resource;
+		surface_data_send_all_info(shell);
+		return;
+	}
+
+	wl_resource_post_error(resource, WL_DISPLAY_ERROR_INVALID_OBJECT,
+			       "permission to bind desktop_shell denied");
+	wl_resource_destroy(resource);
+}
+
+static void
 screensaver_configure(struct weston_surface *surface, int32_t sx, int32_t sy)
 {
 	struct desktop_shell *shell = surface->private;
@@ -3757,6 +4174,7 @@ module_init(struct weston_compositor *ec)
 	ec->shell_interface.set_transient = set_transient;
 	ec->shell_interface.move = surface_move;
 	ec->shell_interface.resize = surface_resize;
+	ec->shell_interface.send_output_mask = send_surface_data_output_mask;
 
 	wl_list_init(&shell->screensaver.surfaces);
 	wl_list_init(&shell->input_panel.surfaces);
@@ -3808,6 +4226,10 @@ module_init(struct weston_compositor *ec)
 				  shell, bind_workspace_manager) == NULL)
 		return -1;
 
+	if (wl_display_add_global(ec->wl_display, &surface_data_manager_interface,
+				  shell, bind_surface_data_manager) == NULL)
+		return -1;
+
 	shell->child.deathstamp = weston_compositor_get_time();
 
 	loop = wl_display_get_event_loop(ec->wl_display);







































diff --git a/configure.ac b/configure.ac
index 64505dd..57a444b 100644
--- a/configure.ac
+++ b/configure.ac
@@ -154,6 +154,16 @@ fi
 AM_CONDITIONAL(INSTALL_RPI_COMPOSITOR, test "x$have_bcm_host" = "xyes")
 
 
+AC_ARG_ENABLE([fbdev-compositor], [  --enable-fbdev-compositor],,
+              enable_fbdev_compositor=yes)
+AM_CONDITIONAL([ENABLE_FBDEV_COMPOSITOR],
+               [test x$enable_fbdev_compositor = xyes])
+AS_IF([test x$enable_fbdev_compositor = xyes], [
+  AC_DEFINE([BUILD_FBDEV_COMPOSITOR], [1], [Build the fbdev compositor])
+  PKG_CHECK_MODULES([FBDEV_COMPOSITOR], [libudev >= 136 mtdev >= 1.1.0])
+])
+
+
 AC_ARG_WITH(cairo-glesv2,
             AS_HELP_STRING([--with-cairo-glesv2],
                            [Use GLESv2 cairo instead of full GL]))
diff --git a/src/Makefile.am b/src/Makefile.am
index cbfa911..efa819d 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -84,7 +84,8 @@ module_LTLIBRARIES =				\
 	$(x11_backend)				\
 	$(drm_backend)				\
 	$(wayland_backend)			\
-	$(headless_backend)
+	$(headless_backend)			\
+	$(fbdev_backend)
 
 # Do not install, since the binary produced via autotools is unusable.
 # The real backend is built by the Android build system.
@@ -195,6 +196,29 @@ headless_backend_la_CFLAGS =			\
 headless_backend_la_SOURCES = compositor-headless.c
 endif
 
+if ENABLE_FBDEV_COMPOSITOR
+fbdev_backend = fbdev-backend.la
+fbdev_backend_la_LDFLAGS = -module -avoid-version
+fbdev_backend_la_LIBADD = \
+	$(COMPOSITOR_LIBS) \
+	$(FBDEV_COMPOSITOR_LIBS) \
+	../shared/libshared.la \
+	$(NULL)
+fbdev_backend_la_CFLAGS = \
+	$(COMPOSITOR_CFLAGS) \
+	$(FBDEV_COMPOSITOR_CFLAGS) \
+	$(PIXMAN_CFLAGS) \
+	$(GCC_CFLAGS) \
+	$(NULL)
+fbdev_backend_la_SOURCES = \
+	compositor-fbdev.c \
+	tty.c \
+	evdev.c \
+	evdev.h \
+	evdev-touchpad.c \
+	$(NULL)
+endif
+
 if ENABLE_DESKTOP_SHELL
 desktop_shell = desktop-shell.la
 desktop_shell_la_LDFLAGS = -module -avoid-version
diff --git a/src/compositor-fbdev.c b/src/compositor-fbdev.c
new file mode 100644
index 0000000..891a4db
--- /dev/null
+++ b/src/compositor-fbdev.c
@@ -0,0 +1,957 @@
+/*
+ * Copyright © 2008-2011 Kristian Høgsberg
+ * Copyright © 2011 Intel Corporation
+ * Copyright © 2012 Raspberry Pi Foundation
+ * Copyright © 2013 Philip Withnall
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of the copyright holders not be used in
+ * advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  The copyright holders make
+ * no representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#define _GNU_SOURCE
+
+#include <errno.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+#include <sys/mman.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <linux/fb.h>
+
+#include <libudev.h>
+
+#include "config.h"
+
+#include "compositor.h"
+#include "pixman-renderer.h"
+#include "evdev.h"
+
+struct fbdev_compositor {
+	struct weston_compositor base;
+	uint32_t prev_state;
+
+	struct udev *udev;
+	struct tty *tty;
+};
+
+struct fbdev_output {
+	struct fbdev_compositor *compositor;
+	struct weston_output base;
+
+	struct weston_mode mode;
+	struct wl_event_source *finish_frame_timer;
+
+	/* Frame buffer details. */
+	struct fb_fix_screeninfo fixed_info;
+	struct fb_var_screeninfo variable_info;
+	void *fb;
+	size_t fb_len;
+
+	/* pixman details. */
+	pixman_image_t *hw_surface;
+	pixman_image_t *shadow_surface;
+	void *shadow_buf;
+	uint8_t depth;
+};
+
+struct fbdev_seat {
+	struct weston_seat base;
+	struct wl_list devices_list;
+
+	struct udev_monitor *udev_monitor;
+	struct wl_event_source *udev_monitor_source;
+	char *seat_id;
+};
+
+struct fbdev_parameters {
+	int tty;
+	char *device;
+};
+
+static inline struct fbdev_output *
+to_fbdev_output(struct weston_output *base)
+{
+	return container_of(base, struct fbdev_output, base);
+}
+
+static inline struct fbdev_seat *
+to_fbdev_seat(struct weston_seat *base)
+{
+	return container_of(base, struct fbdev_seat, base);
+}
+
+static inline struct fbdev_compositor *
+to_fbdev_compositor(struct weston_compositor *base)
+{
+	return container_of(base, struct fbdev_compositor, base);
+}
+
+static void
+fbdev_output_repaint(struct weston_output *base, pixman_region32_t *damage)
+{
+	struct fbdev_output *output = to_fbdev_output(base);
+	struct weston_compositor *ec = output->base.compositor;
+	pixman_box32_t *rects;
+	int nrects, i, src_x, src_y, x1, y1, x2, y2, width, height;
+
+	/* Repaint the damaged region onto the back buffer. */
+	pixman_renderer_output_set_buffer(base, output->shadow_surface);
+	ec->renderer->repaint_output(base, damage);
+
+	/* Transform and composite onto the frame buffer. */
+	width = pixman_image_get_width(output->shadow_surface);
+	height = pixman_image_get_height(output->shadow_surface);
+	rects = pixman_region32_rectangles(damage, &nrects);
+
+	for (i = 0; i < nrects; i++) {
+		switch (base->transform) {
+		default:
+		case WL_OUTPUT_TRANSFORM_NORMAL:
+			x1 = rects[i].x1;
+			x2 = rects[i].x2;
+			y1 = rects[i].y1;
+			y2 = rects[i].y2;
+			break;
+		case WL_OUTPUT_TRANSFORM_180:
+			x1 = width - rects[i].x2;
+			x2 = width - rects[i].x1;
+			y1 = height - rects[i].y2;
+			y2 = height - rects[i].y1;
+			break;
+		case WL_OUTPUT_TRANSFORM_90:
+			x1 = height - rects[i].y2;
+			x2 = height - rects[i].y1;
+			y1 = rects[i].x1;
+			y2 = rects[i].x2;
+			break;
+		case WL_OUTPUT_TRANSFORM_270:
+			x1 = rects[i].y1;
+			x2 = rects[i].y2;
+			y1 = width - rects[i].x2;
+			y2 = width - rects[i].x1;
+			break;
+		}
+		src_x = x1;
+		src_y = y1;
+
+		pixman_image_composite32(PIXMAN_OP_SRC,
+			output->shadow_surface, /* src */
+			NULL /* mask */,
+			output->hw_surface, /* dest */
+			src_x, src_y, /* src_x, src_y */
+			0, 0, /* mask_x, mask_y */
+			x1, y1, /* dest_x, dest_y */
+			x2 - x1, /* width */
+			y2 - y1 /* height */);
+	}
+
+	/* Update the damage region. */
+	pixman_region32_subtract(&ec->primary_plane.damage,
+	                         &ec->primary_plane.damage, damage);
+
+	/* Schedule the end of the frame. We do not sync this to the frame
+	 * buffer clock because users who want that should be using the DRM
+	 * compositor. FBIO_WAITFORVSYNC blocks and FB_ACTIVATE_VBL requires
+	 * panning, which is broken in most kernel drivers.
+	 *
+	 * Finish the frame synchronised to the specified refresh rate. The
+	 * refresh rate is given in mHz and the interval in ms. */
+	wl_event_source_timer_update(output->finish_frame_timer,
+	                             1000000 / output->mode.refresh);
+}
+
+static int
+finish_frame_handler(void *data)
+{
+	struct fbdev_output *output = data;
+	uint32_t msec;
+	struct timeval tv;
+
+	gettimeofday(&tv, NULL);
+	msec = tv.tv_sec * 1000 + tv.tv_usec / 1000;
+	weston_output_finish_frame(&output->base, msec);
+
+	return 1;
+}
+
+static int
+fbdev_frame_buffer_create(struct fbdev_output *output, const char *fb_dev)
+{
+	int retval = -1;
+	int fd = -1;
+
+	/* Open the frame buffer device. */
+	fd = open (fb_dev, O_RDWR | O_CLOEXEC);
+	if (fd < 0) {
+		weston_log("Failed to open frame buffer device ‘%s’: %s\n",
+		           fb_dev, strerror(errno));
+		goto err;
+	}
+
+	/* Grab the screen info. */
+	if (ioctl(fd, FBIOGET_FSCREENINFO, &output->fixed_info) < 0 ||
+	    ioctl(fd, FBIOGET_VSCREENINFO, &output->variable_info) < 0) {
+		weston_log("Failed to get frame buffer info: %s\n",
+		           strerror(errno));
+		goto err;
+	}
+
+	/* Map the frame buffer. Write-only mode, since we don't want to read
+	 * anything back (because it's slow). */
+	output->fb = mmap (NULL, output->fixed_info.smem_len,
+	                   PROT_WRITE, MAP_SHARED, fd, 0);
+	if (output->fb == MAP_FAILED) {
+		weston_log("Failed to mmap frame buffer: %s\n",
+		           strerror(errno));
+		goto err;
+	}
+
+	/* Success! */
+	output->fb_len = output->fixed_info.smem_len;
+	retval = 0;
+
+err:
+	if (fd >= 0)
+		close (fd);
+
+	return retval;
+}
+
+static void
+fbdev_frame_buffer_destroy(struct fbdev_output *output)
+{
+	if (munmap(output->fb, output->fb_len) < 0)
+		weston_log("Failed to munmap frame buffer: %s\n",
+		           strerror(errno));
+
+	output->fb = NULL;
+	output->fb_len = 0;
+}
+
+static pixman_format_code_t
+calculate_pixman_format(struct fb_var_screeninfo *vinfo,
+                        struct fb_fix_screeninfo *finfo)
+{
+	/* Calculate the pixman format supported by the frame buffer from the
+	 * buffer's metadata. Return 0 if no known pixman format is supported
+	 * (since this has depth 0 it's guaranteed to not conflict with any
+	 * actual pixman format).
+	 *
+	 * Documentation on the vinfo and finfo structures:
+	 *    http://www.mjmwired.net/kernel/Documentation/fb/api.txt
+	 *
+	 * TODO: Try a bit harder to support other formats, including setting
+	 * the preferred format in the hardware. */
+	int type;
+
+	weston_log("Calculating pixman format from:\n"
+	           STAMP_SPACE " - type: %i (aux: %i)\n"
+	           STAMP_SPACE " - visual: %i\n"
+	           STAMP_SPACE " - bpp: %i (grayscale: %i)\n"
+	           STAMP_SPACE " - red: offset: %i, length: %i, MSB: %i\n"
+	           STAMP_SPACE " - green: offset: %i, length: %i, MSB: %i\n"
+	           STAMP_SPACE " - blue: offset: %i, length: %i, MSB: %i\n"
+	           STAMP_SPACE " - transp: offset: %i, length: %i, MSB: %i\n",
+	           finfo->type, finfo->type_aux, finfo->visual,
+	           vinfo->bits_per_pixel, vinfo->grayscale,
+	           vinfo->red.offset, vinfo->red.length, vinfo->red.msb_right,
+	           vinfo->green.offset, vinfo->green.length,
+	           vinfo->green.msb_right,
+	           vinfo->blue.offset, vinfo->blue.length,
+	           vinfo->blue.msb_right,
+	           vinfo->transp.offset, vinfo->transp.length,
+	           vinfo->transp.msb_right);
+
+	/* We only handle packed formats at the moment. */
+	if (finfo->type != FB_TYPE_PACKED_PIXELS)
+		return 0;
+
+	/* We only handle true-colour frame buffers at the moment. */
+	if (finfo->visual != FB_VISUAL_TRUECOLOR || vinfo->grayscale != 0)
+		return 0;
+
+	/* We only support formats with MSBs on the left. */
+	if (vinfo->red.msb_right != 0 || vinfo->green.msb_right != 0 ||
+	    vinfo->blue.msb_right != 0)
+		return 0;
+
+	/* Work out the format type from the offsets. We only support RGBA and
+	 * ARGB at the moment. */
+	type = PIXMAN_TYPE_OTHER;
+
+	if ((vinfo->transp.offset >= vinfo->red.offset ||
+	     vinfo->transp.length == 0) &&
+	    vinfo->red.offset >= vinfo->green.offset &&
+	    vinfo->green.offset >= vinfo->blue.offset)
+		type = PIXMAN_TYPE_ARGB;
+	else if (vinfo->red.offset >= vinfo->green.offset &&
+	         vinfo->green.offset >= vinfo->blue.offset &&
+	         vinfo->blue.offset >= vinfo->transp.offset)
+		type = PIXMAN_TYPE_RGBA;
+
+	if (type == PIXMAN_TYPE_OTHER)
+		return 0;
+
+	/* Build the format. */
+	return PIXMAN_FORMAT(vinfo->bits_per_pixel, type,
+	                     vinfo->transp.length,
+	                     vinfo->red.length,
+	                     vinfo->green.length,
+	                     vinfo->blue.length);
+}
+
+static int
+calculate_refresh_rate(struct fb_var_screeninfo *vinfo)
+{
+	uint64_t quot;
+
+	/* Calculate monitor refresh rate. Default is 60 Hz. Units are mHz. */
+	quot = (vinfo->upper_margin + vinfo->lower_margin + vinfo->yres);
+	quot *= (vinfo->left_margin + vinfo->right_margin + vinfo->xres);
+	quot *= vinfo->pixclock;
+
+	if (quot > 0) {
+		uint64_t refresh_rate;
+
+		refresh_rate = 1000000000000000LLU / quot;
+		if (refresh_rate > 200000)
+			refresh_rate = 200000; /* cap at 200 Hz */
+
+		return refresh_rate;
+	}
+
+	return 60 * 1000; /* default to 60 Hz */
+}
+
+static void fbdev_output_destroy(struct weston_output *base);
+
+static int
+fbdev_output_create(struct fbdev_compositor *compositor,
+                    struct fbdev_parameters *param)
+{
+	struct fbdev_output *output;
+	pixman_transform_t transform;
+	int shadow_width, shadow_height;
+	int width, height;
+	pixman_format_code_t pixman_format;
+	struct wl_event_loop *loop;
+
+	output = calloc(1, sizeof *output);
+	if (!output)
+		return -1;
+
+	output->compositor = compositor;
+
+	/* Create the frame buffer. */
+	if (fbdev_frame_buffer_create(output, param->device) < 0) {
+		weston_log("Creating frame buffer failed.\n");
+		goto out_free;
+	}
+
+	pixman_format = calculate_pixman_format(&output->variable_info, &output->fixed_info);
+	if (pixman_format == 0) {
+		weston_log("Frame buffer uses an unsupported format.\n");
+		goto out_fb;
+	}
+
+	output->base.repaint = fbdev_output_repaint;
+	output->base.destroy = fbdev_output_destroy;
+	output->base.assign_planes = NULL;
+	output->base.set_backlight = NULL;
+	output->base.set_dpms = NULL;
+	output->base.switch_mode = NULL;
+
+	/* only one static mode in list */
+	output->mode.flags =
+		WL_OUTPUT_MODE_CURRENT | WL_OUTPUT_MODE_PREFERRED;
+	output->mode.width = output->variable_info.xres;
+	output->mode.height = output->variable_info.yres;
+	output->mode.refresh = calculate_refresh_rate(&output->variable_info);
+	wl_list_init(&output->base.mode_list);
+	wl_list_insert(&output->base.mode_list, &output->mode.link);
+
+	output->base.current = &output->mode;
+	output->base.origin = &output->mode;
+	output->base.subpixel = WL_OUTPUT_SUBPIXEL_UNKNOWN;
+	output->base.make = "fbdev";
+	output->base.model = output->fixed_info.id;
+
+	weston_output_init(&output->base, &compositor->base,
+	                   0, 0, output->variable_info.width,
+	                   output->variable_info.height,
+	                   WL_OUTPUT_TRANSFORM_NORMAL);
+
+	/* Create a pixman image to wrap the memory mapped frame buffer. */
+	width = output->variable_info.xres;
+	height = output->variable_info.yres;
+
+	output->hw_surface =
+		pixman_image_create_bits(pixman_format, width, height,
+		                         output->fb,
+		                         output->fixed_info.line_length);
+	if (output->hw_surface == NULL) {
+		weston_log("Failed to create surface for frame buffer.\n");
+		goto out_output;
+	}
+
+	pixman_transform_init_identity(&transform);
+	switch (output->base.transform) {
+	default:
+	case WL_OUTPUT_TRANSFORM_NORMAL:
+		shadow_width = width;
+		shadow_height = height;
+		pixman_transform_rotate(&transform,
+			NULL, 0, 0);
+		pixman_transform_translate(&transform, NULL,
+			0, 0);
+		break;
+	case WL_OUTPUT_TRANSFORM_180:
+		shadow_width = width;
+		shadow_height = height;
+		pixman_transform_rotate(&transform,
+			NULL, -pixman_fixed_1, 0);
+		pixman_transform_translate(NULL, &transform,
+			pixman_int_to_fixed(shadow_width),
+			pixman_int_to_fixed(shadow_height));
+		break;
+	case WL_OUTPUT_TRANSFORM_270:
+		shadow_width = height;
+		shadow_height = width;
+		pixman_transform_rotate(&transform,
+			NULL, 0, pixman_fixed_1);
+		pixman_transform_translate(&transform,
+			NULL,
+			pixman_int_to_fixed(shadow_width),
+			0);
+		break;
+	case WL_OUTPUT_TRANSFORM_90:
+		shadow_width = height;
+		shadow_height = width;
+		pixman_transform_rotate(&transform,
+			NULL, 0, -pixman_fixed_1);
+		pixman_transform_translate(&transform,
+			NULL,
+			0,
+			pixman_int_to_fixed(shadow_height));
+		break;
+	}
+
+	output->shadow_buf = malloc(width * height * (output->variable_info.bits_per_pixel / 8));
+	output->shadow_surface =
+		pixman_image_create_bits(pixman_format, shadow_width,
+		                         shadow_height, output->shadow_buf,
+		                         shadow_width * (output->variable_info.bits_per_pixel / 8));
+	if (output->shadow_buf == NULL || output->shadow_surface == NULL) {
+		weston_log("Failed to create surface for frame buffer.\n");
+		goto out_hw_surface;
+	}
+
+	/* No need in transform for normal output */
+	if (output->base.transform != WL_OUTPUT_TRANSFORM_NORMAL)
+		pixman_image_set_transform(output->shadow_surface, &transform);
+
+	if (pixman_renderer_output_create(&output->base) < 0)
+		goto out_shadow_surface;
+
+	loop = wl_display_get_event_loop(compositor->base.wl_display);
+	output->finish_frame_timer =
+		wl_event_loop_add_timer(loop, finish_frame_handler, output);
+
+	wl_list_insert(compositor->base.output_list.prev, &output->base.link);
+
+	weston_log("fbdev output %d×%d px\n",
+	           output->mode.width, output->mode.height);
+	weston_log_continue(STAMP_SPACE "guessing %d Hz and 96 dpi\n",
+	                    output->mode.refresh / 1000);
+
+	return 0;
+
+out_shadow_surface:
+	pixman_image_unref(output->shadow_surface);
+out_hw_surface:
+	free(output->shadow_buf);
+	pixman_image_unref(output->hw_surface);
+out_output:
+	weston_output_destroy(&output->base);
+out_fb:
+	fbdev_frame_buffer_destroy(output);
+out_free:
+	free(output);
+
+	return -1;
+}
+
+static void
+fbdev_output_destroy(struct weston_output *base)
+{
+	struct fbdev_output *output = to_fbdev_output(base);
+
+	weston_log("%s\n", __func__);
+
+	pixman_renderer_output_destroy(base);
+
+	pixman_image_unref(output->hw_surface);
+	output->hw_surface = NULL;
+
+	pixman_image_unref(output->shadow_surface);
+	output->shadow_surface = NULL;
+
+	free(output->shadow_buf);
+	output->shadow_buf = NULL;
+
+	fbdev_frame_buffer_destroy(output);
+
+	wl_list_remove(&output->base.link);
+	weston_output_destroy(&output->base);
+
+	free(output);
+}
+
+static void
+fbdev_led_update(struct weston_seat *seat_base, enum weston_led leds)
+{
+	struct fbdev_seat *seat = to_fbdev_seat(seat_base);
+	struct evdev_device *device;
+
+	wl_list_for_each(device, &seat->devices_list, link)
+		evdev_led_update(device, leds);
+}
+
+static const char default_seat[] = "seat0";
+
+static void
+device_added(struct udev_device *udev_device, struct fbdev_seat *master)
+{
+	struct evdev_device *device;
+	const char *devnode;
+	const char *device_seat;
+	int fd;
+
+	device_seat = udev_device_get_property_value(udev_device, "ID_SEAT");
+	if (!device_seat)
+		device_seat = default_seat;
+
+	if (strcmp(device_seat, master->seat_id))
+		return;
+
+	devnode = udev_device_get_devnode(udev_device);
+	if (devnode == NULL) {
+		weston_log("Getting devnode for device on seat ‘%s’ failed.\n",
+		           device_seat);
+		return;
+	}
+
+	/* Use non-blocking mode so that we can loop on read on
+	 * evdev_device_data() until all events on the fd are
+	 * read.  mtdev_get() also expects this. */
+	fd = open(devnode, O_RDWR | O_NONBLOCK | O_CLOEXEC);
+	if (fd < 0) {
+		weston_log("opening input device '%s' failed.\n", devnode);
+		return;
+	}
+
+	device = evdev_device_create(&master->base, devnode, fd);
+	if (!device) {
+		close(fd);
+		weston_log("not using input device '%s'.\n", devnode);
+		return;
+	}
+
+	wl_list_insert(master->devices_list.prev, &device->link);
+}
+
+static void
+evdev_add_devices(struct udev *udev, struct weston_seat *seat_base)
+{
+	struct fbdev_seat *seat = to_fbdev_seat(seat_base);
+	struct udev_enumerate *e;
+	struct udev_list_entry *entry;
+	struct udev_device *device;
+	const char *path, *sysname;
+
+	e = udev_enumerate_new(udev);
+	if (e == NULL)
+		return;
+
+	if (udev_enumerate_add_match_subsystem(e, "input") < 0 ||
+	    udev_enumerate_scan_devices(e) < 0)
+		goto out_enumerate;
+
+	udev_list_entry_foreach(entry, udev_enumerate_get_list_entry(e)) {
+		path = udev_list_entry_get_name(entry);
+		device = udev_device_new_from_syspath(udev, path);
+
+		if (device == NULL)
+			continue;
+
+		sysname = udev_device_get_sysname(device);
+		if (strncmp("event", sysname, 5) != 0) {
+			udev_device_unref(device);
+			continue;
+		}
+
+		device_added(device, seat);
+
+		udev_device_unref(device);
+	}
+	udev_enumerate_unref(e);
+
+	evdev_notify_keyboard_focus(&seat->base, &seat->devices_list);
+
+	if (wl_list_empty(&seat->devices_list)) {
+		weston_log(
+			"warning: no input devices on entering Weston. "
+			"Possible causes:\n"
+			"\t- no permissions to read /dev/input/event*\n"
+			"\t- seats misconfigured "
+			"(Weston backend option 'seat', "
+			"udev device property ID_SEAT)\n");
+	}
+
+	return;
+
+out_enumerate:
+	udev_enumerate_unref(e);
+
+	weston_log ("Failed to enumerate and add evdev devices.\n");
+}
+
+static int
+evdev_udev_handler(int fd, uint32_t mask, void *data)
+{
+	struct fbdev_seat *seat = data;
+	struct udev_device *udev_device;
+	struct evdev_device *device, *next;
+	const char *action;
+	const char *devnode;
+
+	udev_device = udev_monitor_receive_device(seat->udev_monitor);
+	if (!udev_device)
+		return 1;
+
+	action = udev_device_get_action(udev_device);
+	if (!action)
+		goto out;
+
+	if (strncmp("event", udev_device_get_sysname(udev_device), 5) != 0)
+		goto out;
+
+	if (!strcmp(action, "add")) {
+		device_added(udev_device, seat);
+	}
+	else if (!strcmp(action, "remove")) {
+		devnode = udev_device_get_devnode(udev_device);
+		wl_list_for_each_safe(device, next, &seat->devices_list, link)
+			if (!strcmp(device->devnode, devnode)) {
+				weston_log("input device %s, %s removed\n",
+				           device->devname, device->devnode);
+				evdev_device_destroy(device);
+				break;
+			}
+	}
+
+out:
+	udev_device_unref(udev_device);
+
+	return 0;
+}
+
+static int
+evdev_enable_udev_monitor(struct udev *udev, struct weston_seat *seat_base)
+{
+	struct fbdev_seat *master = to_fbdev_seat(seat_base);
+	struct wl_event_loop *loop;
+	struct weston_compositor *c = master->base.compositor;
+	int fd;
+
+	master->udev_monitor = udev_monitor_new_from_netlink(udev, "udev");
+	if (!master->udev_monitor) {
+		weston_log("udev: failed to create the udev monitor\n");
+		goto out;
+	}
+
+	if (udev_monitor_filter_add_match_subsystem_devtype(master->udev_monitor,
+	                                                    "input",
+	                                                    NULL) < 0) {
+		weston_log("udev: failed to add filter\n");
+		goto out_monitor;
+	}
+
+	if (udev_monitor_enable_receiving(master->udev_monitor)) {
+		weston_log("udev: failed to bind the udev monitor\n");
+		goto out_monitor;
+	}
+
+	loop = wl_display_get_event_loop(c->wl_display);
+	fd = udev_monitor_get_fd(master->udev_monitor);
+	master->udev_monitor_source =
+		wl_event_loop_add_fd(loop, fd, WL_EVENT_READABLE,
+		                     evdev_udev_handler, master);
+	if (!master->udev_monitor_source)
+		goto out_monitor;
+
+	return 1;
+
+out_monitor:
+	udev_monitor_unref(master->udev_monitor);
+out:
+	return 0;
+}
+
+static void
+evdev_disable_udev_monitor(struct weston_seat *seat_base)
+{
+	struct fbdev_seat *seat = to_fbdev_seat(seat_base);
+
+	if (!seat->udev_monitor)
+		return;
+
+	udev_monitor_unref(seat->udev_monitor);
+	seat->udev_monitor = NULL;
+	wl_event_source_remove(seat->udev_monitor_source);
+	seat->udev_monitor_source = NULL;
+}
+
+static void
+evdev_input_create(struct weston_compositor *c, struct udev *udev,
+                   const char *seat_id)
+{
+	struct fbdev_seat *seat;
+
+	seat = malloc(sizeof *seat);
+	if (seat == NULL)
+		return;
+
+	memset(seat, 0, sizeof *seat);
+	weston_seat_init(&seat->base, c);
+	seat->base.led_update = fbdev_led_update;
+
+	wl_list_init(&seat->devices_list);
+	seat->seat_id = strdup(seat_id);
+	if (seat->seat_id == NULL ||
+	    !evdev_enable_udev_monitor(udev, &seat->base)) {
+		free(seat->seat_id);
+		free(seat);
+		return;
+	}
+
+	evdev_add_devices(udev, &seat->base);
+}
+
+static void
+evdev_remove_devices(struct weston_seat *seat_base)
+{
+	struct fbdev_seat *seat = to_fbdev_seat(seat_base);
+	struct evdev_device *device, *next;
+
+	wl_list_for_each_safe(device, next, &seat->devices_list, link)
+		evdev_device_destroy(device);
+
+	if (seat->base.seat.keyboard)
+		notify_keyboard_focus_out(&seat->base);
+}
+
+static void
+evdev_input_destroy(struct weston_seat *seat_base)
+{
+	struct fbdev_seat *seat = to_fbdev_seat(seat_base);
+
+	evdev_remove_devices(seat_base);
+	evdev_disable_udev_monitor(&seat->base);
+
+	weston_seat_release(seat_base);
+	free(seat->seat_id);
+	free(seat);
+}
+
+static void
+fbdev_compositor_destroy(struct weston_compositor *base)
+{
+	struct fbdev_compositor *compositor = to_fbdev_compositor(base);
+	struct weston_seat *seat, *next;
+
+	/* Destroy all inputs. */
+	wl_list_for_each_safe(seat, next, &compositor->base.seat_list, link)
+		evdev_input_destroy(seat);
+
+	/* Destroy the output. */
+	weston_compositor_shutdown(&compositor->base);
+
+	/* Chain up. */
+	compositor->base.renderer->destroy(&compositor->base);
+	tty_destroy(compositor->tty);
+
+	free(compositor);
+}
+
+static void
+vt_func(struct weston_compositor *base, int event)
+{
+	struct fbdev_compositor *compositor = to_fbdev_compositor(base);
+	struct weston_seat *seat;
+	struct weston_output *output;
+
+	switch (event) {
+	case TTY_ENTER_VT:
+		weston_log("entering VT\n");
+		compositor->base.focus = 1;
+		compositor->base.state = compositor->prev_state;
+		weston_compositor_damage_all(&compositor->base);
+		wl_list_for_each(seat, &compositor->base.seat_list, link) {
+			evdev_add_devices(compositor->udev, seat);
+			evdev_enable_udev_monitor(compositor->udev, seat);
+		}
+		break;
+	case TTY_LEAVE_VT:
+		weston_log("leaving VT\n");
+		wl_list_for_each(seat, &compositor->base.seat_list, link) {
+			evdev_disable_udev_monitor(seat);
+			evdev_remove_devices(seat);
+		}
+
+		compositor->base.focus = 0;
+		compositor->prev_state = compositor->base.state;
+		compositor->base.state = WESTON_COMPOSITOR_SLEEPING;
+
+		/* If we have a repaint scheduled (from the idle handler), make
+		 * sure we cancel that so we don't try to pageflip when we're
+		 * vt switched away.  The SLEEPING state will prevent
+		 * further attemps at repainting.  When we switch
+		 * back, we schedule a repaint, which will process
+		 * pending frame callbacks. */
+
+		wl_list_for_each(output,
+				 &compositor->base.output_list, link) {
+			output->repaint_needed = 0;
+		}
+
+		break;
+	};
+}
+
+static void
+fbdev_restore(struct weston_compositor *base)
+{
+	struct fbdev_compositor *compositor = to_fbdev_compositor(base);
+
+	tty_reset(compositor->tty);
+}
+
+static void
+switch_vt_binding(struct wl_seat *seat, uint32_t time, uint32_t key, void *data)
+{
+	struct fbdev_compositor *ec = data;
+
+	tty_activate_vt(ec->tty, key - KEY_F1 + 1);
+}
+
+static struct weston_compositor *
+fbdev_compositor_create(struct wl_display *display, int argc, char *argv[],
+                        const char *config_file, struct fbdev_parameters *param)
+{
+	struct fbdev_compositor *compositor;
+	const char *seat = default_seat;
+	uint32_t key;
+
+	weston_log("initializing fbdev backend\n");
+
+	compositor = calloc(1, sizeof *compositor);
+	if (compositor == NULL)
+		return NULL;
+
+	if (weston_compositor_init(&compositor->base, display, argc, argv,
+	                           config_file) < 0)
+		goto out_free;
+
+	compositor->udev = udev_new();
+	if (compositor->udev == NULL) {
+		weston_log("Failed to initialize udev context.\n");
+		goto out_compositor;
+	}
+
+	/* Set up the TTY. */
+	compositor->tty = tty_create(&compositor->base, vt_func, param->tty);
+	if (!compositor->tty) {
+		weston_log("Failed to initialize tty.\n");
+		goto out_udev;
+	}
+
+	compositor->base.destroy = fbdev_compositor_destroy;
+	compositor->base.restore = fbdev_restore;
+
+	compositor->base.focus = 1;
+	compositor->prev_state = WESTON_COMPOSITOR_ACTIVE;
+
+	for (key = KEY_F1; key < KEY_F9; key++)
+		weston_compositor_add_key_binding(&compositor->base, key,
+		                                  MODIFIER_CTRL | MODIFIER_ALT,
+		                                  switch_vt_binding,
+		                                  compositor);
+
+	if (pixman_renderer_init(&compositor->base) < 0)
+		goto out_tty;
+
+	if (fbdev_output_create(compositor, param) < 0)
+		goto out_pixman;
+
+	evdev_input_create(&compositor->base, compositor->udev, seat);
+
+	return &compositor->base;
+
+out_pixman:
+	compositor->base.renderer->destroy(&compositor->base);
+
+out_tty:
+	tty_destroy(compositor->tty);
+
+out_udev:
+	udev_unref(compositor->udev);
+
+out_compositor:
+	weston_compositor_shutdown(&compositor->base);
+
+out_free:
+	free(compositor);
+
+	return NULL;
+}
+
+WL_EXPORT struct weston_compositor *
+backend_init(struct wl_display *display, int argc, char *argv[],
+	     const char *config_file)
+{
+	/* TODO: Ideally, available frame buffers should be enumerated using
+	 * udev, rather than passing a device node in as a parameter. */
+	struct fbdev_parameters param = {
+		.tty = 0, /* default to current tty */
+		.device = "/dev/fb0", /* default frame buffer */
+	};
+
+	const struct weston_option fbdev_options[] = {
+		{ WESTON_OPTION_INTEGER, "tty", 0, &param.tty },
+		{ WESTON_OPTION_STRING, "device", 0, &param.device },
+	};
+
+	parse_options(fbdev_options, ARRAY_LENGTH(fbdev_options), argc, argv);
+
+	return fbdev_compositor_create(display, argc, argv, config_file,
+	                               &param);
+}







































































































diff --git a/clients/desktop-shell.c b/clients/desktop-shell.c
index 1cae789..2737d82 100644
--- a/clients/desktop-shell.c
+++ b/clients/desktop-shell.c
@@ -638,6 +638,7 @@ background_draw(struct widget *widget, void *data)
 	int type = -1;
 	struct display *display;
 	struct wl_region *opaque;
+	const char *path;
 
 	surface = window_get_surface(background->window);
 
@@ -648,8 +649,11 @@ background_draw(struct widget *widget, void *data)
 
 	widget_get_allocation(widget, &allocation);
 	image = NULL;
-	if (key_background_image)
-		image = load_cairo_surface(key_background_image);
+	path = getenv("WESTON_BACKGROUND");
+	if (!path)
+		path = key_background_image;
+	if (path)
+		image = load_cairo_surface(path);
 
 	if (strcmp(key_background_type, "scale") == 0)
 		type = BACKGROUND_SCALE;
diff --git a/protocol/remote.xml b/protocol/remote.xml
new file mode 100644
index 0000000..430a7f3
--- /dev/null
+++ b/protocol/remote.xml
@@ -0,0 +1,44 @@
+<protocol name="remote">
+
+  <interface name="remote" version="1">
+    <enum name="format">
+      <entry name="argb8888" value="0"/>
+      <entry name="xrgb8888" value="1"/>
+    </enum>
+
+    <request name="create_buffer">
+      <description summary="create wl_buffer from pool">
+	Create a wl_buffer from the pool.  The buffer is created a
+	offset bytes into the pool and has width and height as
+	specified.  The stride arguments specifies the number of bytes
+	from beginning of one row to the beginning of the next.  The
+	format is the pixel format of the buffer and must be one of
+	those advertised through the wl_shm.format event.
+
+	A buffer will keep a reference to the pool it was created from
+	so it is valid to destroy the pool immediatedly after creating
+	a buffer from it.
+      </description>
+
+      <arg name="id" type="new_id" interface="wl_buffer"/>
+      <arg name="width" type="int"/>
+      <arg name="height" type="int"/>
+      <arg name="format" type="uint"/>
+    </request>
+
+    <request name="update_buffer">
+      <arg name="buffer" type="object" interface="wl_buffer"/>
+      <arg name="tag" type="uint"
+	   summary="reference to out of band block carrying data"/> 
+      <arg name="region" type="object" interface="wl_region"/>
+    </request>
+
+    <event name="keymap">
+      <arg name="keyboard" type="object" interface="wl_keyboard"/>
+      <arg name="format" type="uint"/>
+      <arg name="tag" type="uint"/>
+      <arg name="size" type="uint"/>
+    </event>
+
+  </interface>
+</protocol>
diff --git a/src/Makefile.am b/src/Makefile.am
index cbfa911..8c039f9 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -84,7 +84,9 @@ module_LTLIBRARIES =				\
 	$(x11_backend)				\
 	$(drm_backend)				\
 	$(wayland_backend)			\
-	$(headless_backend)
+	$(headless_backend)			\
+	remote-proxy.la				\
+	remote-server.la
 
 # Do not install, since the binary produced via autotools is unusable.
 # The real backend is built by the Android build system.
@@ -218,6 +220,31 @@ tablet_shell_la_SOURCES =			\
 	tablet-shell-server-protocol.h
 endif
 
+remote_proxy_la_LDFLAGS = -module -avoid-version
+remote_proxy_la_LIBADD = $(COMPOSITOR_LIBS) -lz
+remote_proxy_la_CFLAGS = $(GCC_CFLAGS) $(COMPOSITOR_CFLAGS)
+remote_proxy_la_SOURCES =			\
+	remote-proxy.c				\
+	remote-stream.c				\
+	remote-stream.h				\
+	remote-protocol.c			\
+	remote-client-protocol.h		\
+	../shared/os-compatibility.c		\
+	../shared/os-compatibility.h
+
+remote_server_la_LDFLAGS = -module -avoid-version
+remote_server_la_LIBADD = $(COMPOSITOR_LIBS) -lz
+remote_server_la_CFLAGS = $(GCC_CFLAGS) $(COMPOSITOR_CFLAGS)
+remote_server_la_SOURCES =			\
+	remote-server.c				\
+	remote-stream.c				\
+	remote-stream.h				\
+	remote-protocol.c			\
+	remote-server-protocol.h		\
+	../shared/os-compatibility.c		\
+	../shared/os-compatibility.h
+
+
 BUILT_SOURCES =					\
 	screenshooter-server-protocol.h		\
 	screenshooter-protocol.c		\
@@ -233,6 +260,9 @@ BUILT_SOURCES =					\
 	input-method-server-protocol.h		\
 	workspaces-server-protocol.h		\
 	workspaces-protocol.c			\
+	remote-protocol.c			\
+	remote-client-protocol.h		\
+	remote-server-protocol.h		\
 	git-version.h
 
 CLEANFILES = $(BUILT_SOURCES)
diff --git a/src/compositor.c b/src/compositor.c
index cd11f6b..8d696bd 100644
--- a/src/compositor.c
+++ b/src/compositor.c
@@ -2280,6 +2280,7 @@ seat_get_keyboard(struct wl_client *client, struct wl_resource *resource,
 		  uint32_t id)
 {
 	struct weston_seat *seat = resource->data;
+	struct weston_compositor *ec = seat->compositor;
 	struct wl_resource *cr;
 
 	if (!seat->seat.keyboard)
@@ -2290,9 +2291,11 @@ seat_get_keyboard(struct wl_client *client, struct wl_resource *resource,
 	wl_list_insert(&seat->seat.keyboard->resource_list, &cr->link);
 	cr->destroy = unbind_resource;
 
-	wl_keyboard_send_keymap(cr, WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1,
-				seat->xkb_info.keymap_fd,
-				seat->xkb_info.keymap_size);
+	if (!ec->try_send_keymap ||
+	    ec->try_send_keymap(client, seat, cr) < 0)
+		wl_keyboard_send_keymap(cr, WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1,
+					seat->xkb_info.keymap_fd,
+					seat->xkb_info.keymap_size);
 
 	if (seat->seat.keyboard->focus &&
 	    seat->seat.keyboard->focus->resource.client == client) {
diff --git a/src/compositor.h b/src/compositor.h
index 544cf33..0fa2da3 100644
--- a/src/compositor.h
+++ b/src/compositor.h
@@ -264,6 +264,9 @@ struct weston_renderer {
 			       pixman_format_code_t format, void *pixels,
 			       uint32_t x, uint32_t y,
 			       uint32_t width, uint32_t height);
+	int (*read_surface_pixels)(struct weston_surface *es,
+				   pixman_format_code_t format, void *pixels,
+				   int x, int y, int width, int height);
 	void (*repaint_output)(struct weston_output *output,
 			       pixman_region32_t *output_damage);
 	void (*flush_damage)(struct weston_surface *surface);
@@ -344,6 +347,10 @@ struct weston_compositor {
 	struct xkb_rule_names xkb_names;
 	struct xkb_context *xkb_context;
 	struct weston_xkb_info xkb_info;
+
+	int (*try_send_keymap)(struct wl_client *client,
+			       struct weston_seat *seat,
+			       struct wl_resource *cr);
 };
 
 struct weston_buffer_reference {
diff --git a/src/gl-renderer.c b/src/gl-renderer.c
index a5dc2f3..cca0b47 100644
--- a/src/gl-renderer.c
+++ b/src/gl-renderer.c
@@ -82,6 +82,8 @@ struct gl_renderer {
 		int32_t width, height;
 	} border;
 
+	GLuint fbo;
+
 	PFNGLEGLIMAGETARGETTEXTURE2DOESPROC image_target_texture_2d;
 	PFNEGLCREATEIMAGEKHRPROC create_image;
 	PFNEGLDESTROYIMAGEKHRPROC destroy_image;
@@ -831,6 +833,49 @@ repaint_surfaces(struct weston_output *output, pixman_region32_t *damage)
 			draw_surface(surface, output, damage);
 }
 
+static int
+gl_renderer_read_surface_pixels(struct weston_surface *es,
+				pixman_format_code_t format, void *pixels,
+				int x, int y, int width, int height)
+{
+	struct wl_buffer *buffer = es->buffer_ref.buffer;
+	struct weston_compositor *ec = es->compositor;
+	struct gl_renderer *gr = get_renderer(ec);
+	struct gl_surface_state *gs = get_surface_state(es);
+	GLenum gl_format;
+	int size;
+
+	switch (format) {
+	case PIXMAN_a8r8g8b8:
+		gl_format = GL_BGRA_EXT;
+		break;
+	case PIXMAN_a8b8g8r8:
+		gl_format = GL_RGBA;
+		break;
+	default:
+		return -1;
+	}
+
+	if (buffer && wl_buffer_is_shm(buffer)) {
+		size = buffer->width * 4 * buffer->height;
+		memcpy(pixels, wl_shm_buffer_get_data(buffer), size);
+	} else {
+		if (gr->fbo == 0)
+			glGenFramebuffers(1, &gr->fbo);
+		glBindFramebuffer(GL_FRAMEBUFFER, gr->fbo);
+		glFramebufferTexture2D(GL_FRAMEBUFFER,
+				       GL_COLOR_ATTACHMENT0,
+				       GL_TEXTURE_2D,
+				       gs->textures[0], 0);
+
+		glReadPixels(x, y, width, height,
+			     gl_format, GL_UNSIGNED_BYTE, pixels);
+
+		glBindFramebuffer(GL_FRAMEBUFFER, 0);
+	}
+
+	return 0;
+}
 
 static int
 texture_border(struct weston_output *output)
@@ -1653,6 +1698,9 @@ gl_renderer_destroy(struct weston_compositor *ec)
 {
 	struct gl_renderer *gr = get_renderer(ec);
 
+	if (gr->fbo)
+		glDeleteFramebuffers(1, &gr->fbo);
+
 	if (gr->has_bind_display)
 		gr->unbind_display(gr->egl_display, ec->wl_display);
 
@@ -1742,6 +1790,7 @@ gl_renderer_create(struct weston_compositor *ec, EGLNativeDisplayType display,
 		return -1;
 
 	gr->base.read_pixels = gl_renderer_read_pixels;
+	gr->base.read_surface_pixels = gl_renderer_read_surface_pixels;
 	gr->base.repaint_output = gl_renderer_repaint_output;
 	gr->base.flush_damage = gl_renderer_flush_damage;
 	gr->base.attach = gl_renderer_attach;
diff --git a/src/remote-proxy.c b/src/remote-proxy.c
new file mode 100644
index 0000000..ca486c0
--- /dev/null
+++ b/src/remote-proxy.c
@@ -0,0 +1,1760 @@
+/*
+ * Copyright © 2012 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of the copyright holders not be used in
+ * advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  The copyright holders make
+ * no representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <linux/input.h>
+#include <sys/uio.h>
+#include <assert.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <errno.h>
+#include <zlib.h>
+
+#include <wayland-server.h>
+#include <wayland-client.h>
+#include "compositor.h"
+
+#include "../shared/os-compatibility.h"
+
+#include "remote-stream.h"
+#include "remote-client-protocol.h"
+
+/*
+ * - Don't abuse weston_seat, weston_output etc.
+ *
+ * - Encapsulate fd users in abstract objects?  wl_buffer,
+ *   wl_keyboard_map... idea is to keep most of core protocol the
+ *   same, but allow the out of band usage to be encapsulated.
+ *
+ * - Minimize shm update regions.
+ *
+ * - Surface enter/leave.
+ *
+ */
+
+struct remote {
+	struct weston_compositor *compositor;
+	struct wl_listener destroy_listener;
+	struct wl_display *display;
+	struct wl_registry *registry;
+	struct wl_list surface_list;
+	struct wl_compositor *remote_compositor;
+	struct wl_shell *shell;
+	struct wl_event_source *source;
+	uint32_t event_mask;
+
+	int protocol_fd[2];
+	char protocol_buffer[4096];
+	struct wl_event_source *protocol_source;
+	struct remote_stream *stream;
+	struct remote *proxy_remote;
+
+	struct remote_stream_block protocol_stream_block;
+};
+
+struct remote_output {
+	struct weston_output output;
+	struct remote *remote;
+	struct wl_output *proxy;
+};
+
+struct remote_seat {
+	struct wl_seat seat;
+	struct remote *remote;
+	struct wl_seat *proxy;
+	struct wl_pointer *proxy_pointer;
+	struct wl_keyboard *proxy_keyboard;
+	uint32_t enter_serial;
+	struct wl_pointer pointer;
+	struct wl_keyboard keyboard;
+
+	int keymap_fd;
+	void *keymap_area;
+	size_t keymap_size;
+};
+
+struct shell_surface {
+	struct wl_resource resource;
+	struct weston_surface *surface;
+};
+
+struct remote_surface {
+	struct weston_surface *surface;
+	struct wl_surface *proxy;
+	struct wl_shell_surface *proxy_shell_surface;
+
+	struct shell_surface *shell_surface;
+
+	struct remote *remote;
+	struct wl_buffer *proxy_buffer;
+	struct buffer_hash *buffer;
+	void *map, *zipped;
+	int width, height;
+	int encoded_length;
+
+	uint32_t remote_ping_serial;
+	uint32_t subst_ping_serial;
+
+	struct wl_listener destroy_listener;
+
+	const struct wl_surface_interface *interface;
+	const struct wl_shell_surface_interface *shell_surface_interface;
+
+	struct remote_stream_block stream_block;
+};
+
+static struct remote_seat *
+is_remote_seat(struct wl_resource *resource);
+
+static void
+destroy_remote(struct wl_listener *listener, void *data);
+
+static int
+keymap_tag_handler(struct remote_stream *stream,
+		   size_t remain, void *data)
+{
+	struct remote_seat *seat = data;
+	int len;
+
+	if (stream->len == 0) {
+		seat->keymap_size = stream->total;
+		seat->keymap_fd =
+			os_create_anonymous_file(seat->keymap_size);
+		seat->keymap_area = mmap(NULL, seat->keymap_size,
+					 PROT_READ | PROT_WRITE,
+					 MAP_SHARED,
+					 seat->keymap_fd, 0);
+	}
+
+	len = read(stream->fd, seat->keymap_area + stream->len, remain);
+	if (len < 0)
+		return -1;
+
+	stream->len += len;
+
+	return len;
+}
+
+static int
+stream_data(int fd, uint32_t mask, void *data)
+{
+	struct remote *remote = data;
+	int ret;
+
+	if (mask & (WL_EVENT_HANGUP | WL_EVENT_ERROR)) {
+		fprintf(stderr, "stream_data: hangup\n");
+		destroy_remote(&remote->destroy_listener, NULL);
+		return 1;
+	}
+
+	if (mask & WL_EVENT_WRITABLE) {
+		ret = remote_stream_write(remote->stream);
+		if (ret == 0) {
+			wl_event_source_fd_update(remote->source,
+						  WL_EVENT_READABLE);
+			wl_event_source_fd_update(remote->stream->source,
+						  WL_EVENT_READABLE);
+		} else if (ret == -1 && errno != EAGAIN) {
+			fprintf(stderr, "other error: %m\n");
+		}
+	}
+
+	if (mask & WL_EVENT_READABLE)
+		remote_stream_read(remote->stream);
+
+	return 1;
+}
+ 
+static int
+protocol_data(int fd, uint32_t mask, void *data)
+{
+	struct remote *remote = data;
+	struct remote_stream_block *block;
+	int len, ret;
+
+	if (mask & (WL_EVENT_HANGUP | WL_EVENT_ERROR)) {
+		fprintf(stderr, "stream_data: hup/err in protocol_data\n");
+		return -1;
+	}
+
+	len = read(fd, remote->protocol_buffer,
+		   sizeof remote->protocol_buffer);
+	if (len == -1 && errno == EAGAIN) {
+		return 1;
+	} else if (len == -1) {
+		fprintf(stderr, "read error: %m\n");
+		return -1;
+	}
+
+	block = &remote->protocol_stream_block;
+	wl_list_insert(&remote->stream->block_queue, &block->link);
+	block->tag = 0;
+	block->written = 0;
+	block->size = len;
+	block->data = remote->protocol_buffer;
+
+	ret = remote_stream_write(remote->stream);
+	if (ret == -1 && errno == EAGAIN) {
+		wl_event_source_fd_update(remote->source, 0);
+		wl_event_source_fd_update(remote->stream->source,
+					  WL_EVENT_READABLE |
+					  WL_EVENT_WRITABLE);
+	} else if (ret == -1) {
+		fprintf(stderr, "other error: %m\n");
+	}
+
+	return 1;
+}
+
+static int
+protocol_tag_handler(struct remote_stream *stream, size_t remain, void *data)
+{
+	struct remote *remote = data;
+	char buffer[4096];
+	int len;
+
+	if (remain > sizeof buffer)
+		len = sizeof buffer;
+	else
+		len = remain;
+
+	len = read(stream->fd, buffer, len);
+	stream->len += len;
+	write(remote->protocol_fd[0], buffer, len);
+
+	return 1;
+}
+
+static struct remote_stream *
+remote_stream_connect(struct remote *remote,
+		      const char *hostname, int port)
+{
+	struct wl_event_loop *loop =
+		wl_display_get_event_loop(remote->compositor->wl_display);
+	struct remote_stream *stream;
+	struct sockaddr_in name;
+	struct hostent *hostinfo;
+
+	stream = malloc(sizeof *stream);
+	if (stream == NULL)
+		return NULL;
+
+	memset(stream, 0, sizeof *stream);
+	stream->tag_handler[0].func = protocol_tag_handler;
+	stream->tag_handler[0].data = remote;
+	stream->tag = 1;
+	stream->tag_handler_count = 1;
+	wl_list_init(&stream->block_queue);
+
+	hostinfo = gethostbyname(hostname);
+	if (hostinfo == NULL) {
+		weston_log("Unknown host %s.\n", hostname);
+		free(stream);
+		return NULL;
+	}
+
+	name.sin_family = AF_INET;
+	name.sin_port = htons(port);
+	name.sin_addr = *(struct in_addr *) hostinfo->h_addr;
+
+	stream->fd = socket(PF_INET,
+			    SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0);
+	if (stream->fd < 0) {
+		weston_log("Failed to create socket for remote stream: %m.\n");
+		free(stream);
+		return NULL;
+	}
+	
+	if (connect(stream->fd, (struct sockaddr *) &name, sizeof name) < 0 &&
+	    errno != EINPROGRESS) {
+		weston_log("Could not connect to remote server: %m.\n");
+		return NULL;
+	}
+
+	/* FIXME: Poll socket for writability, check for error with
+	 * getsockopt for SO_ERROR, level SOL_SOCKET. */
+
+	stream->source =
+		wl_event_loop_add_fd(loop, stream->fd,
+				     WL_EVENT_READABLE, stream_data, remote);
+
+	return stream;
+}
+
+static void
+surface_enter(void *data,
+	      struct wl_surface *wl_surface, struct wl_output *wl_output)
+{
+}
+
+static void
+surface_leave(void *data,
+	      struct wl_surface *wl_surface, struct wl_output *output)
+{
+}
+
+static const struct wl_surface_listener surface_listener = {
+	surface_enter,
+	surface_leave
+};
+
+static void
+shell_surface_handle_ping(void *data, struct wl_shell_surface *shell_surface,
+			  uint32_t serial)
+{
+	struct remote_surface *surface = data;
+	struct weston_compositor *compositor = surface->remote->compositor;
+
+	surface->remote_ping_serial = serial;
+	surface->subst_ping_serial =
+		wl_display_get_serial(compositor->wl_display);
+	wl_shell_surface_send_ping(&surface->shell_surface->resource,
+				   surface->subst_ping_serial);
+}
+
+static void
+shell_surface_handle_configure(void *data,
+			       struct wl_shell_surface *shell_surface,
+			       uint32_t edges, int32_t width, int32_t height)
+{
+	struct remote_surface *surface = data;
+
+	wl_shell_surface_send_configure(&surface->shell_surface->resource,
+					edges, width, height);
+}
+
+static void
+shell_surface_handle_popup_done(void *data,
+				struct wl_shell_surface *shell_surface)
+{
+}
+
+static const struct wl_shell_surface_listener shell_surface_listener = {
+	shell_surface_handle_ping,
+	shell_surface_handle_configure,
+	shell_surface_handle_popup_done
+};
+
+static void
+resize_buffer(struct remote_surface *surface)
+{
+	struct remote *remote = surface->remote;
+	struct weston_surface *es = surface->surface;
+	struct wl_buffer *buffer = es->pending.buffer;
+	int stride, size;
+	uint32_t format;
+
+	if (surface->proxy_buffer != NULL &&
+	    buffer != NULL &&
+	    surface->width == buffer->width &&
+	    surface->height == buffer->height)
+		return;
+
+	if (surface->proxy_buffer != NULL)
+		wl_buffer_destroy(surface->proxy_buffer);
+
+	if (buffer == NULL) {
+		wl_surface_attach(surface->proxy, NULL, 0, 0);
+		return;
+	}
+
+	stride = buffer->width * 4;
+	size = stride * buffer->height;
+
+	/* Assume ARGB for now */
+	format = REMOTE_FORMAT_ARGB8888;
+
+	surface->width = buffer->width;
+	surface->height = buffer->height;
+	surface->map = malloc(size);
+
+	surface->zipped = malloc(size);
+
+	surface->proxy_buffer =
+		remote_create_buffer(remote->proxy_remote,
+				     buffer->width, buffer->height, format);
+
+	wl_surface_attach(surface->proxy, surface->proxy_buffer,
+			  es->pending.sx, es->pending.sy);
+}
+
+struct entry {
+	int count;
+	int matches;
+	uint32_t hash;
+	int x, y;
+	int index;
+};
+
+struct buffer_hash {
+	void *data;
+	struct entry *table;
+	int width, height, stride;
+	int block_stride, length, block_count, shift;
+	int stats[5];
+	int clashes;
+};
+
+static const uint32_t prime = 0x1f821e2d;
+static const uint32_t end_prime = 0xf907ec81;	/* prime^size */
+#if 0
+static const uint32_t vprime = 0x0137b89d;
+static const uint32_t end_vprime = 0xaea9a281;	/* vprime^size */
+#else
+static const uint32_t vprime = 0xf907ec81;
+static const uint32_t end_vprime = 0xcdb99001;	/* vprime^size */
+#endif
+static const uint32_t step = 0x0ac93019;
+static const int size = 32, mask = 31;
+
+static int
+verify_match(struct buffer_hash *bh, int x, int y,
+	     struct buffer_hash *prev, struct entry *entry)
+{
+       int i;
+       void *old, *match;
+
+       if (x + size > bh->width || y + size > bh->height)
+               return 0;
+
+       for (i = 0; i < size; i++) {
+	       match = bh->data + (y + i) * bh->stride + x * 4;
+	       old = prev->data + (entry->y + i) * prev->stride + entry->x * 4;
+               if (memcmp(match, old, size * 4) != 0) {
+		       bh->clashes++;
+		       return 0;
+	       }
+       }
+
+       return 1;
+}
+
+static void
+insert_block(struct buffer_hash *bh, uint32_t h, int x, int y)
+{
+	struct entry *entry;
+	int i;
+	uint32_t collision = 0;
+
+	entry = &bh->table[h >> bh->shift];
+	for (i = step; entry->count > 0 && entry->hash != h; i += step) {
+		entry = &bh->table[(h + i) >> bh->shift];
+		collision++;
+	}
+
+	entry->hash = h;
+	entry->count++;
+	entry->x = x;
+	entry->y = y;
+	entry->index = (bh->block_stride * y + x) / size;
+
+	if (collision > ARRAY_LENGTH(bh->stats) - 1)
+		collision = ARRAY_LENGTH(bh->stats) - 1;
+	bh->stats[collision]++;
+}
+
+static struct entry *
+lookup_block(struct buffer_hash *prev, uint32_t h)
+{
+	uint32_t i;
+	struct entry *entry;
+	int shift = prev->shift;
+
+	for (i = h;
+	     entry = &prev->table[i >> shift], entry->count > 0;
+	     i += step)
+		if (entry->hash == h)
+			return entry;
+
+	return NULL;
+}
+
+struct encoder {
+	uint32_t color;
+	uint32_t color_run;
+	uint32_t delta;
+	uint32_t delta_run;
+	void *data;
+	int bytes;
+};
+
+/* Encoding:
+ *
+ *  - all 1 pixel colors are encoded literally
+ *
+ *  - using premultiplied alpha lets us use colors with alpha 0 and
+ *    non-zero color components as special codes:
+ *
+ *     - 0x00 00 00 00 : one alpha 0 pixel
+ *     - 0xaa rr gg bb : one color pixel, alpha > 0
+ *     - 0x00 1x xx xx : delta 0 run, x is length, (20 bits)
+ *     - 0x00 2x xx xx : block ref, block number x (20 bits)
+ *     - 0x00 3x xx xx 0xaarrggbb : solid color run, length x
+ *     - 0x00 4x xx xx 0xaarrggbb : delta run, length x
+ *
+ */
+
+static void
+emit(struct encoder *encoder, uint32_t symbol)
+{
+	*(uint32_t *) (encoder->data + encoder->bytes) = symbol;
+	encoder->bytes += 4;
+}
+
+static void
+encode_pixel(struct encoder *encoder, uint32_t color, uint32_t delta)
+{
+	if ((encoder->color != color &&
+	     encoder->color_run > encoder->delta_run) ||
+
+	    (encoder->delta != delta &&
+	     encoder->delta_run > encoder->color_run) ||
+
+	    (encoder->delta != delta && encoder->color != color)) {
+
+		if (encoder->color_run >= encoder->delta_run) {
+			if (encoder->color_run == 1) {
+				emit(encoder, encoder->color);
+			} else {
+				emit(encoder, 0x00300000 | encoder->color_run);
+				emit(encoder, encoder->color);
+			}
+		} else {
+			if (encoder->delta == 0) {
+				emit(encoder, 0x00100000 | encoder->delta_run);
+			} else {
+				emit(encoder, 0x00400000 | encoder->delta_run);
+				emit(encoder, encoder->delta);
+			}
+		}
+
+		encoder->color_run = 1;
+		encoder->color = color;
+		encoder->delta_run = 1;
+		encoder->delta = delta;
+		return;
+	}
+
+	if (encoder->color == color) {
+		encoder->color_run++;
+	} else {
+		encoder->color_run = 1;
+		encoder->color = color;
+	}
+
+	if (encoder->delta == delta) {
+		encoder->delta_run++;
+	} else {
+		encoder->delta_run = 1;
+		encoder->delta = delta;
+	}
+}
+
+static void
+encode_block(struct encoder *encoder, struct entry *entry, int x, int y)
+{
+	/* 0x00 2x xx xx 0x xxxx yyyy:
+	 *	block ref, block number x (20 bits) at x, y */
+
+	/* FIXME: Maybe don't encode pixels under blocks and just emit
+	 * blocks at their position within the stream. */
+
+	emit(encoder, 0x00200000 | entry->index);
+	emit(encoder, (x << 16) | y);
+}
+
+static void
+destroy_buffer(struct buffer_hash *bh)
+{
+	free(bh->data);
+	free(bh->table);
+	free(bh);
+}
+
+static struct buffer_hash *
+create_buffer(int width, int height)
+{
+	struct buffer_hash *bh;
+
+	bh = malloc(sizeof *bh);
+	bh->width = width;
+	bh->stride = width * 4;
+	bh->height = height;
+
+	bh->block_stride = (width + size - 1) / size;
+	bh->block_count =
+		bh->block_stride * ((height + size - 1) / size);
+	bh->length = 1 << (31 - __builtin_clz(bh->block_count * 4));
+	bh->shift = __builtin_clz(bh->length) + 1;
+
+	bh->table = malloc(bh->length * sizeof bh->table[0]);
+	memset(bh->table, 0, bh->length * sizeof bh->table[0]);
+
+	memset(bh->stats, 0, sizeof bh->stats);
+	bh->clashes = 0;
+
+	bh->data = malloc(bh->stride * height);
+
+	return bh;
+}
+
+static int
+encode_buffer(struct buffer_hash *bh, struct buffer_hash *prev, void *data)
+{
+	struct entry *entry;
+	int i, j, k;
+	int x0, x1, y0, y1;
+	uint32_t *block_hashes;
+	uint32_t hash, bottom_hash, h, *line, *bottom, *prev_line;
+	int width, height;
+	struct encoder encoder;
+	int *skyline, skyline_pixels;
+	int matches;
+
+	width = bh->width;
+	height = bh->height;
+	x0 = 0;
+	x1 = width;
+	y0 = 0;
+	y1 = height;
+
+	skyline = malloc((width + size) * sizeof skyline[0]);
+	memset(skyline, 0, width * sizeof skyline[0]);
+
+	block_hashes = malloc(width * sizeof block_hashes[0]);
+	memset(block_hashes, 0, width * sizeof block_hashes[0]);
+
+	matches = 0;
+	memset(&encoder, 0, sizeof encoder);
+	encoder.data = data;
+
+	for (i = y0; i < y0 + size; i++) {
+		line = bh->data + i * bh->stride;
+		hash = 0;
+		for (j = x0; j < x0 + size; j++)
+			hash = hash * prime + line[j];
+		for (j = x0; j < x1; j++) {
+			block_hashes[j] = block_hashes[j] * vprime + hash;
+			hash = hash * prime - line[j] * end_prime;
+			if (j + size < width)
+				hash += line[j + size];
+		}
+	}
+
+	for (i = y0; i < y1; i++) {
+		bottom = bh->data + (i + size) * bh->stride;
+		line = bh->data + i * bh->stride;
+		bottom_hash = 0;
+		hash = 0;
+		skyline_pixels = 0;
+
+		if (prev)
+			prev_line = prev->data + i * prev->stride; 
+
+		for (j = x0; j < x0 + size; j++) {
+			hash = hash * prime + line[j];
+			if (i + size < height)
+				bottom_hash = bottom_hash * prime + bottom[j];
+			if (i < skyline[j])
+				skyline_pixels = 0;
+			else
+				skyline_pixels++;
+		}
+		
+		for (j = x0; j < x1; j++) {
+			if (i < skyline[j])
+				encode_pixel(&encoder, line[j], 0);
+			else if (prev) {
+				/* FIXME: Add back overlap exception
+				 * for consecutive blocks */
+
+				h = block_hashes[j];
+				entry = lookup_block(prev, h);
+				if (entry && entry->count < 2 &&
+				    skyline_pixels >= size &&
+				    verify_match(bh, j, i, prev, entry) &&
+				    (entry->x != j || entry->y != i)) {
+					matches++;
+					encode_block(&encoder, entry, j, i);
+
+					for (k = 0; k < size; k++)
+						skyline[j + k] = i + size;
+
+					encode_pixel(&encoder, line[j], 0);
+				} else {
+					encode_pixel(&encoder, line[j],
+						     line[j] - prev_line[j]);
+				}
+			} else
+				encode_pixel(&encoder, line[j], line[j]);
+
+			if (i < skyline[j + size])
+				skyline_pixels = 0;
+			else
+				skyline_pixels++;
+
+			/* Insert block in hash table if we're on a
+			 * grid point. */
+			if (((i | j) & mask) == 0 && i + size <= width &&
+			    j + size <= height)
+				insert_block(bh, block_hashes[j], j, i);
+
+			/* Update sliding block hash */
+			block_hashes[j] =
+				block_hashes[j] * vprime + bottom_hash -
+				hash * end_vprime;
+
+			if (i + size < height) {
+				bottom_hash = bottom_hash * prime -
+					bottom[j] * end_prime;
+				if (j + size < width)
+					bottom_hash += bottom[j + size];
+			}
+			hash = hash * prime + line[j + size] -
+				line[j] * end_prime;
+		}
+	}
+
+#if 0
+	fprintf(stderr, "collision stats:");
+	for (i = 0; i < (int) ARRAY_LENGTH(bh->stats); i++)
+		fprintf(stderr, "%c%d", i == 0 ? ' ' : '/', bh->stats[i]);
+	fprintf(stderr, "\n");
+
+	fprintf(stderr, "%d / %d blocks (%d%%) matched, %d clashes\n",
+		matches, bh->block_count,
+		100 * matches / bh->block_count, bh->clashes);
+
+	fprintf(stderr, "output stream %d bytes, raw buffer %d bytes (%d%%)\n",
+		encoder.bytes, height * bh->stride,
+		100 * encoder.bytes / (height * bh->stride));
+#endif
+
+	free(skyline);
+	free(block_hashes);
+
+	return encoder.bytes;
+}
+
+static void
+remote_surface_commit(struct remote_surface *surface)
+{
+	struct remote *remote = surface->remote;
+	struct weston_renderer *renderer;
+	struct wl_region *region;
+	struct buffer_hash *bh;
+	size_t length;
+
+	resize_buffer(surface);
+
+	bh = create_buffer(surface->width, surface->height);
+	renderer = remote->compositor->renderer;
+	renderer->read_surface_pixels(surface->surface,
+				      remote->compositor->read_format,
+				      bh->data,
+				      0, 0, bh->width, bh->height);
+
+	surface->encoded_length =
+		encode_buffer(bh, surface->buffer, surface->map);
+
+	compress2(surface->zipped, &length,
+		  surface->map, surface->encoded_length, 1);
+
+	if (surface->buffer)
+		destroy_buffer(surface->buffer);
+	surface->buffer = bh;
+
+#if 0
+	if (surface->encoded_length > 0)
+		fprintf(stderr, "zip %d -> %zu bytes (%zu%%)\n",
+			surface->encoded_length, length,
+			length * 100 / surface->encoded_length);
+#endif
+
+	if (surface->encoded_length > 0) {
+		remote_stream_queue_block(remote->stream,
+					  &surface->stream_block,
+					  surface->zipped, length);
+		region = wl_compositor_create_region(remote->remote_compositor);
+		wl_region_add(region, 0, 0, surface->width, surface->height);
+		remote_update_buffer(remote->proxy_remote, surface->proxy_buffer,
+				     surface->stream_block.tag, region);
+		wl_region_destroy(region);
+
+		wl_surface_damage(surface->proxy,
+				  0, 0, surface->width, surface->height);
+
+		/* We need to flush the surface data before the
+		 * commit, but we need something more subtle than this
+		 * big, blocking hammer.  We'll need to read the
+		 * protocol data into a buffer and then queue that.
+		 * We also have to make the socketpair non-blocking so
+		 * that we don't end up in protocol_data after this
+		 * with nothing to read. */
+		wl_display_flush(remote->display);
+		protocol_data(remote->protocol_fd[0], WL_EVENT_READABLE, remote);
+
+		while (!wl_list_empty(&remote->stream->block_queue)) {
+			fprintf(stderr, "more flushing\n");
+			remote_stream_write(remote->stream);
+		}
+	}
+
+	wl_surface_commit(surface->proxy);
+}
+
+static void
+remote_surface_destroy(struct wl_listener *listener, void *data)
+{
+	struct remote_surface *surface =
+		container_of(listener,
+			     struct remote_surface, destroy_listener);
+
+	wl_surface_destroy(surface->proxy);
+	if (surface->proxy_shell_surface)
+		wl_shell_surface_destroy(surface->proxy_shell_surface);
+
+	free(surface);
+}
+
+static struct remote_surface *
+get_remote_surface(struct wl_resource *resource)
+{
+	struct wl_listener *listener;
+
+	listener = wl_signal_get(&resource->destroy_signal,
+				 remote_surface_destroy);
+
+	if (listener == NULL)
+		return NULL;
+
+	return container_of(listener, struct remote_surface, destroy_listener);
+}
+
+static void
+surface_handle_destroy(struct wl_client *client, struct wl_resource *resource)
+{
+	struct remote_surface *surface = get_remote_surface(resource);
+
+	surface->interface->destroy(client, resource);
+}
+
+static void
+surface_handle_attach(struct wl_client *client,
+		      struct wl_resource *resource,
+		      struct wl_resource *buffer_resource,
+		      int32_t sx, int32_t sy)
+{
+	struct remote_surface *surface = get_remote_surface(resource);
+
+	surface->interface->attach(client, resource, buffer_resource, sx, sy);
+}
+
+static void
+surface_handle_damage(struct wl_client *client,
+		      struct wl_resource *resource,
+		      int32_t x, int32_t y, int32_t width, int32_t height)
+{
+	struct remote_surface *surface = get_remote_surface(resource);
+
+	surface->interface->damage(client, resource, x, y, width, height);
+}
+
+static void
+surface_handle_frame(struct wl_client *client,
+		     struct wl_resource *resource, uint32_t callback)
+{
+	struct remote_surface *surface = get_remote_surface(resource);
+
+	surface->interface->frame(client, resource, callback);
+}
+
+static struct wl_region *
+get_remote_region(struct remote *remote, pixman_region32_t *region)
+{
+	struct wl_region *remote_region;
+	pixman_box32_t *rectangles;
+	int i, n;
+
+	remote_region = wl_compositor_create_region(remote->remote_compositor);
+	rectangles = pixman_region32_rectangles(region, &n);
+	for (i = 0; i < n; i++)
+		wl_region_add(remote_region,
+			      rectangles[i].x1, rectangles[i].y1,
+			      rectangles[i].x2 - rectangles[i].x1,
+			      rectangles[i].y2 - rectangles[i].y1);
+
+	return remote_region;
+}
+
+static void
+surface_handle_set_opaque_region(struct wl_client *client,
+				 struct wl_resource *resource,
+				 struct wl_resource *region_resource)
+{
+	struct remote_surface *surface = get_remote_surface(resource);
+	struct weston_region *region;
+	struct wl_region *proxy;
+
+	surface->interface->set_opaque_region(client,
+					      resource, region_resource);
+
+	if (region_resource) {
+		region = region_resource->data;
+		proxy = get_remote_region(surface->remote, &region->region);
+		wl_surface_set_opaque_region(surface->proxy, proxy);
+		wl_region_destroy(proxy);
+	} else {
+		wl_surface_set_opaque_region(surface->proxy, NULL);
+	}
+}
+
+static void
+surface_handle_set_input_region(struct wl_client *client,
+				struct wl_resource *resource,
+				struct wl_resource *region_resource)
+{
+	struct remote_surface *surface = get_remote_surface(resource);
+	struct weston_region *region;
+	struct wl_region *proxy;
+
+	surface->interface->set_input_region(client,
+					     resource, region_resource);
+
+	if (region_resource) {
+		region = region_resource->data;
+		proxy = get_remote_region(surface->remote, &region->region);
+		wl_surface_set_input_region(surface->proxy, proxy);
+		wl_region_destroy(proxy);
+	} else {
+		wl_surface_set_input_region(surface->proxy, NULL);
+	}		
+}
+
+static void
+surface_handle_commit(struct wl_client *client,
+		      struct wl_resource *resource)
+{
+	struct remote_surface *surface = get_remote_surface(resource);
+
+	surface->interface->commit(client, resource);
+
+	remote_surface_commit(surface);
+}
+
+static const struct wl_surface_interface surface_interface = {
+	surface_handle_destroy,
+	surface_handle_attach,
+	surface_handle_damage,
+	surface_handle_frame,
+	surface_handle_set_opaque_region,
+	surface_handle_set_input_region,
+	surface_handle_commit
+};
+
+
+static void
+shell_surface_handle_pong(struct wl_client *client,
+			  struct wl_resource *resource, uint32_t serial)
+{
+	struct shell_surface *shell_surface = resource->data;
+	struct remote_surface *surface =
+		get_remote_surface(&shell_surface->surface->surface.resource);
+
+	if (serial == surface->subst_ping_serial)
+		wl_shell_surface_pong(surface->proxy_shell_surface,
+				      surface->remote_ping_serial);
+	else
+		surface->shell_surface_interface->pong(client,
+						       resource, serial);
+}
+
+static void
+shell_surface_handle_move(struct wl_client *client,
+			  struct wl_resource *resource,
+			  struct wl_resource *seat_resource, uint32_t serial)
+{
+	struct remote_seat *seat;
+	struct shell_surface *shell_surface = resource->data;
+	struct remote_surface *surface =
+		get_remote_surface(&shell_surface->surface->surface.resource);
+
+	seat = is_remote_seat(seat_resource);
+	if (seat) {
+		wl_shell_surface_move(surface->proxy_shell_surface,
+				      seat->proxy, serial);
+	} else {
+		surface->shell_surface_interface->move(client, resource,
+						       seat_resource, serial);
+	}
+}
+
+static void
+shell_surface_handle_resize(struct wl_client *client,
+			    struct wl_resource *resource,
+			    struct wl_resource *seat_resource,
+			    uint32_t serial, uint32_t edges)
+{
+	struct remote_seat *seat;
+	struct shell_surface *shell_surface = resource->data;
+	struct remote_surface *surface =
+		get_remote_surface(&shell_surface->surface->surface.resource);
+
+	seat = is_remote_seat(seat_resource);
+	if (seat) {
+		wl_shell_surface_resize(surface->proxy_shell_surface,
+					seat->proxy, serial, edges);
+	} else {
+		surface->shell_surface_interface->resize(client, resource,
+							 seat_resource,
+							 serial, edges);
+	}
+}
+
+static void
+shell_surface_handle_set_toplevel(struct wl_client *client,
+				  struct wl_resource *resource)
+{
+}
+
+static void
+shell_surface_handle_set_transient(struct wl_client *client,
+				   struct wl_resource *resource,
+				   struct wl_resource *parent_resource,
+				   int x, int y, uint32_t flags)
+{
+}
+
+static void
+shell_surface_handle_set_fullscreen(struct wl_client *client,
+				    struct wl_resource *resource,
+				    uint32_t method,
+				    uint32_t framerate,
+				    struct wl_resource *output_resource)
+{
+	/* FIXME: How could this ever work with different size outputs */
+}
+
+static void
+shell_surface_handle_set_popup(struct wl_client *client,
+			       struct wl_resource *resource,
+			       struct wl_resource *seat_resource,
+			       uint32_t serial,
+			       struct wl_resource *parent_resource,
+			       int32_t x, int32_t y, uint32_t flags)
+{
+}
+
+static void
+shell_surface_handle_set_maximized(struct wl_client *client,
+				   struct wl_resource *resource,
+				   struct wl_resource *output_resource)
+{
+}
+
+static void
+shell_surface_handle_set_title(struct wl_client *client,
+			       struct wl_resource *resource, const char *title)
+{
+}
+
+static void
+shell_surface_handle_set_class(struct wl_client *client,
+			       struct wl_resource *resource, const char *class)
+{
+}
+
+static const struct wl_shell_surface_interface shell_surface_implementation = {
+	shell_surface_handle_pong,
+	shell_surface_handle_move,
+	shell_surface_handle_resize,
+	shell_surface_handle_set_toplevel,
+	shell_surface_handle_set_transient,
+	shell_surface_handle_set_fullscreen,
+	shell_surface_handle_set_popup,
+	shell_surface_handle_set_maximized,
+	shell_surface_handle_set_title,
+	shell_surface_handle_set_class
+};
+
+static struct remote_surface *
+remote_surface_create(struct remote *remote, struct weston_surface *surface,
+		      struct shell_surface *shell_surface)
+{
+	struct remote_surface *rs;
+	struct wl_region *proxy;
+
+	weston_log("creating remote surface for %p\n", surface);
+
+	rs = malloc(sizeof *rs);
+	if (rs == NULL)
+		return NULL;
+
+	memset(rs, 0, sizeof *rs);
+	rs->remote = remote;
+	rs->surface = surface;
+	wl_list_init(&rs->stream_block.link);
+	rs->proxy = wl_compositor_create_surface(remote->remote_compositor);
+	wl_surface_add_listener(rs->proxy, &surface_listener, rs);
+
+	rs->destroy_listener.notify = remote_surface_destroy;
+	wl_signal_add(&surface->surface.resource.destroy_signal,
+		      &rs->destroy_listener);
+
+	rs->interface = (const struct wl_surface_interface *)
+		surface->surface.resource.object.implementation;
+	surface->surface.resource.object.implementation =
+		(void *) &surface_interface;
+
+	rs->shell_surface = shell_surface;
+	if (shell_surface) {
+		rs->proxy_shell_surface =
+			wl_shell_get_shell_surface(remote->shell, rs->proxy);
+		wl_shell_surface_add_listener(rs->proxy_shell_surface,
+					      &shell_surface_listener, rs);
+
+		wl_shell_surface_set_toplevel(rs->proxy_shell_surface);
+
+		rs->shell_surface_interface =
+			(const struct wl_shell_surface_interface *)
+			rs->shell_surface->resource.object.implementation;
+		rs->shell_surface->resource.object.implementation =
+			(void *) &shell_surface_implementation;
+	}
+
+	if (surface->buffer_ref.buffer)
+		remote_surface_commit(rs);
+
+	if (pixman_region32_not_empty(&surface->opaque)) {
+		proxy = get_remote_region(remote, &surface->opaque);
+		wl_surface_set_opaque_region(rs->proxy, proxy);
+		wl_region_destroy(proxy);
+	}
+
+	if (pixman_region32_not_empty(&surface->input)) {
+		proxy = get_remote_region(remote, &surface->input);
+		wl_surface_set_input_region(rs->proxy, proxy);
+		wl_region_destroy(proxy);
+	}
+
+	wl_surface_commit(rs->proxy);
+	wl_display_flush(remote->display);
+
+	return rs;
+}
+
+static void
+remote_binding(struct wl_seat *seat, uint32_t time, uint32_t key, void *data)
+{
+	struct remote *remote = data;
+	struct weston_surface *surface;
+
+	if (seat->keyboard->focus == NULL)
+		return;
+
+	/* FIXME: Verify this is a shell surface, handle other surface
+	 * types (eg cursor) */
+
+	surface = (struct weston_surface *) seat->keyboard->focus;
+	remote_surface_create(remote, surface, surface->private);
+
+#if 0
+	wl_list_remove(&surface->layer_link);
+	wl_list_insert(&remote->surface_list, &surface->layer_link);
+#endif
+	weston_surface_schedule_repaint(surface);
+}
+
+static void
+pointer_handle_set_cursor(struct wl_client *client,
+			  struct wl_resource *resource,
+			  uint32_t serial,
+			  struct wl_resource *surface_resource,
+			  int32_t x, int32_t y)
+{
+	struct remote_seat *seat = resource->data;
+	struct weston_surface *surface;
+	struct remote_surface *remote_surface;
+
+	if (surface_resource == NULL) {
+		wl_pointer_set_cursor(seat->proxy_pointer,
+				      seat->enter_serial, NULL, x, y);
+		return;
+	}
+
+	surface = surface_resource->data;
+	remote_surface = get_remote_surface(surface_resource);
+	if (remote_surface == NULL)
+		remote_surface = remote_surface_create(seat->remote,
+						       surface, NULL);
+
+	wl_pointer_set_cursor(seat->proxy_pointer, seat->enter_serial,
+			      remote_surface->proxy, x, y);
+}
+
+static const struct wl_pointer_interface pointer_implementation = {
+	pointer_handle_set_cursor
+};
+
+static void
+pointer_handle_enter(void *data, struct wl_pointer *pointer,
+		     uint32_t serial, struct wl_surface *wl_surface,
+		     wl_fixed_t sx, wl_fixed_t sy)
+{
+	struct remote_seat *seat = data;
+	struct remote_surface *surface = wl_surface_get_user_data(wl_surface);
+
+	wl_pointer_set_focus(&seat->pointer,
+			     &surface->surface->surface, sx, sy);
+}
+
+static void
+pointer_handle_leave(void *data, struct wl_pointer *pointer,
+		     uint32_t serial, struct wl_surface *surface)
+{
+	struct remote_seat *seat = data;
+
+	wl_pointer_set_focus(&seat->pointer, NULL, 0, 0);
+}
+
+static void
+pointer_handle_motion(void *data, struct wl_pointer *pointer,
+		      uint32_t time, wl_fixed_t x, wl_fixed_t y)
+{
+	struct remote_seat *seat = data;
+	struct wl_resource *resource = seat->pointer.focus_resource;
+
+	if (resource)
+		wl_pointer_send_motion(resource, time, x, y);
+}
+
+static void
+pointer_handle_button(void *data, struct wl_pointer *pointer, uint32_t serial,
+		      uint32_t time, uint32_t button, uint32_t state)
+{
+	struct remote_seat *seat = data;
+	struct wl_resource *resource = seat->pointer.focus_resource;
+
+	/* FIXME: translate serials? */
+
+	if (resource)
+		wl_pointer_send_button(resource, serial, time, button, state);
+}
+
+static void
+pointer_handle_axis(void *data, struct wl_pointer *pointer,
+		    uint32_t time, uint32_t axis, wl_fixed_t value)
+{
+	struct remote_seat *seat = data;
+	struct wl_resource *resource = seat->pointer.focus_resource;
+
+	if (resource)
+		wl_pointer_send_axis(resource, time, axis, value);
+}
+
+static const struct wl_pointer_listener pointer_listener = {
+	pointer_handle_enter,
+	pointer_handle_leave,
+	pointer_handle_motion,
+	pointer_handle_button,
+	pointer_handle_axis,
+};
+
+static void
+keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
+		       uint32_t format, int fd, uint32_t size)
+{
+	/* We'll never get this event. */
+}
+
+static void
+keyboard_handle_enter(void *data, struct wl_keyboard *keyboard,
+		      uint32_t serial, struct wl_surface *wl_surface,
+		      struct wl_array *keys)
+{
+	struct remote_seat *seat = data;
+	struct remote_surface *surface = wl_surface_get_user_data(wl_surface);
+
+	wl_keyboard_set_focus(&seat->keyboard,
+			      &surface->surface->surface);
+}
+
+static void
+keyboard_handle_leave(void *data, struct wl_keyboard *keyboard,
+		      uint32_t serial, struct wl_surface *surface)
+{
+	struct remote_seat *seat = data;
+
+	wl_keyboard_set_focus(&seat->keyboard, NULL);
+}
+
+static void
+keyboard_handle_key(void *data, struct wl_keyboard *keyboard,
+		    uint32_t serial, uint32_t time, uint32_t key,
+		    uint32_t state)
+{
+	struct remote_seat *seat = data;
+	struct wl_resource *resource = seat->keyboard.focus_resource;
+
+	if (resource)
+		wl_keyboard_send_key(resource, serial, time, key, state);
+}
+
+static void
+keyboard_handle_modifiers(void *data, struct wl_keyboard *keyboard,
+			  uint32_t serial, uint32_t mods_depressed,
+			  uint32_t mods_latched, uint32_t mods_locked,
+			  uint32_t group)
+{
+	struct remote_seat *seat = data;
+	struct wl_resource *resource = seat->keyboard.focus_resource;
+
+	if (resource)
+		wl_keyboard_send_modifiers(resource, serial, mods_depressed,
+					   mods_latched, mods_locked, group);
+}
+
+static const struct wl_keyboard_listener keyboard_listener = {
+	keyboard_handle_keymap,
+	keyboard_handle_enter,
+	keyboard_handle_leave,
+	keyboard_handle_key,
+	keyboard_handle_modifiers,
+};
+
+static void
+seat_handle_capabilities(void *data, struct wl_seat *wl_seat,
+			 enum wl_seat_capability capabilities)
+{
+	struct remote_seat *seat = data;
+
+	if (capabilities & WL_SEAT_CAPABILITY_POINTER) {
+		seat->proxy_pointer = wl_seat_get_pointer(seat->proxy);
+		wl_pointer_add_listener(seat->proxy_pointer,
+					&pointer_listener, seat);
+
+		wl_pointer_init(&seat->pointer);
+		wl_seat_set_pointer(&seat->seat, &seat->pointer);
+
+	} else {
+		wl_pointer_destroy(seat->proxy_pointer);
+		seat->proxy_pointer = NULL;
+	}
+
+	if (capabilities & WL_SEAT_CAPABILITY_KEYBOARD) {
+		seat->proxy_keyboard = wl_seat_get_keyboard(seat->proxy);
+		wl_keyboard_add_listener(seat->proxy_keyboard,
+					 &keyboard_listener, seat);
+
+		wl_keyboard_init(&seat->keyboard);
+		wl_seat_set_keyboard(&seat->seat, &seat->keyboard);
+	} else {
+		wl_keyboard_destroy(seat->proxy_keyboard);
+		seat->proxy_keyboard = NULL;
+	}
+}
+
+static const struct wl_seat_listener seat_listener = {
+	seat_handle_capabilities,
+};
+
+static void unbind_resource(struct wl_resource *resource)
+{
+	wl_list_remove(&resource->link);
+	free(resource);
+}
+
+static void
+remote_seat_get_pointer(struct wl_client *client,
+			struct wl_resource *resource, uint32_t id)
+{
+	struct remote_seat *seat = resource->data;
+	struct wl_resource *cr;
+
+	if (!seat->proxy_pointer)
+		return;
+
+        cr = wl_client_add_object(client, &wl_pointer_interface,
+				  &pointer_implementation, id, seat);
+	wl_list_insert(&seat->pointer.resource_list, &cr->link);
+	cr->destroy = unbind_resource;
+}
+
+static void
+remote_seat_get_keyboard(struct wl_client *client,
+			 struct wl_resource *resource, uint32_t id)
+{
+	struct remote_seat *seat = resource->data;
+	struct wl_resource *cr;
+
+	if (!seat->proxy_keyboard)
+		return;
+
+        cr = wl_client_add_object(client, &wl_keyboard_interface,
+				  NULL, id, seat);
+	wl_list_insert(&seat->keyboard.resource_list, &cr->link);
+	cr->destroy = unbind_resource;
+
+	wl_keyboard_send_keymap(cr, WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1,
+				seat->keymap_fd,
+				seat->keymap_size);
+
+	if (seat->seat.keyboard->focus &&
+	    seat->seat.keyboard->focus->resource.client == client) {
+		wl_keyboard_set_focus(seat->seat.keyboard,
+				      seat->seat.keyboard->focus);
+	}
+}
+
+static void
+remote_seat_get_touch(struct wl_client *client,
+		      struct wl_resource *resource, uint32_t id)
+{
+}
+
+static const struct wl_seat_interface remote_seat_interface = {
+	remote_seat_get_pointer,
+	remote_seat_get_keyboard,
+	remote_seat_get_touch,
+};
+
+static struct remote_seat *
+is_remote_seat(struct wl_resource *resource)
+{
+	if (resource->object.implementation == (void *) &remote_seat_interface)
+		return resource->data;
+	else
+		return NULL;
+}
+
+static void
+bind_seat(struct wl_client *client, void *data, uint32_t version, uint32_t id)
+{
+	struct remote_seat *seat = data;
+	struct wl_resource *resource;
+	enum wl_seat_capability caps = 0;
+
+	resource = wl_client_add_object(client, &wl_seat_interface,
+					&remote_seat_interface, id, seat);
+	wl_list_insert(&seat->seat.base_resource_list, &resource->link);
+	resource->destroy = unbind_resource;
+
+	if (seat->proxy_pointer)
+		caps |= WL_SEAT_CAPABILITY_POINTER;
+	if (seat->proxy_keyboard)
+		caps |= WL_SEAT_CAPABILITY_KEYBOARD;
+
+	wl_seat_send_capabilities(resource, caps);
+}
+
+static void
+remote_add_seat(struct remote *remote, uint32_t id)
+{
+	struct remote_seat *seat;
+
+	seat = malloc(sizeof *seat);
+	if (seat == NULL)
+		return;
+
+	memset(seat, 0, sizeof *seat);
+
+	seat->remote = remote;
+	seat->proxy = wl_registry_bind(remote->registry, id,
+				       &wl_seat_interface, 1);
+	wl_seat_add_listener(seat->proxy, &seat_listener, seat);
+
+	wl_seat_init(&seat->seat);
+	wl_display_add_global(seat->remote->compositor->wl_display,
+			      &wl_seat_interface, seat, bind_seat);
+}
+
+static void
+output_handle_geometry(void *data,
+		       struct wl_output *wl_output,
+		       int32_t x, int32_t y,
+		       int32_t physical_width,
+		       int32_t physical_height,
+		       int subpixel,
+		       const char *make,
+		       const char *model,
+		       int transform)
+{
+	struct remote_output *output = data;
+
+	/* Discard x and y. */
+	output->output.make = strdup(make);
+	output->output.model = strdup(model);
+	output->output.mm_width = physical_width;
+	output->output.mm_height = physical_height;
+	output->output.subpixel = subpixel;
+	output->output.transform = transform;
+	wl_list_init(&output->output.mode_list);
+}
+
+struct remote_mode {
+	struct weston_mode base;
+};
+
+static void
+output_handle_mode(void *data,
+		   struct wl_output *wl_output,
+		   uint32_t flags,
+		   int width,
+		   int height,
+		   int refresh)
+{
+	struct remote_output *output = data;
+	struct remote_mode *mode;
+
+	mode = malloc(sizeof *mode);
+
+	mode->base.flags = flags;
+	mode->base.width = width;
+	mode->base.height = height;
+	mode->base.refresh = refresh;
+
+	if (flags & WL_OUTPUT_MODE_CURRENT)
+		output->output.current = &mode->base;
+
+	wl_list_insert(output->output.mode_list.prev, &mode->base.link);
+}
+
+static const struct wl_output_listener output_listener = {
+	output_handle_geometry,
+	output_handle_mode
+};
+
+static void
+output_callback_done(void *data, struct wl_callback *callback, uint32_t time)
+{
+	struct remote_output *output = data;
+	int x = 0, y = 0, width = 800, height = 600;
+
+	wl_callback_destroy(callback);
+	weston_output_init(&output->output, output->remote->compositor,
+			   x, y, width, height, WL_OUTPUT_TRANSFORM_NORMAL);
+}
+
+static const struct wl_callback_listener output_callback_listener = {
+	output_callback_done
+};
+
+static void
+remote_output_destroy(struct weston_output *output)
+{
+	free(output->make);
+	free(output->model);
+	weston_output_destroy(output);
+	wl_list_remove(&output->link);
+}
+
+static void
+remote_output_repaint(struct weston_output *output_base,
+		      pixman_region32_t *damage)
+{
+}
+
+static void
+remote_add_output(struct remote *remote, uint32_t id)
+{
+	struct remote_output *output;
+	struct wl_callback *callback;
+
+	output = malloc(sizeof *output);
+	if (output == NULL)
+		return;
+
+	memset(output, 0, sizeof *output);
+	output->remote = remote;
+	output->proxy = wl_registry_bind(remote->registry, id,
+					 &wl_output_interface, 1);
+
+	output->output.destroy = remote_output_destroy;
+	output->output.repaint = remote_output_repaint;
+
+	wl_output_add_listener(output->proxy, &output_listener, output);
+
+	callback = wl_display_sync(remote->display);
+	wl_callback_add_listener(callback, &output_callback_listener, output);
+}
+
+static void
+remote_handle_keymap(void *data, struct remote *proxy,
+		     struct wl_keyboard *keyboard, uint32_t format,
+		     uint32_t tag, uint32_t size)
+{
+	struct remote *remote = data;
+	struct remote_seat *seat = wl_keyboard_get_user_data(keyboard);
+
+	remote_stream_handle_tag(remote->stream, tag,
+				 keymap_tag_handler, seat);
+}
+
+static const struct remote_listener remote_listener = {
+	remote_handle_keymap
+};
+
+static void
+registry_handle_global(void *data, struct wl_registry *registry, uint32_t name,
+		       const char *interface, uint32_t version)
+{
+	struct remote *remote = data;
+
+	if (strcmp(interface, "wl_compositor") == 0) {
+		remote->remote_compositor =
+			wl_registry_bind(registry, name,
+					 &wl_compositor_interface, 1);
+	} else if (strcmp(interface, "wl_output") == 0) {
+		remote_add_output(remote, name);
+	} else if (strcmp(interface, "wl_seat") == 0) {
+		remote_add_seat(remote, name);
+	} else if (strcmp(interface, "wl_shell") == 0) {
+		remote->shell = wl_registry_bind(registry, name,
+						 &wl_shell_interface, 1);
+	} else if (strcmp(interface, "remote") == 0) {
+		remote->proxy_remote =
+			wl_registry_bind(registry, name, &remote_interface, 1);
+		remote_add_listener(remote->proxy_remote,
+				    &remote_listener, remote);
+	}
+}
+
+static const struct wl_registry_listener registry_listener = {
+	registry_handle_global
+};
+
+static void
+destroy_remote(struct wl_listener *listener, void *data)
+{
+	struct remote *remote =
+		container_of(listener, struct remote, destroy_listener);
+
+	/* FIXME: More clean up needed, unhook all forwarded surfaces,
+	 * for example. */
+
+	wl_registry_destroy(remote->registry);
+	wl_event_source_remove(remote->stream->source);
+	close(remote->stream->fd);
+	wl_event_source_remove(remote->source);
+	wl_event_source_remove(remote->protocol_source);
+	close(remote->protocol_fd[0]);
+	wl_display_disconnect(remote->display);
+	wl_list_remove(&remote->destroy_listener.link);
+	free(remote);
+}
+
+static int
+remote_handle_event(int fd, uint32_t mask, void *data)
+{
+	struct remote *remote = data;
+	int count = 0;
+
+	if (mask & (WL_EVENT_HANGUP | WL_EVENT_ERROR)) {
+		destroy_remote(&remote->destroy_listener, NULL);
+		return 0;
+	}
+
+	if (mask & WL_EVENT_READABLE)
+		count = wl_display_dispatch(remote->display);
+	if (mask & WL_EVENT_WRITABLE)
+		wl_display_flush(remote->display);
+
+	if (mask == 0) {
+		count = wl_display_dispatch_pending(remote->display);
+		wl_display_flush(remote->display);
+	}
+
+	return count;
+}
+
+WL_EXPORT int
+module_init(struct weston_compositor *compositor)
+{
+	struct remote *remote;
+	struct wl_event_loop *loop =
+		wl_display_get_event_loop(compositor->wl_display);
+	int port = 44888;
+	static const char *host;
+
+	host = getenv("WESTON_REMOTE_HOST");
+	if (host == NULL)
+		host = "localhost";
+
+	remote = malloc(sizeof *remote);
+	if (remote == NULL)
+		return -1;
+
+	memset(remote, 0, sizeof *remote);
+	remote->compositor = compositor;
+	remote->stream = remote_stream_connect(remote, host, port);
+	if (remote->stream == NULL)
+ 		return -1;
+
+	if (os_socketpair_cloexec(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK, 0,
+				  remote->protocol_fd) < 0)
+		return -1;
+
+	remote->protocol_source =
+		wl_event_loop_add_fd(loop, remote->protocol_fd[0],
+				     WL_EVENT_READABLE,
+				     protocol_data, remote);
+
+	remote->display =
+		wl_display_connect_to_fd(remote->protocol_fd[1]);
+
+	if (remote->display == NULL) {
+		weston_log("failed to connect to remote display on %s:%d\n",
+			   host, port);
+		free(remote);
+		return -1;
+	}
+
+	remote->source = wl_event_loop_add_fd(loop, remote->protocol_fd[1],
+					      WL_EVENT_READABLE,
+					      remote_handle_event, remote);
+	if (remote->source == NULL) {
+		wl_display_disconnect(remote->display);
+		free(remote);
+		return -1;
+	}
+
+	wl_event_source_check(remote->source);
+
+	remote->registry = wl_display_get_registry(remote->display);
+	wl_registry_add_listener(remote->registry, &registry_listener, remote);
+
+	weston_compositor_add_key_binding(compositor, KEY_F, MODIFIER_SUPER,
+					  remote_binding, remote);
+
+	wl_list_init(&remote->surface_list);
+	remote->destroy_listener.notify = destroy_remote;
+	wl_signal_add(&compositor->destroy_signal, &remote->destroy_listener);
+
+	weston_log("connected to remote host %s:%d\n", host, port);
+
+	wl_display_flush(remote->display);
+
+	return 0;
+}
diff --git a/src/remote-server.c b/src/remote-server.c
new file mode 100644
index 0000000..8b76a93
--- /dev/null
+++ b/src/remote-server.c
@@ -0,0 +1,568 @@
+/*
+ * Copyright © 2012 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of the copyright holders not be used in
+ * advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  The copyright holders make
+ * no representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#define _GNU_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <sys/uio.h>
+#include <assert.h>
+#include <string.h>
+#include <unistd.h>
+#include <zlib.h>
+
+#include "compositor.h"
+#include "../shared/os-compatibility.h"
+
+#include "remote-stream.h"
+#include "remote-server-protocol.h"
+
+
+struct remote_server {
+	struct weston_compositor *compositor;
+	int sock;
+	struct wl_event_source *sock_source;
+	struct wl_global *global;
+};
+
+struct remote_client {
+	struct remote_server *server;
+	int protocol_fd[2];
+	struct wl_event_source *protocol_source;
+	struct wl_client *client;
+	struct wl_listener destroy_listener;
+	struct wl_resource *remote_resource;
+
+	struct remote_stream *stream; 
+	struct remote_stream_block protocol_stream_block;
+	struct remote_stream_block keymap_stream_block;
+};
+
+struct remote_buffer
+{
+	struct wl_buffer *buffer;
+	struct wl_listener destroy_listener;
+	void *encoded_buffer;
+	void *copy;
+};
+
+static void
+decode_buffer(struct remote_buffer *b, int length)
+{
+	uint32_t *p, *end, *d;
+	int i, l, x, y, w, h;
+	int32_t width, height, stride, block_stride;
+	uint32_t *copy;
+	char *src, *dest;
+	div_t qr;
+
+	void *unzipped;
+	size_t uncompressed_length;
+
+	const int size = 32;
+
+	d = wl_shm_buffer_get_data(b->buffer);
+
+	width = wl_shm_buffer_get_width(b->buffer);
+	height = wl_shm_buffer_get_height(b->buffer);
+	stride = wl_shm_buffer_get_stride(b->buffer);
+	block_stride = (width + size - 1) / size;
+	copy = malloc(stride * height);
+	memcpy(copy, d, stride * height);
+
+	unzipped = malloc(height * stride);
+	uncompress(unzipped, &uncompressed_length, b->encoded_buffer, length);
+
+	p = unzipped;
+	end = unzipped + uncompressed_length;
+	while (p < end) {
+		l = *p & 0x000fffff;
+		switch (*p >> 20) {
+		case 0x001:
+			/* delta 0 run */
+			d += l;
+			break;
+		case 0x002:
+			/* block ref */
+			qr = div(l, block_stride);
+
+			x = qr.rem * 32;
+			y = qr.quot * 32;
+
+			w = size;
+			h = size;
+
+			if (x + w > width)
+				w = width - x;
+			if (y + h > height)
+				h = height - y;
+
+			src = (char *) copy + y * stride + x * 4;
+
+			p++;
+			x = *p >> 16;
+			y = *p & 0xffff;
+
+			if (x + w > width)
+				w = width - x;
+			if (y + h > height)
+				h = height - y;
+
+			dest = (char *)
+				wl_shm_buffer_get_data(b->buffer) +
+				y * stride + x * 4;
+
+			for (i = 0; i < h; i++)
+				memcpy(dest + i * stride,
+				       src + i * stride, w * 4);
+			break;
+		case 0x003:
+			/* solid color run */
+			p++;
+			for (i = 0; i < l; i++)
+				*d++ = *p;
+			break;
+		case 0x004:
+			/* delta run */
+			p++;
+			for (i = 0; i < l; i++)
+				*d++ += *p;
+			break;
+		default:
+			/* regular pixel */
+			*d++ = *p;
+			break;
+		}
+		p++;
+	}
+
+	free(copy);
+	free(unzipped);
+}
+
+static int
+buffer_data_tag_handler(struct remote_stream *stream,
+			size_t remain, void *data)
+{
+	struct remote_buffer *b = data;
+	int len;
+
+	len = read(stream->fd, b->encoded_buffer + stream->len, remain);
+	if (len < 0) {
+		weston_log("buffer data read failed: %m\n");
+		return -1;
+	}
+	stream->len += len;
+
+	if (stream->len == stream->total)
+		decode_buffer(b, stream->total);
+
+	return len;
+}
+
+static int
+stream_handle_event(int fd, uint32_t mask, void *data)
+{
+	struct remote_client *client = data;
+
+	if (mask & (WL_EVENT_HANGUP | WL_EVENT_ERROR)) {
+		fprintf(stderr, "stream_handle_event: hangup\n");
+		wl_client_destroy(client->client);
+		return 1;
+	}
+
+	remote_stream_read(client->stream);
+
+	return 1;
+}
+
+static int
+protocol_handle_event(int fd, uint32_t mask, void *data)
+{
+	struct remote_client *client = data;
+	struct remote_stream_block *block;
+	char buffer[4096];
+	int len, ret;
+
+	if (mask & (WL_EVENT_HANGUP | WL_EVENT_ERROR))
+		fprintf(stderr, "protocol_handle_event: hangup\n");
+
+	len = read(fd, buffer, sizeof buffer);
+
+	block = &client->protocol_stream_block;
+	wl_list_insert(&client->stream->block_queue, &block->link);
+	block->tag = 0;
+	block->written = 0;
+	block->size = len;
+	block->data = buffer;
+
+	ret = remote_stream_write(client->stream);
+	if (ret == -1)
+		fprintf(stderr, "remote_stream_write(): %m\n");
+
+	return 1;
+}
+
+static int
+protocol_tag_handler(struct remote_stream *stream, size_t remain, void *data)
+{
+	struct remote_client *client = data;
+	char buffer[4096];
+	int len;
+
+	if (remain > sizeof buffer)
+		len = sizeof buffer;
+	else
+		len = remain;
+
+	len = read(stream->fd, buffer, len);
+	if (len < 0)
+		return -1;
+	stream->len += len;
+	write(client->protocol_fd[0], buffer, len);
+
+	return len;
+}
+
+static struct remote_stream *
+remote_stream_accept(struct remote_server *server,
+		     struct remote_client *client)
+{
+	struct weston_compositor *compositor = server->compositor;
+	struct wl_event_loop *loop =
+		wl_display_get_event_loop(compositor->wl_display);
+	struct remote_stream *stream;
+	struct sockaddr_in name;
+	socklen_t length;
+	int fd;
+
+	length = sizeof name;
+	fd = accept4(server->sock,
+		     (struct sockaddr *) &name, &length, SOCK_CLOEXEC);
+	if (fd < 0) {
+		weston_log("failed to accept: %m\n");
+		return NULL;
+	}
+
+	stream = malloc(sizeof *stream);
+	if (stream == NULL)
+		return NULL;
+
+	memset(stream, 0, sizeof *stream);
+	stream->tag_handler[0].func = protocol_tag_handler;
+	stream->tag_handler[0].data = client;
+	stream->tag = 1;
+	stream->tag_handler_count = 1;
+	stream->fd = fd;
+	wl_list_init(&stream->block_queue);
+
+	stream->source =
+		wl_event_loop_add_fd(loop, stream->fd, WL_EVENT_READABLE,
+				     stream_handle_event, client);
+	if (stream->source == NULL) {
+		weston_log("failed to create remote client: %m\n");
+		close(fd);
+		free(stream);
+		return NULL;
+	}
+
+	return stream;
+}
+
+static void
+remote_stream_destroy(struct remote_stream *stream)
+{
+	wl_event_source_remove(stream->source);
+	close(stream->fd);
+	free(stream);
+}
+
+static void
+remote_client_destroy(struct wl_listener *listener, void *data)
+{
+	struct remote_client *client =
+		container_of(listener, struct remote_client, destroy_listener);
+
+	/* FIXME: Clean up objects */
+
+	remote_stream_destroy(client->stream);
+
+	wl_event_source_remove(client->protocol_source);
+	close(client->protocol_fd[0]);
+	close(client->protocol_fd[1]);
+
+	free(client);
+}
+
+static int
+sock_handle_event(int fd, uint32_t mask, void *data)
+{
+	struct remote_server *server = data;
+	struct weston_compositor *compositor = server->compositor;
+	struct remote_client *client;
+	struct wl_event_loop *loop =
+		wl_display_get_event_loop(compositor->wl_display);
+
+	client = malloc(sizeof *client);
+	if (client == NULL) {
+		weston_log("failed to create remote-server client: %m\n");
+		return 1;
+	}
+
+	memset(client, 0, sizeof *client);
+	client->server = server;
+	client->stream = remote_stream_accept(server, client);
+	if (client->stream == NULL) {
+		free(client);
+		return 1;
+	}
+
+	if (os_socketpair_cloexec(AF_UNIX, SOCK_STREAM, 0,
+				  client->protocol_fd) < 0) {
+		weston_log("failed to create socketpair: %m\n");
+		return 1;
+	}
+
+	client->protocol_source =
+		wl_event_loop_add_fd(loop, client->protocol_fd[0],
+				     WL_EVENT_READABLE,
+				     protocol_handle_event, client);
+	if (client->protocol_source == NULL) {
+		weston_log("failed to create remote client source: %m\n");
+		free(client);
+		return 1;
+	}
+
+	client->client = wl_client_create(compositor->wl_display,
+					  client->protocol_fd[1]);
+
+	client->destroy_listener.notify = remote_client_destroy;
+	wl_client_add_destroy_listener(client->client,
+				       &client->destroy_listener);
+
+	weston_log("remote client connected (%p)\n", client->client);
+
+	return 1;
+}
+
+static int
+remote_try_send_keymap(struct wl_client *client,
+		       struct weston_seat *seat, struct wl_resource *cr)
+{
+	struct wl_listener *listener;
+	struct remote_client *rc;
+
+	listener = wl_client_get_destroy_listener(client,
+						  remote_client_destroy);
+	if (listener == NULL)
+		return -1;
+
+	rc = container_of(listener, struct remote_client, destroy_listener);
+
+	remote_stream_queue_block(rc->stream, &rc->keymap_stream_block,
+				  seat->xkb_info.keymap_area,
+				  seat->xkb_info.keymap_size);
+	remote_send_keymap(rc->remote_resource, cr, 
+			   WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1,
+			   rc->keymap_stream_block.tag,
+			   seat->xkb_info.keymap_size);
+
+	return 0;
+}
+
+static int
+make_socket(uint16_t port)
+{
+	int sock, one = 1;
+	struct sockaddr_in name;
+
+	sock = socket(PF_INET, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK, 0);
+	if (sock < 0) {
+		weston_log("failed to create remote-server socket: %m\n");
+		return -1;
+	}
+
+	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &one, sizeof one);
+
+	name.sin_family = AF_INET;
+	name.sin_port = htons(port);
+	name.sin_addr.s_addr = htonl(INADDR_ANY);
+	if (bind(sock, (struct sockaddr *) &name, sizeof name) < 0) {
+		weston_log("failed to bind remote-server socket: %m\n");
+		close(sock);
+		return -1;
+	}
+
+	if (listen(sock, 1) < 0) {
+		weston_log("failed to listen on remote-server socket: %m\n");
+		close(sock);
+		return -1;
+	}
+
+	return sock;
+}
+
+static void
+remote_buffer_destroy(struct wl_listener *listener, void *data)
+{
+	struct remote_buffer *rb =
+		container_of(listener, struct remote_buffer, destroy_listener);
+
+	free(rb->copy);
+	free(rb->encoded_buffer);
+	free(rb);
+}
+
+static void
+remote_handle_create_buffer(struct wl_client *client,
+			    struct wl_resource *resource, uint32_t id,
+			    int32_t width, int32_t height, uint32_t format)
+{
+	struct remote_buffer *rb;
+
+	switch (format) {
+	case REMOTE_FORMAT_ARGB8888:
+	case REMOTE_FORMAT_XRGB8888:
+		break;
+	default:
+		wl_resource_post_error(resource,
+				       WL_SHM_ERROR_INVALID_FORMAT,
+				       "invalid format");
+		return;
+	}
+
+	/* FIXME: check integer overflow */
+	if (width <= 0 || height <= 0) {
+		wl_resource_post_error(resource,
+				       WL_SHM_ERROR_INVALID_STRIDE,
+				       "invalid width, height or stride (%dx%d)",
+				       width, height);
+		return;
+	}
+
+	/* FIXME: This is going to send spurious buffer.release events
+	 * to the remote side... or is it just right? */
+
+	rb = malloc(sizeof *rb);
+	rb->buffer = wl_shm_buffer_create(client, id,
+					  width, height, width * 4, format);
+	rb->copy = malloc(width * height * 4);
+	rb->destroy_listener.notify = remote_buffer_destroy;
+	wl_signal_add(&rb->buffer->resource.destroy_signal,
+		      &rb->destroy_listener);
+	rb->encoded_buffer = malloc(2 * 1024 * 1024);
+}
+
+static void
+remote_handle_update_buffer(struct wl_client *client,
+			    struct wl_resource *resource,
+			    struct wl_resource *buffer_resource,
+			    uint32_t tag,
+			    struct wl_resource *region)
+{
+	struct wl_listener *listener;
+	struct remote_client *rc;
+	struct remote_buffer *rb;
+
+	listener = wl_client_get_destroy_listener(client,
+						  remote_client_destroy);
+	rc = container_of(listener, struct remote_client, destroy_listener);
+
+	listener = wl_signal_get(&buffer_resource->destroy_signal,
+				 remote_buffer_destroy);
+	rb = container_of(listener, struct remote_buffer, destroy_listener);
+
+	remote_stream_handle_tag(rc->stream, tag,
+				 buffer_data_tag_handler, rb);
+}
+
+static const struct remote_interface remote_implementation = {
+	remote_handle_create_buffer,
+	remote_handle_update_buffer
+};
+
+static void
+bind_remote(struct wl_client *client,
+	    void *data, uint32_t version, uint32_t id)
+{
+	struct remove_server *server = data;
+	struct wl_listener *listener;
+	struct remote_client *rc;
+
+	/* Reject non-remote clients.  This interface only makes sense
+	 * for remote clients that can refer to out-of-band objects. */
+	listener = wl_client_get_destroy_listener(client,
+						  remote_client_destroy);
+	if (!listener)
+		return;
+
+	rc = container_of(listener, struct remote_client, destroy_listener);
+	rc->remote_resource =
+		wl_client_add_object(client, &remote_interface,
+				     &remote_implementation, id, server);
+}
+
+int
+module_init(struct weston_compositor *compositor);
+
+WL_EXPORT int
+module_init(struct weston_compositor *compositor)
+{
+	struct remote_server *server;
+	struct wl_event_loop *loop =
+		wl_display_get_event_loop(compositor->wl_display);
+	int port = 44888;
+
+	server = malloc(sizeof *server);
+	if (server == NULL)
+		return -1;
+
+	server->compositor = compositor;
+	server->sock = make_socket(port);
+	if (server->sock < 0) {
+		free(server);
+		return -1;
+	}
+
+	server->sock_source =
+		wl_event_loop_add_fd(loop, server->sock, WL_EVENT_READABLE,
+				     sock_handle_event, server);
+	if (server->sock_source == NULL) {
+		weston_log("failed to set up remote-server socket source\n");
+		free(server);
+		return -1;
+	}
+
+	server->global = wl_display_add_global(compositor->wl_display,
+					       &remote_interface,
+					       server, bind_remote);
+
+
+	compositor->try_send_keymap = remote_try_send_keymap;
+
+	weston_log("remote server listening on port %d\n", port);
+
+	return 0;
+}
diff --git a/src/remote-stream.c b/src/remote-stream.c
new file mode 100644
index 0000000..69fd568
--- /dev/null
+++ b/src/remote-stream.c
@@ -0,0 +1,143 @@
+/*
+ * Copyright © 2012 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of the copyright holders not be used in
+ * advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  The copyright holders make
+ * no representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <assert.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <sys/uio.h>
+
+#include "compositor.h"
+#include "remote-stream.h"
+
+int
+remote_stream_write(struct remote_stream *stream)
+{
+	struct remote_stream_block *block, *next;
+	uint32_t header;
+	struct iovec iov[2];
+	int len;
+
+	wl_list_for_each_safe(block, next, &stream->block_queue, link) {
+		/* FIXME: Coalesce all this into one writev? */
+		if (block->written == 0) {
+			header = (block->tag << 24) | block->size;
+			iov[0].iov_base = &header;
+			iov[0].iov_len = sizeof header;
+			iov[1].iov_base = block->data;
+			iov[1].iov_len = block->size;
+
+			/* FIXME: async write this... */
+			len = writev(stream->fd, iov, 2);
+			if (len == -1)
+				return len;
+
+			assert(len >= (int) sizeof header);
+			len -= sizeof header;
+		} else {
+			len = write(stream->fd, block->data + block->written,
+				    block->size - block->written);
+		}
+
+		if (len < 0) {
+			weston_log("write error: %m\n");
+			return -1;
+		}
+
+		block->written += len;
+
+		if (block->written < block->size) {
+			/* FIXME: handle EAGAIN in the caller */
+			weston_log("partial write: %m\n");
+			return -1;
+		}
+
+		wl_list_remove(&block->link);
+		block->tag = 0;
+ 	}
+ 
+	stream->tag = 1;
+
+	return 0;
+}
+
+int
+remote_stream_read(struct remote_stream *stream)
+{
+	size_t remain;
+	uint32_t tag;
+
+	if (stream->handler == NULL) {
+		if (stream->header == 0)
+			/* FIXME: Check this read... */
+			read(stream->fd,
+			     &stream->header, sizeof stream->header);
+		tag = stream->header >> 24;
+		if (tag == 0)
+			stream->tag_handler_count = 1;
+		if (tag >= stream->tag_handler_count)
+			/* If there's no handler for this tag yet,
+			 * return to the main loop to process protocol
+			 * events first. */
+			return 1;
+
+		stream->len = 0;
+		stream->total = stream->header & 0xffffff;
+		stream->handler = &stream->tag_handler[tag];
+		stream->header = 0;
+	} else {
+		remain = stream->total - stream->len;
+		stream->handler->func(stream, remain, stream->handler->data);
+		if (stream->len == stream->total)
+			stream->handler = NULL;
+	}
+
+	return 1;
+}
+
+void
+remote_stream_handle_tag(struct remote_stream *stream, uint32_t tag,
+			 remote_stream_handler_func_t func, void *data)
+{
+	/* FIXME: Bad assert */
+	assert(tag < ARRAY_LENGTH(stream->tag_handler));
+
+	if (tag != stream->tag_handler_count)
+		assert("tags out of sync");
+	stream->tag_handler[tag].func = func;
+	stream->tag_handler[tag].data = data;
+	stream->tag_handler_count++;
+}
+
+void
+remote_stream_queue_block(struct remote_stream *stream,
+			  struct remote_stream_block *block,
+			  void *data, size_t size)
+{
+	if (block->tag > 0)
+		return;
+
+	wl_list_insert(stream->block_queue.prev, &block->link);
+	block->tag = stream->tag++;
+	block->written = 0;
+	block->data = data;
+	block->size = size;
+}
diff --git a/src/remote-stream.h b/src/remote-stream.h
new file mode 100644
index 0000000..438c4a4
--- /dev/null
+++ b/src/remote-stream.h
@@ -0,0 +1,48 @@
+#include <stdlib.h>
+#include <stdint.h>
+
+#include <wayland-util.h>
+
+struct remote_stream;
+
+typedef int (*remote_stream_handler_func_t)(struct remote_stream *stream,
+					    size_t remain, void *data);
+
+struct remote_stream_handler {
+	remote_stream_handler_func_t func;
+	void *data;
+};
+
+struct remote_stream {
+	uint32_t tag, header;
+	int len, total;
+	int fd, protocol_fd;
+	uint32_t tag_handler_count;
+	struct remote_stream_handler tag_handler[10];
+	struct remote_stream_handler *handler;
+	struct wl_event_source *source;
+	struct wl_list block_queue;
+};
+
+struct remote_stream_block {
+	struct wl_list link;
+	void *data;
+	size_t size;
+	size_t written;
+	uint32_t tag;
+};
+
+int
+remote_stream_write(struct remote_stream *stream);
+
+int
+remote_stream_read(struct remote_stream *stream);
+
+void
+remote_stream_handle_tag(struct remote_stream *stream, uint32_t tag,
+			 remote_stream_handler_func_t func, void *data);
+
+void
+remote_stream_queue_block(struct remote_stream *stream,
+			  struct remote_stream_block *block,
+			  void *data, size_t size);
