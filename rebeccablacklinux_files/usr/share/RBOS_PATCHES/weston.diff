diff --git a/src/weston-launch.c b/src/weston-launch.c
index 36f9c6b..7238128 100644
--- a/src/weston-launch.c
+++ b/src/weston-launch.c
@@ -109,7 +109,7 @@ weston_launch_allowed(struct weston_launch *wl)
 	if (getuid() == 0)
 		return 1;
 
-	gr = getgrnam("weston-launch");
+	gr = getgrnam("plugdev");
 	if (gr) {
 		groups = read_groups();
 		if (groups) {
@@ -550,7 +550,7 @@ main(int argc, char *argv[])
 #else
 		      " - enable systemd session support for weston-launch.\n"
 #endif
-		      " - or add yourself to the 'weston-launch' group.");
+		      " - or add yourself to the 'plugdev' group.");
 
 	if (setup_tty(&wl, tty) < 0)
 		return 1;







diff --git a/clients/desktop-shell.c b/clients/desktop-shell.c
index 1cae789..f52a4f9 100644
--- a/clients/desktop-shell.c
+++ b/clients/desktop-shell.c
@@ -36,6 +36,7 @@
 #include <libgen.h>
 #include <ctype.h>
 #include <time.h>
+#include <stdbool.h>
 
 #include <wayland-client.h>
 #include "window.h"
@@ -44,6 +45,8 @@
 
 #include "desktop-shell-client-protocol.h"
 
+#define MIN(x, y) (((x) < (y)) ? (x) : (y))
+
 extern char **environ; /* defined by libc */
 
 struct desktop {
@@ -51,37 +54,62 @@ struct desktop {
 	struct desktop_shell *shell;
 	struct unlock_dialog *unlock_dialog;
 	struct task unlock_task;
+	struct wl_list surfaces;
 	struct wl_list outputs;
+	uint32_t output_count;
 
 	struct window *grab_window;
 	struct widget *grab_widget;
 
 	enum cursor_type grab_cursor;
+
+	struct surface_data_manager *surface_data_manager;
 };
 
 struct surface {
+	struct desktop *desktop;
+	struct surface_data *surface_data;
+	struct wl_list item_list;
+	uint32_t output_mask;
+	char *title;
+	bool maximized, minimized;
+	bool focused;
+
+	struct wl_list link;
+};
+
+struct resize {
 	void (*configure)(void *data,
 			  struct desktop_shell *desktop_shell,
 			  uint32_t edges, struct window *window,
 			  int32_t width, int32_t height);
 };
 
+struct rgba {
+	float r, g, b, a;
+};
+
 struct panel {
-	struct surface base;
+	struct resize base;
 	struct window *window;
 	struct widget *widget;
 	struct wl_list launcher_list;
+	struct wl_list window_list;
+	struct rectangle window_list_rect;
+	uint32_t surface_count;
+	struct rgba focused_item;
 	struct panel_clock *clock;
 };
 
 struct background {
-	struct surface base;
+	struct resize base;
 	struct window *window;
 	struct widget *widget;
 };
 
 struct output {
 	struct wl_output *output;
+	uint32_t id;
 	struct wl_list link;
 
 	struct panel *panel;
@@ -99,6 +127,18 @@ struct panel_launcher {
 	struct wl_array argv;
 };
 
+struct list_item {
+	struct surface *surface;
+	struct widget *widget;
+	struct panel *panel;
+	cairo_surface_t *icon;
+	int focused, highlight;
+	float x, y;
+	struct wl_list link;
+	struct wl_list surface_link;
+	struct wl_list reorder_link;
+};
+
 struct panel_clock {
 	struct widget *widget;
 	struct panel *panel;
@@ -156,13 +196,13 @@ sigchild_handler(int s)
 }
 
 static void
-menu_func(struct window *window, int index, void *data)
+panel_menu_func(struct window *window, int index, void *data)
 {
 	printf("Selected index %d from a panel menu.\n", index);
 }
 
 static void
-show_menu(struct panel *panel, struct input *input, uint32_t time)
+panel_show_menu(struct panel *panel, struct input *input, uint32_t time)
 {
 	int32_t x, y;
 	static const char *entries[] = {
@@ -172,7 +212,7 @@ show_menu(struct panel *panel, struct input *input, uint32_t time)
 	input_get_position(input, &x, &y);
 	window_show_menu(window_get_display(panel->window),
 			 input, time, panel->window,
-			 x - 10, y - 10, menu_func, entries, 4);
+			 x - 10, y - 10, panel_menu_func, entries, 4);
 }
 
 static void
@@ -249,6 +289,15 @@ set_hex_color(cairo_t *cr, uint32_t color)
 }
 
 static void
+get_hex_color_rgba(uint32_t color, float *r, float *g, float *b, float *a)
+{
+	*r = ((color >> 16) & 0xff) / 255.0;
+	*g = ((color >>  8) & 0xff) / 255.0;
+	*b = ((color >>  0) & 0xff) / 255.0;
+	*a = ((color >> 24) & 0xff) / 255.0;
+}
+
+static void
 panel_redraw_handler(struct widget *widget, void *data)
 {
 	cairo_surface_t *surface;
@@ -337,7 +386,7 @@ panel_clock_redraw_handler(struct widget *widget, void *data)
 
 	surface = window_get_surface(clock->panel->window);
 	cr = cairo_create(surface);
-	cairo_select_font_face(cr, "sans",
+	cairo_select_font_face(cr, "helvetica",
 			       CAIRO_FONT_SLANT_NORMAL,
 			       CAIRO_FONT_WEIGHT_NORMAL);
 	cairo_set_font_size(cr, 14);
@@ -417,7 +466,36 @@ panel_button_handler(struct widget *widget,
 	struct panel *panel = data;
 
 	if (button == BTN_RIGHT && state == WL_POINTER_BUTTON_STATE_PRESSED)
-		show_menu(panel, input, time);
+		panel_show_menu(panel, input, time);
+}
+
+static void
+panel_window_list_schedule_redraw(struct panel *panel)
+{
+	struct list_item *item;
+	float x, y, w, h;
+	float item_width, padding;
+
+	/* If there are no window list items, redraw the panel to clear it */
+	if (wl_list_empty(&panel->window_list)) {
+		widget_schedule_redraw(panel->widget);
+		return;
+	}
+
+	item_width = ((float) panel->window_list_rect.width /
+							panel->surface_count);
+	padding = MIN(item_width * 0.1f, 10.0f);
+
+	x = panel->window_list_rect.x + padding;
+	y = 16;
+	w = MIN(item_width - padding, 200);
+	h = 24;
+
+	wl_list_for_each(item, &panel->window_list, link) {
+		widget_set_allocation(item->widget, x, y - h / 2, w + 1, h + 1);
+		x += w + padding;
+		widget_schedule_redraw(item->widget);
+	}
 }
 
 static void
@@ -425,11 +503,16 @@ panel_resize_handler(struct widget *widget,
 		     int32_t width, int32_t height, void *data)
 {
 	struct panel_launcher *launcher;
+	struct rectangle launcher_rect;
+	struct rectangle clock_rect;
 	struct panel *panel = data;
 	int x, y, w, h;
-	
+
 	x = 10;
 	y = 16;
+
+	launcher_rect.x = x;
+
 	wl_list_for_each(launcher, &panel->launcher_list, link) {
 		w = cairo_image_surface_get_width(launcher->icon);
 		h = cairo_image_surface_get_height(launcher->icon);
@@ -437,12 +520,25 @@ panel_resize_handler(struct widget *widget,
 				      x, y - h / 2, w + 1, h + 1);
 		x += w + 10;
 	}
-	h=20;
+
+	launcher_rect.width = x - launcher_rect.x;
+
 	w=170;
+	h=20;
 
 	if (panel->clock)
 		widget_set_allocation(panel->clock->widget,
 				      width - w - 8, y - h / 2, w + 1, h + 1);
+
+	widget_get_allocation(panel->clock->widget, &clock_rect);
+
+	panel->window_list_rect.x = launcher_rect.x + launcher_rect.width;
+	panel->window_list_rect.y = 2;
+	panel->window_list_rect.width = width -
+					panel->window_list_rect.x -
+					(clock_rect.width + 20);
+	panel->window_list_rect.height = 28;
+	panel_window_list_schedule_redraw(panel);
 }
 
 static void
@@ -451,7 +547,7 @@ panel_configure(void *data,
 		uint32_t edges, struct window *window,
 		int32_t width, int32_t height)
 {
-	struct surface *surface = window_get_user_data(window);
+	struct resize *surface = window_get_user_data(window);
 	struct panel *panel = container_of(surface, struct panel, base);
 
 	window_schedule_resize(panel->window, width, 32);
@@ -490,6 +586,25 @@ panel_destroy(struct panel *panel)
 	free(panel);
 }
 
+static void
+panel_set_list_item_focus_color(struct panel *panel)
+{
+	float r, g, b, a;
+
+	/* Consider panel color when choosing item highlight color */
+	get_hex_color_rgba(key_panel_color, &r, &b, &g, &a);
+	if (r += 0.2, g += 0.2, b += 0.2, r > 1.0 || g > 1.0 || b > 1.0) {
+		panel->focused_item.r = 0.6;
+		panel->focused_item.g = 0.6;
+		panel->focused_item.b = 0.6;
+	} else {
+		panel->focused_item.r = r;
+		panel->focused_item.g = g;
+		panel->focused_item.b = b;
+	}
+	panel->focused_item.a = 0.75;
+}
+
 static struct panel *
 panel_create(struct display *display)
 {
@@ -502,6 +617,7 @@ panel_create(struct display *display)
 	panel->window = window_create_custom(display);
 	panel->widget = window_add_widget(panel->window, panel);
 	wl_list_init(&panel->launcher_list);
+	wl_list_init(&panel->window_list);
 
 	window_set_title(panel->window, "panel");
 	window_set_user_data(panel->window, panel);
@@ -509,7 +625,9 @@ panel_create(struct display *display)
 	widget_set_redraw_handler(panel->widget, panel_redraw_handler);
 	widget_set_resize_handler(panel->widget, panel_resize_handler);
 	widget_set_button_handler(panel->widget, panel_button_handler);
-	
+
+	panel->surface_count = 0;
+	panel_set_list_item_focus_color(panel);
 	panel_add_clock(panel);
 
 	return panel;
@@ -518,18 +636,21 @@ panel_create(struct display *display)
 static cairo_surface_t *
 load_icon_or_fallback(const char *icon)
 {
-	cairo_surface_t *surface = cairo_image_surface_create_from_png(icon);
+	cairo_surface_t *surface;
 	cairo_t *cr;
-
-	if (cairo_surface_status(surface) == CAIRO_STATUS_SUCCESS)
-		return surface;
-
-	cairo_surface_destroy(surface);
-	fprintf(stderr, "ERROR loading icon from file '%s'\n", icon);
+#ifdef CAIRO_HAS_PNG_FUNCTIONS
+	if (icon) {
+		surface = cairo_image_surface_create_from_png(icon);
+		if (cairo_surface_status(surface) == CAIRO_STATUS_SUCCESS)
+			return surface;
+
+		cairo_surface_destroy(surface);
+		fprintf(stderr, "ERROR loading icon from file '%s'\n", icon);
+	}
+#endif
 
 	/* draw fallback icon */
-	surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32,
-					     20, 20);
+	surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 20, 20);
 	cr = cairo_create(surface);
 
 	cairo_set_source_rgba(cr, 0.8, 0.8, 0.8, 1);
@@ -862,7 +983,7 @@ desktop_shell_configure(void *data,
 			int32_t width, int32_t height)
 {
 	struct window *window = wl_surface_get_user_data(surface);
-	struct surface *s = window_get_user_data(window);
+	struct resize *s = window_get_user_data(window);
 
 	s->configure(data, desktop_shell, edges, window, width, height);
 }
@@ -946,6 +1067,621 @@ background_destroy(struct background *background)
 	free(background);
 }
 
+static void
+panel_list_item_redraw_handler(struct widget *widget, void *data)
+{
+	cairo_t *cr;
+	cairo_surface_t *surface;
+	struct list_item *item = data;
+	struct rectangle rect;
+	cairo_text_extents_t extents;
+	cairo_font_extents_t font_extents;
+	int icon_width;
+	unsigned int dots = 3;
+	char title[128];
+
+	widget_get_allocation(widget, &rect);
+	if (rect.width == 0)
+		return;
+
+	surface = window_get_surface(item->panel->window);
+	cr = cairo_create(surface);
+
+	if (item->highlight || item->surface->focused) {
+		cairo_set_source_rgba(cr,
+					item->panel->focused_item.r,
+					item->panel->focused_item.g,
+					item->panel->focused_item.b,
+					item->panel->focused_item.a);
+		cairo_move_to(cr, rect.x, rect.y);
+		cairo_line_to(cr, rect.x + rect.width, rect.y);
+		cairo_line_to(cr, rect.x + rect.width, rect.y + rect.height);
+		cairo_line_to(cr, rect.x, rect.y + rect.height);
+		cairo_line_to(cr, rect.x, rect.y);
+		cairo_fill(cr);
+	}
+
+	icon_width = cairo_image_surface_get_width(item->icon);
+	if (rect.width > icon_width * 2) {
+		cairo_set_source_surface(cr, item->icon,
+					 rect.x, rect.y);
+		cairo_paint(cr);
+	} else
+		icon_width = 0;
+
+	strcpy(title, item->surface->title);
+	cairo_select_font_face(cr, "helvetica",
+			       CAIRO_FONT_SLANT_NORMAL,
+			       CAIRO_FONT_WEIGHT_NORMAL);
+	cairo_set_font_size(cr, 14);
+	cairo_text_extents(cr, title, &extents);
+
+	/* If the string is too long, clip text to button width */
+	while (extents.width > (rect.width - (10 + icon_width))) {
+		title[strlen(title) - 1] = '\0';
+		cairo_text_extents(cr, title, &extents);
+		if (extents.width <= 0) {
+			title[0] = '\0';
+			break;
+		}
+	}
+
+	/* If the text is clipped, add an ellipsis */
+	if (strlen(title) < dots)
+		dots = strlen(title) + 1;
+	if (strlen(title) != strlen(item->surface->title))
+		while (dots-- > 0)
+			title[strlen(title) - dots] = '.';
+
+	cairo_font_extents (cr, &font_extents);
+	cairo_move_to(cr, rect.x + 10 + icon_width,
+		      rect.y + 3 * (rect.height >> 2) + 1);
+	cairo_set_source_rgb(cr, 0, 0, 0);
+	cairo_show_text(cr, title);
+	cairo_move_to(cr, rect.x + 9 + icon_width,
+		      rect.y + 3 * (rect.height >> 2));
+	if (item->highlight)
+		cairo_set_source_rgb(cr, 1, 1, 1);
+	else
+		cairo_set_source_rgb(cr, 0.85, 0.85, 0.85);
+	cairo_show_text(cr, title);
+	cairo_destroy(cr);
+}
+
+static int
+panel_list_item_motion_handler(struct widget *widget, struct input *input,
+			      uint32_t time, float x, float y, void *data)
+{
+	struct list_item *item = data;
+
+	item->x = x;
+	item->y = y;
+	widget_set_tooltip(widget, basename((char *)item->surface->title), x, y);
+
+	return CURSOR_LEFT_PTR;
+}
+
+static int
+panel_list_item_enter_handler(struct widget *widget, struct input *input,
+			     float x, float y, void *data)
+{
+	struct list_item *item = data;
+
+	item->x = x;
+	item->y = y;
+	item->highlight = true;
+	item->focused = true;
+	widget_schedule_redraw(widget);
+
+	return CURSOR_LEFT_PTR;
+}
+
+static void
+panel_list_item_leave_handler(struct widget *widget,
+			     struct input *input, void *data)
+{
+	struct list_item *item = data;
+
+	item->highlight = false;
+	item->focused = false;
+	widget_destroy_tooltip(widget);
+	widget_schedule_redraw(widget);
+}
+
+static void
+desktop_update_list_items(struct desktop *desktop, struct surface *surface);
+
+static void
+list_item_menu_handle_button(struct list_item *item, int index)
+{
+	struct surface *surface = item->surface;
+
+	switch (index) {
+	case 0: /* (Un)Minimize */
+		if (surface->minimized) {
+			surface_data_unminimize(surface->surface_data);
+			surface->minimized = false;
+		}
+		else {
+			surface_data_minimize(surface->surface_data);
+			surface->minimized = true;
+		}
+		break;
+	case 1: /* (Un)Maximize */
+		if (surface->maximized) {
+			surface_data_unmaximize(surface->surface_data);
+			surface->maximized = false;
+		}
+		else {
+			surface_data_maximize(surface->surface_data);
+			surface->maximized = true;
+		}
+		break;
+	case 2: /* Close */
+		surface_data_close(surface->surface_data);
+		break;
+	default:
+		item->highlight = false;
+		break;
+	}
+
+	desktop_update_list_items(surface->desktop, surface);
+	widget_destroy_tooltip(item->widget);
+	widget_schedule_redraw(item->widget);
+}
+
+static void
+list_item_menu_func(struct window *window, int index, void *data)
+{
+	struct list_item *item;
+	struct panel *panel;
+
+	panel = data;
+
+	wl_list_for_each(item, &panel->window_list, link)
+		if (item->focused) {
+			list_item_menu_handle_button(item, index);
+			return;
+		}
+}
+
+#define NUM_ENTRIES 3
+
+static void
+list_item_show_menu(struct list_item *item, struct input *input, uint32_t time)
+{
+	struct panel *panel;
+	int32_t x, y;
+	static const char *entries[NUM_ENTRIES];
+
+	entries[0] = item->surface->minimized ? "Unminimize" : "Minimize";
+	entries[1] = item->surface->maximized ? "Unmaximize" : "Maximize";
+	entries[2] = "Close";
+
+	panel = item->panel;
+	input_get_position(input, &x, &y);
+	window_show_menu(window_get_display(panel->window), input,
+				time, panel->window, x - 10, y - 10,
+				list_item_menu_func, entries, NUM_ENTRIES);
+}
+
+static bool
+rect_contains_point(struct rectangle rect, int x, int y)
+{
+	int x1, y1, x2, y2;
+
+	x1 = rect.x;
+	y1 = rect.y;
+	x2 = rect.x + rect.width;
+	y2 = rect.y + rect.height;
+
+	if (x > x1 && x < x2 && y > y1 && y < y2)
+		return true;
+
+	return false;
+}
+
+static bool
+item_contains_point(struct list_item *item, int x, int y)
+{
+	struct rectangle item_rect;
+
+	widget_get_allocation(item->widget, &item_rect);
+
+	return rect_contains_point(item_rect, x, y);
+}
+
+static bool
+list_contains_point(struct list_item *item, int x, int y)
+{
+	struct rectangle list_rect;
+
+	list_rect = item->panel->window_list_rect;
+
+	return rect_contains_point(list_rect, x, y);
+}
+
+static void
+panel_item_list_reorder(struct panel *panel,
+			struct list_item *current, struct list_item *item)
+{
+	struct rectangle current_rect, item_rect;
+
+	if (current == item)
+		return;
+
+	widget_get_allocation(current->widget, &current_rect);
+	widget_get_allocation(item->widget, &item_rect);
+
+	wl_list_remove(&current->link);
+
+	if (item_rect.x < current_rect.x)
+		wl_list_insert(item->link.prev, &current->link);
+	else
+		wl_list_insert(&item->link, &current->link);
+
+	panel_window_list_schedule_redraw(item->panel);
+}
+
+static void
+list_item_move(struct list_item *current, int x, int y)
+{
+	struct list_item *item;
+
+	wl_list_for_each(item, &current->panel->window_list, link) {
+		if (item == current)
+			continue;
+		if (item_contains_point(item, x, y)) {
+			panel_item_list_reorder(item->panel, current, item);
+			return;
+		}
+	}
+}
+
+static void
+panel_list_item_button_handler(struct widget *widget,
+			      struct input *input, uint32_t time,
+			      uint32_t button,
+			      enum wl_pointer_button_state state, void *data)
+{
+	struct list_item *item;
+	struct surface *surface;
+
+	item = data;
+
+	widget_schedule_redraw(widget);
+
+	if (button == BTN_RIGHT && state == WL_POINTER_BUTTON_STATE_PRESSED) {
+		widget_destroy_tooltip(item->widget);
+		widget_schedule_redraw(item->widget);
+		list_item_show_menu(item, input, time);
+		return;
+	}
+
+	if ((button != BTN_LEFT) || (state != WL_POINTER_BUTTON_STATE_RELEASED))
+		return;
+
+	surface = item->surface;
+	if (!item_contains_point(item, item->x, item->y)) {
+		if (list_contains_point(item, item->x, item->y))
+			list_item_move(item, item->x, item->y);
+		return;
+	}
+	if (!surface->focused && !surface->minimized) {
+		surface_data_focus(surface->surface_data);
+		surface->focused = true;
+		return;
+	}
+	if (surface->minimized) {
+		surface_data_unminimize(surface->surface_data);
+		surface->minimized = false;
+	}
+	else {
+		surface_data_minimize(surface->surface_data);
+		surface->minimized = true;
+	}
+}
+
+static struct list_item *
+panel_list_item_add(struct panel *panel, const char *icon, const char *text)
+{
+	struct list_item *item;
+	item = malloc(sizeof *item);
+	memset(item, 0, sizeof *item);
+
+	item->icon = load_icon_or_fallback(icon);
+
+	item->panel = panel;
+	wl_list_insert(panel->window_list.prev, &item->link);
+	panel->surface_count++;
+
+	item->widget = widget_add_widget(panel->widget, item);
+	widget_set_enter_handler(item->widget, panel_list_item_enter_handler);
+	widget_set_leave_handler(item->widget, panel_list_item_leave_handler);
+	widget_set_button_handler(item->widget, panel_list_item_button_handler);
+	widget_set_redraw_handler(item->widget, panel_list_item_redraw_handler);
+	widget_set_motion_handler(item->widget, panel_list_item_motion_handler);
+
+	return item;
+}
+
+static void
+panel_list_item_remove(struct list_item *item)
+{
+	item->panel->surface_count--;
+	wl_list_remove(&item->link);
+	wl_list_remove(&item->surface_link);
+	widget_destroy(item->widget);
+	panel_window_list_schedule_redraw(item->panel);
+	free(item);
+}
+
+static int
+panel_list_item_exists(struct panel *panel, struct surface *surface)
+{
+	struct list_item *p_item, *s_item;
+
+	wl_list_for_each(p_item, &panel->window_list, link) {
+		wl_list_for_each(s_item, &surface->item_list, surface_link) {
+			if (p_item == s_item)
+				return 1;
+		}
+	}
+
+	return 0;
+}
+
+static void
+output_update_window_list(struct output *output, struct surface *surface)
+{
+	struct list_item *item, *next;
+	struct panel *panel;
+
+	panel = output->panel;
+
+	/* Make a list item for each panel of the surfaces output mask */
+	if ((1 << output->id) & surface->output_mask) {
+		if (!panel_list_item_exists(panel, surface)) {
+			/* TODO: Use a real icon instead of
+			 * passing NULL for the fallback */
+			item = panel_list_item_add(panel, NULL, surface->title);
+			wl_list_insert(surface->item_list.prev,
+							&item->surface_link);
+			item->surface = surface;
+		}
+	} else {
+		/* Remove item from panel if surface
+		 * is no longer on the output */
+		wl_list_for_each_safe(item, next, &surface->item_list,
+								surface_link) {
+			if (item->panel == panel)
+				panel_list_item_remove(item);
+		}
+	}
+
+	panel_window_list_schedule_redraw(panel);
+}
+
+static struct surface*
+desktop_create_surface(struct desktop *desktop,
+			struct surface_data *surface_data)
+{
+	struct surface *surface;
+
+	surface = calloc(1, sizeof *surface);
+
+	if (!surface) {
+		fprintf(stderr, "ERROR: Failed to allocate memory!\n");
+		exit(EXIT_FAILURE);
+	}
+
+	surface->desktop = desktop;
+	surface->surface_data = surface_data;
+	surface->title = strdup("unknown");
+	surface->output_mask = 1;
+	surface->maximized = false;
+	surface->minimized = false;
+	surface->focused = false;
+	wl_list_init(&surface->item_list);
+	wl_list_insert(&desktop->surfaces, &surface->link);
+
+	return surface;
+}
+
+static void
+desktop_destroy_surface(struct surface *surface)
+{
+	struct list_item *item, *next;
+
+	wl_list_for_each_safe(item, next, &surface->item_list, surface_link)
+		panel_list_item_remove(item);
+
+	wl_list_remove(&surface->link);
+	free(surface->title);
+	free(surface);
+}
+
+static struct surface *
+desktop_get_surface(struct desktop *desktop, struct surface_data *surface_data)
+{
+	struct output *output;
+	struct list_item *item;
+
+	wl_list_for_each(output, &desktop->outputs, link) {
+		wl_list_for_each(item, &output->panel->window_list, link) {
+			if (surface_data == item->surface->surface_data)
+				return item->surface;
+		}
+	}
+
+	return NULL;
+}
+
+static void
+desktop_update_list_items(struct desktop *desktop, struct surface *surface)
+{
+	struct output *output;
+
+	wl_list_for_each(output, &desktop->outputs, link)
+		output_update_window_list(output, surface);
+}
+
+static void
+surface_data_set_output_mask(void *data,
+				struct surface_data *surface_data,
+				uint32_t output_mask)
+{
+	struct desktop *desktop;
+	struct surface *surface;
+
+	desktop = data;
+
+	surface = desktop_get_surface(desktop, surface_data);
+
+	if (!surface)
+		surface = desktop_create_surface(desktop, surface_data);
+
+	surface->output_mask = output_mask;
+
+	desktop_update_list_items(desktop, surface);
+}
+
+static void
+surface_data_set_title(void *data,
+				struct surface_data *surface_data,
+				const char *title)
+{
+	struct desktop *desktop;
+	struct surface *surface;
+
+	desktop = data;
+
+	surface = desktop_get_surface(desktop, surface_data);
+
+	if (!surface)
+		surface = desktop_create_surface(desktop, surface_data);
+
+	if (surface->title)
+		free(surface->title);
+	surface->title = strdup(title);
+
+	desktop_update_list_items(desktop, surface);
+}
+
+static void
+surface_data_set_maximized_state(void *data,
+				struct surface_data *surface_data,
+				int maximized)
+{
+	struct desktop *desktop;
+	struct surface *surface;
+
+	desktop = data;
+
+	surface = desktop_get_surface(desktop, surface_data);
+
+	if (!surface)
+		surface = desktop_create_surface(desktop, surface_data);
+
+	surface->maximized = maximized;
+
+	desktop_update_list_items(desktop, surface);
+}
+
+static void
+surface_data_set_minimized_state(void *data,
+				struct surface_data *surface_data,
+				int minimized)
+{
+	struct desktop *desktop;
+	struct surface *surface;
+
+	desktop = data;
+
+	surface = desktop_get_surface(desktop, surface_data);
+
+	if (!surface)
+		surface = desktop_create_surface(desktop, surface_data);
+
+	surface->minimized = minimized;
+
+	desktop_update_list_items(desktop, surface);
+}
+
+static void
+surface_data_set_focused_state(void *data,
+				struct surface_data *surface_data,
+				int focused)
+{
+	struct desktop *desktop;
+	struct surface *surface;
+	struct list_item *item;
+
+	desktop = data;
+
+	wl_list_for_each(surface, &desktop->surfaces, link)
+		if (surface->surface_data != surface_data && focused) {
+			surface->focused = false;
+			wl_list_for_each(item, &surface->item_list, surface_link)
+				if (!item->focused)
+					item->highlight = false;
+		}
+
+	surface = desktop_get_surface(desktop, surface_data);
+
+	if (!surface)
+		surface = desktop_create_surface(desktop, surface_data);
+
+	surface->focused = focused;
+
+	desktop_update_list_items(desktop, surface);
+}
+
+static void
+surface_data_destroy_handler(void *data, struct surface_data *surface_data)
+{
+	struct list_item *item, *next;
+	struct desktop *desktop;
+	struct output *output;
+	struct panel *panel;
+
+	desktop = data;
+
+	surface_data_destroy(surface_data);
+
+	wl_list_for_each(output, &desktop->outputs, link) {
+		panel = output->panel;
+		wl_list_for_each_safe(item, next, &panel->window_list, link) {
+			if (surface_data == item->surface->surface_data) {
+				desktop_destroy_surface(item->surface);
+				return;
+			}
+		}
+	}
+}
+
+static const struct surface_data_listener surface_data_listener = {
+	surface_data_set_output_mask,
+	surface_data_set_title,
+	surface_data_set_maximized_state,
+	surface_data_set_minimized_state,
+	surface_data_set_focused_state,
+	surface_data_destroy_handler
+};
+
+static void
+surface_data_receive_surface_object(void *data,
+				struct surface_data_manager *manager,
+				struct surface_data *surface_data)
+{
+	surface_data_add_listener(surface_data,
+				   &surface_data_listener, data);
+}
+
+static const struct surface_data_manager_listener surface_data_manager_listener = {
+	surface_data_receive_surface_object
+};
+
 static struct background *
 background_create(struct desktop *desktop)
 {
@@ -1022,6 +1758,15 @@ desktop_destroy_outputs(struct desktop *desktop)
 }
 
 static void
+desktop_destroy_surfaces(struct desktop *desktop)
+{
+	struct surface *surface, *next;
+
+	wl_list_for_each_safe(surface, next, &desktop->surfaces, link)
+		desktop_destroy_surface(surface);
+}
+
+static void
 create_output(struct desktop *desktop, uint32_t id)
 {
 	struct output *output;
@@ -1033,7 +1778,9 @@ create_output(struct desktop *desktop, uint32_t id)
 	output->output =
 		display_bind(desktop->display, id, &wl_output_interface, 1);
 
-	wl_list_insert(&desktop->outputs, &output->link);
+	output->id = desktop->output_count++;
+
+	wl_list_insert(desktop->outputs.prev, &output->link);
 }
 
 static void
@@ -1046,6 +1793,12 @@ global_handler(struct display *display, uint32_t id,
 		desktop->shell = display_bind(desktop->display,
 					      id, &desktop_shell_interface, 1);
 		desktop_shell_add_listener(desktop->shell, &listener, desktop);
+	} else if (strcmp(interface, "surface_data_manager") == 0) {
+		desktop->surface_data_manager =
+				display_bind(display, id,
+					&surface_data_manager_interface, 1);
+		surface_data_manager_add_listener(desktop->surface_data_manager,
+					&surface_data_manager_listener, desktop);
 	} else if (!strcmp(interface, "wl_output")) {
 		create_output(desktop, id);
 	}
@@ -1100,6 +1853,9 @@ int main(int argc, char *argv[])
 		return -1;
 	}
 
+	wl_list_init(&desktop.surfaces);
+	desktop.output_count = 0;
+
 	display_set_user_data(desktop.display, &desktop);
 	display_set_global_handler(desktop.display, global_handler);
 
@@ -1133,6 +1889,7 @@ int main(int argc, char *argv[])
 
 	/* Cleanup */
 	grab_surface_destroy(&desktop);
+	desktop_destroy_surfaces(&desktop);
 	desktop_destroy_outputs(&desktop);
 	if (desktop.unlock_dialog)
 		unlock_dialog_destroy(desktop.unlock_dialog);
diff --git a/clients/simple-egl.c b/clients/simple-egl.c
index fcbea75..273159b 100644
--- a/clients/simple-egl.c
+++ b/clients/simple-egl.c
@@ -250,10 +250,34 @@ handle_popup_done(void *data, struct wl_shell_surface *shell_surface)
 {
 }
 
+static void
+handle_maximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unmaximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_minimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unminimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
 static const struct wl_shell_surface_listener shell_surface_listener = {
 	handle_ping,
 	handle_configure,
-	handle_popup_done
+	handle_popup_done,
+	handle_maximize,
+	handle_unmaximize,
+	handle_minimize,
+	handle_unminimize
 };
 
 static void
diff --git a/clients/simple-shm.c b/clients/simple-shm.c
index a09ec91..7f8809a 100644
--- a/clients/simple-shm.c
+++ b/clients/simple-shm.c
@@ -107,10 +107,34 @@ handle_popup_done(void *data, struct wl_shell_surface *shell_surface)
 {
 }
 
+static void
+handle_maximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unmaximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_minimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unminimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
 static const struct wl_shell_surface_listener shell_surface_listener = {
 	handle_ping,
 	handle_configure,
-	handle_popup_done
+	handle_popup_done,
+	handle_maximize,
+	handle_unmaximize,
+	handle_minimize,
+	handle_unminimize
 };
 
 static struct window *
diff --git a/clients/simple-touch.c b/clients/simple-touch.c
index cbe3877..c9b594b 100644
--- a/clients/simple-touch.c
+++ b/clients/simple-touch.c
@@ -233,10 +233,34 @@ handle_popup_done(void *data, struct wl_shell_surface *shell_surface)
 {
 }
 
+static void
+handle_maximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unmaximize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_minimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
+static void
+handle_unminimize(void *data, struct wl_shell_surface *shell_surface)
+{
+}
+
 static const struct wl_shell_surface_listener shell_surface_listener = {
 	handle_ping,
 	handle_configure,
-	handle_popup_done
+	handle_popup_done,
+	handle_maximize,
+	handle_unmaximize,
+	handle_minimize,
+	handle_unminimize
 };
 
 static void
diff --git a/clients/window.c b/clients/window.c
index fe968ed..9a11571 100644
--- a/clients/window.c
+++ b/clients/window.c
@@ -163,6 +163,7 @@ struct window {
 	int type;
 	int transparent;
 	int focus_count;
+	int minimized;
 
 	enum window_buffer_type buffer_type;
 
@@ -1564,7 +1565,7 @@ frame_button_button_handler(struct widget *widget,
 			display_exit(window->display);
 		break;
 	case FRAME_BUTTON_MINIMIZE:
-		fprintf(stderr,"Minimize stub\n");
+		window_set_minimized(window, !window->minimized);
 		break;
 	case FRAME_BUTTON_MAXIMIZE:
 		window_set_maximized(window, window->type != TYPE_MAXIMIZED);
@@ -2932,10 +2933,48 @@ handle_popup_done(void *data, struct wl_shell_surface *shell_surface)
 	menu_destroy(menu);
 }
 
+static void
+handle_maximize(void *data, struct wl_shell_surface *shell_surface)
+{
+	struct window *window = data;
+
+	window_set_maximized(window, 1);
+}
+
+static void
+handle_unmaximize(void *data, struct wl_shell_surface *shell_surface)
+{
+	struct window *window = data;
+
+	window_set_maximized(window, 0);
+}
+
+static void
+handle_minimize(void *data, struct wl_shell_surface *shell_surface)
+{
+	struct window *window = data;
+
+	if (!window->minimized)
+		window->minimized = 1;
+}
+
+static void
+handle_unminimize(void *data, struct wl_shell_surface *shell_surface)
+{
+	struct window *window = data;
+
+	if (window->minimized)
+		window->minimized = 0;
+}
+
 static const struct wl_shell_surface_listener shell_surface_listener = {
 	handle_ping,
 	handle_configure,
-	handle_popup_done
+	handle_popup_done,
+	handle_maximize,
+	handle_unmaximize,
+	handle_minimize,
+	handle_unminimize
 };
 
 void
@@ -3048,6 +3087,8 @@ window_set_maximized(struct window *window, int maximized)
 		return;
 
 	if (window->type == TYPE_TOPLEVEL) {
+		if (window->resize_needed)
+			return;
 		window->saved_allocation = window->allocation;
 		wl_shell_surface_set_maximized(window->shell_surface, NULL);
 		window->type = TYPE_MAXIMIZED;
@@ -3061,6 +3102,22 @@ window_set_maximized(struct window *window, int maximized)
 }
 
 void
+window_set_minimized(struct window *window, int minimized)
+{
+	if (!window->display->shell)
+		return;
+
+	if ((window->minimized) == minimized)
+		return;
+
+	if (!window->minimized) {
+		wl_shell_surface_set_minimized(window->shell_surface);
+		window->minimized = 1;
+	} else
+		window->minimized = 0;
+}
+
+void
 window_set_user_data(struct window *window, void *data)
 {
 	window->user_data = data;
diff --git a/clients/window.h b/clients/window.h
index 84846ff..81fd1ea 100644
--- a/clients/window.h
+++ b/clients/window.h
@@ -304,6 +304,9 @@ void
 window_set_maximized(struct window *window, int maximized);
 
 void
+window_set_minimized(struct window *window, int minimized);
+
+void
 window_set_user_data(struct window *window, void *data);
 
 void *
diff --git a/protocol/desktop-shell.xml b/protocol/desktop-shell.xml
index 2b6afbd..2af3b85 100644
--- a/protocol/desktop-shell.xml
+++ b/protocol/desktop-shell.xml
@@ -82,6 +82,78 @@
     </enum>
   </interface>
 
+  <interface name="surface_data" version="1">
+    <description summary="the surface data offer object">
+	The shell can use this interface to receive surface information or make
+	requests for this surface.
+    </description>
+    <request name="maximize">
+      <description summary="ask the compositor to maximize the surface"/>
+    </request>
+    <request name="unmaximize">
+      <description summary="ask the compositor to unmaximize the surface"/>
+    </request>
+    <request name="minimize">
+      <description summary="ask the compositor to minimize the surface"/>
+    </request>
+    <request name="unminimize">
+      <description summary="ask the compositor to unminimize the surface"/>
+    </request>
+    <request name="focus">
+      <description summary="ask the compositor to focus the surface"/>
+    </request>
+    <request name="close">
+      <description summary="ask the compositor to close the surface"/>
+    </request>
+    <request name="destroy" type="destructor">
+      <description summary="destroy surface request">
+	The shell must send this request in response to a gone event so	the
+	compositor can destroy the object properly.
+      </description>
+    </request>
+    <event name="output_mask">
+      <description summary="send the surface object output_mask to the shell"/>
+      <arg name="output_mask" type="uint"/>
+    </event>
+    <event name="title">
+      <description summary="send the surface object title to the shell"/>
+      <arg name="title" type="string"/>
+    </event>
+    <event name="maximized">
+      <description summary="send the surface object maximize state to the shell"/>
+      <arg name="maximized" type="int"/>
+    </event>
+    <event name="minimized">
+      <description summary="send the surface object minimize state to the shell"/>
+      <arg name="minimized" type="int"/>
+    </event>
+    <event name="focused">
+      <description summary="send the surface object focus state to the shell"/>
+      <arg name="focused" type="int"/>
+    </event>
+    <event name="gone">
+      <description summary="destroy surface notification">
+	The compositor should send this event to notify the shell that a
+	surface has been destroyed. The client must respond with a destroy
+	request.
+      </description>
+    </event>
+  </interface>
+
+  <interface name="surface_data_manager" version="1">
+    <description summary="send surface object to shell">
+	The compositor can offer surface data to a shell. The client can use
+	this interface as a way to receive special surface_data objects.
+    </description>
+    <event name="surface_object">
+      <description summary="surface object">
+	Surface object sent to a shell. This object is intended to allow the
+	shell to initiate a surface_data object interface.
+      </description>
+      <arg name="id" type="new_id" interface="surface_data"/>
+    </event>
+  </interface>
+
   <interface name="screensaver" version="1">
     <description summary="interface for implementing screensavers">
       Only one client can bind this interface at a time.
diff --git a/src/compositor.c b/src/compositor.c
index 2d5b263..403f910 100644
--- a/src/compositor.c
+++ b/src/compositor.c
@@ -374,6 +374,8 @@ weston_surface_update_output_mask(struct weston_surface *es, uint32_t mask)
 		if (1 << output->id & left)
 			wl_surface_send_leave(&es->surface.resource, resource);
 	}
+
+	es->compositor->shell_interface.send_output_mask(es);
 }
 
 static void
@@ -1056,6 +1058,7 @@ WL_EXPORT void
 weston_layer_init(struct weston_layer *layer, struct wl_list *below)
 {
 	wl_list_init(&layer->surface_list);
+	wl_list_init(&layer->minimized_list);
 	if (below != NULL)
 		wl_list_insert(below, &layer->link);
 }
diff --git a/src/compositor.h b/src/compositor.h
index 121f6bf..31f1949 100644
--- a/src/compositor.h
+++ b/src/compositor.h
@@ -94,6 +94,7 @@ struct weston_shell_interface {
 	int (*move)(struct shell_surface *shsurf, struct weston_seat *ws);
 	int (*resize)(struct shell_surface *shsurf,
 		      struct weston_seat *ws, uint32_t edges);
+	void (*send_output_mask)(struct weston_surface *surface);
 
 };
 
@@ -265,6 +266,7 @@ enum {
 
 struct weston_layer {
 	struct wl_list surface_list;
+	struct wl_list minimized_list;
 	struct wl_list link;
 };
 
diff --git a/src/shell.c b/src/shell.c
index b28353e..26068cd 100644
--- a/src/shell.c
+++ b/src/shell.c
@@ -97,6 +97,8 @@ struct desktop_shell {
 		uint32_t deathstamp;
 	} child;
 
+	struct wl_resource *surface_data_manager;
+
 	bool locked;
 	bool showing_input_panels;
 	bool prepare_event_sent;
@@ -152,6 +154,11 @@ struct ping_timer {
 	uint32_t serial;
 };
 
+struct surface_data {
+	struct shell_surface *shsurf;
+	struct wl_resource resource;
+};
+
 struct shell_surface {
 	struct wl_resource resource;
 
@@ -160,11 +167,12 @@ struct shell_surface {
 	struct weston_surface *parent;
 	struct desktop_shell *shell;
 
-	enum shell_surface_type type, next_type;
+	enum shell_surface_type type, next_type, saved_type;
 	char *title, *class;
 	int32_t saved_x, saved_y;
 	bool saved_position_valid;
 	bool saved_rotation_valid;
+	bool minimized;
 	int unresponsive;
 
 	struct {
@@ -202,6 +210,7 @@ struct shell_surface {
 	struct wl_list link;
 
 	const struct weston_shell_client *client;
+	struct surface_data *surface_data;
 };
 
 struct shell_grab {
@@ -1397,6 +1406,339 @@ shell_surface_pong(struct wl_client *client, struct wl_resource *resource,
 }
 
 static void
+surface_data_destroy_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	wl_resource_destroy(resource);
+}
+
+static void
+send_surface_data_focused_state(struct weston_surface *surface);
+
+static void
+activate(struct desktop_shell *shell, struct weston_surface *es,
+	 struct weston_seat *seat);
+
+static void
+shell_surface_focus(struct shell_surface *shsurf)
+{
+	struct desktop_shell *shell;
+	struct weston_compositor *compositor;
+	struct weston_surface *surface;
+	struct weston_seat *seat;
+
+	shell = shsurf->shell;
+	compositor = shell->compositor;
+	surface = shsurf->surface;
+
+	wl_list_for_each(seat, &surface->compositor->seat_list, link)
+		if (seat->seat.keyboard) {
+			wl_keyboard_set_focus(seat->seat.keyboard,
+							&surface->surface);
+			activate(shell, surface, seat);
+		}
+
+	weston_compositor_damage_all(compositor);
+}
+
+static void
+shell_surface_minimize(struct shell_surface *shsurf)
+{
+	struct desktop_shell *shell;
+	struct weston_compositor *compositor;
+	struct weston_surface *surface;
+	struct workspace *ws;
+	struct weston_seat *seat;
+	struct weston_surface *focus;
+
+	shell = shsurf->shell;
+	compositor = shell->compositor;
+	surface = shsurf->surface;
+	ws = get_current_workspace(shell);
+
+	wl_list_remove(&surface->layer_link);
+	wl_list_insert(ws->layer.minimized_list.prev, &surface->layer_link);
+	shsurf->saved_type = shsurf->type;
+	shsurf->minimized = true;
+
+	/* Focus next surface in stack */
+	if (!wl_list_empty(&ws->layer.surface_list)) {
+		focus = container_of(ws->layer.surface_list.next,
+					 struct weston_surface,
+					 layer_link);
+		wl_list_for_each(seat, &compositor->seat_list, link)
+			if (seat->seat.keyboard &&
+			    seat->keyboard.focus == &surface->surface) {
+				shsurf = get_shell_surface(focus);
+				if (!shsurf)
+					break;
+				shell_surface_focus(shsurf);
+			}
+	}
+
+	send_surface_data_focused_state(surface);
+	wl_shell_surface_send_minimize(&shsurf->resource);
+
+	weston_compositor_damage_all(compositor);
+}
+
+static void
+surface_unminimize(struct shell_surface *shsurf, struct workspace *ws)
+{
+	struct desktop_shell *shell;
+	struct weston_compositor *compositor;
+	struct weston_surface *surface;
+
+	shell = shsurf->shell;
+	compositor = shell->compositor;
+	surface = shsurf->surface;
+
+	wl_list_remove(&surface->layer_link);
+	wl_list_insert(ws->layer.surface_list.prev, &surface->layer_link);
+	shell_surface_focus(shsurf);
+	send_surface_data_focused_state(surface);
+	wl_shell_surface_send_unminimize(&shsurf->resource);
+	shsurf->minimized = false;
+	weston_compositor_damage_all(compositor);
+}
+
+static void
+shell_surface_unminimize(struct shell_surface *shsurf)
+{
+	struct weston_surface *surface;
+	struct workspace *ws = get_current_workspace(shsurf->shell);
+
+	wl_list_for_each(surface, &ws->layer.minimized_list, layer_link)
+		if (surface == shsurf->surface) {
+			surface_unminimize(shsurf, ws);
+			return;
+		}
+}
+
+static void
+surface_data_maximize_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data = resource->data;
+
+	wl_shell_surface_send_maximize(&surface_data->shsurf->resource);
+}
+
+static void
+surface_data_unmaximize_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data = resource->data;
+
+	wl_shell_surface_send_unmaximize(&surface_data->shsurf->resource);
+}
+
+static void
+surface_data_minimize_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data = resource->data;
+
+	shell_surface_minimize(surface_data->shsurf);
+}
+
+static void
+surface_data_unminimize_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data = resource->data;
+
+	shell_surface_unminimize(surface_data->shsurf);
+}
+
+static void
+surface_data_focus_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data = resource->data;
+
+	shell_surface_focus(surface_data->shsurf);
+}
+
+static void
+surface_data_close_handler(struct wl_client *client,
+				struct wl_resource *resource)
+{
+	struct surface_data *surface_data;
+	struct shell_surface *shsurf;
+	struct wl_surface *target_surface;
+	struct wl_client *target_client;
+	struct desktop_shell *shell;
+	struct weston_compositor *compositor;
+	pid_t pid;
+
+	surface_data = resource->data;
+	shsurf = surface_data->shsurf;
+	target_surface = &shsurf->surface->surface;
+	shell = shsurf->shell;
+	compositor = shell->compositor;
+
+	if (!target_surface)
+		return;
+
+	wl_signal_emit(&compositor->kill_signal, target_surface);
+
+	target_client = target_surface->resource.client;
+	wl_client_get_credentials(target_client, &pid, NULL, NULL);
+
+	/* Skip clients that we launched ourselves (the credentials of
+	 * the socketpair is ours) */
+	if (pid == getpid())
+		return;
+
+	kill(pid, SIGTERM);
+}
+
+static const struct surface_data_interface
+					surface_data_implementation = {
+	surface_data_maximize_handler,
+	surface_data_unmaximize_handler,
+	surface_data_minimize_handler,
+	surface_data_unminimize_handler,
+	surface_data_focus_handler,
+	surface_data_close_handler,
+	surface_data_destroy_handler
+};
+
+static void
+surface_data_object_destroy(struct wl_resource *resource)
+{
+	struct shell_surface *shsurf;
+	struct surface_data *surface_data = resource->data;
+
+	shsurf = surface_data->shsurf;
+
+	free(surface_data);
+
+	if (!shsurf)
+		return;
+
+	shsurf->surface_data = NULL;
+}
+
+static int
+create_surface_data(struct desktop_shell *shell, struct shell_surface *shsurf)
+{
+	struct surface_data *surface_data;
+
+	surface_data = malloc(sizeof *surface_data);
+	if (surface_data == NULL)
+		return -1;
+
+	surface_data->resource.data = surface_data;
+	surface_data->resource.object.id = 0;
+	surface_data->resource.object.interface = &surface_data_interface;
+	surface_data->resource.destroy = surface_data_object_destroy;
+	surface_data->resource.object.implementation =
+			(void (**)(void)) &surface_data_implementation;
+	surface_data->shsurf = shsurf;
+	wl_signal_init(&surface_data->resource.destroy_signal);
+
+	wl_client_add_resource(shell->surface_data_manager->client,
+					&surface_data->resource);
+
+	shsurf->surface_data = surface_data;
+
+	return 0;
+}
+
+static void
+send_surface_data_object(struct desktop_shell *shell, struct shell_surface *shsurf)
+{
+	surface_data_manager_send_surface_object(shell->surface_data_manager,
+					&shsurf->surface_data->resource);
+}
+
+static bool
+surface_is_window_list_candidate(struct weston_surface *surface,
+					struct shell_surface *out)
+{
+	struct desktop_shell *shell;
+	struct shell_surface *shsurf;
+
+	shsurf = get_shell_surface(surface);
+	if (!shsurf)
+		return false;
+
+	shell = shsurf->shell;
+
+	if (!shell->surface_data_manager)
+		return false;
+
+	switch (shsurf->type) {
+	default:
+	case SHELL_SURFACE_TRANSIENT:
+	case SHELL_SURFACE_POPUP:
+	case SHELL_SURFACE_NONE:
+		return false;
+	case SHELL_SURFACE_FULLSCREEN:
+	case SHELL_SURFACE_MAXIMIZED:
+	case SHELL_SURFACE_TOPLEVEL:
+		if (!shsurf->surface_data) {
+			if (create_surface_data(shell, shsurf))
+				return 0;
+			send_surface_data_object(shell, shsurf);
+		}
+		*out = *shsurf;
+		return true;
+	}
+}
+
+static void
+send_surface_data_output_mask(struct weston_surface *surface)
+{
+	struct shell_surface shsurf;
+
+	if (surface_is_window_list_candidate(surface, &shsurf))
+		surface_data_send_output_mask(&shsurf.surface_data->resource,
+						surface->output_mask);
+}
+
+static void
+send_surface_data_title(struct weston_surface *surface)
+{
+	struct shell_surface shsurf;
+
+	if (surface_is_window_list_candidate(surface, &shsurf))
+		surface_data_send_title(&shsurf.surface_data->resource,
+						shsurf.title == NULL ?
+						"Surface" : shsurf.title);
+}
+
+static void
+send_surface_data_minimized_state(struct weston_surface *surface)
+{
+	struct shell_surface shsurf;
+
+	if (surface_is_window_list_candidate(surface, &shsurf))
+		surface_data_send_minimized(&shsurf.surface_data->resource,
+					shsurf.minimized ? true : false);
+}
+
+static void
+send_surface_data_focused_state(struct weston_surface *surface)
+{
+	struct shell_surface shsurf;
+	struct focus_state *state;
+	struct workspace *ws;
+	bool focused = false;
+
+	if (surface_is_window_list_candidate(surface, &shsurf)) {
+		ws = get_current_workspace(shsurf.shell);
+		wl_list_for_each(state, &ws->focus_list, link)
+			if (state->keyboard_focus == shsurf.surface)
+				focused = true;
+		surface_data_send_focused(&shsurf.surface_data->resource,
+					focused);
+	}
+}
+
+static void
 shell_surface_set_title(struct wl_client *client,
 			struct wl_resource *resource, const char *title)
 {
@@ -1404,6 +1746,7 @@ shell_surface_set_title(struct wl_client *client,
 
 	free(shsurf->title);
 	shsurf->title = strdup(title);
+	send_surface_data_title(shsurf->surface);
 }
 
 static void
@@ -1466,6 +1809,7 @@ reset_shell_surface_type(struct shell_surface *surface)
 		weston_surface_set_position(surface->surface,
 					    surface->saved_x,
 					    surface->saved_y);
+		surface_data_send_maximized(&surface->surface_data->resource, false);
 		break;
 	case SHELL_SURFACE_NONE:
 	case SHELL_SURFACE_TOPLEVEL:
@@ -1502,6 +1846,7 @@ set_surface_type(struct shell_surface *shsurf)
 		shsurf->saved_x = surface->geometry.x;
 		shsurf->saved_y = surface->geometry.y;
 		shsurf->saved_position_valid = true;
+		surface_data_send_maximized(&shsurf->surface_data->resource, true);
 		break;
 
 	case SHELL_SURFACE_FULLSCREEN:
@@ -1520,6 +1865,8 @@ set_surface_type(struct shell_surface *shsurf)
 	default:
 		break;
 	}
+
+	send_surface_data_title(surface);
 }
 
 static void
@@ -1618,6 +1965,16 @@ shell_surface_set_maximized(struct wl_client *client,
 }
 
 static void
+shell_surface_set_minimized(struct wl_client *client,
+			    struct wl_resource *resource)
+{
+	struct shell_surface *shsurf = resource->data;
+
+	shell_surface_minimize(shsurf);
+	send_surface_data_minimized_state(shsurf->surface);
+}
+
+static void
 black_surface_configure(struct weston_surface *es, int32_t sx, int32_t sy);
 
 static struct weston_surface *
@@ -1924,6 +2281,7 @@ static const struct wl_shell_surface_interface shell_surface_implementation = {
 	shell_surface_set_fullscreen,
 	shell_surface_set_popup,
 	shell_surface_set_maximized,
+	shell_surface_set_minimized,
 	shell_surface_set_title,
 	shell_surface_set_class
 };
@@ -1931,6 +2289,10 @@ static const struct wl_shell_surface_interface shell_surface_implementation = {
 static void
 destroy_shell_surface(struct shell_surface *shsurf)
 {
+	if (shsurf->surface_data) {
+		shsurf->surface_data->shsurf = NULL;
+		surface_data_send_gone(&shsurf->surface_data->resource);
+	}
 	if (shsurf->popup.grab.pointer)
 		wl_pointer_end_grab(shsurf->popup.grab.pointer);
 
@@ -2012,6 +2374,7 @@ create_shell_surface(void *shell, struct weston_surface *surface,
 
 	shsurf->shell = (struct desktop_shell *) shell;
 	shsurf->unresponsive = 0;
+	shsurf->minimized = false;
 	shsurf->saved_position_valid = false;
 	shsurf->saved_rotation_valid = false;
 	shsurf->surface = surface;
@@ -2315,6 +2678,28 @@ static const struct desktop_shell_interface desktop_shell_implementation = {
 	desktop_shell_set_grab_surface
 };
 
+static void
+surface_data_send_all_info(struct desktop_shell *shell)
+{
+	struct weston_surface *surface;
+	struct workspace *ws;
+
+	ws = get_current_workspace(shell);
+
+	wl_list_for_each(surface, &ws->layer.surface_list, layer_link) {
+		send_surface_data_minimized_state(surface);
+		send_surface_data_focused_state(surface);
+		send_surface_data_output_mask(surface);
+		send_surface_data_title(surface);
+	}
+	wl_list_for_each(surface, &ws->layer.minimized_list, layer_link) {
+		send_surface_data_minimized_state(surface);
+		send_surface_data_focused_state(surface);
+		send_surface_data_output_mask(surface);
+		send_surface_data_title(surface);
+	}
+}
+
 static enum shell_surface_type
 get_shell_surface_type(struct weston_surface *surface)
 {
@@ -2650,6 +3035,7 @@ activate(struct desktop_shell *shell, struct weston_surface *es,
 		return;
 
 	state->keyboard_focus = es;
+	send_surface_data_focused_state(es);
 	wl_list_remove(&state->surface_destroy_listener.link);
 	wl_signal_add(&es->surface.resource.destroy_signal,
 		      &state->surface_destroy_listener);
@@ -2674,7 +3060,7 @@ black_surface_configure(struct weston_surface *es, int32_t sx, int32_t sy)
 {
 }
 
-static bool 
+static bool
 is_black_surface (struct weston_surface *es, struct weston_surface **fs_surface)
 {
 	if (es->configure == black_surface_configure) {
@@ -3143,6 +3529,37 @@ bind_desktop_shell(struct wl_client *client,
 }
 
 static void
+unbind_surface_data_manager(struct wl_resource *resource)
+{
+	struct desktop_shell *shell = resource->data;
+
+	shell->surface_data_manager = NULL;
+	free(resource);
+}
+
+static void
+bind_surface_data_manager(struct wl_client *client,
+		   void *data, uint32_t version, uint32_t id)
+{
+	struct desktop_shell *shell = data;
+	struct wl_resource *resource;
+
+	resource = wl_client_add_object(client, &surface_data_manager_interface,
+					NULL, id, shell);
+
+	if (client == shell->child.client) {
+		resource->destroy = unbind_surface_data_manager;
+		shell->surface_data_manager = resource;
+		surface_data_send_all_info(shell);
+		return;
+	}
+
+	wl_resource_post_error(resource, WL_DISPLAY_ERROR_INVALID_OBJECT,
+			       "permission to bind desktop_shell denied");
+	wl_resource_destroy(resource);
+}
+
+static void
 screensaver_configure(struct weston_surface *surface, int32_t sx, int32_t sy)
 {
 	struct desktop_shell *shell = surface->private;
@@ -3757,6 +4174,7 @@ module_init(struct weston_compositor *ec)
 	ec->shell_interface.set_transient = set_transient;
 	ec->shell_interface.move = surface_move;
 	ec->shell_interface.resize = surface_resize;
+	ec->shell_interface.send_output_mask = send_surface_data_output_mask;
 
 	wl_list_init(&shell->screensaver.surfaces);
 	wl_list_init(&shell->input_panel.surfaces);
@@ -3808,6 +4226,10 @@ module_init(struct weston_compositor *ec)
 				  shell, bind_workspace_manager) == NULL)
 		return -1;
 
+	if (wl_display_add_global(ec->wl_display, &surface_data_manager_interface,
+				  shell, bind_surface_data_manager) == NULL)
+		return -1;
+
 	shell->child.deathstamp = weston_compositor_get_time();
 
 	loop = wl_display_get_event_loop(ec->wl_display);

















































diff --git a/clients/Makefile.am b/clients/Makefile.am
index c1b65ce..ea03eed 100644
--- a/clients/Makefile.am
+++ b/clients/Makefile.am
@@ -1,6 +1,7 @@
 bin_PROGRAMS =					\
 	weston-info				\
-	$(terminal)
+	$(terminal)				\
+	$(xwm)
 
 noinst_PROGRAMS =				\
 	$(clients_programs)			\
@@ -74,6 +75,8 @@ endif
 
 screenshooter = weston-screenshooter
 
+xwm = weston-xwm
+
 noinst_LIBRARIES = libtoytoolkit.a
 
 libtoytoolkit_a_SOURCES =			\
@@ -168,6 +171,14 @@ weston_tablet_shell_SOURCES =			\
 	tablet-shell-protocol.c
 weston_tablet_shell_LDADD = $(toolkit_libs)
 
+weston_xwm_SOURCES =				\
+	xwm.h					\
+	xwm.c					\
+	xwm-selection.c				\
+	xserver-client-protocol.h		\
+	xserver-protocol.c
+weston_xwm_LDADD = $(toolkit_libs)
+
 BUILT_SOURCES =					\
 	screenshooter-client-protocol.h		\
 	screenshooter-protocol.c		\
@@ -182,7 +193,9 @@ BUILT_SOURCES =					\
 	tablet-shell-client-protocol.h		\
 	tablet-shell-protocol.c			\
 	workspaces-client-protocol.h		\
-	workspaces-protocol.c
+	workspaces-protocol.c			\
+	xserver-client-protocol.h		\
+	xserver-protocol.c
 
 CLEANFILES = $(BUILT_SOURCES)
 endif
diff --git a/clients/xwm-selection.c b/clients/xwm-selection.c
new file mode 100644
index 0000000..ab33b07
--- /dev/null
+++ b/clients/xwm-selection.c
@@ -0,0 +1,651 @@
+/*
+ * Copyright © 2012 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of the copyright holders not be used in
+ * advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  The copyright holders make
+ * no representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#define _GNU_SOURCE
+
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/epoll.h>
+
+#include <wayland-client.h>
+#include "xserver-client-protocol.h"
+#include "xwm.h"
+
+static void
+xwm_write_property(struct task *task, uint32_t events)
+{
+	struct xwm_wm *wm =
+		container_of(task, struct xwm_wm, selection_write_task);
+	unsigned char *property;
+	int len, remainder;
+
+	property = xcb_get_property_value(wm->property_reply);
+	remainder = xcb_get_property_value_length(wm->property_reply) -
+		wm->property_start;
+
+	len = write(wm->data_source_fd, property + wm->property_start,
+		    remainder);
+	if (len == -1) {
+		free(wm->property_reply);
+		display_unwatch_fd(wm->display, wm->data_source_fd);
+		close(wm->data_source_fd);
+		fprintf(stderr, "write error to target fd: %m\n");
+		return;
+	}
+
+	fprintf(stderr, "wrote %d (chunk size %d) of %d bytes\n",
+		wm->property_start + len,
+		len, xcb_get_property_value_length(wm->property_reply));
+
+	wm->property_start += len;
+	if (len == remainder) {
+		free(wm->property_reply);
+		display_unwatch_fd(wm->display, wm->data_source_fd);
+
+		if (wm->incr) {
+			xcb_delete_property(wm->conn,
+					    wm->selection_window,
+					    wm->atom.wl_selection);
+		} else {
+			fprintf(stderr, "transfer complete\n");
+			close(wm->data_source_fd);
+		}
+	}
+}
+
+static void
+xwm_get_incr_chunk(struct xwm_wm *wm)
+{
+	xcb_get_property_cookie_t cookie;
+	xcb_get_property_reply_t *reply;
+
+	cookie = xcb_get_property(wm->conn,
+				  0, /* delete */
+				  wm->selection_window,
+				  wm->atom.wl_selection,
+				  XCB_GET_PROPERTY_TYPE_ANY,
+				  0, /* offset */
+				  0x1fffffff /* length */);
+
+	reply = xcb_get_property_reply(wm->conn, cookie, NULL);
+
+	dump_property(wm, wm->atom.wl_selection, reply);
+
+	if (xcb_get_property_value_length(reply) > 0) {
+		wm->property_start = 0;
+		wm->selection_write_task.run = xwm_write_property;
+		display_watch_fd(wm->display, wm->data_source_fd,
+				 EPOLLOUT, &wm->selection_write_task);
+		wm->property_reply = reply;
+	} else {
+		fprintf(stderr, "transfer complete\n");
+		close(wm->data_source_fd);
+		free(reply);
+	}
+}
+
+static void
+data_source_accept(void *data, struct wl_data_source *source,
+		   const char *mime_type)
+{
+}
+
+static void
+data_source_send(void *data, struct wl_data_source *source,
+		 const char *mime_type, int32_t fd)
+{
+	struct xwm_wm *wm = data;
+
+	if (strcmp(mime_type, "text/plain;charset=utf-8") == 0) {
+		/* Get data for the utf8_string target */
+		xcb_convert_selection(wm->conn,
+				      wm->selection_window,
+				      wm->atom.clipboard,
+				      wm->atom.utf8_string,
+				      wm->atom.wl_selection,
+				      XCB_TIME_CURRENT_TIME);
+
+		xcb_flush(wm->conn);
+
+		fcntl(fd, F_SETFL, O_WRONLY | O_NONBLOCK);
+		wm->data_source_fd = fcntl(fd, F_DUPFD_CLOEXEC, fd);
+	}
+}
+
+static void
+data_source_cancel(void *data, struct wl_data_source *source)
+{
+}
+
+static const struct wl_data_source_listener data_source_listener = {
+	data_source_accept,
+	data_source_send,
+	data_source_cancel
+};
+
+static void
+xwm_get_selection_targets(struct xwm_wm *wm)
+{
+	xcb_get_property_cookie_t cookie;
+	xcb_get_property_reply_t *reply;
+	xcb_atom_t *value;
+	uint32_t i;
+	int has_text_plain = 0;
+	struct xwm *xwm = wm->xwm;
+
+	cookie = xcb_get_property(wm->conn,
+				  1, /* delete */
+				  wm->selection_window,
+				  wm->atom.wl_selection,
+				  XCB_GET_PROPERTY_TYPE_ANY,
+				  0, /* offset */
+				  4096 /* length */);
+
+	reply = xcb_get_property_reply(wm->conn, cookie, NULL);
+
+	dump_property(wm, wm->atom.wl_selection, reply);
+
+	if (reply->type != XCB_ATOM_ATOM) {
+		free(reply);
+		return;
+	}
+	value = xcb_get_property_value(reply);
+	for (i = 0; i < reply->value_len; i++) {
+		if (value[i] == wm->atom.utf8_string)
+			has_text_plain = 1;
+	}
+	free(reply);
+
+	if (!has_text_plain)
+		return;
+
+	wm->selection =
+	    wl_data_device_manager_create_data_source(xwm->data_device_manager);
+	wl_data_source_offer(wm->selection, "text/plain;charset=utf-8");
+	wl_data_source_add_listener(wm->selection,
+				&data_source_listener, wm);
+	wl_data_device_set_selection(xwm->data_device, wm->selection,
+				display_get_serial(wm->display));
+}
+
+static void
+xwm_get_selection_data(struct xwm_wm *wm)
+{
+	xcb_get_property_cookie_t cookie;
+	xcb_get_property_reply_t *reply;
+
+	cookie = xcb_get_property(wm->conn,
+				  1, /* delete */
+				  wm->selection_window,
+				  wm->atom.wl_selection,
+				  XCB_GET_PROPERTY_TYPE_ANY,
+				  0, /* offset */
+				  0x1fffffff /* length */);
+
+	reply = xcb_get_property_reply(wm->conn, cookie, NULL);
+
+	if (reply->type == wm->atom.incr) {
+		dump_property(wm, wm->atom.wl_selection, reply);
+		wm->incr = 1;
+		free(reply);
+	} else {
+		dump_property(wm, wm->atom.wl_selection, reply);
+		wm->incr = 0;
+		wm->property_start = 0;
+		wm->selection_write_task.run = xwm_write_property;
+		display_watch_fd(wm->display, wm->data_source_fd,
+				 EPOLLOUT, &wm->selection_write_task);
+		wm->property_reply = reply;
+	}
+}
+static void
+xwm_handle_selection_notify(struct xwm_wm *wm, xcb_generic_event_t *event)
+{
+	xcb_selection_notify_event_t *selection_notify =
+		(xcb_selection_notify_event_t *) event;
+
+	if (selection_notify->property == XCB_ATOM_NONE) {
+		/* convert selection failed */
+	} else if (selection_notify->target == wm->atom.targets) {
+		xwm_get_selection_targets(wm);
+	} else {
+		xwm_get_selection_data(wm);
+	}
+}
+
+static const size_t incr_chunk_size = 64 * 1024;
+
+static void
+xwm_send_selection_notify(struct xwm_wm *wm, xcb_atom_t property)
+{
+	xcb_selection_notify_event_t selection_notify;
+
+	memset(&selection_notify, 0, sizeof selection_notify);
+	selection_notify.response_type = XCB_SELECTION_NOTIFY;
+	selection_notify.sequence = 0;
+	selection_notify.time = wm->selection_request.time;
+	selection_notify.requestor = wm->selection_request.requestor;
+	selection_notify.selection = wm->selection_request.selection;
+	selection_notify.target = wm->selection_request.target;
+	selection_notify.property = property;
+
+	xcb_send_event(wm->conn, 0, /* propagate */
+		       wm->selection_request.requestor,
+		       XCB_EVENT_MASK_NO_EVENT, (char *) &selection_notify);
+}
+
+static void
+xwm_send_targets(struct xwm_wm *wm)
+{
+	xcb_atom_t targets[] = {
+		wm->atom.timestamp,
+		wm->atom.targets,
+		wm->atom.utf8_string,
+		/* wm->atom.compound_text, */
+		wm->atom.text,
+		/* wm->atom.string */
+	};
+
+	xcb_change_property(wm->conn,
+			    XCB_PROP_MODE_REPLACE,
+			    wm->selection_request.requestor,
+			    wm->selection_request.property,
+			    XCB_ATOM_ATOM,
+			    32, /* format */
+			    ARRAY_LENGTH(targets), targets);
+
+	xwm_send_selection_notify(wm, wm->selection_request.property);
+}
+
+static void
+xwm_send_timestamp(struct xwm_wm *wm)
+{
+	xcb_change_property(wm->conn,
+			    XCB_PROP_MODE_REPLACE,
+			    wm->selection_request.requestor,
+			    wm->selection_request.property,
+			    XCB_ATOM_INTEGER,
+			    32, /* format */
+			    1, &wm->selection_timestamp);
+
+	xwm_send_selection_notify(wm, wm->selection_request.property);
+}
+
+static int
+xwm_flush_source_data(struct xwm_wm *wm)
+{
+	int length;
+
+	xcb_change_property(wm->conn,
+			    XCB_PROP_MODE_REPLACE,
+			    wm->selection_request.requestor,
+			    wm->selection_request.property,
+			    wm->selection_target,
+			    8, /* format */
+			    wm->source_data.size,
+			    wm->source_data.data);
+	wm->selection_property_set = 1;
+	length = wm->source_data.size;
+	wm->source_data.size = 0;
+
+	return length;
+}
+
+static void
+xwm_read_data_source(struct task *task, uint32_t events)
+{
+	struct xwm_wm *wm =
+		container_of(task, struct xwm_wm, selection_read_task);
+	int len, current, available;
+	void *p;
+
+	current = wm->source_data.size;
+	if (wm->source_data.size < incr_chunk_size)
+		p = wl_array_add(&wm->source_data, incr_chunk_size);
+	else
+		p = (char *) wm->source_data.data + wm->source_data.size;
+	available = wm->source_data.alloc - current;
+
+	len = read(wm->data_source_fd, p, available);
+	if (len == -1) {
+		fprintf(stderr, "read error from data source: %m\n");
+		xwm_send_selection_notify(wm, XCB_ATOM_NONE);
+		display_unwatch_fd(wm->display, wm->data_source_fd);
+		close(wm->data_source_fd);
+		wl_array_release(&wm->source_data);
+	}
+
+	fprintf(stderr, "read %d (available %d) bytes: \"%.*s\"\n",
+		len, available, len, (char *) p);
+
+	wm->source_data.size = current + len;
+	if (wm->source_data.size >= incr_chunk_size) {
+		if (!wm->incr) {
+			fprintf(stderr, "got %zu bytes, starting incr\n",
+				wm->source_data.size);
+			wm->incr = 1;
+			xcb_change_property(wm->conn,
+					    XCB_PROP_MODE_REPLACE,
+					    wm->selection_request.requestor,
+					    wm->selection_request.property,
+					    wm->atom.incr,
+					    32, /* format */
+					    1, &incr_chunk_size);
+			wm->selection_property_set = 1;
+			wm->flush_property_on_delete = 1;
+			display_unwatch_fd(wm->display, wm->data_source_fd);
+			xwm_send_selection_notify(wm, wm->selection_request.property);
+		} else if (wm->selection_property_set) {
+			fprintf(stderr, "got %zu bytes, waiting for "
+				"property delete\n", wm->source_data.size);
+
+			wm->flush_property_on_delete = 1;
+			display_unwatch_fd(wm->display, wm->data_source_fd);
+		} else {
+			fprintf(stderr, "got %zu bytes, "
+				"property deleted, seting new property\n",
+				wm->source_data.size);
+			xwm_flush_source_data(wm);
+		}
+	} else if (len == 0 && !wm->incr) {
+		fprintf(stderr, "non-incr transfer complete\n");
+		/* Non-incr transfer all done. */
+		xwm_flush_source_data(wm);
+		xwm_send_selection_notify(wm, wm->selection_request.property);
+		xcb_flush(wm->conn);
+		display_unwatch_fd(wm->display, wm->data_source_fd);
+		close(wm->data_source_fd);
+		wl_array_release(&wm->source_data);
+		wm->selection_request.requestor = XCB_NONE;
+	} else if (len == 0 && wm->incr) {
+		fprintf(stderr, "incr transfer complete\n");
+
+		wm->flush_property_on_delete = 1;
+		if (wm->selection_property_set) {
+			fprintf(stderr, "got %zu bytes, waiting for "
+				"property delete\n", wm->source_data.size);
+		} else {
+			fprintf(stderr, "got %zu bytes, "
+				"property deleted, seting new property\n",
+				wm->source_data.size);
+			xwm_flush_source_data(wm);
+		}
+		xcb_flush(wm->conn);
+		display_unwatch_fd(wm->display, wm->data_source_fd);
+		close(wm->data_source_fd);
+		wm->data_source_fd = -1;
+	} else {
+		fprintf(stderr, "nothing happened, buffered the bytes\n");
+	}
+}
+
+static void
+xwm_send_data(struct xwm_wm *wm, xcb_atom_t target, const char *mime_type)
+{
+	int p[2];
+
+	if (pipe2(p, O_CLOEXEC) == -1) {
+		fprintf(stderr, "pipe2 failed: %m\n");
+		xwm_send_selection_notify(wm, XCB_ATOM_NONE);
+		return;
+	}
+
+	wm_set_selection(wm->xwm->wm, mime_type, p[1]);
+	close(p[1]);
+
+	wl_array_init(&wm->source_data);
+	wm->selection_target = target;
+	wm->data_source_fd = p[0];
+	wm->selection_read_task.run = xwm_read_data_source;
+	display_watch_fd(wm->display, wm->data_source_fd,
+			 EPOLLIN, &wm->selection_read_task);
+
+}
+
+static void
+xwm_send_incr_chunk(struct xwm_wm *wm)
+{
+	int length;
+
+	fprintf(stderr, "property deleted\n");
+
+	wm->selection_property_set = 0;
+	if (wm->flush_property_on_delete) {
+		fprintf(stderr, "setting new property, %zu bytes\n",
+			wm->source_data.size);
+		wm->flush_property_on_delete = 0;
+		length = xwm_flush_source_data(wm);
+
+		if (wm->data_source_fd >= 0) {
+			wm->selection_read_task.run = xwm_read_data_source;
+			display_watch_fd(wm->display, wm->data_source_fd,
+					 EPOLLIN, &wm->selection_read_task);
+		} else if (length > 0) {
+			/* Transfer is all done, but queue a flush for
+			 * the delete of the last chunk so we can set
+			 * the 0 sized propert to signal the end of
+			 * the transfer. */
+			wm->flush_property_on_delete = 1;
+			wl_array_release(&wm->source_data);
+		} else {
+			wm->selection_request.requestor = XCB_NONE;
+		}
+	}
+}
+
+static int
+xwm_handle_selection_property_notify(struct xwm_wm *wm,
+				     xcb_generic_event_t *event)
+{
+	xcb_property_notify_event_t *property_notify =
+		(xcb_property_notify_event_t *) event;
+
+	if (property_notify->window == wm->selection_window) {
+		if (property_notify->state == XCB_PROPERTY_NEW_VALUE &&
+		    property_notify->atom == wm->atom.wl_selection &&
+		    wm->incr)
+			xwm_get_incr_chunk(wm);
+		return 1;
+	} else if (property_notify->window == wm->selection_request.requestor) {
+		if (property_notify->state == XCB_PROPERTY_DELETE &&
+		    property_notify->atom == wm->selection_request.property &&
+		    wm->incr)
+			xwm_send_incr_chunk(wm);
+		return 1;
+	}
+
+	return 0;
+}
+
+static void
+xwm_handle_selection_request(struct xwm_wm *wm, xcb_generic_event_t *event)
+{
+	xcb_selection_request_event_t *selection_request =
+		(xcb_selection_request_event_t *) event;
+
+	fprintf(stderr, "selection request, %s, ",
+		get_atom_name(wm->conn, selection_request->selection));
+	fprintf(stderr, "target %s, ",
+		get_atom_name(wm->conn, selection_request->target));
+	fprintf(stderr, "property %s\n",
+		get_atom_name(wm->conn, selection_request->property));
+
+	wm->selection_request = *selection_request;
+	wm->incr = 0;
+	wm->flush_property_on_delete = 0;
+
+	if (selection_request->selection == wm->atom.clipboard_manager) {
+		/* The weston clipboard should already have grabbed
+		 * the first target, so just send selection notify
+		 * now.  This isn't synchronized with the clipboard
+		 * finishing getting the data, so there's a race here. */
+		xwm_send_selection_notify(wm, wm->selection_request.property);
+		return;
+	}
+
+	if (selection_request->target == wm->atom.targets) {
+		xwm_send_targets(wm);
+	} else if (selection_request->target == wm->atom.timestamp) {
+		xwm_send_timestamp(wm);
+	} else if (selection_request->target == wm->atom.utf8_string ||
+		   selection_request->target == wm->atom.text) {
+		xwm_send_data(wm, wm->atom.utf8_string,
+				  "text/plain;charset=utf-8");
+	} else {
+		fprintf(stderr, "can only handle UTF8_STRING targets...\n");
+		xwm_send_selection_notify(wm, XCB_ATOM_NONE);
+	}
+}
+
+static void
+xwm_handle_xfixes_selection_notify(struct xwm_wm *wm,
+				   xcb_generic_event_t *event)
+{
+	struct xwm *xwm = wm->xwm;
+
+	xcb_xfixes_selection_notify_event_t *xfixes_selection_notify =
+		(xcb_xfixes_selection_notify_event_t *) event;
+
+	fprintf(stderr, "xfixes selection notify event: owner %d\n",
+	       xfixes_selection_notify->owner);
+
+	if (xfixes_selection_notify->owner == XCB_WINDOW_NONE) {
+		if (wm->selection_owner != wm->selection_window) {
+			/* A real X client selection went away, not our
+			 * proxy selection.  Clear the wayland selection. */
+			wl_data_device_set_selection(xwm->data_device,
+					NULL, display_get_serial(wm->display));
+		}
+
+		wm->selection_owner = XCB_WINDOW_NONE;
+
+		return;
+	}
+
+	wm->selection_owner = xfixes_selection_notify->owner;
+
+	/* We have to use XCB_TIME_CURRENT_TIME when we claim the
+	 * selection, so grab the actual timestamp here so we can
+	 * answer TIMESTAMP conversion requests correctly. */
+	if (xfixes_selection_notify->owner == wm->selection_window) {
+		wm->selection_timestamp = xfixes_selection_notify->timestamp;
+		fprintf(stderr, "our window, skipping\n");
+		return;
+	}
+
+	wm->incr = 0;
+	xcb_convert_selection(wm->conn, wm->selection_window,
+			      wm->atom.clipboard,
+			      wm->atom.targets,
+			      wm->atom.wl_selection,
+			      xfixes_selection_notify->timestamp);
+
+	xcb_flush(wm->conn);
+}
+
+int
+xwm_handle_selection_event(struct xwm_wm *wm, xcb_generic_event_t *event)
+{
+	switch (event->response_type & ~0x80) {
+	case XCB_SELECTION_NOTIFY:
+		xwm_handle_selection_notify(wm, event);
+		return 1;
+	case XCB_PROPERTY_NOTIFY:
+		return xwm_handle_selection_property_notify(wm, event);
+	case XCB_SELECTION_REQUEST:
+		xwm_handle_selection_request(wm, event);
+		return 1;
+	}
+
+	switch (event->response_type - wm->xfixes->first_event) {
+	case XCB_XFIXES_SELECTION_NOTIFY:
+		xwm_handle_xfixes_selection_notify(wm, event);
+		return 1;
+	}
+
+	return 0;
+}
+
+void
+xwm_set_selection(struct xwm *xwm, int has_text_plain)
+{
+	struct xwm_wm *wm = xwm->xwm_wm;
+
+	if (wm->selection_owner == wm->selection_window) {
+		xcb_set_selection_owner(wm->conn,
+					XCB_ATOM_NONE,
+					wm->atom.clipboard,
+					wm->selection_timestamp);
+		return;
+	}
+
+	if (has_text_plain) {
+		xcb_set_selection_owner(wm->conn,
+					wm->selection_window,
+					wm->atom.clipboard,
+					XCB_TIME_CURRENT_TIME);
+	} else {
+		xcb_set_selection_owner(wm->conn,
+					XCB_ATOM_NONE,
+					wm->atom.clipboard,
+					XCB_TIME_CURRENT_TIME);
+	}
+}
+
+void
+xwm_selection_init(struct xwm_wm *wm)
+{
+	uint32_t values[1], mask;
+
+	wm->selection_request.requestor = XCB_NONE;
+
+	values[0] = XCB_EVENT_MASK_PROPERTY_CHANGE;
+	wm->selection_window = xcb_generate_id(wm->conn);
+	xcb_create_window(wm->conn,
+			  XCB_COPY_FROM_PARENT,
+			  wm->selection_window,
+			  wm->screen->root,
+			  0, 0,
+			  10, 10,
+			  0,
+			  XCB_WINDOW_CLASS_INPUT_OUTPUT,
+			  wm->screen->root_visual,
+			  XCB_CW_EVENT_MASK, values);
+
+	xcb_set_selection_owner(wm->conn,
+				wm->selection_window,
+				wm->atom.clipboard_manager,
+				XCB_TIME_CURRENT_TIME);
+
+	mask =
+		XCB_XFIXES_SELECTION_EVENT_MASK_SET_SELECTION_OWNER |
+		XCB_XFIXES_SELECTION_EVENT_MASK_SELECTION_WINDOW_DESTROY |
+		XCB_XFIXES_SELECTION_EVENT_MASK_SELECTION_CLIENT_CLOSE;
+	xcb_xfixes_select_selection_input(wm->conn, wm->selection_window,
+					  wm->atom.clipboard, mask);
+
+	xcb_set_selection_owner(wm->conn, XCB_ATOM_NONE,
+			        wm->atom.clipboard, wm->selection_timestamp);
+	xcb_flush(wm->conn);
+}
diff --git a/clients/xwm.c b/clients/xwm.c
new file mode 100644
index 0000000..1f04298
--- /dev/null
+++ b/clients/xwm.c
@@ -0,0 +1,1646 @@
+/*
+ * Copyright © 2011 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of the copyright holders not be used in
+ * advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  The copyright holders make
+ * no representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#define _GNU_SOURCE
+
+#include <stdlib.h>
+#include <sys/un.h>
+#include <unistd.h>
+#include <sys/epoll.h>
+#include <sys/wait.h>
+#include <X11/Xcursor/Xcursor.h>
+
+#include <wayland-client.h>
+#include "xwm.h"
+#include "window.h"
+#include "xserver-client-protocol.h"
+#include "../shared/cairo-util.h"
+#include "../shared/xwayland-hash.h"
+
+struct xwm_window {
+	struct xwm_wm *wm;
+	xcb_window_t id;
+	struct wm_xwin *xwin;
+
+	/* frame border decoration */
+	xcb_window_t frame_id;
+	struct wm_xwin *xwin_frame;
+	cairo_surface_t *cairo_surface;
+	struct task paint_task;
+	int repaint_scheduled;
+
+	int properties_dirty;
+	int pid;
+	char *machine;
+	char *class;
+	char *name;
+	struct xwm_window *transient_for;
+	uint32_t protocols;
+	xcb_atom_t type;
+	int width, height;
+	int x, y;
+	int decorate;
+	int override_redirect;
+};
+
+struct motif_wm_hints {
+	uint32_t flags;
+	uint32_t functions;
+	uint32_t decorations;
+	int32_t input_mode;
+	uint32_t status;
+};
+
+#define MWM_HINTS_FUNCTIONS     (1L << 0)
+#define MWM_HINTS_DECORATIONS   (1L << 1)
+#define MWM_HINTS_INPUT_MODE    (1L << 2)
+#define MWM_HINTS_STATUS        (1L << 3)
+
+#define MWM_FUNC_ALL            (1L << 0)
+#define MWM_FUNC_RESIZE         (1L << 1)
+#define MWM_FUNC_MOVE           (1L << 2)
+#define MWM_FUNC_MINIMIZE       (1L << 3)
+#define MWM_FUNC_MAXIMIZE       (1L << 4)
+#define MWM_FUNC_CLOSE          (1L << 5)
+
+#define MWM_DECOR_ALL           (1L << 0)
+#define MWM_DECOR_BORDER        (1L << 1)
+#define MWM_DECOR_RESIZEH       (1L << 2)
+#define MWM_DECOR_TITLE         (1L << 3)
+#define MWM_DECOR_MENU          (1L << 4)
+#define MWM_DECOR_MINIMIZE      (1L << 5)
+#define MWM_DECOR_MAXIMIZE      (1L << 6)
+
+#define MWM_INPUT_MODELESS 0
+#define MWM_INPUT_PRIMARY_APPLICATION_MODAL 1
+#define MWM_INPUT_SYSTEM_MODAL 2
+#define MWM_INPUT_FULL_APPLICATION_MODAL 3
+#define MWM_INPUT_APPLICATION_MODAL MWM_INPUT_PRIMARY_APPLICATION_MODAL
+
+#define MWM_TEAROFF_WINDOW      (1L<<0)
+
+#define _NET_WM_MOVERESIZE_SIZE_TOPLEFT      0
+#define _NET_WM_MOVERESIZE_SIZE_TOP          1
+#define _NET_WM_MOVERESIZE_SIZE_TOPRIGHT     2
+#define _NET_WM_MOVERESIZE_SIZE_RIGHT        3
+#define _NET_WM_MOVERESIZE_SIZE_BOTTOMRIGHT  4
+#define _NET_WM_MOVERESIZE_SIZE_BOTTOM       5
+#define _NET_WM_MOVERESIZE_SIZE_BOTTOMLEFT   6
+#define _NET_WM_MOVERESIZE_SIZE_LEFT         7
+#define _NET_WM_MOVERESIZE_MOVE              8   /* movement only */
+#define _NET_WM_MOVERESIZE_SIZE_KEYBOARD     9   /* size via keyboard */
+#define _NET_WM_MOVERESIZE_MOVE_KEYBOARD    10   /* move via keyboard */
+#define _NET_WM_MOVERESIZE_CANCEL           11   /* cancel operation */
+
+static void
+xwm_window_draw_decoration(struct xwm_window *window);
+
+static void
+xwm_schedule_task(struct task *task, uint32_t events)
+{
+	struct xwm_window *window =
+		container_of(task, struct xwm_window, paint_task);
+
+	xwm_window_draw_decoration(window);
+	window->repaint_scheduled = 0;
+}
+
+static void
+xwm_window_schedule_repaint(struct xwm_window *window)
+{
+	struct xwm_wm *wm = window->wm;
+
+	if (window->repaint_scheduled)
+		return;
+
+	window->paint_task.run = xwm_schedule_task;
+	display_defer(wm->xwm->display, &window->paint_task);
+	window->repaint_scheduled = 1;
+}
+
+const char *
+get_atom_name(xcb_connection_t *c, xcb_atom_t atom)
+{
+	xcb_get_atom_name_cookie_t cookie;
+	xcb_get_atom_name_reply_t *reply;
+	xcb_generic_error_t *e;
+	static char buffer[64];
+
+	if (atom == XCB_ATOM_NONE)
+		return "None";
+
+	cookie = xcb_get_atom_name (c, atom);
+	reply = xcb_get_atom_name_reply (c, cookie, &e);
+	snprintf(buffer, sizeof buffer, "%.*s",
+		 xcb_get_atom_name_name_length (reply),
+		 xcb_get_atom_name_name (reply));
+	free(reply);
+
+	return buffer;
+}
+
+static xcb_cursor_t
+xcb_cursor_image_load_cursor(struct xwm_wm *wm, const XcursorImage *img)
+{
+	xcb_connection_t *c = wm->conn;
+	xcb_screen_iterator_t s = xcb_setup_roots_iterator(xcb_get_setup(c));
+	xcb_screen_t *screen = s.data;
+	xcb_gcontext_t gc;
+	xcb_pixmap_t pix;
+	xcb_render_picture_t pic;
+	xcb_cursor_t cursor;
+	int stride = img->width * 4;
+
+	pix = xcb_generate_id(c);
+	xcb_create_pixmap(c, 32, pix, screen->root, img->width, img->height);
+
+	pic = xcb_generate_id(c);
+	xcb_render_create_picture(c, pic, pix, wm->format_rgba.id, 0, 0);
+
+	gc = xcb_generate_id(c);
+	xcb_create_gc(c, gc, pix, 0, 0);
+
+	xcb_put_image(c, XCB_IMAGE_FORMAT_Z_PIXMAP, pix, gc,
+		      img->width, img->height, 0, 0, 0, 32,
+		      stride * img->height, (uint8_t *) img->pixels);
+	xcb_free_gc(c, gc);
+
+	cursor = xcb_generate_id(c);
+	xcb_render_create_cursor(c, cursor, pic, img->xhot, img->yhot);
+
+	xcb_render_free_picture(c, pic);
+	xcb_free_pixmap(c, pix);
+
+	return cursor;
+}
+
+static xcb_cursor_t
+xcb_cursor_images_load_cursor(struct xwm_wm *wm, const XcursorImages *images)
+{
+	/* TODO: treat animated cursors as well */
+	if (images->nimage != 1)
+		return -1;
+
+	return xcb_cursor_image_load_cursor(wm, images->images[0]);
+}
+
+static xcb_cursor_t
+xcb_cursor_library_load_cursor(struct xwm_wm *wm, const char *file)
+{
+	xcb_cursor_t cursor;
+	XcursorImages *images;
+	char *v = NULL;
+	int size = 0;
+
+	if (!file)
+		return 0;
+
+	v = getenv ("XCURSOR_SIZE");
+	if (v)
+		size = atoi(v);
+
+	if (!size)
+		size = 32;
+
+	images = XcursorLibraryLoadImages (file, NULL, size);
+	if (!images)
+		return -1;
+
+	cursor = xcb_cursor_images_load_cursor (wm, images);
+	XcursorImagesDestroy (images);
+
+	return cursor;
+}
+
+void
+dump_property(struct xwm_wm *wm,
+	      xcb_atom_t property, xcb_get_property_reply_t *reply)
+{
+	int32_t *incr_value;
+	const char *text_value, *name;
+	xcb_atom_t *atom_value;
+	int width, len;
+	uint32_t i;
+
+	width = fprintf(stderr, "%s: ", get_atom_name(wm->conn, property));
+	if (reply == NULL) {
+		fprintf(stderr, "(no reply)\n");
+		return;
+	}
+
+	width += fprintf(stderr,
+			 "%s/%d, length %d (value_len %d): ",
+			 get_atom_name(wm->conn, reply->type),
+			 reply->format,
+			 xcb_get_property_value_length(reply),
+			 reply->value_len);
+
+	if (reply->type == wm->atom.incr) {
+		incr_value = xcb_get_property_value(reply);
+		fprintf(stderr, "%d\n", *incr_value);
+	} else if (reply->type == wm->atom.utf8_string ||
+	      reply->type == wm->atom.string) {
+		text_value = xcb_get_property_value(reply);
+		if (reply->value_len > 40)
+			len = 40;
+		else
+			len = reply->value_len;
+		fprintf(stderr, "\"%.*s\"\n", len, text_value);
+	} else if (reply->type == XCB_ATOM_ATOM) {
+		atom_value = xcb_get_property_value(reply);
+		for (i = 0; i < reply->value_len; i++) {
+			name = get_atom_name(wm->conn, atom_value[i]);
+			if (width + strlen(name) + 2 > 78) {
+				fprintf(stderr, "\n    ");
+				width = 4;
+			} else if (i > 0) {
+				width +=  fprintf(stderr, ", ");
+			}
+
+			width +=  fprintf(stderr, "%s", name);
+		}
+		fprintf(stderr, "\n");
+	} else {
+		fprintf(stderr, "huh?\n");
+	}
+}
+
+static void
+read_and_dump_property(struct xwm_wm *wm,
+		       xcb_window_t window, xcb_atom_t property)
+{
+	xcb_get_property_reply_t *reply;
+	xcb_get_property_cookie_t cookie;
+
+	cookie = xcb_get_property(wm->conn, 0, window,
+				  property, XCB_ATOM_ANY, 0, 2048);
+	reply = xcb_get_property_reply(wm->conn, cookie, NULL);
+
+	dump_property(wm, property, reply);
+
+	free(reply);
+}
+
+/* We reuse some predefined, but otherwise useles atoms */
+#define TYPE_WM_PROTOCOLS	XCB_ATOM_CUT_BUFFER0
+#define TYPE_MOTIF_WM_HINTS	XCB_ATOM_CUT_BUFFER1
+
+static void
+xwm_window_read_properties(struct xwm_window *window)
+{
+	struct xwm_wm *wm = window->wm;
+
+#define F(field) offsetof(struct xwm_window, field)
+	const struct {
+		xcb_atom_t atom;
+		xcb_atom_t type;
+		int offset;
+	} props[] = {
+		{ XCB_ATOM_WM_CLASS, XCB_ATOM_STRING, F(class) },
+		{ XCB_ATOM_WM_NAME, XCB_ATOM_STRING, F(name) },
+		{ XCB_ATOM_WM_TRANSIENT_FOR, XCB_ATOM_WINDOW, F(transient_for) },
+		{ wm->atom.wm_protocols, TYPE_WM_PROTOCOLS, F(protocols) },
+		{ wm->atom.net_wm_window_type, XCB_ATOM_ATOM, F(type) },
+		{ wm->atom.net_wm_name, XCB_ATOM_STRING, F(name) },
+		{ wm->atom.net_wm_pid, XCB_ATOM_CARDINAL, F(pid) },
+		{ wm->atom.motif_wm_hints, TYPE_MOTIF_WM_HINTS, 0 },
+		{ wm->atom.wm_client_machine, XCB_ATOM_WM_CLIENT_MACHINE, F(machine) },
+	};
+#undef F
+
+	xcb_get_property_cookie_t cookie[ARRAY_LENGTH(props)];
+	xcb_get_property_reply_t *reply;
+	void *p;
+	uint32_t *xid;
+	xcb_atom_t *atom;
+	uint32_t i;
+	struct motif_wm_hints *hints;
+
+	if (!window->properties_dirty)
+		return;
+	window->properties_dirty = 0;
+
+	for (i = 0; i < ARRAY_LENGTH(props); i++)
+		cookie[i] = xcb_get_property(wm->conn,
+					     0, /* delete */
+					     window->id,
+					     props[i].atom,
+					     XCB_ATOM_ANY, 0, 2048);
+
+	window->decorate = !window->override_redirect;
+	for (i = 0; i < ARRAY_LENGTH(props); i++)  {
+		reply = xcb_get_property_reply(wm->conn, cookie[i], NULL);
+		if (!reply)
+			/* Bad window, typically */
+			continue;
+		if (reply->type == XCB_ATOM_NONE) {
+			/* No such property */
+			free(reply);
+			continue;
+		}
+
+		p = ((char *) window + props[i].offset);
+
+		switch (props[i].type) {
+		case XCB_ATOM_WM_CLIENT_MACHINE:
+		case XCB_ATOM_STRING:
+			/* FIXME: We're using this for both string and
+			   utf8_string */
+			if (*(char **) p)
+				free(*(char **) p);
+
+			*(char **) p =
+				strndup(xcb_get_property_value(reply),
+					xcb_get_property_value_length(reply));
+			break;
+		case XCB_ATOM_WINDOW:
+			xid = xcb_get_property_value(reply);
+			*(struct xwm_window **) p =
+				hash_table_lookup(wm->window_hash, *xid);
+			break;
+		case XCB_ATOM_CARDINAL:
+		case XCB_ATOM_ATOM:
+			atom = xcb_get_property_value(reply);
+			*(xcb_atom_t *) p = *atom;
+			break;
+		case TYPE_WM_PROTOCOLS:
+			break;
+		case TYPE_MOTIF_WM_HINTS:
+			hints = xcb_get_property_value(reply);
+			if (hints->flags & MWM_HINTS_DECORATIONS)
+				window->decorate = hints->decorations > 0;
+			break;
+		default:
+			break;
+		}
+		free(reply);
+	}
+}
+
+static void
+xwm_window_get_frame_size(struct xwm_window *window,
+				int *width, int *height)
+{
+	struct theme *t = window->wm->theme;
+
+	if (window->decorate) {
+		*width = window->width + (t->margin + t->width) * 2;
+		*height = window->height +
+			t->margin * 2 + t->width + t->titlebar_height;
+	} else {
+		*width = window->width + t->margin * 2;
+		*height = window->height + t->margin * 2;
+	}
+}
+
+static void
+xwm_window_get_child_position(struct xwm_window *window,
+				    int *x, int *y)
+{
+	struct theme *t = window->wm->theme;
+
+	if (window->decorate) {
+		*x = t->margin + t->width;
+		*y = t->margin + t->titlebar_height;
+	} else {
+		*x = t->margin;
+		*y = t->margin;
+	}
+}
+
+static void
+xwm_handle_configure_request(struct xwm_wm *wm, xcb_generic_event_t *event)
+{
+	xcb_configure_request_event_t *configure_request =
+		(xcb_configure_request_event_t *) event;
+	struct xwm_window *window;
+	uint32_t mask, values[16];
+	int x, y, width, height, i = 0;
+
+	fprintf(stderr, "XCB_CONFIGURE_REQUEST (window %d) %d,%d @ %dx%d\n",
+		configure_request->window,
+		configure_request->x, configure_request->y,
+		configure_request->width, configure_request->height);
+
+	window = hash_table_lookup(wm->window_hash, configure_request->window);
+
+	if (configure_request->value_mask & XCB_CONFIG_WINDOW_WIDTH)
+		window->width = configure_request->width;
+	if (configure_request->value_mask & XCB_CONFIG_WINDOW_HEIGHT)
+		window->height = configure_request->height;
+
+	xwm_window_get_child_position(window, &x, &y);
+	values[i++] = x;
+	values[i++] = y;
+	values[i++] = window->width;
+	values[i++] = window->height;
+	values[i++] = 0;
+	mask = XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y |
+		XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT |
+		XCB_CONFIG_WINDOW_BORDER_WIDTH;
+	if (configure_request->value_mask & XCB_CONFIG_WINDOW_SIBLING) {
+		values[i++] = configure_request->sibling;
+		mask |= XCB_CONFIG_WINDOW_SIBLING;
+	}
+	if (configure_request->value_mask & XCB_CONFIG_WINDOW_STACK_MODE) {
+		values[i++] = configure_request->stack_mode;
+		mask |= XCB_CONFIG_WINDOW_STACK_MODE;
+	}
+
+	xcb_configure_window(wm->conn, window->id, mask, values);
+
+	xwm_window_get_frame_size(window, &width, &height);
+	values[0] = width;
+	values[1] = height;
+	mask = XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT;
+	xcb_configure_window(wm->conn, window->frame_id, mask, values);
+
+	xwm_window_schedule_repaint(window);
+}
+
+static void
+xwm_handle_configure_notify(struct xwm_wm *wm, xcb_generic_event_t *event)
+{
+	xcb_configure_notify_event_t *configure_notify =
+		(xcb_configure_notify_event_t *) event;
+	struct xwm_window *window;
+	int x, y;
+
+	window = hash_table_lookup(wm->window_hash, configure_notify->window);
+
+	fprintf(stderr, "XCB_CONFIGURE_NOTIFY (%s window %d) %d,%d @ %dx%d\n",
+		configure_notify->window == window->id ? "client" : "frame",
+		configure_notify->window,
+		configure_notify->x, configure_notify->y,
+		configure_notify->width, configure_notify->height);
+
+	/* resize falls here */
+	if (configure_notify->window != window->id)
+		return;
+
+	xwm_window_get_child_position(window, &x, &y);
+	window->x = configure_notify->x - x;
+	window->y = configure_notify->y - y;
+
+	wm_xwin_set_window(window->xwin, window->x, window->y,
+		      configure_notify->width, configure_notify->height,
+		      window->override_redirect);
+	wl_display_flush(wm->xwm->wl_display);
+}
+
+static int
+our_resource(struct xwm_wm *wm, uint32_t id)
+{
+	const xcb_setup_t *setup;
+
+	setup = xcb_get_setup(wm->conn);
+
+	return (id & ~setup->resource_id_mask) == setup->resource_id_base;
+}
+
+#define ICCCM_WITHDRAWN_STATE	0
+#define ICCCM_NORMAL_STATE	1
+#define ICCCM_ICONIC_STATE	3
+
+static void
+xwm_window_set_state(struct xwm_window *window, int32_t state)
+{
+	struct xwm_wm *wm = window->wm;
+	uint32_t property[2];
+
+	property[0] = state;
+	property[1] = XCB_WINDOW_NONE;
+
+	xcb_change_property(wm->conn,
+			    XCB_PROP_MODE_REPLACE,
+			    window->id,
+			    wm->atom.wm_state,
+			    wm->atom.wm_state,
+			    32, /* format */
+			    2, property);
+}
+
+static void
+handle_configure(void *data, struct wm_xwin *xwin, uint32_t edges,
+		 int width, int height)
+{
+	struct xwm_window *window = data;
+	struct xwm_wm *wm = window->wm;
+	struct theme *t = wm->theme;
+	uint32_t values[2];
+
+	if (window->decorate) {
+		window->width = width - 2 * (t->margin + t->width);
+		window->height = height - 2 * t->margin -
+			t->titlebar_height - t->width;
+	} else {
+		window->width = width - 2 * t->margin;
+		window->height = height - 2 * t->margin;
+	}
+
+	values[0] = window->width;
+	values[1] = window->height;
+	xcb_configure_window(wm->conn,
+			     window->id,
+			     XCB_CONFIG_WINDOW_WIDTH |
+			     XCB_CONFIG_WINDOW_HEIGHT,
+			     values);
+
+	xwm_window_get_frame_size(window, &width, &height);
+	values[0] = width;
+	values[1] = height;
+	xcb_configure_window(wm->conn,
+			     window->frame_id,
+			     XCB_CONFIG_WINDOW_WIDTH |
+			     XCB_CONFIG_WINDOW_HEIGHT,
+			     values);
+	xcb_flush(wm->conn);
+
+	xwm_window_schedule_repaint(window);
+}
+
+static void
+set_state_activate(struct xwm *xwm, struct xwm_window *window)
+{
+	struct xwm_wm *wm = xwm->xwm_wm;
+	xcb_client_message_event_t client_message;
+
+	if (window) {
+		client_message.response_type = XCB_CLIENT_MESSAGE;
+		client_message.format = 32;
+		client_message.window = window->id;
+		client_message.type = wm->atom.wm_protocols;
+		client_message.data.data32[0] = wm->atom.wm_take_focus;
+		client_message.data.data32[1] = XCB_TIME_CURRENT_TIME;
+
+		xcb_send_event(wm->conn, 0, window->id,
+			       XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT,
+			       (char *) &client_message);
+
+		xcb_set_input_focus (wm->conn, XCB_INPUT_FOCUS_POINTER_ROOT,
+				     window->id, XCB_TIME_CURRENT_TIME);
+	} else {
+		xcb_set_input_focus (wm->conn,
+				     XCB_INPUT_FOCUS_POINTER_ROOT,
+				     XCB_NONE,
+				     XCB_TIME_CURRENT_TIME);
+	}
+
+	if (wm->focus_window)
+		xwm_window_schedule_repaint(wm->focus_window);
+	wm->focus_window = window;
+	if (wm->focus_window)
+		xwm_window_schedule_repaint(wm->focus_window);
+}
+
+static void
+set_state_kill(struct xwm_window *window)
+{
+        char name[1024];
+
+        gethostname(name, 1024);
+
+        /* this is only one heuristic to guess the PID of a client is valid,
+         * assuming it's compliant with icccm and ewmh. Non-compliants and
+         * remote applications of course fail. */
+        if (!strcmp(window->machine, name) && window->pid != 0)
+                kill(window->pid, SIGKILL);
+}
+
+static void
+handle_state(void *data, struct wm_xwin *xwin, enum wm_xwin_state state)
+{
+	struct xwm_window *window = data;
+
+	switch (state) {
+	case WM_XWIN_STATE_ACTIVATE:
+		set_state_activate(window->wm->xwm, window);
+		break;
+	case WM_XWIN_STATE_KILL:
+		set_state_kill(window);
+		break;
+	}
+}
+
+static const struct wm_xwin_listener wm_xwin_listener = {
+	handle_configure,
+	handle_state
+};
+
+static void
+xwm_handle_map_request(struct xwm_wm *wm, xcb_generic_event_t *event)
+{
+	xcb_map_request_event_t *map_request =
+		(xcb_map_request_event_t *) event;
+	struct xwm_window *window;
+	uint32_t values[1];
+	int x, y, width, height;
+
+	if (our_resource(wm, map_request->window)) {
+		fprintf(stderr, "XCB_MAP_REQUEST (window %d, ours)\n",
+			map_request->window);
+		return;
+	}
+
+	window = hash_table_lookup(wm->window_hash, map_request->window);
+
+	if (window->frame_id)
+		return;
+
+	xwm_window_read_properties(window);
+
+	xwm_window_get_frame_size(window, &width, &height);
+	xwm_window_get_child_position(window, &x, &y);
+
+	values[0] =
+		XCB_EVENT_MASK_KEY_PRESS |
+		XCB_EVENT_MASK_KEY_RELEASE |
+		XCB_EVENT_MASK_BUTTON_PRESS |
+		XCB_EVENT_MASK_BUTTON_RELEASE |
+		XCB_EVENT_MASK_POINTER_MOTION |
+		XCB_EVENT_MASK_ENTER_WINDOW |
+		XCB_EVENT_MASK_LEAVE_WINDOW |
+		XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY |
+		XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT;
+
+	window->frame_id = xcb_generate_id(wm->conn);
+	xcb_create_window(wm->conn,
+			  XCB_COPY_FROM_PARENT,
+			  window->frame_id,
+			  wm->screen->root,
+			  0, 0,
+			  width, height,
+			  0,
+			  XCB_WINDOW_CLASS_INPUT_OUTPUT,
+			  wm->screen->root_visual,
+			  XCB_CW_EVENT_MASK, values);
+	xcb_reparent_window(wm->conn, window->id, window->frame_id, x, y);
+
+	window->xwin_frame = wm_create_xwindow(wm->xwm->wm, window->frame_id);
+	wm_xwin_add_listener(window->xwin_frame, &wm_xwin_listener, window);
+	hash_table_insert(wm->window_hash, window->frame_id, window);
+	wm_xwin_set_window(window->xwin_frame, window->x, window->y,
+			   width, height, 0);
+
+	wl_display_flush(wm->xwm->wl_display);
+
+	values[0] = 0;
+	xcb_configure_window(wm->conn, window->id,
+			     XCB_CONFIG_WINDOW_BORDER_WIDTH, values);
+
+	fprintf(stderr, "XCB_MAP_REQUEST (window %d, %p, frame %d)\n",
+		window->id, window, window->frame_id);
+
+	xcb_map_window(wm->conn, map_request->window);
+	xcb_map_window(wm->conn, window->frame_id);
+	xwm_window_set_state(window, ICCCM_NORMAL_STATE);
+
+	window->cairo_surface =
+		cairo_xcb_surface_create_with_xrender_format(wm->conn,
+							     wm->screen,
+							     window->frame_id,
+							     &wm->format_rgb,
+							     width, height);
+}
+
+static void
+xwm_handle_map_notify(struct xwm_wm *wm, xcb_generic_event_t *event)
+{
+	xcb_map_notify_event_t *map_notify = (xcb_map_notify_event_t *) event;
+	struct xwm_window *window;
+
+	window = hash_table_lookup(wm->window_hash, map_notify->window);
+	if (our_resource(wm, map_notify->window)) {
+		wm_xwin_map(window->xwin_frame);
+
+		fprintf(stderr, "XCB_MAP_NOTIFY (window %d, ours)\n",
+			map_notify->window);
+		return;
+	}
+
+	wm_xwin_map(window->xwin);
+	fprintf(stderr, "XCB_MAP_NOTIFY (window %d)\n", map_notify->window);
+}
+
+static void
+xwm_handle_unmap_notify(struct xwm_wm *wm, xcb_generic_event_t *event)
+{
+	xcb_unmap_notify_event_t *unmap_notify =
+		(xcb_unmap_notify_event_t *) event;
+	struct xwm_window *window;
+
+	fprintf(stderr, "XCB_UNMAP_NOTIFY (window %d, event %d%s)\n",
+		unmap_notify->window,
+		unmap_notify->event,
+		our_resource(wm, unmap_notify->window) ? ", ours" : "");
+
+	if (our_resource(wm, unmap_notify->window))
+		return;
+
+	if (unmap_notify->response_type & 0x80)
+		/* We just ignore the ICCCM 4.1.4 synthetic unmap notify
+		 * as it may come in after we've destroyed the window. */
+		return;
+
+	window = hash_table_lookup(wm->window_hash, unmap_notify->window);
+	if (window->cairo_surface)
+		cairo_surface_destroy(window->cairo_surface);
+
+	if (window->frame_id) {
+		xcb_reparent_window(wm->conn, window->id, wm->wm_window, 0, 0);
+		xcb_destroy_window(wm->conn, window->frame_id);
+		xwm_window_set_state(window, ICCCM_WITHDRAWN_STATE);
+		hash_table_remove(wm->window_hash, window->frame_id);
+		window->frame_id = XCB_WINDOW_NONE;
+	}
+
+	if (wm->focus_window == window)
+		wm->focus_window = NULL;
+	/*TODO: need to send a message to remove the window on compositor */
+}
+
+static void
+xwm_window_draw_decoration(struct xwm_window *window)
+{
+	struct xwm_wm *wm = window->wm;
+	struct theme *t = wm->theme;
+	struct wl_region *region;
+	cairo_t *cr;
+	int x, y, width, height;
+	const char *title;
+	uint32_t flags = 0;
+
+	if (window->frame_id == XCB_WINDOW_NONE) {
+		xwm_window_get_frame_size(window, &width, &height);
+		region = wl_compositor_create_region(wm->xwm->compositor);
+		wl_region_add(region, 0, 0, width, height);
+		wm_xwin_set_opaque_override(window->xwin, region);
+		wl_region_destroy(region);
+		return;
+	}
+
+	xwm_window_read_properties(window);
+
+	xwm_window_get_frame_size(window, &width, &height);
+	xwm_window_get_child_position(window, &x, &y);
+
+	cairo_xcb_surface_set_size(window->cairo_surface, width, height);
+	cr = cairo_create(window->cairo_surface);
+
+	if (window->decorate) {
+		if (wm->focus_window == window)
+			flags |= THEME_FRAME_ACTIVE;
+
+		if (window->name)
+			title = window->name;
+		else
+			title = "untitled";
+
+		theme_render_frame(t, cr, width, height, title, flags);
+	} else {
+		cairo_set_operator(cr, CAIRO_OPERATOR_SOURCE);
+		cairo_set_source_rgba(cr, 0, 0, 0, 0);
+		cairo_paint(cr);
+
+		cairo_set_operator(cr, CAIRO_OPERATOR_OVER);
+		cairo_set_source_rgba(cr, 0, 0, 0, 0.45);
+		tile_mask(cr, t->shadow, 2, 2, width + 8, height + 8, 64, 64);
+	}
+	xcb_flush(window->wm->conn);
+
+	cairo_destroy(cr);
+
+	region = wl_compositor_create_region(wm->xwm->compositor);
+	/* We leave an extra pixel around the X window area to make sure we
+	 * don't sample from the undefined alpha channel when filtering. */
+	wl_region_add(region, x - 1, y - 1,
+		      window->width + 2, window->height + 2);
+	wm_xwin_set_opaque_override(window->xwin_frame, region);
+	wl_region_destroy(region);
+
+	region = wl_compositor_create_region(wm->xwm->compositor);
+	wl_region_add(region, t->margin, t->margin,
+		      width - 2 * t->margin, height - 2 * t->margin);
+	wm_xwin_set_input_region(window->xwin_frame, region);
+	wl_region_destroy(region);
+}
+
+static void
+xwm_handle_property_notify(struct xwm_wm *wm, xcb_generic_event_t *event)
+{
+	xcb_property_notify_event_t *property_notify =
+		(xcb_property_notify_event_t *) event;
+	struct xwm_window *window;
+
+	window = hash_table_lookup(wm->window_hash, property_notify->window);
+	if (window)
+		window->properties_dirty = 1;
+
+	fprintf(stderr, "XCB_PROPERTY_NOTIFY: window %d, ",
+		property_notify->window);
+	if (property_notify->state == XCB_PROPERTY_DELETE)
+		fprintf(stderr, "deleted\n");
+	else
+		read_and_dump_property(wm, property_notify->window,
+				       property_notify->atom);
+
+	if (property_notify->atom == wm->atom.net_wm_name ||
+	    property_notify->atom == XCB_ATOM_WM_NAME)
+		xwm_window_schedule_repaint(window);
+}
+
+static void
+xwm_window_create(struct xwm_wm *wm,
+			xcb_window_t id, int width, int height, int override)
+{
+	struct xwm_window *window;
+	uint32_t values[1];
+
+	window = malloc(sizeof *window);
+	if (window == NULL) {
+		fprintf(stderr, "failed to allocate window\n");
+		return;
+	}
+
+	values[0] = XCB_EVENT_MASK_PROPERTY_CHANGE;
+	xcb_change_window_attributes(wm->conn, id, XCB_CW_EVENT_MASK, values);
+
+	memset(window, 0, sizeof *window);
+	window->wm = wm;
+	window->id = id;
+	window->repaint_scheduled = 0;
+	window->properties_dirty = 1;
+	window->override_redirect = override;
+	window->width = width;
+	window->height = height;
+
+	window->xwin = wm_create_xwindow(wm->xwm->wm, id);
+	wm_xwin_add_listener(window->xwin, &wm_xwin_listener, window);
+	hash_table_insert(wm->window_hash, id, window);
+	wm_xwin_set_window(window->xwin, window->x, window->y,
+			   width, height, window->override_redirect);
+
+	wl_display_flush(wm->xwm->wl_display);
+}
+
+static void
+xwm_window_destroy(struct xwm_window *window)
+{
+	hash_table_remove(window->wm->window_hash, window->id);
+	free(window);
+}
+
+static void
+xwm_handle_create_notify(struct xwm_wm *wm, xcb_generic_event_t *event)
+{
+	xcb_create_notify_event_t *create_notify =
+		(xcb_create_notify_event_t *) event;
+
+	fprintf(stderr, "XCB_CREATE_NOTIFY (window %d, width %d, height %d%s%s)\n",
+		create_notify->window,
+		create_notify->width, create_notify->height,
+		create_notify->override_redirect ? ", override" : "",
+		our_resource(wm, create_notify->window) ? ", ours" : "");
+
+	if (our_resource(wm, create_notify->window))
+		return;
+
+	xwm_window_create(wm, create_notify->window,
+				create_notify->width, create_notify->height,
+				create_notify->override_redirect);
+}
+
+static void
+xwm_handle_destroy_notify(struct xwm_wm *wm, xcb_generic_event_t *event)
+{
+	xcb_destroy_notify_event_t *destroy_notify =
+		(xcb_destroy_notify_event_t *) event;
+	struct xwm_window *window;
+
+	fprintf(stderr, "XCB_DESTROY_NOTIFY, win %d, event %d%s\n",
+		destroy_notify->window,
+		destroy_notify->event,
+		our_resource(wm, destroy_notify->window) ? ", ours" : "");
+
+	if (our_resource(wm, destroy_notify->window))
+		return;
+
+	window = hash_table_lookup(wm->window_hash, destroy_notify->window);
+	xwm_window_destroy(window);
+}
+
+static void
+xwm_handle_reparent_notify(struct xwm_wm *wm, xcb_generic_event_t *event)
+{
+	xcb_reparent_notify_event_t *reparent_notify =
+		(xcb_reparent_notify_event_t *) event;
+	struct xwm_window *window;
+
+	fprintf(stderr, "XCB_REPARENT_NOTIFY (window %d, parent %d, event %d)\n",
+		reparent_notify->window,
+		reparent_notify->parent,
+		reparent_notify->event);
+
+	if (reparent_notify->parent == wm->screen->root) {
+		xwm_window_create(wm, reparent_notify->window, 10, 10,
+					reparent_notify->override_redirect);
+	} else if (!our_resource(wm, reparent_notify->parent)) {
+		window = hash_table_lookup(wm->window_hash,
+					   reparent_notify->window);
+		xwm_window_destroy(window);
+	}
+}
+
+static void
+xwm_window_handle_moveresize(struct xwm_window *window,
+				   xcb_client_message_event_t *client_message)
+{
+	static const int map[] = {
+		THEME_LOCATION_RESIZING_TOP_LEFT,
+		THEME_LOCATION_RESIZING_TOP,
+		THEME_LOCATION_RESIZING_TOP_RIGHT,
+		THEME_LOCATION_RESIZING_RIGHT,
+		THEME_LOCATION_RESIZING_BOTTOM_RIGHT,
+		THEME_LOCATION_RESIZING_BOTTOM,
+		THEME_LOCATION_RESIZING_BOTTOM_LEFT,
+		THEME_LOCATION_RESIZING_LEFT
+	};
+	int detail;
+
+	detail = client_message->data.data32[2];
+	switch (detail) {
+	case _NET_WM_MOVERESIZE_MOVE:
+		wm_xwin_move(window->xwin_frame);
+		break;
+	case _NET_WM_MOVERESIZE_SIZE_TOPLEFT:
+	case _NET_WM_MOVERESIZE_SIZE_TOP:
+	case _NET_WM_MOVERESIZE_SIZE_TOPRIGHT:
+	case _NET_WM_MOVERESIZE_SIZE_RIGHT:
+	case _NET_WM_MOVERESIZE_SIZE_BOTTOMRIGHT:
+	case _NET_WM_MOVERESIZE_SIZE_BOTTOM:
+	case _NET_WM_MOVERESIZE_SIZE_BOTTOMLEFT:
+	case _NET_WM_MOVERESIZE_SIZE_LEFT:
+		wm_xwin_resize(window->xwin_frame, map[detail]);
+		break;
+	case _NET_WM_MOVERESIZE_CANCEL:
+		break;
+	}
+}
+
+static void
+xwm_handle_client_message(struct xwm_wm *wm, xcb_generic_event_t *event)
+{
+	xcb_client_message_event_t *client_message =
+		(xcb_client_message_event_t *) event;
+	struct xwm_window *window;
+
+	window = hash_table_lookup(wm->window_hash, client_message->window);
+
+	fprintf(stderr, "XCB_CLIENT_MESSAGE (%s %d %d %d %d %d)\n",
+		get_atom_name(wm->conn, client_message->type),
+		client_message->data.data32[0],
+		client_message->data.data32[1],
+		client_message->data.data32[2],
+		client_message->data.data32[3],
+		client_message->data.data32[4]);
+
+	if (client_message->type == wm->atom.net_wm_moveresize)
+		xwm_window_handle_moveresize(window, client_message);
+}
+
+enum xwm_cursor_type {
+	XWM_CURSOR_TOP,
+	XWM_CURSOR_BOTTOM,
+	XWM_CURSOR_LEFT,
+	XWM_CURSOR_RIGHT,
+	XWM_CURSOR_TOP_LEFT,
+	XWM_CURSOR_TOP_RIGHT,
+	XWM_CURSOR_BOTTOM_LEFT,
+	XWM_CURSOR_BOTTOM_RIGHT,
+	XWM_CURSOR_LEFT_PTR,
+};
+
+static const char *cursors[] = {
+	"top_side",
+	"bottom_side",
+	"left_side",
+	"right_side",
+	"top_left_corner",
+	"top_right_corner",
+	"bottom_left_corner",
+	"bottom_right_corner",
+	"left_ptr"
+};
+
+static void
+xwm_create_cursors(struct xwm_wm *wm)
+{
+	int i, count = ARRAY_LENGTH(cursors);
+
+	wm->cursors = malloc(count * sizeof(xcb_cursor_t));
+	for (i = 0; i < count; i++) {
+		wm->cursors[i] =
+			xcb_cursor_library_load_cursor(wm, cursors[i]);
+	}
+
+	wm->last_cursor = -1;
+}
+
+static void
+xwm_destroy_cursors(struct xwm_wm *wm)
+{
+	uint8_t i;
+
+	for (i = 0; i < ARRAY_LENGTH(cursors); i++)
+		xcb_free_cursor(wm->conn, wm->cursors[i]);
+
+	free(wm->cursors);
+}
+
+static int
+get_cursor_for_location(struct theme *t, int width, int height, int x, int y)
+{
+	int location = theme_get_location(t, x, y, width, height, 0);
+
+	switch (location) {
+		case THEME_LOCATION_RESIZING_TOP:
+			return XWM_CURSOR_TOP;
+		case THEME_LOCATION_RESIZING_BOTTOM:
+			return XWM_CURSOR_BOTTOM;
+		case THEME_LOCATION_RESIZING_LEFT:
+			return XWM_CURSOR_LEFT;
+		case THEME_LOCATION_RESIZING_RIGHT:
+			return XWM_CURSOR_RIGHT;
+		case THEME_LOCATION_RESIZING_TOP_LEFT:
+			return XWM_CURSOR_TOP_LEFT;
+		case THEME_LOCATION_RESIZING_TOP_RIGHT:
+			return XWM_CURSOR_TOP_RIGHT;
+		case THEME_LOCATION_RESIZING_BOTTOM_LEFT:
+			return XWM_CURSOR_BOTTOM_LEFT;
+		case THEME_LOCATION_RESIZING_BOTTOM_RIGHT:
+			return XWM_CURSOR_BOTTOM_RIGHT;
+		case THEME_LOCATION_EXTERIOR:
+		case THEME_LOCATION_TITLEBAR:
+		default:
+			return XWM_CURSOR_LEFT_PTR;
+	}
+}
+
+static void
+xwm_window_set_cursor(struct xwm_wm *wm, xcb_window_t window_id, int cursor)
+{
+	uint32_t cursor_value_list;
+
+	if (wm->last_cursor == cursor)
+		return;
+
+	wm->last_cursor = cursor;
+
+	cursor_value_list = wm->cursors[cursor];
+	xcb_change_window_attributes (wm->conn, window_id,
+				      XCB_CW_CURSOR, &cursor_value_list);
+	xcb_flush(wm->conn);
+}
+
+static void
+xwm_handle_button(struct xwm_wm *wm, xcb_generic_event_t *event)
+{
+	xcb_button_press_event_t *button = (xcb_button_press_event_t *) event;
+	struct xwm_window *window;
+	enum theme_location location;
+	struct theme *t = wm->theme;
+	int width, height;
+
+	fprintf(stderr, "XCB_BUTTON_%s (detail %d)\n",
+		button->response_type == XCB_BUTTON_PRESS ?
+		"PRESS" : "RELEASE", button->detail);
+
+	window = hash_table_lookup(wm->window_hash, button->event);
+	xwm_window_get_frame_size(window, &width, &height);
+
+	if (button->response_type == XCB_BUTTON_PRESS &&
+	    button->detail == 1) {
+		location = theme_get_location(t,
+					      button->event_x,
+					      button->event_y,
+					      width, height, 0);
+
+		switch (location) {
+		case THEME_LOCATION_TITLEBAR:
+			wm_xwin_move(window->xwin_frame);
+			break;
+		case THEME_LOCATION_RESIZING_TOP:
+		case THEME_LOCATION_RESIZING_BOTTOM:
+		case THEME_LOCATION_RESIZING_LEFT:
+		case THEME_LOCATION_RESIZING_RIGHT:
+		case THEME_LOCATION_RESIZING_TOP_LEFT:
+		case THEME_LOCATION_RESIZING_TOP_RIGHT:
+		case THEME_LOCATION_RESIZING_BOTTOM_LEFT:
+		case THEME_LOCATION_RESIZING_BOTTOM_RIGHT:
+			wm_xwin_resize(window->xwin_frame, location);
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+static void
+xwm_handle_motion(struct xwm_wm *wm, xcb_generic_event_t *event)
+{
+	xcb_motion_notify_event_t *motion = (xcb_motion_notify_event_t *) event;
+	struct xwm_window *window;
+	int cursor, width, height;
+
+	window = hash_table_lookup(wm->window_hash, motion->event);
+	if (!window || !window->decorate)
+		return;
+
+	xwm_window_get_frame_size(window, &width, &height);
+	cursor = get_cursor_for_location(wm->theme, width, height,
+					 motion->event_x, motion->event_y);
+
+	xwm_window_set_cursor(wm, window->frame_id, cursor);
+}
+
+static void
+xwm_handle_enter(struct xwm_wm *wm, xcb_generic_event_t *event)
+{
+	xcb_enter_notify_event_t *enter = (xcb_enter_notify_event_t *) event;
+	struct xwm_window *window;
+	int cursor, width, height;
+
+	window = hash_table_lookup(wm->window_hash, enter->event);
+	if (!window || !window->decorate)
+		return;
+
+	xwm_window_get_frame_size(window, &width, &height);
+	cursor = get_cursor_for_location(wm->theme, width, height,
+					 enter->event_x, enter->event_y);
+
+	xwm_window_set_cursor(wm, window->frame_id, cursor);
+}
+
+static void
+xwm_handle_leave(struct xwm_wm *wm, xcb_generic_event_t *event)
+{
+	xcb_leave_notify_event_t *leave = (xcb_leave_notify_event_t *) event;
+	struct xwm_window *window;
+
+	window = hash_table_lookup(wm->window_hash, leave->event);
+	if (!window || !window->decorate)
+		return;
+
+	xwm_window_set_cursor(wm, window->frame_id, XWM_CURSOR_LEFT_PTR);
+}
+
+static int
+xwm_handle_event(int fd, uint32_t mask, void *data)
+{
+	struct xwm_wm *wm = data;
+	xcb_generic_event_t *event;
+	int count = 0;
+
+	while (event = xcb_poll_for_event(wm->conn), event != NULL) {
+		if (xwm_handle_selection_event(wm, event)) {
+			free(event);
+			count++;
+			continue;
+		}
+
+		switch (event->response_type & ~0x80) {
+		case XCB_BUTTON_PRESS:
+		case XCB_BUTTON_RELEASE:
+			xwm_handle_button(wm, event);
+			break;
+		case XCB_ENTER_NOTIFY:
+			xwm_handle_enter(wm, event);
+			break;
+		case XCB_LEAVE_NOTIFY:
+			xwm_handle_leave(wm, event);
+			break;
+		case XCB_MOTION_NOTIFY:
+			xwm_handle_motion(wm, event);
+			break;
+		case XCB_CREATE_NOTIFY:
+			xwm_handle_create_notify(wm, event);
+			break;
+		case XCB_MAP_REQUEST:
+			xwm_handle_map_request(wm, event);
+			break;
+		case XCB_MAP_NOTIFY:
+			xwm_handle_map_notify(wm, event);
+			break;
+		case XCB_UNMAP_NOTIFY:
+			xwm_handle_unmap_notify(wm, event);
+			break;
+		case XCB_REPARENT_NOTIFY:
+			xwm_handle_reparent_notify(wm, event);
+			break;
+		case XCB_CONFIGURE_REQUEST:
+			xwm_handle_configure_request(wm, event);
+			break;
+		case XCB_CONFIGURE_NOTIFY:
+			xwm_handle_configure_notify(wm, event);
+			break;
+		case XCB_DESTROY_NOTIFY:
+			xwm_handle_destroy_notify(wm, event);
+			break;
+		case XCB_MAPPING_NOTIFY:
+			fprintf(stderr, "XCB_MAPPING_NOTIFY\n");
+			break;
+		case XCB_PROPERTY_NOTIFY:
+			xwm_handle_property_notify(wm, event);
+			break;
+		case XCB_CLIENT_MESSAGE:
+			xwm_handle_client_message(wm, event);
+			break;
+		}
+
+		free(event);
+		count++;
+	}
+
+	xcb_flush(wm->conn);
+
+	return count;
+}
+
+static void
+xwm_get_resources(struct xwm_wm *wm)
+{
+
+#define F(field) offsetof(struct xwm_wm, field)
+
+	static const struct { const char *name; int offset; } atoms[] = {
+		{ "WM_PROTOCOLS",	F(atom.wm_protocols) },
+		{ "WM_TAKE_FOCUS",	F(atom.wm_take_focus) },
+		{ "WM_DELETE_WINDOW",	F(atom.wm_delete_window) },
+		{ "WM_STATE",		F(atom.wm_state) },
+		{ "WM_S0",		F(atom.wm_s0) },
+		{ "WM_CLIENT_MACHINE",	F(atom.wm_client_machine) },
+		{ "_NET_WM_NAME",	F(atom.net_wm_name) },
+		{ "_NET_WM_PID",	F(atom.net_wm_pid) },
+		{ "_NET_WM_ICON",	F(atom.net_wm_icon) },
+		{ "_NET_WM_STATE",	F(atom.net_wm_state) },
+		{ "_NET_WM_STATE_FULLSCREEN", F(atom.net_wm_state_fullscreen) },
+		{ "_NET_WM_USER_TIME", F(atom.net_wm_user_time) },
+		{ "_NET_WM_ICON_NAME", F(atom.net_wm_icon_name) },
+		{ "_NET_WM_WINDOW_TYPE", F(atom.net_wm_window_type) },
+
+		{ "_NET_WM_WINDOW_TYPE_DESKTOP", F(atom.net_wm_window_type_desktop) },
+		{ "_NET_WM_WINDOW_TYPE_DOCK", F(atom.net_wm_window_type_dock) },
+		{ "_NET_WM_WINDOW_TYPE_TOOLBAR", F(atom.net_wm_window_type_toolbar) },
+		{ "_NET_WM_WINDOW_TYPE_MENU", F(atom.net_wm_window_type_menu) },
+		{ "_NET_WM_WINDOW_TYPE_UTILITY", F(atom.net_wm_window_type_utility) },
+		{ "_NET_WM_WINDOW_TYPE_SPLASH", F(atom.net_wm_window_type_splash) },
+		{ "_NET_WM_WINDOW_TYPE_DIALOG", F(atom.net_wm_window_type_dialog) },
+		{ "_NET_WM_WINDOW_TYPE_DROPDOWN_MENU", F(atom.net_wm_window_type_dropdown) },
+		{ "_NET_WM_WINDOW_TYPE_POPUP_MENU", F(atom.net_wm_window_type_popup) },
+		{ "_NET_WM_WINDOW_TYPE_TOOLTIP", F(atom.net_wm_window_type_tooltip) },
+		{ "_NET_WM_WINDOW_TYPE_NOTIFICATION", F(atom.net_wm_window_type_notification) },
+		{ "_NET_WM_WINDOW_TYPE_COMBO", F(atom.net_wm_window_type_combo) },
+		{ "_NET_WM_WINDOW_TYPE_DND", F(atom.net_wm_window_type_dnd) },
+		{ "_NET_WM_WINDOW_TYPE_NORMAL",	F(atom.net_wm_window_type_normal) },
+
+		{ "_NET_WM_MOVERESIZE", F(atom.net_wm_moveresize) },
+		{ "_NET_SUPPORTING_WM_CHECK",
+					F(atom.net_supporting_wm_check) },
+		{ "_NET_SUPPORTED",     F(atom.net_supported) },
+		{ "_MOTIF_WM_HINTS",	F(atom.motif_wm_hints) },
+		{ "CLIPBOARD",		F(atom.clipboard) },
+		{ "CLIPBOARD_MANAGER",	F(atom.clipboard_manager) },
+		{ "TARGETS",		F(atom.targets) },
+		{ "UTF8_STRING",	F(atom.utf8_string) },
+		{ "_WL_SELECTION",	F(atom.wl_selection) },
+		{ "INCR",		F(atom.incr) },
+		{ "TIMESTAMP",		F(atom.timestamp) },
+		{ "MULTIPLE",		F(atom.multiple) },
+		{ "UTF8_STRING"	,	F(atom.utf8_string) },
+		{ "COMPOUND_TEXT",	F(atom.compound_text) },
+		{ "TEXT",		F(atom.text) },
+		{ "STRING",		F(atom.string) },
+		{ "text/plain;charset=utf-8",	F(atom.text_plain_utf8) },
+		{ "text/plain",		F(atom.text_plain) },
+	};
+#undef F
+
+	xcb_xfixes_query_version_cookie_t xfixes_cookie;
+	xcb_xfixes_query_version_reply_t *xfixes_reply;
+	xcb_intern_atom_cookie_t cookies[ARRAY_LENGTH(atoms)];
+	xcb_intern_atom_reply_t *reply;
+	xcb_render_query_pict_formats_reply_t *formats_reply;
+	xcb_render_query_pict_formats_cookie_t formats_cookie;
+	xcb_render_pictforminfo_t *formats;
+	uint32_t i;
+
+	xcb_prefetch_extension_data (wm->conn, &xcb_xfixes_id);
+
+	formats_cookie = xcb_render_query_pict_formats(wm->conn);
+
+	for (i = 0; i < ARRAY_LENGTH(atoms); i++)
+		cookies[i] = xcb_intern_atom (wm->conn, 0,
+					      strlen(atoms[i].name),
+					      atoms[i].name);
+
+	for (i = 0; i < ARRAY_LENGTH(atoms); i++) {
+		reply = xcb_intern_atom_reply (wm->conn, cookies[i], NULL);
+		*(xcb_atom_t *) ((char *) wm + atoms[i].offset) = reply->atom;
+		free(reply);
+	}
+
+	wm->xfixes = xcb_get_extension_data(wm->conn, &xcb_xfixes_id);
+	if (!wm->xfixes || !wm->xfixes->present)
+		fprintf(stderr, "xfixes not available\n");
+
+	xfixes_cookie = xcb_xfixes_query_version(wm->conn,
+						 XCB_XFIXES_MAJOR_VERSION,
+						 XCB_XFIXES_MINOR_VERSION);
+	xfixes_reply = xcb_xfixes_query_version_reply(wm->conn,
+						      xfixes_cookie, NULL);
+
+	fprintf(stderr, "xfixes version: %d.%d\n",
+	       xfixes_reply->major_version, xfixes_reply->minor_version);
+
+	free(xfixes_reply);
+
+	formats_reply = xcb_render_query_pict_formats_reply(wm->conn,
+							    formats_cookie, 0);
+	if (formats_reply == NULL)
+		return;
+
+	formats = xcb_render_query_pict_formats_formats(formats_reply);
+	for (i = 0; i < formats_reply->num_formats; i++) {
+		if (formats[i].direct.red_mask != 0xff &&
+		    formats[i].direct.red_shift != 16)
+			continue;
+		if (formats[i].type == XCB_RENDER_PICT_TYPE_DIRECT &&
+		    formats[i].depth == 24)
+			wm->format_rgb = formats[i];
+		if (formats[i].type == XCB_RENDER_PICT_TYPE_DIRECT &&
+		    formats[i].depth == 32 &&
+		    formats[i].direct.alpha_mask == 0xff &&
+		    formats[i].direct.alpha_shift == 24)
+			wm->format_rgba = formats[i];
+	}
+
+	free(formats_reply);
+}
+
+static void
+xwm_create_wm_window(struct xwm_wm *wm)
+{
+	static const char name[] = "Weston WM";
+
+	wm->wm_window = xcb_generate_id(wm->conn);
+	xcb_create_window(wm->conn,
+			  XCB_COPY_FROM_PARENT,
+			  wm->wm_window,
+			  wm->screen->root,
+			  0, 0,
+			  10, 10,
+			  0,
+			  XCB_WINDOW_CLASS_INPUT_OUTPUT,
+			  wm->screen->root_visual,
+			  0, NULL);
+
+	xcb_change_property(wm->conn,
+			    XCB_PROP_MODE_REPLACE,
+			    wm->wm_window,
+			    wm->atom.net_supporting_wm_check,
+			    XCB_ATOM_WINDOW,
+			    32, /* format */
+			    1, &wm->wm_window);
+
+	xcb_change_property(wm->conn,
+			    XCB_PROP_MODE_REPLACE,
+			    wm->wm_window,
+			    wm->atom.net_wm_name,
+			    wm->atom.utf8_string,
+			    8, /* format */
+			    strlen(name), name);
+
+	xcb_change_property(wm->conn,
+			    XCB_PROP_MODE_REPLACE,
+			    wm->screen->root,
+			    wm->atom.net_supporting_wm_check,
+			    XCB_ATOM_WINDOW,
+			    32, /* format */
+			    1, &wm->wm_window);
+
+	/* Claim the WM_S0 selection even though we don't suport
+	 * the --replace functionality. */
+	xcb_set_selection_owner(wm->conn,
+				wm->wm_window,
+				wm->atom.wm_s0,
+				XCB_TIME_CURRENT_TIME);
+}
+
+static void
+wm_func(struct task *task, uint32_t events)
+{
+	struct xwm_wm *wm =
+		container_of(task, struct xwm_wm, wm_task);
+
+	xwm_handle_event(0, 0, wm);
+}
+
+static void
+xwm_create(struct xwm *xwm, int fd)
+{
+	struct xwm_wm *wm;
+	xcb_screen_iterator_t s;
+	uint32_t values[1];
+	xcb_atom_t supported[1];
+
+	wm = malloc(sizeof *wm);
+	if (wm == NULL)
+		return;
+
+	memset(wm, 0, sizeof *wm);
+	wm->display = xwm->display;
+	wm->window_hash = hash_table_create();
+	if (wm->window_hash == NULL) {
+		free(wm);
+		return;
+	}
+
+	/* xcb_connect_to_fd takes ownership of the fd. */
+	wm->conn = xcb_connect_to_fd(fd, NULL);
+	if (xcb_connection_has_error(wm->conn)) {
+		fprintf(stderr, "xcb_connect_to_fd failed\n");
+		close(fd);
+		hash_table_destroy(wm->window_hash);
+		free(wm);
+		return;
+	}
+
+	wm->wm_task.run = wm_func;
+	display_watch_fd(wm->display, fd, EPOLLIN, &wm->wm_task);
+
+	s = xcb_setup_roots_iterator(xcb_get_setup(wm->conn));
+	wm->screen = s.data;
+
+	xwm_get_resources(wm);
+
+	values[0] =
+		XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY |
+		XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT |
+		XCB_EVENT_MASK_PROPERTY_CHANGE;
+	xcb_change_window_attributes(wm->conn, wm->screen->root,
+				     XCB_CW_EVENT_MASK, values);
+	wm->theme = theme_create();
+
+	xwm_create_wm_window(wm);
+
+	supported[0] = wm->atom.net_wm_moveresize;
+	xcb_change_property(wm->conn,
+			    XCB_PROP_MODE_REPLACE,
+			    wm->screen->root,
+			    wm->atom.net_supported,
+			    XCB_ATOM_ATOM,
+			    32, /* format */
+			    ARRAY_LENGTH(supported), supported);
+
+	xwm_selection_init(wm);
+
+	xcb_flush(wm->conn);
+
+	xwm_create_cursors(wm);
+	xwm_window_set_cursor(wm, wm->screen->root, XWM_CURSOR_LEFT_PTR);
+
+	wm->xwm = xwm;
+	xwm->xwm_wm = wm;
+
+	fprintf(stderr, "weston-xwm: connected to X\n");
+	wm_is_ready(wm->xwm->wm);
+}
+
+static void
+xwm_destroy(struct xwm_wm *wm)
+{
+	/* FIXME: Free windows in hash. */
+	hash_table_destroy(wm->window_hash);
+	xwm_destroy_cursors(wm);
+	xcb_disconnect(wm->conn);
+
+	free(wm);
+}
+
+static void
+wm_handle_xserver(void *data, struct wm *w, int32_t fd)
+{
+	struct xwm *xwm = data;
+
+	xwm_create(xwm, fd);
+}
+
+static void
+wm_handle_state(void *data, struct wm *w, uint32_t state)
+{
+	struct xwm *xwm = data;
+
+	set_state_activate(xwm, NULL);
+}
+
+static void
+wm_handle_selection(void *data, struct wm *w, uint32_t has_text_plain)
+{
+	struct xwm *xwm = data;
+
+	xwm_set_selection(xwm, has_text_plain);
+}
+
+static const struct wm_listener wm_listener = {
+	wm_handle_xserver,
+	wm_handle_state,
+	wm_handle_selection
+};
+
+static void
+registry_handle_global(void *data, struct wl_registry *registry, uint32_t id,
+		       const char *interface, uint32_t version)
+{
+	struct xwm *xwm = data;
+
+	if (strcmp(interface, "wl_compositor") == 0) {
+		xwm->compositor = wl_registry_bind(registry, id,
+					&wl_compositor_interface, 1);
+	} else if (strcmp(interface, "wl_seat") == 0) {
+		xwm->seat = wl_registry_bind(registry, id,
+					&wl_seat_interface, 1);
+		xwm->data_device =
+		wl_data_device_manager_get_data_device(xwm->data_device_manager,
+					xwm->seat);
+	} else if (strcmp(interface, "wl_data_device_manager") == 0) {
+		xwm->data_device_manager = wl_registry_bind(registry, id,
+					&wl_data_device_manager_interface, 1);
+	} else if (!strcmp(interface, "wm")) {
+		xwm->wm = wl_registry_bind(registry, id,
+					&wm_interface, 1);
+		wm_add_listener(xwm->wm, &wm_listener, xwm);
+	}
+}
+
+static void
+sigchild_handler(int s)
+{
+	int status;
+	pid_t pid;
+
+	while (pid = waitpid(-1, &status, WNOHANG), pid > 0)
+		fprintf(stderr, "child %d exited\n", pid);
+}
+
+static const struct wl_registry_listener registry_listener = {
+	registry_handle_global
+};
+
+int
+main(int argc, char **argv)
+{
+	struct xwm xwm = { 0 };
+
+	xwm.display = display_create(argc, argv);
+	if (xwm.display == NULL) {
+		fprintf(stderr, "failed to create display: %m\n");
+		return -1;
+	}
+	display_set_user_data(xwm.display, &xwm);
+
+	xwm.wl_display = display_get_display(xwm.display);
+	xwm.registry = wl_display_get_registry(xwm.wl_display);
+	wl_registry_add_listener(xwm.registry, &registry_listener, &xwm);
+	wl_display_dispatch(xwm.wl_display);
+
+	signal(SIGCHLD, sigchild_handler);
+
+	display_run(xwm.display);
+
+	xwm_destroy(xwm.xwm_wm);
+	wl_data_device_manager_destroy(xwm.data_device_manager);
+	wl_data_device_destroy(xwm.data_device);
+	display_destroy(xwm.display);
+
+	return 0;
+}
+
diff --git a/clients/xwm.h b/clients/xwm.h
new file mode 100644
index 0000000..bdd00aa
--- /dev/null
+++ b/clients/xwm.h
@@ -0,0 +1,137 @@
+/*
+ * Copyright © 2012 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of the copyright holders not be used in
+ * advertising or publicity pertaining to distribution of the software
+ * without specific, written prior permission.  The copyright holders make
+ * no representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+ * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+ * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <xcb/xcb.h>
+#include <xcb/xfixes.h>
+#include <cairo/cairo-xcb.h>
+
+#include "window.h"
+
+struct xwm {
+	struct wl_registry *registry;
+	struct wl_display *wl_display;
+	struct wl_compositor *compositor;
+	struct wl_seat *seat;
+	struct wl_data_device_manager *data_device_manager;
+	struct wl_data_device *data_device;
+
+	struct wm *wm;
+	struct wm_xwin *wm_xwin;
+	struct xwm_wm *xwm_wm;
+	struct display *display;
+};
+
+struct xwm_wm {
+	struct xwm *xwm;
+	struct task wm_task;
+	xcb_connection_t *conn;
+	struct display *display;
+	const xcb_query_extension_reply_t *xfixes;
+	xcb_screen_t *screen;
+	struct hash_table *window_hash;
+	xcb_window_t wm_window;
+	struct xwm_window *focus_window;
+	struct theme *theme;
+	xcb_cursor_t *cursors;
+	int last_cursor;
+	xcb_render_pictforminfo_t format_rgb, format_rgba;
+
+	/* copy and paste proxy */
+	struct task selection_write_task;
+	struct task selection_read_task;
+	xcb_window_t selection_window;
+	xcb_window_t selection_owner;
+	int incr;
+	int data_source_fd;
+	struct wl_data_offer *selection_offer;
+	xcb_get_property_reply_t *property_reply;
+	int property_start;
+	struct wl_data_source *selection;
+	struct wl_array source_data;
+	xcb_selection_request_event_t selection_request;
+	xcb_atom_t selection_target;
+	xcb_timestamp_t selection_timestamp;
+	int selection_property_set;
+	int flush_property_on_delete;
+
+	struct {
+		xcb_atom_t		 wm_protocols;
+		xcb_atom_t		 wm_take_focus;
+		xcb_atom_t		 wm_delete_window;
+		xcb_atom_t		 wm_state;
+		xcb_atom_t		 wm_s0;
+		xcb_atom_t		 wm_client_machine;
+		xcb_atom_t		 net_wm_name;
+		xcb_atom_t		 net_wm_pid;
+		xcb_atom_t		 net_wm_icon;
+		xcb_atom_t		 net_wm_state;
+		xcb_atom_t		 net_wm_state_fullscreen;
+		xcb_atom_t		 net_wm_user_time;
+		xcb_atom_t		 net_wm_icon_name;
+		xcb_atom_t		 net_wm_window_type;
+		xcb_atom_t		 net_wm_window_type_desktop;
+		xcb_atom_t		 net_wm_window_type_dock;
+		xcb_atom_t		 net_wm_window_type_toolbar;
+		xcb_atom_t		 net_wm_window_type_menu;
+		xcb_atom_t		 net_wm_window_type_utility;
+		xcb_atom_t		 net_wm_window_type_splash;
+		xcb_atom_t		 net_wm_window_type_dialog;
+		xcb_atom_t		 net_wm_window_type_dropdown;
+		xcb_atom_t		 net_wm_window_type_popup;
+		xcb_atom_t		 net_wm_window_type_tooltip;
+		xcb_atom_t		 net_wm_window_type_notification;
+		xcb_atom_t		 net_wm_window_type_combo;
+		xcb_atom_t		 net_wm_window_type_dnd;
+		xcb_atom_t		 net_wm_window_type_normal;
+		xcb_atom_t		 net_wm_moveresize;
+		xcb_atom_t		 net_supporting_wm_check;
+		xcb_atom_t		 net_supported;
+		xcb_atom_t		 motif_wm_hints;
+		xcb_atom_t		 clipboard;
+		xcb_atom_t		 clipboard_manager;
+		xcb_atom_t		 targets;
+		xcb_atom_t		 utf8_string;
+		xcb_atom_t		 wl_selection;
+		xcb_atom_t		 incr;
+		xcb_atom_t		 timestamp;
+		xcb_atom_t		 multiple;
+		xcb_atom_t		 compound_text;
+		xcb_atom_t		 text;
+		xcb_atom_t		 string;
+		xcb_atom_t		 text_plain_utf8;
+		xcb_atom_t		 text_plain;
+	} atom;
+};
+
+void
+dump_property(struct xwm_wm *wm, xcb_atom_t property,
+	      xcb_get_property_reply_t *reply);
+
+const char *
+get_atom_name(xcb_connection_t *c, xcb_atom_t atom);
+
+void
+xwm_selection_init(struct xwm_wm *wm);
+int
+xwm_handle_selection_event(struct xwm_wm *wm, xcb_generic_event_t *event);
+void
+xwm_set_selection(struct xwm *xwm, int has_text_plain);
diff --git a/configure.ac b/configure.ac
index 8cff8dc..6a8f975 100644
--- a/configure.ac
+++ b/configure.ac
@@ -196,7 +196,7 @@ AM_CONDITIONAL(BUILD_CLIENTS, test x$enable_clients = xyes)
 if test x$enable_clients = xyes; then
   AC_DEFINE([BUILD_CLIENTS], [1], [Build the Wayland clients])
 
-  PKG_CHECK_MODULES(CLIENT, [wayland-client cairo >= 1.10.0 xkbcommon wayland-cursor])
+  PKG_CHECK_MODULES(CLIENT, [wayland-client cairo >= 1.10.0 xkbcommon wayland-cursor xcursor])
   PKG_CHECK_MODULES(WESTON_INFO, [wayland-client])
 
   PKG_CHECK_MODULES(POPPLER, [poppler-glib glib-2.0 gobject-2.0 gio-2.0 ],
diff --git a/protocol/xserver.xml b/protocol/xserver.xml
index 9e25f5c..b76b01d 100644
--- a/protocol/xserver.xml
+++ b/protocol/xserver.xml
@@ -1,18 +1,218 @@
 <protocol name="xserver">
 
   <interface name="xserver" version="1">
-    <request name="set_window_id">
+    <description summary="global object to connect X with Wayland">
+    </description>
+
+    <request name="set_window_surface">
+      <description summary="specify window surface">
+	It specifies the assignment between an X Window 'id' and an Wayland
+	'surface'. The compositor will cache it internally, then create a
+	shell_surface which will be mapped on the screen based on the
+	information the wm interface will provide for the given window.
+      </description>
+
       <arg name="surface" type="object" interface="wl_surface"/>
-      <arg name="id" type="uint"/>
+      <arg name="xid" type="uint"/>
     </request>
 
     <event name="client">
+      <description summary="send client fd to X">
+	In principle, this event must be used only once and to send window
+	manager (WM) fd to X. This is one tip of the opened socketpair; the
+	other has to be sent via wm interface in order to plug both X and WM.
+      </description>
       <arg name="fd" type="fd"/>
     </event>
 
     <event name="listen_socket">
+      <description summary="send client to be listened on opened fd">
+	This event should be used to send the first real X client fd to the X
+	server; this is the client that triggered X initialization but had to
+	wait for the WM gets connected before. A good practice is to call this
+	event after receiving wm.is_ready.
+      </description>
+      <arg name="fd" type="fd"/>
+    </event>
+
+    <event name="map">
+      <description summary="notify X when window can be mapped">
+	Notify X that Window 'xid' is ready to be mapped. Effectively this
+	happens after compositor receiving wm_xwin.map from WM.
+      </description>
+
+      <arg name="xid" type="uint"/>
+    </event>
+
+    <event name="configure">
+      <description summary="notify X about new window configuration">
+	Worth to note that coordinates 'x' and 'y' are global.
+      </description>
+
+      <arg name="xid" type="uint"/>
+      <arg name="x" type="int"/>
+      <arg name="y" type="int"/>
+      <arg name="width" type="int"/>
+      <arg name="height" type="int"/>
+      <arg name="edges" type="uint"/>
+    </event>
+
+  </interface>
+
+  <interface name="wm" version="1">
+    <description summary="XWayland window manager global object">
+    </description>
+
+    <request name="is_ready">
+      <description summary="notifies that WM is ready and connected to X">
+      </description>
+    </request>
+
+    <request name="create_xwindow">
+      <description summary="instantiates xm_xwin objects">
+      </description>
+      <arg name="id" type="new_id" interface="wm_xwin"/>
+      <arg name="xid" type="uint"/>
+    </request>
+
+    <request name="set_selection">
+      <description summary="send the selection data">
+	Request for data from another client.  Send the data as the specified
+	mime-type over the passed fd.
+      </description>
+
+      <arg name="mime_type" type="string"/>
+      <arg name="fd" type="fd"/>
+    </request>
+
+    <event name="xserver">
+      <description summary="send X fd to window manager">
+	This is the other tip of the socketpair used for connecting X and
+	window manager with each other; see xserver.wm.
+      </description>
+
       <arg name="fd" type="fd"/>
     </event>
+
+    <enum name="state">
+      <description summary="wm states">
+        Describes the wm state the Wayland compositor desires.
+      </description>
+
+      <entry name="deactivate" value="1" summary="deactivate all the windows"/>
+    </enum>
+
+    <event name="state">
+      <description summary="notifies window manager about window state">
+      </description>
+
+      <arg name="state" type="uint"/>
+    </event>
+
+    <event name="selection">
+      <description summary="notifies wm whether a text plain was selected">
+	The selection itself will happen via X then.
+      </description>
+
+      <arg name="has_text_plain" type="uint"/>
+    </event>
+  </interface>
+
+  <interface name="wm_xwin" version="1">
+    <description summary="">
+    </description>
+
+    <request name="map">
+      <description summary="notify compositor when window can be mapped">
+	Notify compositor that the current window is ready to be mapped by X.
+	Effectively this happens after a MapNotify hits the window manager and
+	the compositor in principle would proceed notifying X via xserver.map.
+      </description>
+    </request>
+
+    <request name="set_window">
+      <description summary="specify window id, geometries and positioning">
+	Notifies the compositor about X Window id and its configuration
+	regarding size and location on the screen. The compositor is
+	responsible for looking the surface based on the id and map it on the
+	screen. The x and y arguments specify the global position of the
+	surface on the current output, exactly how X11 works. The flags
+	argument can be used to tell the type of window or control whether the
+	surface will receive the keyboard focus or not, after being mapped.
+      </description>
+
+      <arg name="x" type="int"/>
+      <arg name="y" type="int"/>
+      <arg name="width" type="int"/>
+      <arg name="height" type="int"/>
+      <arg name="flags" type="uint"/>
+    </request>
+
+    <request name="set_opaque_override">
+      <description summary="set opaque override region">
+	Textures coming from X windows usually have their X window as RGBx,
+	i.e. 32 bit with an undefined alpha channel for the content part while
+	the decorations are rendered with a well-defined alpha channel. On
+	this case set_opaque_override is needed for marking a rectangle in a
+	texture and force the alpha = 1.0.
+
+	This is different from the wl_surface.set_opaque_region, where that
+	one is meant only as a hint for optimization while this is a necessity
+	for painting XWayland windows right. Therefore X must never use
+	wl_surface.set_opaque_region either.
+      </description>
+
+      <arg name="region" type="object" interface="wl_region"/>
+    </request>
+
+    <request name="set_input_region">
+      <description summary="set window input region">
+      </description>
+
+      <arg name="region" type="object" interface="wl_region" allow-null="true"/>
+    </request>
+
+    <request name="move">
+    </request>
+
+    <request name="resize">
+      <arg name="edges" type="uint"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy an wm_xwindow">
+      </description>
+    </request>
+
+    <event name="configure">
+      <description summary="suggest resize">
+	The configure event asks the client to resize its surface. The size is
+	a hint, in the sense that the client is free to ignore it if it
+	doesn't resize, pick a smaller size (to satisfy aspect ration or
+	resize in steps of NxM pixels). The client is free to dismiss all but
+	the last configure event it received.
+      </description>
+
+      <arg name="edges" type="uint"/>
+      <arg name="width" type="int"/>
+      <arg name="height" type="int"/>
+    </event>
+
+    <enum name="state">
+      <description summary="window states">
+        Describes the window state the Wayland compositor desires.
+      </description>
+
+      <entry name="activate" value="1" summary="activate and give focus"/>
+      <entry name="kill" value="2" summary="send a kill"/>
+    </enum>
+
+    <event name="state">
+      <description summary="notifies window about its state">
+      </description>
+
+      <arg name="state" type="uint"/>
+    </event>
   </interface>
 
 </protocol>
diff --git a/shared/Makefile.am b/shared/Makefile.am
index b38cb95..db23464 100644
--- a/shared/Makefile.am
+++ b/shared/Makefile.am
@@ -27,4 +27,6 @@ libshared_cairo_la_SOURCES =			\
 	$(libshared_la_SOURCES)			\
 	image-loader.c				\
 	cairo-util.c				\
-	cairo-util.h
+	cairo-util.h				\
+	xwayland-hash.c				\
+	xwayland-hash.h
diff --git a/shared/xwayland-hash.c b/shared/xwayland-hash.c
new file mode 100644
index 0000000..2d47f33
--- /dev/null
+++ b/shared/xwayland-hash.c
@@ -0,0 +1,307 @@
+/*
+ * Copyright © 2009 Intel Corporation
+ * Copyright © 1988-2004 Keith Packard and Bart Massey.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the names of the authors
+ * or their institutions shall not be used in advertising or
+ * otherwise to promote the sale, use or other dealings in this
+ * Software without prior written authorization from the
+ * authors.
+ *
+ * Authors:
+ *    Eric Anholt <eric@anholt.net>
+ *    Keith Packard <keithp@keithp.com>
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+
+#include "xwayland-hash.h"
+
+struct hash_entry {
+	uint32_t hash;
+	void *data;
+};
+
+struct hash_table {
+	struct hash_entry *table;
+	uint32_t size;
+	uint32_t rehash;
+	uint32_t max_entries;
+	uint32_t size_index;
+	uint32_t entries;
+	uint32_t deleted_entries;
+};
+
+#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))
+
+/*
+ * From Knuth -- a good choice for hash/rehash values is p, p-2 where
+ * p and p-2 are both prime.  These tables are sized to have an extra 10%
+ * free to avoid exponential performance degradation as the hash table fills
+ */
+
+static const uint32_t deleted_data;
+
+static const struct {
+   uint32_t max_entries, size, rehash;
+} hash_sizes[] = {
+    { 2,		5,		3	  },
+    { 4,		7,		5	  },
+    { 8,		13,		11	  },
+    { 16,		19,		17	  },
+    { 32,		43,		41        },
+    { 64,		73,		71        },
+    { 128,		151,		149       },
+    { 256,		283,		281       },
+    { 512,		571,		569       },
+    { 1024,		1153,		1151      },
+    { 2048,		2269,		2267      },
+    { 4096,		4519,		4517      },
+    { 8192,		9013,		9011      },
+    { 16384,		18043,		18041     },
+    { 32768,		36109,		36107     },
+    { 65536,		72091,		72089     },
+    { 131072,		144409,		144407    },
+    { 262144,		288361,		288359    },
+    { 524288,		576883,		576881    },
+    { 1048576,		1153459,	1153457   },
+    { 2097152,		2307163,	2307161   },
+    { 4194304,		4613893,	4613891   },
+    { 8388608,		9227641,	9227639   },
+    { 16777216,		18455029,	18455027  },
+    { 33554432,		36911011,	36911009  },
+    { 67108864,		73819861,	73819859  },
+    { 134217728,	147639589,	147639587 },
+    { 268435456,	295279081,	295279079 },
+    { 536870912,	590559793,	590559791 },
+    { 1073741824,	1181116273,	1181116271},
+    { 2147483648ul,	2362232233ul,	2362232231ul}
+};
+
+static int
+entry_is_free(struct hash_entry *entry)
+{
+	return entry->data == NULL;
+}
+
+static int
+entry_is_deleted(struct hash_entry *entry)
+{
+	return entry->data == &deleted_data;
+}
+
+static int
+entry_is_present(struct hash_entry *entry)
+{
+	return entry->data != NULL && entry->data != &deleted_data;
+}
+
+struct hash_table *
+hash_table_create(void)
+{
+	struct hash_table *ht;
+
+	ht = malloc(sizeof(*ht));
+	if (ht == NULL)
+		return NULL;
+
+	ht->size_index = 0;
+	ht->size = hash_sizes[ht->size_index].size;
+	ht->rehash = hash_sizes[ht->size_index].rehash;
+	ht->max_entries = hash_sizes[ht->size_index].max_entries;
+	ht->table = calloc(ht->size, sizeof(*ht->table));
+	ht->entries = 0;
+	ht->deleted_entries = 0;
+
+	if (ht->table == NULL) {
+		free(ht);
+		return NULL;
+	}
+
+	return ht;
+}
+
+/**
+ * Frees the given hash table.
+ */
+void
+hash_table_destroy(struct hash_table *ht)
+{
+	if (!ht)
+		return;
+
+	free(ht->table);
+	free(ht);
+}
+
+/**
+ * Finds a hash table entry with the given key and hash of that key.
+ *
+ * Returns NULL if no entry is found.  Note that the data pointer may be
+ * modified by the user.
+ */
+static void *
+hash_table_search(struct hash_table *ht, uint32_t hash)
+{
+	uint32_t hash_address;
+
+	hash_address = hash % ht->size;
+	do {
+		uint32_t double_hash;
+
+		struct hash_entry *entry = ht->table + hash_address;
+
+		if (entry_is_free(entry)) {
+			return NULL;
+		} else if (entry_is_present(entry) && entry->hash == hash) {
+			return entry;
+		}
+
+		double_hash = 1 + hash % ht->rehash;
+
+		hash_address = (hash_address + double_hash) % ht->size;
+	} while (hash_address != hash % ht->size);
+
+	return NULL;
+}
+
+void
+hash_table_for_each(struct hash_table *ht,
+		    hash_table_iterator_func_t func, void *data)
+{
+	struct hash_entry *entry;
+	uint32_t i;
+
+	for (i = 0; i < ht->size; i++) {
+		entry = ht->table + i;
+		if (entry_is_present(entry))
+			func(entry->data, data);
+	}
+}
+
+void *
+hash_table_lookup(struct hash_table *ht, uint32_t hash)
+{
+	struct hash_entry *entry;
+
+	entry = hash_table_search(ht, hash);
+	if (entry != NULL)
+		return entry->data;
+
+	return NULL;
+}
+
+static void
+hash_table_rehash(struct hash_table *ht, unsigned int new_size_index)
+{
+	struct hash_table old_ht;
+	struct hash_entry *table, *entry;
+
+	if (new_size_index >= ARRAY_SIZE(hash_sizes))
+		return;
+
+	table = calloc(hash_sizes[new_size_index].size, sizeof(*ht->table));
+	if (table == NULL)
+		return;
+
+	old_ht = *ht;
+
+	ht->table = table;
+	ht->size_index = new_size_index;
+	ht->size = hash_sizes[ht->size_index].size;
+	ht->rehash = hash_sizes[ht->size_index].rehash;
+	ht->max_entries = hash_sizes[ht->size_index].max_entries;
+	ht->entries = 0;
+	ht->deleted_entries = 0;
+
+	for (entry = old_ht.table;
+	     entry != old_ht.table + old_ht.size;
+	     entry++) {
+		if (entry_is_present(entry)) {
+			hash_table_insert(ht, entry->hash, entry->data);
+		}
+	}
+
+	free(old_ht.table);
+}
+
+/**
+ * Inserts the data with the given hash into the table.
+ *
+ * Note that insertion may rearrange the table on a resize or rehash,
+ * so previously found hash_entries are no longer valid after this function.
+ */
+int
+hash_table_insert(struct hash_table *ht, uint32_t hash, void *data)
+{
+	uint32_t hash_address;
+
+	if (ht->entries >= ht->max_entries) {
+		hash_table_rehash(ht, ht->size_index + 1);
+	} else if (ht->deleted_entries + ht->entries >= ht->max_entries) {
+		hash_table_rehash(ht, ht->size_index);
+	}
+
+	hash_address = hash % ht->size;
+	do {
+		struct hash_entry *entry = ht->table + hash_address;
+		uint32_t double_hash;
+
+		if (!entry_is_present(entry)) {
+			if (entry_is_deleted(entry))
+				ht->deleted_entries--;
+			entry->hash = hash;
+			entry->data = data;
+			ht->entries++;
+			return 0;
+		}
+
+		double_hash = 1 + hash % ht->rehash;
+
+		hash_address = (hash_address + double_hash) % ht->size;
+	} while (hash_address != hash % ht->size);
+
+	/* We could hit here if a required resize failed. An unchecked-malloc
+	 * application could ignore this result.
+	 */
+	return -1;
+}
+
+/**
+ * This function deletes the given hash table entry.
+ *
+ * Note that deletion doesn't otherwise modify the table, so an iteration over
+ * the table deleting entries is safe.
+ */
+void
+hash_table_remove(struct hash_table *ht, uint32_t hash)
+{
+	struct hash_entry *entry;
+
+	entry = hash_table_search(ht, hash);
+	if (entry != NULL) {
+		entry->data = (void *) &deleted_data;
+		ht->entries--;
+		ht->deleted_entries++;
+	}
+}
diff --git a/shared/xwayland-hash.h b/shared/xwayland-hash.h
new file mode 100644
index 0000000..6e1674e
--- /dev/null
+++ b/shared/xwayland-hash.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright © 2009 Intel Corporation
+ * Copyright © 1988-2004 Keith Packard and Bart Massey.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the names of the authors
+ * or their institutions shall not be used in advertising or
+ * otherwise to promote the sale, use or other dealings in this
+ * Software without prior written authorization from the
+ * authors.
+ *
+ * Authors:
+ *    Eric Anholt <eric@anholt.net>
+ *    Keith Packard <keithp@keithp.com>
+ */
+
+#ifndef HASH_H
+#define HASH_H
+
+struct hash_table;
+struct hash_table *hash_table_create(void);
+typedef void (*hash_table_iterator_func_t)(void *element, void *data);
+
+void hash_table_destroy(struct hash_table *ht);
+void *hash_table_lookup(struct hash_table *ht, uint32_t hash);
+int hash_table_insert(struct hash_table *ht, uint32_t hash, void *data);
+void hash_table_remove(struct hash_table *ht, uint32_t hash);
+void hash_table_for_each(struct hash_table *ht,
+			 hash_table_iterator_func_t func, void *data);
+
+#endif
diff --git a/src/compositor.c b/src/compositor.c
index e556766..02dd649 100644
--- a/src/compositor.c
+++ b/src/compositor.c
@@ -2955,6 +2955,7 @@ weston_compositor_init(struct weston_compositor *ec,
 	ec->wl_display = display;
 	wl_signal_init(&ec->destroy_signal);
 	wl_signal_init(&ec->activate_signal);
+	wl_signal_init(&ec->position_signal);
 	wl_signal_init(&ec->kill_signal);
 	wl_signal_init(&ec->lock_signal);
 	wl_signal_init(&ec->unlock_signal);
diff --git a/src/compositor.h b/src/compositor.h
index 15d6939..eb8efed 100644
--- a/src/compositor.h
+++ b/src/compositor.h
@@ -73,6 +73,25 @@ struct weston_shell_client {
 			       uint32_t edges, int32_t width, int32_t height);
 };
 
+enum weston_xwayland {
+	XWAYLAND_ACTIVE = (1 << 0),
+	XWAYLAND_INACTIVE = (1 << 1)
+};
+
+/*
+ * weston_shell_interface is the interface for the WM compositor module
+ * (window-manager.c) access the shell implementation. Its methods need to be
+ * implemented and hooked for XWayland usage only.
+ *
+ * Once a handler is received (create_shell_surface), window types are set by
+ * the WM, so windows are mapped on the screen (wm_xwin.set_window, 'flags'
+ * argument). The WM compositor module has in particular two types for
+ * mapping: set_toplevel and set_transient_xwayland. Worth to mention that the
+ * latter is an XWayland specific type and shells are not exposing it to
+ * regular clients via Wayland protocol; it differs from the regular
+ * set_transient protocol type because set_transient_xwayland maps a surface
+ * in a absolute coordinate on the screen, a peculiar feature of X.
+ */
 struct weston_shell_interface {
 	void *shell;			/* either desktop or tablet */
 
@@ -82,13 +101,21 @@ struct weston_shell_interface {
 
 	void (*set_toplevel)(struct shell_surface *shsurf);
 
-	void (*set_transient)(struct shell_surface *shsurf,
-			      struct weston_surface *parent,
-			      int x, int y, uint32_t flags);
+	/*
+	 * 'x' and 'y' arguments accept global absolute coordinates, while
+	 * 'flags' is used for receiving keyboard focus or not.
+	 *
+	 * As a side note, ICCCM 'transient' has a slightly different meaning
+	 * than this here. On that one it requires a parent top-level window,
+	 * which is not the case here. So set_transient_xwayland is
+	 * 'transient' in the sense of "lasting only for a short time;
+	 * impermanent", used for tooltips, dropdown, dialogs, among others.
+	 */
+	void (*set_transient_xwayland)(struct shell_surface *shsurf,
+			int x, int y, enum weston_xwayland flags);
 	int (*move)(struct shell_surface *shsurf, struct weston_seat *ws);
 	int (*resize)(struct shell_surface *shsurf,
 		      struct weston_seat *ws, uint32_t edges);
-
 };
 
 struct weston_border {
@@ -282,6 +309,7 @@ struct weston_compositor {
 	struct weston_shell_interface shell_interface;
 
 	struct wl_signal activate_signal;
+	struct wl_signal position_signal;
 	struct wl_signal kill_signal;
 	struct wl_signal lock_signal;
 	struct wl_signal unlock_signal;
diff --git a/src/shell.c b/src/shell.c
index aa1c7c1..dcefd9c 100644
--- a/src/shell.c
+++ b/src/shell.c
@@ -141,6 +141,7 @@ enum shell_surface_type {
 	SHELL_SURFACE_NONE,
 	SHELL_SURFACE_TOPLEVEL,
 	SHELL_SURFACE_TRANSIENT,
+	SHELL_SURFACE_TRANSIENT_XWAYLAND,
 	SHELL_SURFACE_FULLSCREEN,
 	SHELL_SURFACE_MAXIMIZED,
 	SHELL_SURFACE_POPUP
@@ -192,6 +193,11 @@ struct shell_surface {
 		struct weston_surface *black_surface;
 	} fullscreen;
 
+	struct {
+		int32_t x, y;
+		enum weston_xwayland flags;
+	} xwayland;
+
 	struct ping_timer *ping_timer;
 
 	struct weston_transform workspace_transform;
@@ -297,9 +303,13 @@ shell_grab_start(struct shell_grab *grab,
 static void
 shell_grab_end(struct shell_grab *grab)
 {
+	struct weston_compositor *compositor =
+		grab->shsurf->surface->compositor;
+
 	if (grab->shsurf)
 		wl_list_remove(&grab->shsurf_destroy_listener.link);
 
+	wl_signal_emit(&compositor->position_signal, grab->shsurf->surface);
 	wl_pointer_end_grab(grab->pointer);
 }
 
@@ -1469,6 +1479,7 @@ reset_shell_surface_type(struct shell_surface *surface)
 	case SHELL_SURFACE_NONE:
 	case SHELL_SURFACE_TOPLEVEL:
 	case SHELL_SURFACE_TRANSIENT:
+	case SHELL_SURFACE_TRANSIENT_XWAYLAND:
 	case SHELL_SURFACE_POPUP:
 		break;
 	}
@@ -1496,7 +1507,10 @@ set_surface_type(struct shell_surface *shsurf)
 				pes->geometry.x + shsurf->transient.x,
 				pes->geometry.y + shsurf->transient.y);
 		break;
-
+	case SHELL_SURFACE_TRANSIENT_XWAYLAND:
+		weston_surface_set_position(surface, shsurf->xwayland.x,
+					    shsurf->xwayland.y);
+		break;
 	case SHELL_SURFACE_MAXIMIZED:
 		shsurf->saved_x = surface->geometry.x;
 		shsurf->saved_y = surface->geometry.y;
@@ -1515,7 +1529,6 @@ set_surface_type(struct shell_surface *shsurf)
 			shsurf->saved_rotation_valid = true;
 		}
 		break;
-
 	default:
 		break;
 	}
@@ -1560,6 +1573,16 @@ shell_surface_set_transient(struct wl_client *client,
 	set_transient(shsurf, parent, x, y, flags);
 }
 
+static void
+set_transient_xwayland(struct shell_surface *shsurf, int x, int y,
+		       enum weston_xwayland flags)
+{
+	shsurf->xwayland.x = x;
+	shsurf->xwayland.y = y;
+	shsurf->xwayland.flags = flags;
+	shsurf->next_type = SHELL_SURFACE_TRANSIENT_XWAYLAND;
+}
+
 static struct desktop_shell *
 shell_surface_get_shell(struct shell_surface *shsurf)
 {
@@ -2928,6 +2951,7 @@ map(struct desktop_shell *shell, struct weston_surface *surface,
 					    surface->geometry.x + sx,
 					    surface->geometry.y + sy);
 		break;
+	case SHELL_SURFACE_TRANSIENT_XWAYLAND:
 	default:
 		;
 	}
@@ -2942,6 +2966,7 @@ map(struct desktop_shell *shell, struct weston_surface *surface,
 	case SHELL_SURFACE_FULLSCREEN:
 	case SHELL_SURFACE_NONE:
 		break;
+	case SHELL_SURFACE_TRANSIENT_XWAYLAND:
 	default:
 		ws = get_current_workspace(shell);
 		wl_list_insert(&ws->layer.surface_list, &surface->layer_link);
@@ -2959,6 +2984,9 @@ map(struct desktop_shell *shell, struct weston_surface *surface,
 		if (shsurf->transient.flags ==
 				WL_SHELL_SURFACE_TRANSIENT_INACTIVE)
 			break;
+	case SHELL_SURFACE_TRANSIENT_XWAYLAND:
+		if (shsurf->xwayland.flags == XWAYLAND_INACTIVE)
+			break;
 	case SHELL_SURFACE_TOPLEVEL:
 	case SHELL_SURFACE_FULLSCREEN:
 	case SHELL_SURFACE_MAXIMIZED:
@@ -3034,6 +3062,7 @@ shell_surface_configure(struct weston_surface *es, int32_t sx, int32_t sy)
 {
 	struct shell_surface *shsurf = get_shell_surface(es);
 	struct desktop_shell *shell = shsurf->shell;
+	struct weston_compositor *compositor = shsurf->surface->compositor;
 	int32_t width = weston_surface_buffer_width(es);
 	int32_t height = weston_surface_buffer_height(es);
 	int type_changed = 0;
@@ -3059,6 +3088,8 @@ shell_surface_configure(struct weston_surface *es, int32_t sx, int32_t sy)
 			  es->geometry.y + to_y - from_y,
 			  width, height);
 	}
+
+	wl_signal_emit(&compositor->position_signal, shsurf->surface);
 }
 
 static void launch_desktop_shell_process(void *data);
@@ -3841,7 +3872,7 @@ module_init(struct weston_compositor *ec)
 	ec->shell_interface.shell = shell;
 	ec->shell_interface.create_shell_surface = create_shell_surface;
 	ec->shell_interface.set_toplevel = set_toplevel;
-	ec->shell_interface.set_transient = set_transient;
+	ec->shell_interface.set_transient_xwayland = set_transient_xwayland;
 	ec->shell_interface.move = surface_move;
 	ec->shell_interface.resize = surface_resize;
 
diff --git a/src/xwayland/Makefile.am b/src/xwayland/Makefile.am
index 8f3bddd..cd222d1 100644
--- a/src/xwayland/Makefile.am
+++ b/src/xwayland/Makefile.am
@@ -1,7 +1,5 @@
 AM_CPPFLAGS =					\
-	-DDATADIR='"$(datadir)"'		\
-	-DMODULEDIR='"$(moduledir)"'		\
-	-DLIBEXECDIR='"$(libexecdir)"'		\
+	-DBINDIR='"$(bindir)"'			\
 	-DXSERVER_PATH='"@XSERVER_PATH@"'
 
 moduledir = @libdir@/weston
@@ -20,12 +18,9 @@ xwayland_la_CFLAGS =				\
 xwayland_la_SOURCES =				\
 	xwayland.h				\
 	window-manager.c			\
-	selection.c				\
 	launcher.c				\
 	xserver-protocol.c			\
-	xserver-server-protocol.h		\
-	hash.c					\
-	hash.h
+	xserver-server-protocol.h
 
 BUILT_SOURCES =					\
 	xserver-protocol.c			\
diff --git a/src/xwayland/hash.c b/src/xwayland/hash.c
deleted file mode 100644
index d841883..0000000
--- a/src/xwayland/hash.c
+++ /dev/null
@@ -1,307 +0,0 @@
-/*
- * Copyright © 2009 Intel Corporation
- * Copyright © 1988-2004 Keith Packard and Bart Massey.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- *
- * Except as contained in this notice, the names of the authors
- * or their institutions shall not be used in advertising or
- * otherwise to promote the sale, use or other dealings in this
- * Software without prior written authorization from the
- * authors.
- *
- * Authors:
- *    Eric Anholt <eric@anholt.net>
- *    Keith Packard <keithp@keithp.com>
- */
-
-#include <stdlib.h>
-#include <stdint.h>
-
-#include "hash.h"
-
-struct hash_entry {
-	uint32_t hash;
-	void *data;
-};
-
-struct hash_table {
-	struct hash_entry *table;
-	uint32_t size;
-	uint32_t rehash;
-	uint32_t max_entries;
-	uint32_t size_index;
-	uint32_t entries;
-	uint32_t deleted_entries;
-};
-
-#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))
-
-/*
- * From Knuth -- a good choice for hash/rehash values is p, p-2 where
- * p and p-2 are both prime.  These tables are sized to have an extra 10%
- * free to avoid exponential performance degradation as the hash table fills
- */
-
-static const uint32_t deleted_data;
-
-static const struct {
-   uint32_t max_entries, size, rehash;
-} hash_sizes[] = {
-    { 2,		5,		3	  },
-    { 4,		7,		5	  },
-    { 8,		13,		11	  },
-    { 16,		19,		17	  },
-    { 32,		43,		41        },
-    { 64,		73,		71        },
-    { 128,		151,		149       },
-    { 256,		283,		281       },
-    { 512,		571,		569       },
-    { 1024,		1153,		1151      },
-    { 2048,		2269,		2267      },
-    { 4096,		4519,		4517      },
-    { 8192,		9013,		9011      },
-    { 16384,		18043,		18041     },
-    { 32768,		36109,		36107     },
-    { 65536,		72091,		72089     },
-    { 131072,		144409,		144407    },
-    { 262144,		288361,		288359    },
-    { 524288,		576883,		576881    },
-    { 1048576,		1153459,	1153457   },
-    { 2097152,		2307163,	2307161   },
-    { 4194304,		4613893,	4613891   },
-    { 8388608,		9227641,	9227639   },
-    { 16777216,		18455029,	18455027  },
-    { 33554432,		36911011,	36911009  },
-    { 67108864,		73819861,	73819859  },
-    { 134217728,	147639589,	147639587 },
-    { 268435456,	295279081,	295279079 },
-    { 536870912,	590559793,	590559791 },
-    { 1073741824,	1181116273,	1181116271},
-    { 2147483648ul,	2362232233ul,	2362232231ul}
-};
-
-static int
-entry_is_free(struct hash_entry *entry)
-{
-	return entry->data == NULL;
-}
-
-static int
-entry_is_deleted(struct hash_entry *entry)
-{
-	return entry->data == &deleted_data;
-}
-
-static int
-entry_is_present(struct hash_entry *entry)
-{
-	return entry->data != NULL && entry->data != &deleted_data;
-}
-
-struct hash_table *
-hash_table_create(void)
-{
-	struct hash_table *ht;
-
-	ht = malloc(sizeof(*ht));
-	if (ht == NULL)
-		return NULL;
-
-	ht->size_index = 0;
-	ht->size = hash_sizes[ht->size_index].size;
-	ht->rehash = hash_sizes[ht->size_index].rehash;
-	ht->max_entries = hash_sizes[ht->size_index].max_entries;
-	ht->table = calloc(ht->size, sizeof(*ht->table));
-	ht->entries = 0;
-	ht->deleted_entries = 0;
-
-	if (ht->table == NULL) {
-		free(ht);
-		return NULL;
-	}
-
-	return ht;
-}
-
-/**
- * Frees the given hash table.
- */
-void
-hash_table_destroy(struct hash_table *ht)
-{
-	if (!ht)
-		return;
-
-	free(ht->table);
-	free(ht);
-}
-
-/**
- * Finds a hash table entry with the given key and hash of that key.
- *
- * Returns NULL if no entry is found.  Note that the data pointer may be
- * modified by the user.
- */
-static void *
-hash_table_search(struct hash_table *ht, uint32_t hash)
-{
-	uint32_t hash_address;
-
-	hash_address = hash % ht->size;
-	do {
-		uint32_t double_hash;
-
-		struct hash_entry *entry = ht->table + hash_address;
-
-		if (entry_is_free(entry)) {
-			return NULL;
-		} else if (entry_is_present(entry) && entry->hash == hash) {
-			return entry;
-		}
-
-		double_hash = 1 + hash % ht->rehash;
-
-		hash_address = (hash_address + double_hash) % ht->size;
-	} while (hash_address != hash % ht->size);
-
-	return NULL;
-}
-
-void
-hash_table_for_each(struct hash_table *ht,
-		    hash_table_iterator_func_t func, void *data)
-{
-	struct hash_entry *entry;
-	uint32_t i;
-
-	for (i = 0; i < ht->size; i++) {
-		entry = ht->table + i;
-		if (entry_is_present(entry))
-			func(entry->data, data);
-	}
-}
-
-void *
-hash_table_lookup(struct hash_table *ht, uint32_t hash)
-{
-	struct hash_entry *entry;
-
-	entry = hash_table_search(ht, hash);
-	if (entry != NULL)
-		return entry->data;
-
-	return NULL;
-}
-
-static void
-hash_table_rehash(struct hash_table *ht, unsigned int new_size_index)
-{
-	struct hash_table old_ht;
-	struct hash_entry *table, *entry;
-
-	if (new_size_index >= ARRAY_SIZE(hash_sizes))
-		return;
-
-	table = calloc(hash_sizes[new_size_index].size, sizeof(*ht->table));
-	if (table == NULL)
-		return;
-
-	old_ht = *ht;
-
-	ht->table = table;
-	ht->size_index = new_size_index;
-	ht->size = hash_sizes[ht->size_index].size;
-	ht->rehash = hash_sizes[ht->size_index].rehash;
-	ht->max_entries = hash_sizes[ht->size_index].max_entries;
-	ht->entries = 0;
-	ht->deleted_entries = 0;
-
-	for (entry = old_ht.table;
-	     entry != old_ht.table + old_ht.size;
-	     entry++) {
-		if (entry_is_present(entry)) {
-			hash_table_insert(ht, entry->hash, entry->data);
-		}
-	}
-
-	free(old_ht.table);
-}
-
-/**
- * Inserts the data with the given hash into the table.
- *
- * Note that insertion may rearrange the table on a resize or rehash,
- * so previously found hash_entries are no longer valid after this function.
- */
-int
-hash_table_insert(struct hash_table *ht, uint32_t hash, void *data)
-{
-	uint32_t hash_address;
-
-	if (ht->entries >= ht->max_entries) {
-		hash_table_rehash(ht, ht->size_index + 1);
-	} else if (ht->deleted_entries + ht->entries >= ht->max_entries) {
-		hash_table_rehash(ht, ht->size_index);
-	}
-
-	hash_address = hash % ht->size;
-	do {
-		struct hash_entry *entry = ht->table + hash_address;
-		uint32_t double_hash;
-
-		if (!entry_is_present(entry)) {
-			if (entry_is_deleted(entry))
-				ht->deleted_entries--;
-			entry->hash = hash;
-			entry->data = data;
-			ht->entries++;
-			return 0;
-		}
-
-		double_hash = 1 + hash % ht->rehash;
-
-		hash_address = (hash_address + double_hash) % ht->size;
-	} while (hash_address != hash % ht->size);
-
-	/* We could hit here if a required resize failed. An unchecked-malloc
-	 * application could ignore this result.
-	 */
-	return -1;
-}
-
-/**
- * This function deletes the given hash table entry.
- *
- * Note that deletion doesn't otherwise modify the table, so an iteration over
- * the table deleting entries is safe.
- */
-void
-hash_table_remove(struct hash_table *ht, uint32_t hash)
-{
-	struct hash_entry *entry;
-
-	entry = hash_table_search(ht, hash);
-	if (entry != NULL) {
-		entry->data = (void *) &deleted_data;
-		ht->entries--;
-		ht->deleted_entries++;
-	}
-}
diff --git a/src/xwayland/hash.h b/src/xwayland/hash.h
deleted file mode 100644
index 6e1674e..0000000
--- a/src/xwayland/hash.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright © 2009 Intel Corporation
- * Copyright © 1988-2004 Keith Packard and Bart Massey.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- *
- * Except as contained in this notice, the names of the authors
- * or their institutions shall not be used in advertising or
- * otherwise to promote the sale, use or other dealings in this
- * Software without prior written authorization from the
- * authors.
- *
- * Authors:
- *    Eric Anholt <eric@anholt.net>
- *    Keith Packard <keithp@keithp.com>
- */
-
-#ifndef HASH_H
-#define HASH_H
-
-struct hash_table;
-struct hash_table *hash_table_create(void);
-typedef void (*hash_table_iterator_func_t)(void *element, void *data);
-
-void hash_table_destroy(struct hash_table *ht);
-void *hash_table_lookup(struct hash_table *ht, uint32_t hash);
-int hash_table_insert(struct hash_table *ht, uint32_t hash, void *data);
-void hash_table_remove(struct hash_table *ht, uint32_t hash);
-void hash_table_for_each(struct hash_table *ht,
-			 hash_table_iterator_func_t func, void *data);
-
-#endif
diff --git a/src/xwayland/launcher.c b/src/xwayland/launcher.c
index ddd9640..0dec723 100644
--- a/src/xwayland/launcher.c
+++ b/src/xwayland/launcher.c
@@ -33,21 +33,41 @@
 #include <signal.h>
 
 #include "xwayland.h"
+#include "../../shared/xwayland-hash.h"
 #include "xserver-server-protocol.h"
 
+static void
+wm_sigchld(struct weston_process *process, int status)
+{
+	struct weston_xserver *wxs =
+		container_of(process, struct weston_xserver, wm_child.process);
+
+	wxs->wm_child.process.pid = 0;
+	wxs->wm_child.client = NULL;
+
+	wxs->wm_resource = NULL;
+}
 
 static int
 weston_xserver_handle_event(int listen_fd, uint32_t mask, void *data)
 {
 	struct weston_xserver *wxs = data;
 	char display[8], s[8];
-	int sv[2], client_fd;
+	int sv[2], swm[2], client_fd;
+	const char *wm_exe = BINDIR "/weston-xwm";
 
 	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, sv) < 0) {
 		weston_log("socketpair failed\n");
 		return 1;
 	}
 
+	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, swm) < 0) {
+		weston_log("socketpair failed\n");
+		return 1;
+	}
+	wxs->wm_xfd = swm[0];
+	wxs->wm_fd = swm[1];
+
 	wxs->process.pid = fork();
 	switch (wxs->process.pid) {
 	case 0:
@@ -84,6 +104,14 @@ weston_xserver_handle_event(int listen_fd, uint32_t mask, void *data)
 
 		wl_event_source_remove(wxs->abstract_source);
 		wl_event_source_remove(wxs->unix_source);
+
+		wxs->wm_child.client = weston_client_launch(wxs->compositor,
+				&wxs->wm_child.process, wm_exe, wm_sigchld);
+		if (!wxs->wm_child.client) {
+			weston_log("failed to fork XWM\n");
+			return 1;
+		}
+		weston_log("forked Weston XWM, pid %d\n", wxs->wm_child.process.pid);
 		break;
 
 	case -1:
@@ -109,8 +137,6 @@ weston_xserver_shutdown(struct weston_xserver *wxs)
 	}
 	close(wxs->abstract_fd);
 	close(wxs->unix_fd);
-	if (wxs->wm)
-		weston_wm_destroy(wxs->wm);
 	wxs->loop = NULL;
 }
 
@@ -134,17 +160,10 @@ weston_xserver_cleanup(struct weston_process *process, int status)
 				     WL_EVENT_READABLE,
 				     weston_xserver_handle_event, wxs);
 
-	if (wxs->wm) {
-		weston_log("xserver exited, code %d\n", status);
-		weston_wm_destroy(wxs->wm);
-		wxs->wm = NULL;
-	} else {
-		/* If the X server crashes before it binds to the
-		 * xserver interface, shut down and don't try
-		 * again. */
-		weston_log("xserver crashing too fast: %d\n", status);
-		weston_xserver_shutdown(wxs);
-	}
+	/* If the X server crashes before it binds to the xserver interface,
+	 * shut down and don't try again. */
+	weston_log("xserver crashing too fast: %d\n", status);
+	weston_xserver_shutdown(wxs);
 }
 
 static void
@@ -153,22 +172,27 @@ bind_xserver(struct wl_client *client,
 {
 	struct weston_xserver *wxs = data;
 
-	/* If it's a different client than the xserver we launched,
-	 * don't start the wm. */
-	if (client != wxs->client)
-		return;
-
 	wxs->resource = 
 		wl_client_add_object(client, &xserver_interface,
 				     &xserver_implementation, id, wxs);
+}
 
-	wxs->wm = weston_wm_create(wxs);
-	if (wxs->wm == NULL) {
-		weston_log("failed to create wm\n");
-	}
+static void
+bind_wm(struct wl_client *client, void *data, uint32_t version, uint32_t id)
+{
+	struct weston_xserver *wxs = data;
+
+	wxs->wm_resource = wl_client_add_object(client, &wm_interface,
+						&wm_implementation, id, wxs);
+
+	/* sending X fd (from the socketpair) to client WM, which will connect
+	 * onto it and initialize the first WM related procedures */
+	wm_send_xserver(wxs->wm_resource, wxs->wm_xfd);
 
-	xserver_send_listen_socket(wxs->resource, wxs->abstract_fd);
-	xserver_send_listen_socket(wxs->resource, wxs->unix_fd);
+	/* meanwhile X will be in fact managing the WM connecting by sending
+	 * the other socketpair file descriptor (via (AddClientOnOpenFD) */
+	xserver_send_client(wxs->resource, wxs->wm_fd);
+	close(wxs->wm_fd);
 }
 
 static int
@@ -373,6 +397,7 @@ module_init(struct weston_compositor *compositor)
 				     weston_xserver_handle_event, wxs);
 
 	wl_display_add_global(display, &xserver_interface, wxs, bind_xserver);
+	wl_display_add_global(display, &wm_interface, wxs, bind_wm);
 
 	wxs->destroy_listener.notify = weston_xserver_destroy;
 	wl_signal_add(&compositor->destroy_signal, &wxs->destroy_listener);
diff --git a/src/xwayland/selection.c b/src/xwayland/selection.c
deleted file mode 100644
index edc7ce6..0000000
--- a/src/xwayland/selection.c
+++ /dev/null
@@ -1,703 +0,0 @@
-/*
- * Copyright © 2012 Intel Corporation
- *
- * Permission to use, copy, modify, distribute, and sell this software and
- * its documentation for any purpose is hereby granted without fee, provided
- * that the above copyright notice appear in all copies and that both that
- * copyright notice and this permission notice appear in supporting
- * documentation, and that the name of the copyright holders not be used in
- * advertising or publicity pertaining to distribution of the software
- * without specific, written prior permission.  The copyright holders make
- * no representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
- * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
- * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
- * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
- * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
- * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#define _GNU_SOURCE
-
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <fcntl.h>
-
-#include "xwayland.h"
-
-static int
-weston_wm_write_property(int fd, uint32_t mask, void *data)
-{
-	struct weston_wm *wm = data;
-	unsigned char *property;
-	int len, remainder;
-
-	property = xcb_get_property_value(wm->property_reply);
-	remainder = xcb_get_property_value_length(wm->property_reply) -
-		wm->property_start;
-
-	len = write(fd, property + wm->property_start, remainder);
-	if (len == -1) {
-		free(wm->property_reply);
-		wl_event_source_remove(wm->property_source);
-		close(fd);
-		weston_log("write error to target fd: %m\n");
-		return 1;
-	}
-
-	weston_log("wrote %d (chunk size %d) of %d bytes\n",
-		wm->property_start + len,
-		len, xcb_get_property_value_length(wm->property_reply));
-
-	wm->property_start += len;
-	if (len == remainder) {
-		free(wm->property_reply);
-		wl_event_source_remove(wm->property_source);
-
-		if (wm->incr) {
-			xcb_delete_property(wm->conn,
-					    wm->selection_window,
-					    wm->atom.wl_selection);
-		} else {
-			weston_log("transfer complete\n");
-			close(fd);
-		}
-	}
-
-	return 1;
-}
-
-static void
-weston_wm_get_incr_chunk(struct weston_wm *wm)
-{
-	xcb_get_property_cookie_t cookie;
-	xcb_get_property_reply_t *reply;
-
-	cookie = xcb_get_property(wm->conn,
-				  0, /* delete */
-				  wm->selection_window,
-				  wm->atom.wl_selection,
-				  XCB_GET_PROPERTY_TYPE_ANY,
-				  0, /* offset */
-				  0x1fffffff /* length */);
-
-	reply = xcb_get_property_reply(wm->conn, cookie, NULL);
-
-	dump_property(wm, wm->atom.wl_selection, reply);
-
-	if (xcb_get_property_value_length(reply) > 0) {
-		wm->property_start = 0;
-		wm->property_source =
-			wl_event_loop_add_fd(wm->server->loop,
-					     wm->data_source_fd,
-					     WL_EVENT_WRITABLE,
-					     weston_wm_write_property,
-					     wm);
-		wm->property_reply = reply;
-	} else {
-		weston_log("transfer complete\n");
-		close(wm->data_source_fd);
-		free(reply);
-	}
-}
-
-struct x11_data_source {
-	struct wl_data_source base;
-	struct weston_wm *wm;
-};
-
-static void
-data_source_accept(struct wl_data_source *source,
-		   uint32_t time, const char *mime_type)
-{
-}
-
-static void
-data_source_send(struct wl_data_source *base,
-		 const char *mime_type, int32_t fd)
-{
-	struct x11_data_source *source = (struct x11_data_source *) base;
-	struct weston_wm *wm = source->wm;
-
-	if (strcmp(mime_type, "text/plain;charset=utf-8") == 0) {
-		/* Get data for the utf8_string target */
-		xcb_convert_selection(wm->conn,
-				      wm->selection_window,
-				      wm->atom.clipboard,
-				      wm->atom.utf8_string,
-				      wm->atom.wl_selection,
-				      XCB_TIME_CURRENT_TIME);
-
-		xcb_flush(wm->conn);
-
-		fcntl(fd, F_SETFL, O_WRONLY | O_NONBLOCK);
-		wm->data_source_fd = fcntl(fd, F_DUPFD_CLOEXEC, fd);
-	}
-}
-
-static void
-data_source_cancel(struct wl_data_source *source)
-{
-}
-
-static void
-weston_wm_get_selection_targets(struct weston_wm *wm)
-{
-	struct x11_data_source *source;
-	struct weston_compositor *compositor;
-	struct weston_seat *seat = weston_wm_pick_seat(wm);
-	xcb_get_property_cookie_t cookie;
-	xcb_get_property_reply_t *reply;
-	xcb_atom_t *value;
-	char **p;
-	uint32_t i;
-
-	cookie = xcb_get_property(wm->conn,
-				  1, /* delete */
-				  wm->selection_window,
-				  wm->atom.wl_selection,
-				  XCB_GET_PROPERTY_TYPE_ANY,
-				  0, /* offset */
-				  4096 /* length */);
-
-	reply = xcb_get_property_reply(wm->conn, cookie, NULL);
-
-	dump_property(wm, wm->atom.wl_selection, reply);
-
-	if (reply->type != XCB_ATOM_ATOM) {
-		free(reply);
-		return;
-	}
-
-	source = malloc(sizeof *source);
-	if (source == NULL)
-		return;
-
-	wl_signal_init(&source->base.resource.destroy_signal);
-	source->base.accept = data_source_accept;
-	source->base.send = data_source_send;
-	source->base.cancel = data_source_cancel;
-	source->base.resource.data = source;
-	source->wm = wm;
-
-	wl_array_init(&source->base.mime_types);
-	value = xcb_get_property_value(reply);
-	for (i = 0; i < reply->value_len; i++) {
-		if (value[i] == wm->atom.utf8_string) {
-			p = wl_array_add(&source->base.mime_types, sizeof *p);
-			if (p)
-				*p = strdup("text/plain;charset=utf-8");
-		}
-	}
-
-	compositor = wm->server->compositor;
-	wl_seat_set_selection(&seat->seat, &source->base,
-			      wl_display_next_serial(compositor->wl_display));
-
-	free(reply);
-}
-
-static void
-weston_wm_get_selection_data(struct weston_wm *wm)
-{
-	xcb_get_property_cookie_t cookie;
-	xcb_get_property_reply_t *reply;
-
-	cookie = xcb_get_property(wm->conn,
-				  1, /* delete */
-				  wm->selection_window,
-				  wm->atom.wl_selection,
-				  XCB_GET_PROPERTY_TYPE_ANY,
-				  0, /* offset */
-				  0x1fffffff /* length */);
-
-	reply = xcb_get_property_reply(wm->conn, cookie, NULL);
-
-	if (reply->type == wm->atom.incr) {
-		dump_property(wm, wm->atom.wl_selection, reply);
-		wm->incr = 1;
-		free(reply);
-	} else {
-		dump_property(wm, wm->atom.wl_selection, reply);
-		wm->incr = 0;
-		wm->property_start = 0;
-		wm->property_source =
-			wl_event_loop_add_fd(wm->server->loop,
-					     wm->data_source_fd,
-					     WL_EVENT_WRITABLE,
-					     weston_wm_write_property,
-					     wm);
-		wm->property_reply = reply;
-	}
-}
-
-static void
-weston_wm_handle_selection_notify(struct weston_wm *wm,
-				xcb_generic_event_t *event)
-{
-	xcb_selection_notify_event_t *selection_notify =
-		(xcb_selection_notify_event_t *) event;
-
-	if (selection_notify->property == XCB_ATOM_NONE) {
-		/* convert selection failed */
-	} else if (selection_notify->target == wm->atom.targets) {
-		weston_wm_get_selection_targets(wm);
-	} else {
-		weston_wm_get_selection_data(wm);
-	}
-}
-
-static const size_t incr_chunk_size = 64 * 1024;
-
-static void
-weston_wm_send_selection_notify(struct weston_wm *wm, xcb_atom_t property)
-{
-	xcb_selection_notify_event_t selection_notify;
-
-	memset(&selection_notify, 0, sizeof selection_notify);
-	selection_notify.response_type = XCB_SELECTION_NOTIFY;
-	selection_notify.sequence = 0;
-	selection_notify.time = wm->selection_request.time;
-	selection_notify.requestor = wm->selection_request.requestor;
-	selection_notify.selection = wm->selection_request.selection;
-	selection_notify.target = wm->selection_request.target;
-	selection_notify.property = property;
-
-	xcb_send_event(wm->conn, 0, /* propagate */
-		       wm->selection_request.requestor,
-		       XCB_EVENT_MASK_NO_EVENT, (char *) &selection_notify);
-}
-
-static void
-weston_wm_send_targets(struct weston_wm *wm)
-{
-	xcb_atom_t targets[] = {
-		wm->atom.timestamp,
-		wm->atom.targets,
-		wm->atom.utf8_string,
-		/* wm->atom.compound_text, */
-		wm->atom.text,
-		/* wm->atom.string */
-	};
-
-	xcb_change_property(wm->conn,
-			    XCB_PROP_MODE_REPLACE,
-			    wm->selection_request.requestor,
-			    wm->selection_request.property,
-			    XCB_ATOM_ATOM,
-			    32, /* format */
-			    ARRAY_LENGTH(targets), targets);
-
-	weston_wm_send_selection_notify(wm, wm->selection_request.property);
-}
-
-static void
-weston_wm_send_timestamp(struct weston_wm *wm)
-{
-	xcb_change_property(wm->conn,
-			    XCB_PROP_MODE_REPLACE,
-			    wm->selection_request.requestor,
-			    wm->selection_request.property,
-			    XCB_ATOM_INTEGER,
-			    32, /* format */
-			    1, &wm->selection_timestamp);
-
-	weston_wm_send_selection_notify(wm, wm->selection_request.property);
-}
-
-static int
-weston_wm_flush_source_data(struct weston_wm *wm)
-{
-	int length;
-
-	xcb_change_property(wm->conn,
-			    XCB_PROP_MODE_REPLACE,
-			    wm->selection_request.requestor,
-			    wm->selection_request.property,
-			    wm->selection_target,
-			    8, /* format */
-			    wm->source_data.size,
-			    wm->source_data.data);
-	wm->selection_property_set = 1;
-	length = wm->source_data.size;
-	wm->source_data.size = 0;
-
-	return length;
-}
-
-static int
-weston_wm_read_data_source(int fd, uint32_t mask, void *data)
-{
-	struct weston_wm *wm = data;
-	int len, current, available;
-	void *p;
-
-	current = wm->source_data.size;
-	if (wm->source_data.size < incr_chunk_size)
-		p = wl_array_add(&wm->source_data, incr_chunk_size);
-	else
-		p = (char *) wm->source_data.data + wm->source_data.size;
-	available = wm->source_data.alloc - current;
-
-	len = read(fd, p, available);
-	if (len == -1) {
-		weston_log("read error from data source: %m\n");
-		weston_wm_send_selection_notify(wm, XCB_ATOM_NONE);
-		wl_event_source_remove(wm->property_source);
-		close(fd);
-		wl_array_release(&wm->source_data);
-	}
-
-	weston_log("read %d (available %d, mask 0x%x) bytes: \"%.*s\"\n",
-		len, available, mask, len, (char *) p);
-
-	wm->source_data.size = current + len;
-	if (wm->source_data.size >= incr_chunk_size) {
-		if (!wm->incr) {
-			weston_log("got %zu bytes, starting incr\n",
-				wm->source_data.size);
-			wm->incr = 1;
-			xcb_change_property(wm->conn,
-					    XCB_PROP_MODE_REPLACE,
-					    wm->selection_request.requestor,
-					    wm->selection_request.property,
-					    wm->atom.incr,
-					    32, /* format */
-					    1, &incr_chunk_size);
-			wm->selection_property_set = 1;
-			wm->flush_property_on_delete = 1;
-			wl_event_source_remove(wm->property_source);
-			weston_wm_send_selection_notify(wm, wm->selection_request.property);
-		} else if (wm->selection_property_set) {
-			weston_log("got %zu bytes, waiting for "
-				"property delete\n", wm->source_data.size);
-
-			wm->flush_property_on_delete = 1;
-			wl_event_source_remove(wm->property_source);
-		} else {
-			weston_log("got %zu bytes, "
-				"property deleted, seting new property\n",
-				wm->source_data.size);
-			weston_wm_flush_source_data(wm);
-		}
-	} else if (len == 0 && !wm->incr) {
-		weston_log("non-incr transfer complete\n");
-		/* Non-incr transfer all done. */
-		weston_wm_flush_source_data(wm);
-		weston_wm_send_selection_notify(wm, wm->selection_request.property);
-		xcb_flush(wm->conn);
-		wl_event_source_remove(wm->property_source);
-		close(fd);
-		wl_array_release(&wm->source_data);
-		wm->selection_request.requestor = XCB_NONE;
-	} else if (len == 0 && wm->incr) {
-		weston_log("incr transfer complete\n");
-
-		wm->flush_property_on_delete = 1;
-		if (wm->selection_property_set) {
-			weston_log("got %zu bytes, waiting for "
-				"property delete\n", wm->source_data.size);
-		} else {
-			weston_log("got %zu bytes, "
-				"property deleted, seting new property\n",
-				wm->source_data.size);
-			weston_wm_flush_source_data(wm);
-		}
-		xcb_flush(wm->conn);
-		wl_event_source_remove(wm->property_source);
-		close(wm->data_source_fd);
-		wm->data_source_fd = -1;
-		close(fd);
-	} else {
-		weston_log("nothing happened, buffered the bytes\n");
-	}
-
-	return 1;
-}
-
-static void
-weston_wm_send_data(struct weston_wm *wm, xcb_atom_t target, const char *mime_type)
-{
-	struct wl_data_source *source;
-	struct weston_seat *seat = weston_wm_pick_seat(wm);
-	int p[2];
-
-	if (pipe2(p, O_CLOEXEC | O_NONBLOCK) == -1) {
-		weston_log("pipe2 failed: %m\n");
-		weston_wm_send_selection_notify(wm, XCB_ATOM_NONE);
-		return;
-	}
-
-	wl_array_init(&wm->source_data);
-	wm->selection_target = target;
-	wm->data_source_fd = p[0];
-	wm->property_source = wl_event_loop_add_fd(wm->server->loop,
-						   wm->data_source_fd,
-						   WL_EVENT_READABLE,
-						   weston_wm_read_data_source,
-						   wm);
-
-	source = seat->seat.selection_data_source;
-	source->send(source, mime_type, p[1]);
-}
-
-static void
-weston_wm_send_incr_chunk(struct weston_wm *wm)
-{
-	int length;
-
-	weston_log("property deleted\n");
-
-	wm->selection_property_set = 0;
-	if (wm->flush_property_on_delete) {
-		weston_log("setting new property, %zu bytes\n",
-			wm->source_data.size);
-		wm->flush_property_on_delete = 0;
-		length = weston_wm_flush_source_data(wm);
-
-		if (wm->data_source_fd >= 0) {
-			wm->property_source =
-				wl_event_loop_add_fd(wm->server->loop,
-						     wm->data_source_fd,
-						     WL_EVENT_READABLE,
-						     weston_wm_read_data_source,
-						     wm);
-		} else if (length > 0) {
-			/* Transfer is all done, but queue a flush for
-			 * the delete of the last chunk so we can set
-			 * the 0 sized propert to signal the end of
-			 * the transfer. */
-			wm->flush_property_on_delete = 1;
-			wl_array_release(&wm->source_data);
-		} else {
-			wm->selection_request.requestor = XCB_NONE;
-		}
-	}
-}
-
-static int
-weston_wm_handle_selection_property_notify(struct weston_wm *wm,
-					   xcb_generic_event_t *event)
-{
-	xcb_property_notify_event_t *property_notify =
-		(xcb_property_notify_event_t *) event;
-
-	if (property_notify->window == wm->selection_window) {
-		if (property_notify->state == XCB_PROPERTY_NEW_VALUE &&
-		    property_notify->atom == wm->atom.wl_selection &&
-		    wm->incr)
-			weston_wm_get_incr_chunk(wm);
-		return 1;
-	} else if (property_notify->window == wm->selection_request.requestor) {
-		if (property_notify->state == XCB_PROPERTY_DELETE &&
-		    property_notify->atom == wm->selection_request.property &&
-		    wm->incr)
-			weston_wm_send_incr_chunk(wm);
-		return 1;
-	}
-
-	return 0;
-}
-
-static void
-weston_wm_handle_selection_request(struct weston_wm *wm,
-				 xcb_generic_event_t *event)
-{
-	xcb_selection_request_event_t *selection_request =
-		(xcb_selection_request_event_t *) event;
-
-	weston_log("selection request, %s, ",
-		get_atom_name(wm->conn, selection_request->selection));
-	weston_log_continue("target %s, ",
-		get_atom_name(wm->conn, selection_request->target));
-	weston_log_continue("property %s\n",
-		get_atom_name(wm->conn, selection_request->property));
-
-	wm->selection_request = *selection_request;
-	wm->incr = 0;
-	wm->flush_property_on_delete = 0;
-
-	if (selection_request->selection == wm->atom.clipboard_manager) {
-		/* The weston clipboard should already have grabbed
-		 * the first target, so just send selection notify
-		 * now.  This isn't synchronized with the clipboard
-		 * finishing getting the data, so there's a race here. */
-		weston_wm_send_selection_notify(wm, wm->selection_request.property);
-		return;
-	}
-
-	if (selection_request->target == wm->atom.targets) {
-		weston_wm_send_targets(wm);
-	} else if (selection_request->target == wm->atom.timestamp) {
-		weston_wm_send_timestamp(wm);
-	} else if (selection_request->target == wm->atom.utf8_string ||
-		   selection_request->target == wm->atom.text) {
-		weston_wm_send_data(wm, wm->atom.utf8_string,
-				  "text/plain;charset=utf-8");
-	} else {
-		weston_log("can only handle UTF8_STRING targets...\n");
-		weston_wm_send_selection_notify(wm, XCB_ATOM_NONE);
-	}
-}
-
-static void
-weston_wm_handle_xfixes_selection_notify(struct weston_wm *wm,
-				       xcb_generic_event_t *event)
-{
-	xcb_xfixes_selection_notify_event_t *xfixes_selection_notify =
-		(xcb_xfixes_selection_notify_event_t *) event;
-	struct weston_compositor *compositor;
-	struct weston_seat *seat = weston_wm_pick_seat(wm);
-	uint32_t serial;
-
-	weston_log("xfixes selection notify event: owner %d\n",
-	       xfixes_selection_notify->owner);
-
-	if (xfixes_selection_notify->owner == XCB_WINDOW_NONE) {
-		if (wm->selection_owner != wm->selection_window) {
-			/* A real X client selection went away, not our
-			 * proxy selection.  Clear the wayland selection. */
-			compositor = wm->server->compositor;
-			serial = wl_display_next_serial(compositor->wl_display);
-			wl_seat_set_selection(&seat->seat, NULL, serial);
-		}
-
-		wm->selection_owner = XCB_WINDOW_NONE;
-
-		return;
-	}
-
-	wm->selection_owner = xfixes_selection_notify->owner;
-
-	/* We have to use XCB_TIME_CURRENT_TIME when we claim the
-	 * selection, so grab the actual timestamp here so we can
-	 * answer TIMESTAMP conversion requests correctly. */
-	if (xfixes_selection_notify->owner == wm->selection_window) {
-		wm->selection_timestamp = xfixes_selection_notify->timestamp;
-		weston_log("our window, skipping\n");
-		return;
-	}
-
-	wm->incr = 0;
-	xcb_convert_selection(wm->conn, wm->selection_window,
-			      wm->atom.clipboard,
-			      wm->atom.targets,
-			      wm->atom.wl_selection,
-			      xfixes_selection_notify->timestamp);
-
-	xcb_flush(wm->conn);
-}
-
-int
-weston_wm_handle_selection_event(struct weston_wm *wm,
-				 xcb_generic_event_t *event)
-{
-	switch (event->response_type & ~0x80) {
-	case XCB_SELECTION_NOTIFY:
-		weston_wm_handle_selection_notify(wm, event);
-		return 1;
-	case XCB_PROPERTY_NOTIFY:
-		return weston_wm_handle_selection_property_notify(wm, event);
-	case XCB_SELECTION_REQUEST:
-		weston_wm_handle_selection_request(wm, event);
-		return 1;
-	}
-
-	switch (event->response_type - wm->xfixes->first_event) {
-	case XCB_XFIXES_SELECTION_NOTIFY:
-		weston_wm_handle_xfixes_selection_notify(wm, event);
-		return 1;
-	}
-
-	return 0;
-}
-
-static void
-weston_wm_set_selection(struct wl_listener *listener, void *data)
-{
-	struct wl_seat *seat = data;
-	struct weston_wm *wm =
-		container_of(listener, struct weston_wm, selection_listener);
-	struct wl_data_source *source = seat->selection_data_source;
-	const char **p, **end;
-	int has_text_plain = 0;
-
-	if (source == NULL) {
-		if (wm->selection_owner == wm->selection_window)
-			xcb_set_selection_owner(wm->conn,
-						XCB_ATOM_NONE,
-						wm->atom.clipboard,
-						wm->selection_timestamp);
-		return;
-	}
-
-	if (source->send == data_source_send)
-		return;
-
-	p = source->mime_types.data;
-	end = (const char **)
-		((char *) source->mime_types.data + source->mime_types.size);
-	while (p < end) {
-		weston_log("  %s\n", *p);
-		if (strcmp(*p, "text/plain") == 0 ||
-		    strcmp(*p, "text/plain;charset=utf-8") == 0)
-			has_text_plain = 1;
-		p++;
-	}
-
-	if (has_text_plain) {
-		xcb_set_selection_owner(wm->conn,
-					wm->selection_window,
-					wm->atom.clipboard,
-					XCB_TIME_CURRENT_TIME);
-	} else {
-		xcb_set_selection_owner(wm->conn,
-					XCB_ATOM_NONE,
-					wm->atom.clipboard,
-					XCB_TIME_CURRENT_TIME);
-	}
-}
-
-void
-weston_wm_selection_init(struct weston_wm *wm)
-{
-	struct weston_seat *seat;
-	uint32_t values[1], mask;
-
-	wm->selection_request.requestor = XCB_NONE;
-
-	values[0] = XCB_EVENT_MASK_PROPERTY_CHANGE;
-	wm->selection_window = xcb_generate_id(wm->conn);
-	xcb_create_window(wm->conn,
-			  XCB_COPY_FROM_PARENT,
-			  wm->selection_window,
-			  wm->screen->root,
-			  0, 0,
-			  10, 10,
-			  0,
-			  XCB_WINDOW_CLASS_INPUT_OUTPUT,
-			  wm->screen->root_visual,
-			  XCB_CW_EVENT_MASK, values);
-
-	xcb_set_selection_owner(wm->conn,
-				wm->selection_window,
-				wm->atom.clipboard_manager,
-				XCB_TIME_CURRENT_TIME);
-
-	mask =
-		XCB_XFIXES_SELECTION_EVENT_MASK_SET_SELECTION_OWNER |
-		XCB_XFIXES_SELECTION_EVENT_MASK_SELECTION_WINDOW_DESTROY |
-		XCB_XFIXES_SELECTION_EVENT_MASK_SELECTION_CLIENT_CLOSE;
-	xcb_xfixes_select_selection_input(wm->conn, wm->selection_window,
-					  wm->atom.clipboard, mask);
-
-	seat = weston_wm_pick_seat(wm);
-	wm->selection_listener.notify = weston_wm_set_selection;
-	wl_signal_add(&seat->seat.selection_signal, &wm->selection_listener);
-
-	weston_wm_set_selection(&wm->selection_listener, seat);
-}
diff --git a/src/xwayland/window-manager.c b/src/xwayland/window-manager.c
index 303ef15..1229aa0 100644
--- a/src/xwayland/window-manager.c
+++ b/src/xwayland/window-manager.c
@@ -1,5 +1,5 @@
 /*
- * Copyright © 2011 Intel Corporation
+ * Copyright © 2011-2012 Intel Corporation
  *
  * Permission to use, copy, modify, distribute, and sell this software and
  * its documentation for any purpose is hereby granted without fee, provided
@@ -18,1674 +18,400 @@
  * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
  * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Author: Tiago Vignatti
  */
 
-#define _GNU_SOURCE
-
 #include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <sys/socket.h>
-#include <sys/un.h>
-#include <fcntl.h>
-#include <errno.h>
 #include <unistd.h>
-#include <signal.h>
-#include <X11/Xcursor/Xcursor.h>
-
+#include <string.h>
 #include "xwayland.h"
 
-#include "../../shared/cairo-util.h"
-#include "../compositor.h"
+#include "../../shared/xwayland-hash.h"
 #include "xserver-server-protocol.h"
-#include "hash.h"
-
-struct motif_wm_hints {
-	uint32_t flags;
-	uint32_t functions;
-	uint32_t decorations;
-	int32_t input_mode;
-	uint32_t status;
-};
 
-#define MWM_HINTS_FUNCTIONS     (1L << 0)
-#define MWM_HINTS_DECORATIONS   (1L << 1)
-#define MWM_HINTS_INPUT_MODE    (1L << 2)
-#define MWM_HINTS_STATUS        (1L << 3)
-
-#define MWM_FUNC_ALL            (1L << 0)
-#define MWM_FUNC_RESIZE         (1L << 1)
-#define MWM_FUNC_MOVE           (1L << 2)
-#define MWM_FUNC_MINIMIZE       (1L << 3)
-#define MWM_FUNC_MAXIMIZE       (1L << 4)
-#define MWM_FUNC_CLOSE          (1L << 5)
-
-#define MWM_DECOR_ALL           (1L << 0)
-#define MWM_DECOR_BORDER        (1L << 1)
-#define MWM_DECOR_RESIZEH       (1L << 2)
-#define MWM_DECOR_TITLE         (1L << 3)
-#define MWM_DECOR_MENU          (1L << 4)
-#define MWM_DECOR_MINIMIZE      (1L << 5)
-#define MWM_DECOR_MAXIMIZE      (1L << 6)
-
-#define MWM_INPUT_MODELESS 0
-#define MWM_INPUT_PRIMARY_APPLICATION_MODAL 1
-#define MWM_INPUT_SYSTEM_MODAL 2
-#define MWM_INPUT_FULL_APPLICATION_MODAL 3
-#define MWM_INPUT_APPLICATION_MODAL MWM_INPUT_PRIMARY_APPLICATION_MODAL
-
-#define MWM_TEAROFF_WINDOW      (1L<<0)
-
-#define _NET_WM_MOVERESIZE_SIZE_TOPLEFT      0
-#define _NET_WM_MOVERESIZE_SIZE_TOP          1
-#define _NET_WM_MOVERESIZE_SIZE_TOPRIGHT     2
-#define _NET_WM_MOVERESIZE_SIZE_RIGHT        3
-#define _NET_WM_MOVERESIZE_SIZE_BOTTOMRIGHT  4
-#define _NET_WM_MOVERESIZE_SIZE_BOTTOM       5
-#define _NET_WM_MOVERESIZE_SIZE_BOTTOMLEFT   6
-#define _NET_WM_MOVERESIZE_SIZE_LEFT         7
-#define _NET_WM_MOVERESIZE_MOVE              8   /* movement only */
-#define _NET_WM_MOVERESIZE_SIZE_KEYBOARD     9   /* size via keyboard */
-#define _NET_WM_MOVERESIZE_MOVE_KEYBOARD    10   /* move via keyboard */
-#define _NET_WM_MOVERESIZE_CANCEL           11   /* cancel operation */
-
-
-
-struct weston_wm_window {
-	struct weston_wm *wm;
-	xcb_window_t id;
-	xcb_window_t frame_id;
-	cairo_surface_t *cairo_surface;
-	struct weston_surface *surface;
+struct xserver_window {
+	struct wl_resource resource;
+	struct wl_list link;
+
+	struct weston_xserver *wxs;
+	struct wl_surface *surface;
 	struct shell_surface *shsurf;
 	struct wl_listener surface_destroy_listener;
-	struct wl_event_source *repaint_source;
-	struct wl_event_source *configure_source;
-	int properties_dirty;
-	int pid;
-	char *machine;
-	char *class;
-	char *name;
-	struct weston_wm_window *transient_for;
-	uint32_t protocols;
-	xcb_atom_t type;
-	int width, height;
+	struct wl_listener position_listener;
+	struct wl_listener kill_listener;
+
+	uint32_t xid;
 	int x, y;
-	int decorate;
-	int override_redirect;
+	int width, height;
+	int flags;
 };
 
-static struct weston_wm_window *
-get_wm_window(struct weston_surface *surface);
-
-static void
-weston_wm_window_schedule_repaint(struct weston_wm_window *window);
-
-const char *
-get_atom_name(xcb_connection_t *c, xcb_atom_t atom)
-{
-	xcb_get_atom_name_cookie_t cookie;
-	xcb_get_atom_name_reply_t *reply;
-	xcb_generic_error_t *e;
-	static char buffer[64];
-
-	if (atom == XCB_ATOM_NONE)
-		return "None";
-
-	cookie = xcb_get_atom_name (c, atom);
-	reply = xcb_get_atom_name_reply (c, cookie, &e);
-	snprintf(buffer, sizeof buffer, "%.*s",
-		 xcb_get_atom_name_name_length (reply),
-		 xcb_get_atom_name_name (reply));
-	free(reply);
-
-	return buffer;
-}
-
-static xcb_cursor_t
-xcb_cursor_image_load_cursor(struct weston_wm *wm, const XcursorImage *img)
-{
-	xcb_connection_t *c = wm->conn;
-	xcb_screen_iterator_t s = xcb_setup_roots_iterator(xcb_get_setup(c));
-	xcb_screen_t *screen = s.data;
-	xcb_gcontext_t gc;
-	xcb_pixmap_t pix;
-	xcb_render_picture_t pic;
-	xcb_cursor_t cursor;
-	int stride = img->width * 4;
-
-	pix = xcb_generate_id(c);
-	xcb_create_pixmap(c, 32, pix, screen->root, img->width, img->height);
-
-	pic = xcb_generate_id(c);
-	xcb_render_create_picture(c, pic, pix, wm->format_rgba.id, 0, 0);
-
-	gc = xcb_generate_id(c);
-	xcb_create_gc(c, gc, pix, 0, 0);
-
-	xcb_put_image(c, XCB_IMAGE_FORMAT_Z_PIXMAP, pix, gc,
-		      img->width, img->height, 0, 0, 0, 32,
-		      stride * img->height, (uint8_t *) img->pixels);
-	xcb_free_gc(c, gc);
-
-	cursor = xcb_generate_id(c);
-	xcb_render_create_cursor(c, cursor, pic, img->xhot, img->yhot);
-
-	xcb_render_free_picture(c, pic);
-	xcb_free_pixmap(c, pix);
-
-	return cursor;
-}
-
-static xcb_cursor_t
-xcb_cursor_images_load_cursor(struct weston_wm *wm, const XcursorImages *images)
-{
-	/* TODO: treat animated cursors as well */
-	if (images->nimage != 1)
-		return -1;
-
-	return xcb_cursor_image_load_cursor(wm, images->images[0]);
-}
-
-static xcb_cursor_t
-xcb_cursor_library_load_cursor(struct weston_wm *wm, const char *file)
-{
-	xcb_cursor_t cursor;
-	XcursorImages *images;
-	char *v = NULL;
-	int size = 0;
-
-	if (!file)
-		return 0;
-
-	v = getenv ("XCURSOR_SIZE");
-	if (v)
-		size = atoi(v);
-
-	if (!size)
-		size = 32;
-
-	images = XcursorLibraryLoadImages (file, NULL, size);
-	if (!images)
-		return -1;
-
-	cursor = xcb_cursor_images_load_cursor (wm, images);
-	XcursorImagesDestroy (images);
-
-	return cursor;
-}
-
-void
-dump_property(struct weston_wm *wm,
-	      xcb_atom_t property, xcb_get_property_reply_t *reply)
-{
-	int32_t *incr_value;
-	const char *text_value, *name;
-	xcb_atom_t *atom_value;
-	int width, len;
-	uint32_t i;
-
-	width = weston_log_continue("%s: ", get_atom_name(wm->conn, property));
-	if (reply == NULL) {
-		weston_log_continue("(no reply)\n");
-		return;
-	}
-
-	width += weston_log_continue(
-			 "%s/%d, length %d (value_len %d): ",
-			 get_atom_name(wm->conn, reply->type),
-			 reply->format,
-			 xcb_get_property_value_length(reply),
-			 reply->value_len);
-
-	if (reply->type == wm->atom.incr) {
-		incr_value = xcb_get_property_value(reply);
-		weston_log_continue("%d\n", *incr_value);
-	} else if (reply->type == wm->atom.utf8_string ||
-	      reply->type == wm->atom.string) {
-		text_value = xcb_get_property_value(reply);
-		if (reply->value_len > 40)
-			len = 40;
-		else
-			len = reply->value_len;
-		weston_log_continue("\"%.*s\"\n", len, text_value);
-	} else if (reply->type == XCB_ATOM_ATOM) {
-		atom_value = xcb_get_property_value(reply);
-		for (i = 0; i < reply->value_len; i++) {
-			name = get_atom_name(wm->conn, atom_value[i]);
-			if (width + strlen(name) + 2 > 78) {
-				weston_log_continue("\n    ");
-				width = 4;
-			} else if (i > 0) {
-				width +=  weston_log_continue(", ");
-			}
-
-			width +=  weston_log_continue("%s", name);
-		}
-		weston_log_continue("\n");
-	} else {
-		weston_log_continue("huh?\n");
-	}
-}
-
-static void
-read_and_dump_property(struct weston_wm *wm,
-		       xcb_window_t window, xcb_atom_t property)
-{
-	xcb_get_property_reply_t *reply;
-	xcb_get_property_cookie_t cookie;
-
-	cookie = xcb_get_property(wm->conn, 0, window,
-				  property, XCB_ATOM_ANY, 0, 2048);
-	reply = xcb_get_property_reply(wm->conn, cookie, NULL);
-
-	dump_property(wm, property, reply);
-
-	free(reply);
-}
-
-/* We reuse some predefined, but otherwise useles atoms */
-#define TYPE_WM_PROTOCOLS	XCB_ATOM_CUT_BUFFER0
-#define TYPE_MOTIF_WM_HINTS	XCB_ATOM_CUT_BUFFER1
-
-static void
-weston_wm_window_read_properties(struct weston_wm_window *window)
-{
-	struct weston_wm *wm = window->wm;
-
-#define F(field) offsetof(struct weston_wm_window, field)
-	const struct {
-		xcb_atom_t atom;
-		xcb_atom_t type;
-		int offset;
-	} props[] = {
-		{ XCB_ATOM_WM_CLASS, XCB_ATOM_STRING, F(class) },
-		{ XCB_ATOM_WM_NAME, XCB_ATOM_STRING, F(name) },
-		{ XCB_ATOM_WM_TRANSIENT_FOR, XCB_ATOM_WINDOW, F(transient_for) },
-		{ wm->atom.wm_protocols, TYPE_WM_PROTOCOLS, F(protocols) },
-		{ wm->atom.net_wm_window_type, XCB_ATOM_ATOM, F(type) },
-		{ wm->atom.net_wm_name, XCB_ATOM_STRING, F(name) },
-		{ wm->atom.net_wm_pid, XCB_ATOM_CARDINAL, F(pid) },
-		{ wm->atom.motif_wm_hints, TYPE_MOTIF_WM_HINTS, 0 },
-		{ wm->atom.wm_client_machine, XCB_ATOM_WM_CLIENT_MACHINE, F(machine) },
-	};
-#undef F
-
-	xcb_get_property_cookie_t cookie[ARRAY_LENGTH(props)];
-	xcb_get_property_reply_t *reply;
-	void *p;
-	uint32_t *xid;
-	xcb_atom_t *atom;
-	uint32_t i;
-	struct motif_wm_hints *hints;
-
-	if (!window->properties_dirty)
-		return;
-	window->properties_dirty = 0;
-
-	for (i = 0; i < ARRAY_LENGTH(props); i++)
-		cookie[i] = xcb_get_property(wm->conn,
-					     0, /* delete */
-					     window->id,
-					     props[i].atom,
-					     XCB_ATOM_ANY, 0, 2048);
-
-	window->decorate = !window->override_redirect;
-	for (i = 0; i < ARRAY_LENGTH(props); i++)  {
-		reply = xcb_get_property_reply(wm->conn, cookie[i], NULL);
-		if (!reply)
-			/* Bad window, typically */
-			continue;
-		if (reply->type == XCB_ATOM_NONE) {
-			/* No such property */
-			free(reply);
-			continue;
-		}
-
-		p = ((char *) window + props[i].offset);
-
-		switch (props[i].type) {
-		case XCB_ATOM_WM_CLIENT_MACHINE:
-		case XCB_ATOM_STRING:
-			/* FIXME: We're using this for both string and
-			   utf8_string */
-			if (*(char **) p)
-				free(*(char **) p);
-
-			*(char **) p =
-				strndup(xcb_get_property_value(reply),
-					xcb_get_property_value_length(reply));
-			break;
-		case XCB_ATOM_WINDOW:
-			xid = xcb_get_property_value(reply);
-			*(struct weston_wm_window **) p =
-				hash_table_lookup(wm->window_hash, *xid);
-			break;
-		case XCB_ATOM_CARDINAL:
-		case XCB_ATOM_ATOM:
-			atom = xcb_get_property_value(reply);
-			*(xcb_atom_t *) p = *atom;
-			break;
-		case TYPE_WM_PROTOCOLS:
-			break;
-		case TYPE_MOTIF_WM_HINTS:
-			hints = xcb_get_property_value(reply);
-			if (hints->flags & MWM_HINTS_DECORATIONS)
-				window->decorate = hints->decorations > 0;
-			break;
-		default:
-			break;
-		}
-		free(reply);
-	}
-}
-
 static void
-weston_wm_window_get_frame_size(struct weston_wm_window *window,
-				int *width, int *height)
-{
-	struct theme *t = window->wm->theme;
-
-	if (window->decorate) {
-		*width = window->width + (t->margin + t->width) * 2;
-		*height = window->height +
-			t->margin * 2 + t->width + t->titlebar_height;
-	} else {
-		*width = window->width + t->margin * 2;
-		*height = window->height + t->margin * 2;
-	}
-}
-
-static void
-weston_wm_window_get_child_position(struct weston_wm_window *window,
-				    int *x, int *y)
-{
-	struct theme *t = window->wm->theme;
-
-	if (window->decorate) {
-		*x = t->margin + t->width;
-		*y = t->margin + t->titlebar_height;
-	} else {
-		*x = t->margin;
-		*y = t->margin;
-	}
-}
-
-static void
-weston_wm_handle_configure_request(struct weston_wm *wm, xcb_generic_event_t *event)
+surface_destroy(struct wl_listener *listener, void *data)
 {
-	xcb_configure_request_event_t *configure_request = 
-		(xcb_configure_request_event_t *) event;
-	struct weston_wm_window *window;
-	uint32_t mask, values[16];
-	int x, y, width, height, i = 0;
-
-	weston_log("XCB_CONFIGURE_REQUEST (window %d) %d,%d @ %dx%d\n",
-		configure_request->window,
-		configure_request->x, configure_request->y,
-		configure_request->width, configure_request->height);
-
-	window = hash_table_lookup(wm->window_hash, configure_request->window);
-
-	if (configure_request->value_mask & XCB_CONFIG_WINDOW_WIDTH)
-		window->width = configure_request->width;
-	if (configure_request->value_mask & XCB_CONFIG_WINDOW_HEIGHT)
-		window->height = configure_request->height;
-
-	weston_wm_window_get_child_position(window, &x, &y);
-	values[i++] = x;
-	values[i++] = y;
-	values[i++] = window->width;
-	values[i++] = window->height;
-	values[i++] = 0;
-	mask = XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y |
-		XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT |
-		XCB_CONFIG_WINDOW_BORDER_WIDTH;
-	if (configure_request->value_mask & XCB_CONFIG_WINDOW_SIBLING) {
-		values[i++] = configure_request->sibling;
-		mask |= XCB_CONFIG_WINDOW_SIBLING;
-	}
-	if (configure_request->value_mask & XCB_CONFIG_WINDOW_STACK_MODE) {
-		values[i++] = configure_request->stack_mode;
-		mask |= XCB_CONFIG_WINDOW_STACK_MODE;
-	}
-
-	xcb_configure_window(wm->conn, window->id, mask, values);
+	struct xserver_window *window = container_of(listener,
+			struct xserver_window, surface_destroy_listener);
 
-	weston_wm_window_get_frame_size(window, &width, &height);
-	values[0] = width;
-	values[1] = height;
-	mask = XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT;
-	xcb_configure_window(wm->conn, window->frame_id, mask, values);
-
-	weston_wm_window_schedule_repaint(window);
+	fprintf(stderr, "surface for xid %d destroyed\n", window->xid);
 }
 
-static void
-weston_wm_handle_configure_notify(struct weston_wm *wm, xcb_generic_event_t *event)
+static struct xserver_window *
+get_xserver_window(struct weston_surface *surface)
 {
-	xcb_configure_notify_event_t *configure_notify = 
-		(xcb_configure_notify_event_t *) event;
-	struct weston_wm_window *window;
-	int x, y;
-
-	window = hash_table_lookup(wm->window_hash, configure_notify->window);
-
-	weston_log("XCB_CONFIGURE_NOTIFY (%s window %d) %d,%d @ %dx%d\n",
-		configure_notify->window == window->id ? "client" : "frame",
-		configure_notify->window,
-		configure_notify->x, configure_notify->y,
-		configure_notify->width, configure_notify->height);
+	struct wl_resource *resource = &surface->surface.resource;
+	struct wl_listener *listener;
 
-	/* resize falls here */
-	if (configure_notify->window != window->id)
-		return;
+	listener = wl_signal_get(&resource->destroy_signal, surface_destroy);
+	if (listener)
+		return container_of(listener, struct xserver_window,
+				    surface_destroy_listener);
 
-	weston_wm_window_get_child_position(window, &x, &y);
-	window->x = configure_notify->x - x;
-	window->y = configure_notify->y - y;
+	return NULL;
 }
 
-static void
-weston_wm_kill_client(struct wl_listener *listener, void *data)
+static struct weston_seat *
+weston_wm_pick_seat(struct weston_xserver *wxs)
 {
-	struct weston_surface *surface = data;
-	struct weston_wm_window *window = get_wm_window(surface);
-	char name[1024];
-
-	if (!window)
-		return;
-
-	gethostname(name, 1024);
-
-	/* this is only one heuristic to guess the PID of a client is valid,
-	 * assuming it's compliant with icccm and ewmh. Non-compliants and
-	 * remote applications of course fail. */
-	if (!strcmp(window->machine, name) && window->pid != 0)
-		kill(window->pid, SIGKILL);
+	return container_of(wxs->compositor->seat_list.next,
+			    struct weston_seat, link);
 }
 
 static void
-weston_wm_window_activate(struct wl_listener *listener, void *data)
+send_configure(struct weston_surface *surface, uint32_t edges,
+		int32_t width, int32_t height)
 {
-	struct weston_surface *surface = data;
-	struct weston_wm_window *window = get_wm_window(surface);
-	struct weston_wm *wm =
-		container_of(listener, struct weston_wm, activate_listener);
-	xcb_client_message_event_t client_message;
-
-	if (window) {
-		client_message.response_type = XCB_CLIENT_MESSAGE;
-		client_message.format = 32;
-		client_message.window = window->id;
-		client_message.type = wm->atom.wm_protocols;
-		client_message.data.data32[0] = wm->atom.wm_take_focus;
-		client_message.data.data32[1] = XCB_TIME_CURRENT_TIME;
-
-		xcb_send_event(wm->conn, 0, window->id, 
-			       XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT,
-			       (char *) &client_message);
-
-		xcb_set_input_focus (wm->conn, XCB_INPUT_FOCUS_POINTER_ROOT,
-				     window->id, XCB_TIME_CURRENT_TIME);
-	} else {
-		xcb_set_input_focus (wm->conn,
-				     XCB_INPUT_FOCUS_POINTER_ROOT,
-				     XCB_NONE,
-				     XCB_TIME_CURRENT_TIME);
-	}
+	struct xserver_window *window = get_xserver_window(surface);
 
-	if (wm->focus_window)
-		weston_wm_window_schedule_repaint(wm->focus_window);
-	wm->focus_window = window;
 	if (window)
-		wm->focus_latest = window;
-	if (wm->focus_window)
-		weston_wm_window_schedule_repaint(wm->focus_window);
-}
-
-static int
-our_resource(struct weston_wm *wm, uint32_t id)
-{
-	const xcb_setup_t *setup;
-
-	setup = xcb_get_setup(wm->conn);
-
-	return (id & ~setup->resource_id_mask) == setup->resource_id_base;
-}
-
-#define ICCCM_WITHDRAWN_STATE	0
-#define ICCCM_NORMAL_STATE	1
-#define ICCCM_ICONIC_STATE	3
-
-static void
-weston_wm_window_set_state(struct weston_wm_window *window, int32_t state)
-{
-	struct weston_wm *wm = window->wm;
-	uint32_t property[2];
-
-	property[0] = state;
-	property[1] = XCB_WINDOW_NONE;
-
-	xcb_change_property(wm->conn,
-			    XCB_PROP_MODE_REPLACE,
-			    window->id,
-			    wm->atom.wm_state,
-			    wm->atom.wm_state,
-			    32, /* format */
-			    2, property);
-}
-
-static void
-weston_wm_handle_map_request(struct weston_wm *wm, xcb_generic_event_t *event)
-{
-	xcb_map_request_event_t *map_request =
-		(xcb_map_request_event_t *) event;
-	struct weston_wm_window *window;
-	uint32_t values[1];
-	int x, y, width, height;
-
-	if (our_resource(wm, map_request->window)) {
-		weston_log("XCB_MAP_REQUEST (window %d, ours)\n",
-			map_request->window);
-		return;
-	}
-
-	window = hash_table_lookup(wm->window_hash, map_request->window);
-
-	if (window->frame_id)
-		return;
-
-	weston_wm_window_read_properties(window);
-
-	weston_wm_window_get_frame_size(window, &width, &height);
-	weston_wm_window_get_child_position(window, &x, &y);
-
-	values[0] =
-		XCB_EVENT_MASK_KEY_PRESS |
-		XCB_EVENT_MASK_KEY_RELEASE |
-		XCB_EVENT_MASK_BUTTON_PRESS |
-		XCB_EVENT_MASK_BUTTON_RELEASE |
-		XCB_EVENT_MASK_POINTER_MOTION |
-		XCB_EVENT_MASK_ENTER_WINDOW |
-		XCB_EVENT_MASK_LEAVE_WINDOW |
-		XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY |
-		XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT;
-
-	window->frame_id = xcb_generate_id(wm->conn);
-	xcb_create_window(wm->conn,
-			  XCB_COPY_FROM_PARENT,
-			  window->frame_id,
-			  wm->screen->root,
-			  0, 0,
-			  width, height,
-			  0,
-			  XCB_WINDOW_CLASS_INPUT_OUTPUT,
-			  wm->screen->root_visual,
-			  XCB_CW_EVENT_MASK, values);
-	xcb_reparent_window(wm->conn, window->id, window->frame_id, x, y);
-
-	values[0] = 0;
-	xcb_configure_window(wm->conn, window->id,
-			     XCB_CONFIG_WINDOW_BORDER_WIDTH, values);
-
-	weston_log("XCB_MAP_REQUEST (window %d, %p, frame %d)\n",
-		window->id, window, window->frame_id);
-
-	xcb_map_window(wm->conn, map_request->window);
-	xcb_map_window(wm->conn, window->frame_id);
-	weston_wm_window_set_state(window, ICCCM_NORMAL_STATE);
-
-	window->cairo_surface =
-		cairo_xcb_surface_create_with_xrender_format(wm->conn,
-							     wm->screen,
-							     window->frame_id,
-							     &wm->format_rgb,
-							     width, height);
-
-	hash_table_insert(wm->window_hash, window->frame_id, window);
+		wm_xwin_send_configure(&window->resource, edges,
+				       width, height);
 }
 
-static void
-weston_wm_handle_map_notify(struct weston_wm *wm, xcb_generic_event_t *event)
-{
-	xcb_map_notify_event_t *map_notify = (xcb_map_notify_event_t *) event;
-
-	if (our_resource(wm, map_notify->window)) {
-			weston_log("XCB_MAP_NOTIFY (window %d, ours)\n",
-				map_notify->window);
-			return;
-	}
-
-	weston_log("XCB_MAP_NOTIFY (window %d)\n", map_notify->window);
-}
+static const struct weston_shell_client shell_client = {
+	send_configure
+};
 
 static void
-weston_wm_handle_unmap_notify(struct weston_wm *wm, xcb_generic_event_t *event)
+xserver_handle_window_surface(struct wl_client *client,
+		struct wl_resource *resource,
+		struct wl_resource *surface_resource, uint32_t xid)
 {
-	xcb_unmap_notify_event_t *unmap_notify =
-		(xcb_unmap_notify_event_t *) event;
-	struct weston_wm_window *window;
-
-	weston_log("XCB_UNMAP_NOTIFY (window %d, event %d%s)\n",
-		unmap_notify->window,
-		unmap_notify->event,
-		our_resource(wm, unmap_notify->window) ? ", ours" : "");
+	struct weston_xserver *wxs = resource->data;
+	struct wl_surface *surface = surface_resource->data;
+	struct weston_surface *weston_surface =
+		(struct weston_surface *) surface;
+	struct xserver_window *window;
+	struct weston_shell_interface *shell_interface =
+		&wxs->compositor->shell_interface;
 
-	if (our_resource(wm, unmap_notify->window))
-		return;
+	wl_list_for_each(window, &wxs->xserver_window_list, link)
+		if (window->xid == xid)
+			break;
 
-	if (unmap_notify->response_type & 0x80)
-		/* We just ignore the ICCCM 4.1.4 synthetic unmap notify
-		 * as it may come in after we've destroyed the window. */
+	if (window == NULL) {
+		weston_log("unknown window %d\n", xid);
 		return;
-
-	window = hash_table_lookup(wm->window_hash, unmap_notify->window);
-	if (window->repaint_source)
-		wl_event_source_remove(window->repaint_source);
-	if (window->cairo_surface)
-		cairo_surface_destroy(window->cairo_surface);
-
-	if (window->frame_id) {
-		xcb_reparent_window(wm->conn, window->id, wm->wm_window, 0, 0);
-		xcb_destroy_window(wm->conn, window->frame_id);
-		weston_wm_window_set_state(window, ICCCM_WITHDRAWN_STATE);
-		hash_table_remove(wm->window_hash, window->frame_id);
-		window->frame_id = XCB_WINDOW_NONE;
 	}
 
-	if (wm->focus_window == window)
-		wm->focus_window = NULL;
-	if (window->surface)
-		wl_list_remove(&window->surface_destroy_listener.link);
-	window->surface = NULL;
-}
-
-static void
-weston_wm_window_draw_decoration(void *data)
-{
-	struct weston_wm_window *window = data;
-	struct weston_wm *wm = window->wm;
-	struct theme *t = wm->theme;
-	cairo_t *cr;
-	int x, y, width, height;
-	const char *title;
-	uint32_t flags = 0;
-
-	weston_wm_window_read_properties(window);
-
-	window->repaint_source = NULL;
-
-	weston_wm_window_get_frame_size(window, &width, &height);
-	weston_wm_window_get_child_position(window, &x, &y);
-
-	cairo_xcb_surface_set_size(window->cairo_surface, width, height);
-	cr = cairo_create(window->cairo_surface);
-
-	if (window->decorate) {
-		if (wm->focus_window == window)
-			flags |= THEME_FRAME_ACTIVE;
-
-		if (window->name)
-			title = window->name;
-		else
-			title = "untitled";
-
-		theme_render_frame(t, cr, width, height, title, flags);
-	} else {
-		cairo_set_operator(cr, CAIRO_OPERATOR_SOURCE);
-		cairo_set_source_rgba(cr, 0, 0, 0, 0);
-		cairo_paint(cr);
-
-		cairo_set_operator(cr, CAIRO_OPERATOR_OVER);
-		cairo_set_source_rgba(cr, 0, 0, 0, 0.45);
-		tile_mask(cr, t->shadow, 2, 2, width + 8, height + 8, 64, 64);
-	}
+	window->surface = surface;
+	window->surface_destroy_listener.notify = surface_destroy;
+	wl_signal_add(&surface->resource.destroy_signal,
+		      &window->surface_destroy_listener);
 
-	cairo_destroy(cr);
-
-	if (window->surface) {
-		pixman_region32_fini(&window->surface->pending.opaque);
-		pixman_region32_init_rect(&window->surface->pending.opaque, 0, 0,
-					  width, height);
-
-		/* We leave an extra pixel around the X window area to
-		 * make sure we don't sample from the undefined alpha
-		 * channel when filtering. */
-		pixman_region32_intersect_rect(&window->surface->pending.opaque,
-					       &window->surface->pending.opaque,
-					       x - 1, y - 1,
-					       window->width + 2,
-					       window->height + 2);
-		window->surface->geometry.dirty = 1;
-
-		pixman_region32_init_rect(&window->surface->input,
-					  t->margin, t->margin,
-					  width - 2 * t->margin,
-					  height - 2 * t->margin);
-	}
+	window->shsurf =
+		shell_interface->create_shell_surface(shell_interface->shell,
+						      weston_surface,
+						      &shell_client);
+	if (!window->flags)
+		shell_interface->set_toplevel(window->shsurf);
+	else
+		shell_interface->set_transient_xwayland(window->shsurf,
+				window->x + 32, window->y + 32,
+				XWAYLAND_INACTIVE);
 }
 
-static void
-weston_wm_window_schedule_repaint(struct weston_wm_window *window)
-{
-	struct weston_wm *wm = window->wm;
-	int width, height;
-
-	if (window->frame_id == XCB_WINDOW_NONE) {
-		if (window->surface != NULL) {
-			weston_wm_window_get_frame_size(window, &width, &height);
-			pixman_region32_fini(&window->surface->pending.opaque);
-			pixman_region32_init_rect(&window->surface->pending.opaque, 0, 0,
-						  width, height);
-			window->surface->geometry.dirty = 1;
-		}
-		return;
-	}
-
-	if (window->repaint_source)
-		return;
-
-	window->repaint_source =
-		wl_event_loop_add_idle(wm->server->loop,
-				       weston_wm_window_draw_decoration,
-				       window);
-}
+const struct xserver_interface xserver_implementation = {
+	xserver_handle_window_surface
+};
 
 static void
-weston_wm_handle_property_notify(struct weston_wm *wm, xcb_generic_event_t *event)
+wm_xwin_handle_map(struct wl_client *client, struct wl_resource *resource)
 {
-	xcb_property_notify_event_t *property_notify =
-		(xcb_property_notify_event_t *) event;
-	struct weston_wm_window *window;
+	struct xserver_window *window = resource->data;
 
-	window = hash_table_lookup(wm->window_hash, property_notify->window);
-	if (window)
-		window->properties_dirty = 1;
-
-	weston_log("XCB_PROPERTY_NOTIFY: window %d, ",
-		property_notify->window);
-	if (property_notify->state == XCB_PROPERTY_DELETE)
-		weston_log("deleted\n");
-	else
-		read_and_dump_property(wm, property_notify->window,
-				       property_notify->atom);
-
-	if (property_notify->atom == wm->atom.net_wm_name ||
-	    property_notify->atom == XCB_ATOM_WM_NAME)
-		weston_wm_window_schedule_repaint(window);
+	xserver_send_map(window->wxs->resource, window->xid);
 }
 
 static void
-weston_wm_window_create(struct weston_wm *wm,
-			xcb_window_t id, int width, int height, int override)
+wm_xwin_handle_set_window(struct wl_client *client,
+			  struct wl_resource *resource, int x, int y,
+			  int width, int height, uint32_t flags)
 {
-	struct weston_wm_window *window;
-	uint32_t values[1];
-
-	window = malloc(sizeof *window);
-	if (window == NULL) {
-		weston_log("failed to allocate window\n");
-		return;
-	}
+	struct xserver_window *window = resource->data;
 
-	values[0] = XCB_EVENT_MASK_PROPERTY_CHANGE;
-	xcb_change_window_attributes(wm->conn, id, XCB_CW_EVENT_MASK, values);
-
-	memset(window, 0, sizeof *window);
-	window->wm = wm;
-	window->id = id;
-	window->properties_dirty = 1;
-	window->override_redirect = override;
+	window->x = x;
+	window->y = y;
 	window->width = width;
 	window->height = height;
-
-	hash_table_insert(wm->window_hash, id, window);
+	window->flags = flags;
 }
 
 static void
-weston_wm_window_destroy(struct weston_wm_window *window)
+wm_xwin_handle_opaque_override(struct wl_client *client,
+			       struct wl_resource *resource,
+			       struct wl_resource *region_resource)
 {
-	hash_table_remove(window->wm->window_hash, window->id);
-	free(window);
-}
-
-static void
-weston_wm_handle_create_notify(struct weston_wm *wm, xcb_generic_event_t *event)
-{
-	xcb_create_notify_event_t *create_notify =
-		(xcb_create_notify_event_t *) event;
+	struct xserver_window *window = resource->data;
+	struct weston_surface *surface =
+		(struct weston_surface *) window->surface;
+	struct weston_region *region;
 
-	weston_log("XCB_CREATE_NOTIFY (window %d, width %d, height %d%s%s)\n",
-		create_notify->window,
-		create_notify->width, create_notify->height,
-		create_notify->override_redirect ? ", override" : "",
-		our_resource(wm, create_notify->window) ? ", ours" : "");
+	if (!region_resource) {
+		weston_log("Region resource not provided\n");
+		return;
+	}
+	region = region_resource->data;
 
-	if (our_resource(wm, create_notify->window))
+	if (!surface)
 		return;
 
-	weston_wm_window_create(wm, create_notify->window,
-				create_notify->width, create_notify->height,
-				create_notify->override_redirect);
+	pixman_region32_copy(&surface->pending.opaque, &region->region);
+	surface->geometry.dirty = 1;
 }
 
 static void
-weston_wm_handle_destroy_notify(struct weston_wm *wm, xcb_generic_event_t *event)
+wm_xwin_handle_input_region(struct wl_client *client,
+			    struct wl_resource *resource,
+			    struct wl_resource *region_resource)
 {
-	xcb_destroy_notify_event_t *destroy_notify =
-		(xcb_destroy_notify_event_t *) event;
-	struct weston_wm_window *window;
-
-	weston_log("XCB_DESTROY_NOTIFY, win %d, event %d%s\n",
-		destroy_notify->window,
-		destroy_notify->event,
-		our_resource(wm, destroy_notify->window) ? ", ours" : "");
+	struct xserver_window *window = resource->data;
+	struct weston_surface *surface =
+		(struct weston_surface *) window->surface;
+	struct weston_region *region;
 
-	if (our_resource(wm, destroy_notify->window))
+	if (!region_resource) {
+		weston_log("Region resource not provided\n");
 		return;
-
-	window = hash_table_lookup(wm->window_hash, destroy_notify->window);
-	weston_wm_window_destroy(window);
-}
-
-static void
-weston_wm_handle_reparent_notify(struct weston_wm *wm, xcb_generic_event_t *event)
-{
-	xcb_reparent_notify_event_t *reparent_notify =
-		(xcb_reparent_notify_event_t *) event;
-	struct weston_wm_window *window;
-
-	weston_log("XCB_REPARENT_NOTIFY (window %d, parent %d, event %d)\n",
-		reparent_notify->window,
-		reparent_notify->parent,
-		reparent_notify->event);
-
-	if (reparent_notify->parent == wm->screen->root) {
-		weston_wm_window_create(wm, reparent_notify->window, 10, 10,
-					reparent_notify->override_redirect);
-	} else if (!our_resource(wm, reparent_notify->parent)) {
-		window = hash_table_lookup(wm->window_hash,
-					   reparent_notify->window);
-		weston_wm_window_destroy(window);
 	}
-}
-
-struct weston_seat *
-weston_wm_pick_seat(struct weston_wm *wm)
-{
-	return container_of(wm->server->compositor->seat_list.next,
-			    struct weston_seat, link);
-}
-
-static void
-weston_wm_window_handle_moveresize(struct weston_wm_window *window,
-				   xcb_client_message_event_t *client_message)
-{
-	static const int map[] = {
-		THEME_LOCATION_RESIZING_TOP_LEFT,
-		THEME_LOCATION_RESIZING_TOP,
-		THEME_LOCATION_RESIZING_TOP_RIGHT,
-		THEME_LOCATION_RESIZING_RIGHT,
-		THEME_LOCATION_RESIZING_BOTTOM_RIGHT,
-		THEME_LOCATION_RESIZING_BOTTOM,
-		THEME_LOCATION_RESIZING_BOTTOM_LEFT,
-		THEME_LOCATION_RESIZING_LEFT
-	};
-
-	struct weston_wm *wm = window->wm;
-	struct weston_seat *seat = weston_wm_pick_seat(wm);
-	int detail;
-	struct weston_shell_interface *shell_interface =
-		&wm->server->compositor->shell_interface;
+	region = region_resource->data;
 
-	if (seat->seat.pointer->button_count != 1 ||
-	    seat->seat.pointer->focus != &window->surface->surface)
+	if (!surface)
 		return;
 
-	detail = client_message->data.data32[2];
-	switch (detail) {
-	case _NET_WM_MOVERESIZE_MOVE:
-		shell_interface->move(window->shsurf, seat);
-		break;
-	case _NET_WM_MOVERESIZE_SIZE_TOPLEFT:
-	case _NET_WM_MOVERESIZE_SIZE_TOP:
-	case _NET_WM_MOVERESIZE_SIZE_TOPRIGHT:
-	case _NET_WM_MOVERESIZE_SIZE_RIGHT:
-	case _NET_WM_MOVERESIZE_SIZE_BOTTOMRIGHT:
-	case _NET_WM_MOVERESIZE_SIZE_BOTTOM:
-	case _NET_WM_MOVERESIZE_SIZE_BOTTOMLEFT:
-	case _NET_WM_MOVERESIZE_SIZE_LEFT:
-		shell_interface->resize(window->shsurf, seat, map[detail]);
-		break;
-	case _NET_WM_MOVERESIZE_CANCEL:
-		break;
-	}
+	pixman_region32_copy(&surface->pending.input, &region->region);
+	surface->geometry.dirty = 1;
 }
 
 static void
-weston_wm_handle_client_message(struct weston_wm *wm,
-				xcb_generic_event_t *event)
+wm_xwin_handle_move(struct wl_client *client, struct wl_resource *resource)
 {
-	xcb_client_message_event_t *client_message =
-		(xcb_client_message_event_t *) event;
-	struct weston_wm_window *window;
-
-	window = hash_table_lookup(wm->window_hash, client_message->window);
-
-	weston_log("XCB_CLIENT_MESSAGE (%s %d %d %d %d %d)\n",
-		get_atom_name(wm->conn, client_message->type),
-		client_message->data.data32[0],
-		client_message->data.data32[1],
-		client_message->data.data32[2],
-		client_message->data.data32[3],
-		client_message->data.data32[4]);
-
-	if (client_message->type == wm->atom.net_wm_moveresize)
-		weston_wm_window_handle_moveresize(window, client_message);
-}
-
-enum cursor_type {
-	XWM_CURSOR_TOP,
-	XWM_CURSOR_BOTTOM,
-	XWM_CURSOR_LEFT,
-	XWM_CURSOR_RIGHT,
-	XWM_CURSOR_TOP_LEFT,
-	XWM_CURSOR_TOP_RIGHT,
-	XWM_CURSOR_BOTTOM_LEFT,
-	XWM_CURSOR_BOTTOM_RIGHT,
-	XWM_CURSOR_LEFT_PTR,
-};
-
-static const char *cursors[] = {
-	"top_side",
-	"bottom_side",
-	"left_side",
-	"right_side",
-	"top_left_corner",
-	"top_right_corner",
-	"bottom_left_corner",
-	"bottom_right_corner",
-	"left_ptr"
-};
-
-static void
-weston_wm_create_cursors(struct weston_wm *wm)
-{
-	int i, count = ARRAY_LENGTH(cursors);
+	struct xserver_window *window = resource->data;
+	struct weston_xserver *wxs = window->wxs;
+	struct weston_shell_interface *shell_interface =
+		&wxs->compositor->shell_interface;
+	struct weston_seat *seat = weston_wm_pick_seat(wxs);
 
-	wm->cursors = malloc(count * sizeof(xcb_cursor_t));
-	for (i = 0; i < count; i++) {
-		wm->cursors[i] =
-			xcb_cursor_library_load_cursor(wm, cursors[i]);
-	}
+        if (seat->seat.pointer->button_count != 1 ||
+            seat->seat.pointer->focus != window->surface)
+                return;
 
-	wm->last_cursor = -1;
+	shell_interface->move(window->shsurf, seat);
 }
 
 static void
-weston_wm_destroy_cursors(struct weston_wm *wm)
+wm_xwin_handle_resize(struct wl_client *client,
+		      struct wl_resource *resource, uint32_t location)
 {
-	uint8_t i;
-
-	for (i = 0; i < ARRAY_LENGTH(cursors); i++)
-		xcb_free_cursor(wm->conn, wm->cursors[i]);
+	struct xserver_window *window = resource->data;
+	struct weston_xserver *wxs = window->wxs;
+	struct weston_shell_interface *shell_interface =
+		&wxs->compositor->shell_interface;
+	struct weston_seat *seat = weston_wm_pick_seat(wxs);
 
-	free(wm->cursors);
-}
+        if (seat->seat.pointer->button_count != 1 ||
+            seat->seat.pointer->focus != window->surface)
+                return;
 
-static int
-get_cursor_for_location(struct theme *t, int width, int height, int x, int y)
-{
-	int location = theme_get_location(t, x, y, width, height, 0);
-
-	switch (location) {
-		case THEME_LOCATION_RESIZING_TOP:
-			return XWM_CURSOR_TOP;
-		case THEME_LOCATION_RESIZING_BOTTOM:
-			return XWM_CURSOR_BOTTOM;
-		case THEME_LOCATION_RESIZING_LEFT:
-			return XWM_CURSOR_LEFT;
-		case THEME_LOCATION_RESIZING_RIGHT:
-			return XWM_CURSOR_RIGHT;
-		case THEME_LOCATION_RESIZING_TOP_LEFT:
-			return XWM_CURSOR_TOP_LEFT;
-		case THEME_LOCATION_RESIZING_TOP_RIGHT:
-			return XWM_CURSOR_TOP_RIGHT;
-		case THEME_LOCATION_RESIZING_BOTTOM_LEFT:
-			return XWM_CURSOR_BOTTOM_LEFT;
-		case THEME_LOCATION_RESIZING_BOTTOM_RIGHT:
-			return XWM_CURSOR_BOTTOM_RIGHT;
-		case THEME_LOCATION_EXTERIOR:
-		case THEME_LOCATION_TITLEBAR:
-		default:
-			return XWM_CURSOR_LEFT_PTR;
-	}
+	shell_interface->resize(window->shsurf, seat, location);
 }
 
 static void
-weston_wm_window_set_cursor(struct weston_wm *wm, xcb_window_t window_id,
-			    int cursor)
+wm_destroy_xwin(struct wl_resource *resource)
 {
-	uint32_t cursor_value_list;
+	struct xserver_window *window = resource->data;
 
-	if (wm->last_cursor == cursor)
-		return;
-
-	wm->last_cursor = cursor;
-
-	cursor_value_list = wm->cursors[cursor];
-	xcb_change_window_attributes (wm->conn, window_id,
-				      XCB_CW_CURSOR, &cursor_value_list);
-	xcb_flush(wm->conn);
+	wl_list_remove(&window->link);
+	window = NULL;
+	free(window);
 }
 
 static void
-weston_wm_handle_button(struct weston_wm *wm, xcb_generic_event_t *event)
+wm_xwin_handle_destroy(struct wl_client *client, struct wl_resource *resource)
 {
-	xcb_button_press_event_t *button = (xcb_button_press_event_t *) event;
-	struct weston_shell_interface *shell_interface =
-		&wm->server->compositor->shell_interface;
-	struct weston_seat *seat = weston_wm_pick_seat(wm);
-	struct weston_wm_window *window;
-	enum theme_location location;
-	struct theme *t = wm->theme;
-	int width, height;
-
-	weston_log("XCB_BUTTON_%s (detail %d)\n",
-		button->response_type == XCB_BUTTON_PRESS ?
-		"PRESS" : "RELEASE", button->detail);
-
-	window = hash_table_lookup(wm->window_hash, button->event);
-	weston_wm_window_get_frame_size(window, &width, &height);
-
-	if (button->response_type == XCB_BUTTON_PRESS &&
-	    button->detail == 1) {
-		location = theme_get_location(t,
-					      button->event_x,
-					      button->event_y,
-					      width, height, 0);
-
-		switch (location) {
-		case THEME_LOCATION_TITLEBAR:
-			shell_interface->move(window->shsurf, seat);
-			break;
-		case THEME_LOCATION_RESIZING_TOP:
-		case THEME_LOCATION_RESIZING_BOTTOM:
-		case THEME_LOCATION_RESIZING_LEFT:
-		case THEME_LOCATION_RESIZING_RIGHT:
-		case THEME_LOCATION_RESIZING_TOP_LEFT:
-		case THEME_LOCATION_RESIZING_TOP_RIGHT:
-		case THEME_LOCATION_RESIZING_BOTTOM_LEFT:
-		case THEME_LOCATION_RESIZING_BOTTOM_RIGHT:
-			shell_interface->resize(window->shsurf,
-						seat, location);
-			break;
-		default:
-			break;
-		}
-	}
+	wm_destroy_xwin(resource);
 }
 
-static void
-weston_wm_handle_motion(struct weston_wm *wm, xcb_generic_event_t *event)
-{
-	xcb_motion_notify_event_t *motion = (xcb_motion_notify_event_t *) event;
-	struct weston_wm_window *window;
-	int cursor, width, height;
-
-	window = hash_table_lookup(wm->window_hash, motion->event);
-	if (!window || !window->decorate)
-		return;
-
-	weston_wm_window_get_frame_size(window, &width, &height);
-	cursor = get_cursor_for_location(wm->theme, width, height,
-					 motion->event_x, motion->event_y);
-
-	weston_wm_window_set_cursor(wm, window->frame_id, cursor);
-}
+const struct wm_xwin_interface wm_xwin_implementation = {
+	wm_xwin_handle_map,
+	wm_xwin_handle_set_window,
+	wm_xwin_handle_opaque_override,
+	wm_xwin_handle_input_region,
+	wm_xwin_handle_move,
+	wm_xwin_handle_resize,
+	wm_xwin_handle_destroy
+};
 
 static void
-weston_wm_handle_enter(struct weston_wm *wm, xcb_generic_event_t *event)
+wm_activate_listener(struct wl_listener *listener, void *data)
 {
-	xcb_enter_notify_event_t *enter = (xcb_enter_notify_event_t *) event;
-	struct weston_wm_window *window;
-	int cursor, width, height;
-
-	window = hash_table_lookup(wm->window_hash, enter->event);
-	if (!window || !window->decorate)
-		return;
-
-	weston_wm_window_get_frame_size(window, &width, &height);
-	cursor = get_cursor_for_location(wm->theme, width, height,
-					 enter->event_x, enter->event_y);
+	struct weston_surface *surface = data;
+	struct xserver_window *window = get_xserver_window(surface);
+	struct weston_xserver *wxs = container_of(listener,
+			struct weston_xserver, activate_listener);
 
-	weston_wm_window_set_cursor(wm, window->frame_id, cursor);
+	if (window)
+		wm_xwin_send_state(&window->resource, WM_XWIN_STATE_ACTIVATE);
+	else
+		wm_send_state(wxs->wm_resource, WM_STATE_DEACTIVATE);
 }
 
 static void
-weston_wm_handle_leave(struct weston_wm *wm, xcb_generic_event_t *event)
+wm_set_selection_listener(struct wl_listener *listener, void *data)
 {
-	xcb_leave_notify_event_t *leave = (xcb_leave_notify_event_t *) event;
-	struct weston_wm_window *window;
+	struct weston_xserver *wxs = container_of(listener,
+			struct weston_xserver, selection_listener);
+	struct wl_seat *seat = data;
+	struct weston_surface *weston_surface =
+		(struct weston_surface *) seat->keyboard->focus;
+	struct xserver_window *window = get_xserver_window(weston_surface);
+	struct wl_data_source *source = seat->selection_data_source;
+	const char **p, **end;
+	int has_text_plain = 0;
 
-	window = hash_table_lookup(wm->window_hash, leave->event);
-	if (!window || !window->decorate)
+	/* just forward set_selection to WM when a Wayland client has
+	 * initiated it */
+	if (window)
 		return;
 
-	weston_wm_window_set_cursor(wm, window->frame_id, XWM_CURSOR_LEFT_PTR);
-}
-
-static int
-weston_wm_handle_event(int fd, uint32_t mask, void *data)
-{
-	struct weston_wm *wm = data;
-	xcb_generic_event_t *event;
-	int count = 0;
-
-	while (event = xcb_poll_for_event(wm->conn), event != NULL) {
-		if (weston_wm_handle_selection_event(wm, event)) {
-			free(event);
-			count++;
-			continue;
-		}
-
-		switch (event->response_type & ~0x80) {
-		case XCB_BUTTON_PRESS:
-		case XCB_BUTTON_RELEASE:
-			weston_wm_handle_button(wm, event);
-			break;
-		case XCB_ENTER_NOTIFY:
-			weston_wm_handle_enter(wm, event);
-			break;
-		case XCB_LEAVE_NOTIFY:
-			weston_wm_handle_leave(wm, event);
-			break;
-		case XCB_MOTION_NOTIFY:
-			weston_wm_handle_motion(wm, event);
-			break;
-		case XCB_CREATE_NOTIFY:
-			weston_wm_handle_create_notify(wm, event);
-			break;
-		case XCB_MAP_REQUEST:
-			weston_wm_handle_map_request(wm, event);
-			break;
-		case XCB_MAP_NOTIFY:
-			weston_wm_handle_map_notify(wm, event);
-			break;
-		case XCB_UNMAP_NOTIFY:
-			weston_wm_handle_unmap_notify(wm, event);
-			break;
-		case XCB_REPARENT_NOTIFY:
-			weston_wm_handle_reparent_notify(wm, event);
-			break;
-		case XCB_CONFIGURE_REQUEST:
-			weston_wm_handle_configure_request(wm, event);
-			break;
-		case XCB_CONFIGURE_NOTIFY:
-			weston_wm_handle_configure_notify(wm, event);
-			break;
-		case XCB_DESTROY_NOTIFY:
-			weston_wm_handle_destroy_notify(wm, event);
-			break;
-		case XCB_MAPPING_NOTIFY:
-			weston_log("XCB_MAPPING_NOTIFY\n");
-			break;
-		case XCB_PROPERTY_NOTIFY:
-			weston_wm_handle_property_notify(wm, event);
-			break;
-		case XCB_CLIENT_MESSAGE:
-			weston_wm_handle_client_message(wm, event);
-			break;
-		}
-
-		free(event);
-		count++;
+	p = source->mime_types.data;
+	end = (const char **)
+		((char *) source->mime_types.data + source->mime_types.size);
+	while (p < end) {
+		weston_log("  %s\n", *p);
+		if (strcmp(*p, "text/plain") == 0 ||
+				strcmp(*p, "text/plain;charset=utf-8") == 0)
+			has_text_plain = 1;
+		p++;
 	}
 
-	xcb_flush(wm->conn);
-
-	return count;
+	wm_send_selection(wxs->wm_resource, has_text_plain);
 }
 
 static void
-weston_wm_get_resources(struct weston_wm *wm)
+window_position_listener(struct wl_listener *listener, void *data)
 {
+	struct weston_surface *surface = data;
+	struct xserver_window *window = get_xserver_window(surface);
+	struct weston_output *output = surface->output;
+	float sxf, syf;
 
-#define F(field) offsetof(struct weston_wm, field)
-
-	static const struct { const char *name; int offset; } atoms[] = {
-		{ "WM_PROTOCOLS",	F(atom.wm_protocols) },
-		{ "WM_TAKE_FOCUS",	F(atom.wm_take_focus) },
-		{ "WM_DELETE_WINDOW",	F(atom.wm_delete_window) },
-		{ "WM_STATE",		F(atom.wm_state) },
-		{ "WM_S0",		F(atom.wm_s0) },
-		{ "WM_CLIENT_MACHINE",	F(atom.wm_client_machine) },
-		{ "_NET_WM_NAME",	F(atom.net_wm_name) },
-		{ "_NET_WM_PID",	F(atom.net_wm_pid) },
-		{ "_NET_WM_ICON",	F(atom.net_wm_icon) },
-		{ "_NET_WM_STATE",	F(atom.net_wm_state) },
-		{ "_NET_WM_STATE_FULLSCREEN", F(atom.net_wm_state_fullscreen) },
-		{ "_NET_WM_USER_TIME", F(atom.net_wm_user_time) },
-		{ "_NET_WM_ICON_NAME", F(atom.net_wm_icon_name) },
-		{ "_NET_WM_WINDOW_TYPE", F(atom.net_wm_window_type) },
-
-		{ "_NET_WM_WINDOW_TYPE_DESKTOP", F(atom.net_wm_window_type_desktop) },
-		{ "_NET_WM_WINDOW_TYPE_DOCK", F(atom.net_wm_window_type_dock) },
-		{ "_NET_WM_WINDOW_TYPE_TOOLBAR", F(atom.net_wm_window_type_toolbar) },
-		{ "_NET_WM_WINDOW_TYPE_MENU", F(atom.net_wm_window_type_menu) },
-		{ "_NET_WM_WINDOW_TYPE_UTILITY", F(atom.net_wm_window_type_utility) },
-		{ "_NET_WM_WINDOW_TYPE_SPLASH", F(atom.net_wm_window_type_splash) },
-		{ "_NET_WM_WINDOW_TYPE_DIALOG", F(atom.net_wm_window_type_dialog) },
-		{ "_NET_WM_WINDOW_TYPE_DROPDOWN_MENU", F(atom.net_wm_window_type_dropdown) },
-		{ "_NET_WM_WINDOW_TYPE_POPUP_MENU", F(atom.net_wm_window_type_popup) },
-		{ "_NET_WM_WINDOW_TYPE_TOOLTIP", F(atom.net_wm_window_type_tooltip) },
-		{ "_NET_WM_WINDOW_TYPE_NOTIFICATION", F(atom.net_wm_window_type_notification) },
-		{ "_NET_WM_WINDOW_TYPE_COMBO", F(atom.net_wm_window_type_combo) },
-		{ "_NET_WM_WINDOW_TYPE_DND", F(atom.net_wm_window_type_dnd) },
-		{ "_NET_WM_WINDOW_TYPE_NORMAL",	F(atom.net_wm_window_type_normal) },
-
-		{ "_NET_WM_MOVERESIZE", F(atom.net_wm_moveresize) },
-		{ "_NET_SUPPORTING_WM_CHECK",
-					F(atom.net_supporting_wm_check) },
-		{ "_NET_SUPPORTED",     F(atom.net_supported) },
-		{ "_MOTIF_WM_HINTS",	F(atom.motif_wm_hints) },
-		{ "CLIPBOARD",		F(atom.clipboard) },
-		{ "CLIPBOARD_MANAGER",	F(atom.clipboard_manager) },
-		{ "TARGETS",		F(atom.targets) },
-		{ "UTF8_STRING",	F(atom.utf8_string) },
-		{ "_WL_SELECTION",	F(atom.wl_selection) },
-		{ "INCR",		F(atom.incr) },
-		{ "TIMESTAMP",		F(atom.timestamp) },
-		{ "MULTIPLE",		F(atom.multiple) },
-		{ "UTF8_STRING"	,	F(atom.utf8_string) },
-		{ "COMPOUND_TEXT",	F(atom.compound_text) },
-		{ "TEXT",		F(atom.text) },
-		{ "STRING",		F(atom.string) },
-		{ "text/plain;charset=utf-8",	F(atom.text_plain_utf8) },
-		{ "text/plain",		F(atom.text_plain) },
-	};
-#undef F
-
-	xcb_xfixes_query_version_cookie_t xfixes_cookie;
-	xcb_xfixes_query_version_reply_t *xfixes_reply;
-	xcb_intern_atom_cookie_t cookies[ARRAY_LENGTH(atoms)];
-	xcb_intern_atom_reply_t *reply;
-	xcb_render_query_pict_formats_reply_t *formats_reply;
-	xcb_render_query_pict_formats_cookie_t formats_cookie;
-	xcb_render_pictforminfo_t *formats;
-	uint32_t i;
-
-	xcb_prefetch_extension_data (wm->conn, &xcb_xfixes_id);
-
-	formats_cookie = xcb_render_query_pict_formats(wm->conn);
-
-	for (i = 0; i < ARRAY_LENGTH(atoms); i++)
-		cookies[i] = xcb_intern_atom (wm->conn, 0,
-					      strlen(atoms[i].name),
-					      atoms[i].name);
-
-	for (i = 0; i < ARRAY_LENGTH(atoms); i++) {
-		reply = xcb_intern_atom_reply (wm->conn, cookies[i], NULL);
-		*(xcb_atom_t *) ((char *) wm + atoms[i].offset) = reply->atom;
-		free(reply);
-	}
-
-	wm->xfixes = xcb_get_extension_data(wm->conn, &xcb_xfixes_id);
-	if (!wm->xfixes || !wm->xfixes->present)
-		weston_log("xfixes not available\n");
-
-	xfixes_cookie = xcb_xfixes_query_version(wm->conn,
-						 XCB_XFIXES_MAJOR_VERSION,
-						 XCB_XFIXES_MINOR_VERSION);
-	xfixes_reply = xcb_xfixes_query_version_reply(wm->conn,
-						      xfixes_cookie, NULL);
-
-	weston_log("xfixes version: %d.%d\n",
-	       xfixes_reply->major_version, xfixes_reply->minor_version);
-
-	free(xfixes_reply);
-
-	formats_reply = xcb_render_query_pict_formats_reply(wm->conn,
-							    formats_cookie, 0);
-	if (formats_reply == NULL)
+	if (!window || !weston_surface_is_mapped(surface))
 		return;
 
-	formats = xcb_render_query_pict_formats_formats(formats_reply);
-	for (i = 0; i < formats_reply->num_formats; i++) {
-		if (formats[i].direct.red_mask != 0xff &&
-		    formats[i].direct.red_shift != 16)
-			continue;
-		if (formats[i].type == XCB_RENDER_PICT_TYPE_DIRECT &&
-		    formats[i].depth == 24)
-			wm->format_rgb = formats[i];
-		if (formats[i].type == XCB_RENDER_PICT_TYPE_DIRECT &&
-		    formats[i].depth == 32 &&
-		    formats[i].direct.alpha_mask == 0xff &&
-		    formats[i].direct.alpha_shift == 24)
-			wm->format_rgba = formats[i];
-	}
+	weston_surface_to_global_float(surface, output->x, output->y,
+				       &sxf, &syf);
 
-	free(formats_reply);
+	xserver_send_configure(window->wxs->resource, window->xid,
+			       (int) sxf, (int) syf,
+			       window->width, window->height,
+			       WL_SHELL_SURFACE_RESIZE_NONE);
 }
 
 static void
-weston_wm_create_wm_window(struct weston_wm *wm)
+window_kill_listener(struct wl_listener *listener, void *data)
 {
-	static const char name[] = "Weston WM";
-
-	wm->wm_window = xcb_generate_id(wm->conn);
-	xcb_create_window(wm->conn,
-			  XCB_COPY_FROM_PARENT,
-			  wm->wm_window,
-			  wm->screen->root,
-			  0, 0,
-			  10, 10,
-			  0,
-			  XCB_WINDOW_CLASS_INPUT_OUTPUT,
-			  wm->screen->root_visual,
-			  0, NULL);
-
-	xcb_change_property(wm->conn,
-			    XCB_PROP_MODE_REPLACE,
-			    wm->wm_window,
-			    wm->atom.net_supporting_wm_check,
-			    XCB_ATOM_WINDOW,
-			    32, /* format */
-			    1, &wm->wm_window);
-
-	xcb_change_property(wm->conn,
-			    XCB_PROP_MODE_REPLACE,
-			    wm->wm_window,
-			    wm->atom.net_wm_name,
-			    wm->atom.utf8_string,
-			    8, /* format */
-			    strlen(name), name);
-
-	xcb_change_property(wm->conn,
-			    XCB_PROP_MODE_REPLACE,
-			    wm->screen->root,
-			    wm->atom.net_supporting_wm_check,
-			    XCB_ATOM_WINDOW,
-			    32, /* format */
-			    1, &wm->wm_window);
-
-	/* Claim the WM_S0 selection even though we don't suport
-	 * the --replace functionality. */
-	xcb_set_selection_owner(wm->conn,
-				wm->wm_window,
-				wm->atom.wm_s0,
-				XCB_TIME_CURRENT_TIME);
-}
-
-struct weston_wm *
-weston_wm_create(struct weston_xserver *wxs)
-{
-	struct weston_wm *wm;
-	struct wl_event_loop *loop;
-	xcb_screen_iterator_t s;
-	uint32_t values[1];
-	int sv[2];
-	xcb_atom_t supported[1];
-
-	wm = malloc(sizeof *wm);
-	if (wm == NULL)
-		return NULL;
-
-	memset(wm, 0, sizeof *wm);
-	wm->server = wxs;
-	wm->window_hash = hash_table_create();
-	if (wm->window_hash == NULL) {
-		free(wm);
-		return NULL;
-	}
-
-	if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0, sv) < 0) {
-		weston_log("socketpair failed\n");
-		hash_table_destroy(wm->window_hash);
-		free(wm);
-		return NULL;
-	}
-
-	xserver_send_client(wxs->resource, sv[1]);
-	wl_client_flush(wxs->resource->client);
-	close(sv[1]);
-	
-	/* xcb_connect_to_fd takes ownership of the fd. */
-	wm->conn = xcb_connect_to_fd(sv[0], NULL);
-	if (xcb_connection_has_error(wm->conn)) {
-		weston_log("xcb_connect_to_fd failed\n");
-		close(sv[0]);
-		hash_table_destroy(wm->window_hash);
-		free(wm);
-		return NULL;
-	}
-
-	s = xcb_setup_roots_iterator(xcb_get_setup(wm->conn));
-	wm->screen = s.data;
-
-	loop = wl_display_get_event_loop(wxs->wl_display);
-	wm->source =
-		wl_event_loop_add_fd(loop, sv[0],
-				     WL_EVENT_READABLE,
-				     weston_wm_handle_event, wm);
-	wl_event_source_check(wm->source);
-
-	weston_wm_get_resources(wm);
-
-	values[0] =
-		XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY |
-		XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT |
-		XCB_EVENT_MASK_PROPERTY_CHANGE;
-	xcb_change_window_attributes(wm->conn, wm->screen->root,
-				     XCB_CW_EVENT_MASK, values);
-	wm->theme = theme_create();
-
-	weston_wm_create_wm_window(wm);
-
-	supported[0] = wm->atom.net_wm_moveresize;
-	xcb_change_property(wm->conn,
-			    XCB_PROP_MODE_REPLACE,
-			    wm->screen->root,
-			    wm->atom.net_supported,
-			    XCB_ATOM_ATOM,
-			    32, /* format */
-			    ARRAY_LENGTH(supported), supported);
-
-	weston_wm_selection_init(wm);
-
-	xcb_flush(wm->conn);
-
-	wm->activate_listener.notify = weston_wm_window_activate;
-	wl_signal_add(&wxs->compositor->activate_signal,
-		      &wm->activate_listener);
-	wm->kill_listener.notify = weston_wm_kill_client;
-	wl_signal_add(&wxs->compositor->kill_signal,
-		      &wm->kill_listener);
-
-	weston_wm_create_cursors(wm);
-	weston_wm_window_set_cursor(wm, wm->screen->root, XWM_CURSOR_LEFT_PTR);
-
-	weston_log("created wm\n");
-
-	return wm;
-}
+	struct weston_surface *surface = data;
+	struct xserver_window *window = get_xserver_window(surface);
 
-void
-weston_wm_destroy(struct weston_wm *wm)
-{
-	/* FIXME: Free windows in hash. */
-	hash_table_destroy(wm->window_hash);
-	weston_wm_destroy_cursors(wm);
-	xcb_disconnect(wm->conn);
-	wl_event_source_remove(wm->source);
-	wl_list_remove(&wm->selection_listener.link);
-	wl_list_remove(&wm->activate_listener.link);
-	wl_list_remove(&wm->kill_listener.link);
-
-	free(wm);
+	if (window)
+		wm_xwin_send_state(&window->resource, WM_XWIN_STATE_KILL);
 }
 
 static void
-surface_destroy(struct wl_listener *listener, void *data)
+wm_handle_ready(struct wl_client *client, struct wl_resource *resource)
 {
-	struct weston_wm_window *window =
-		container_of(listener,
-			     struct weston_wm_window, surface_destroy_listener);
+	struct weston_xserver *wxs = resource->data;
+	struct weston_seat *seat = weston_wm_pick_seat(wxs);
 
-	weston_log("surface for xid %d destroyed\n", window->id);
-}
+	/* sending now the X display connection together with the actual first
+	 * X client that got connected */
+	xserver_send_listen_socket(wxs->resource, wxs->abstract_fd);
+	xserver_send_listen_socket(wxs->resource, wxs->unix_fd);
 
-static struct weston_wm_window *
-get_wm_window(struct weston_surface *surface)
-{
-	struct wl_resource *resource = &surface->surface.resource;
-	struct wl_listener *listener;
+	wl_list_init(&wxs->xserver_window_list);
 
-	listener = wl_signal_get(&resource->destroy_signal, surface_destroy);
-	if (listener)
-		return container_of(listener, struct weston_wm_window,
-				    surface_destroy_listener);
+	wxs->activate_listener.notify = wm_activate_listener;
+	wl_signal_add(&wxs->compositor->activate_signal,
+		      &wxs->activate_listener);
 
-	return NULL;
+	wxs->selection_listener.notify = wm_set_selection_listener;
+	wl_signal_add(&seat->seat.selection_signal,
+		      &wxs->selection_listener);
 }
 
 static void
-weston_wm_window_configure(void *data)
+wm_handle_create_xwindow(struct wl_client *client,
+			 struct wl_resource *resource,
+			 uint32_t id, uint32_t xid)
 {
-	struct weston_wm_window *window = data;
-	struct weston_wm *wm = window->wm;
-	uint32_t values[2];
-	int width, height;
-
-	values[0] = window->width;
-	values[1] = window->height;
-	xcb_configure_window(wm->conn,
-			     window->id,
-			     XCB_CONFIG_WINDOW_WIDTH |
-			     XCB_CONFIG_WINDOW_HEIGHT,
-			     values);
-
-	weston_wm_window_get_frame_size(window, &width, &height);
-	values[0] = width;
-	values[1] = height;
-	xcb_configure_window(wm->conn,
-			     window->frame_id,
-			     XCB_CONFIG_WINDOW_WIDTH |
-			     XCB_CONFIG_WINDOW_HEIGHT,
-			     values);
-
-	window->configure_source = NULL;
-
-	weston_wm_window_schedule_repaint(window);
-}
+	struct weston_xserver *wxs = resource->data;
+	struct xserver_window *window;
 
-static void
-send_configure(struct weston_surface *surface,
-	       uint32_t edges, int32_t width, int32_t height)
-{
-	struct weston_wm_window *window = get_wm_window(surface);
-	struct weston_wm *wm = window->wm;
-	struct theme *t = window->wm->theme;
-
-	if (window->decorate) {
-		window->width = width - 2 * (t->margin + t->width);
-		window->height = height - 2 * t->margin -
-			t->titlebar_height - t->width;
-	} else {
-		window->width = width - 2 * t->margin;
-		window->height = height - 2 * t->margin;
+	window = malloc(sizeof *window);
+	if (!window) {
+		wl_resource_post_no_memory(resource);
+                return;
 	}
 
-	if (window->configure_source)
-		return;
-
-	window->configure_source =
-		wl_event_loop_add_idle(wm->server->loop,
-				       weston_wm_window_configure, window);
-}
-
-static const struct weston_shell_client shell_client = {
-	send_configure
-};
-
-static void
-xserver_map_shell_surface(struct weston_wm *wm,
-			  struct weston_wm_window *window)
-{
-	struct weston_shell_interface *shell_interface =
-		&wm->server->compositor->shell_interface;
-	struct weston_wm_window *parent;
-	struct theme *t = window->wm->theme;
-	int parent_id, x = 0, y = 0;
-
-	if (!shell_interface->create_shell_surface)
-		return;
-
-	window->shsurf = 
-		shell_interface->create_shell_surface(shell_interface->shell,
-						      window->surface,
-						      &shell_client);
+	window->surface = NULL;
+	window->shsurf = NULL;
+	window->wxs = wxs;
+	window->xid = xid;
 
-	/* ICCCM 4.1.1 */
-	if (!window->override_redirect) {
-		shell_interface->set_toplevel(window->shsurf);
-		return;
-	}
+	window->resource.destroy = wm_destroy_xwin;
+	window->resource.object.id = id;
+	window->resource.object.interface = &wm_xwin_interface;
+	window->resource.object.implementation =
+		(void (**)(void)) &wm_xwin_implementation;
+	window->resource.data = window;
+	wl_client_add_resource(client, &window->resource);
 
-	/* not all non-toplevel has transient_for set. So we need this
-	 * workaround to guess a parent that will determine the relative
-	 * position of the transient surface */
-	if (!window->transient_for)
-		parent_id = wm->focus_latest->id;
-	else
-		parent_id = window->transient_for->id;
+	window->kill_listener.notify = window_kill_listener;
+	wl_signal_add(&wxs->compositor->kill_signal, &window->kill_listener);
 
-	parent = hash_table_lookup(wm->window_hash, parent_id);
+	window->position_listener.notify = window_position_listener;
+	wl_signal_add(&wxs->compositor->position_signal,
+		      &window->position_listener);
 
-	/* non-decorated and non-toplevel windows, e.g. sub-menus */
-	if (!parent->decorate && parent->override_redirect) {
-		x = parent->x + t->margin;
-		y = parent->y + t->margin;
-	}
-
-	shell_interface->set_transient(window->shsurf, parent->surface,
-				       window->x + t->margin - x,
-				       window->y + t->margin - y,
-				       WL_SHELL_SURFACE_TRANSIENT_INACTIVE);
+	wl_list_insert(&wxs->xserver_window_list, &window->link);
 }
 
 static void
-xserver_set_window_id(struct wl_client *client, struct wl_resource *resource,
-		      struct wl_resource *surface_resource, uint32_t id)
+wm_handle_set_selection(struct wl_client *client,
+			struct wl_resource *resource,
+			const char *mime_type, int32_t fd)
 {
 	struct weston_xserver *wxs = resource->data;
-	struct weston_wm *wm = wxs->wm;
-	struct wl_surface *surface = surface_resource->data;
-	struct weston_wm_window *window;
+	struct weston_seat *seat = weston_wm_pick_seat(wxs);
+	struct wl_data_source *source;
 
-	if (client != wxs->client)
-		return;
-
-	window = hash_table_lookup(wm->window_hash, id);
-	if (window == NULL) {
-		weston_log("set_window_id for unknown window %d\n", id);
-		return;
-	}
-
-	weston_log("set_window_id %d for surface %p\n", id, surface);
-
-	weston_wm_window_read_properties(window);
-
-	window->surface = (struct weston_surface *) surface;
-	window->surface_destroy_listener.notify = surface_destroy;
-	wl_signal_add(&surface->resource.destroy_signal,
-		      &window->surface_destroy_listener);
-
-	weston_wm_window_schedule_repaint(window);
-	xserver_map_shell_surface(wm, window);
+	source = seat->seat.selection_data_source;
+	source->send(source, mime_type, fd);
 }
 
-const struct xserver_interface xserver_implementation = {
-	xserver_set_window_id
+const struct wm_interface wm_implementation = {
+	wm_handle_ready,
+	wm_handle_create_xwindow,
+	wm_handle_set_selection,
 };
diff --git a/src/xwayland/xwayland.h b/src/xwayland/xwayland.h
index 2230b97..1ba92b6 100644
--- a/src/xwayland/xwayland.h
+++ b/src/xwayland/xwayland.h
@@ -21,10 +21,6 @@
  */
 
 #include <wayland-server.h>
-#include <xcb/xcb.h>
-#include <xcb/xfixes.h>
-#include <cairo/cairo-xcb.h>
-
 #include "../compositor.h"
 
 struct weston_xserver {
@@ -40,110 +36,20 @@ struct weston_xserver {
 	struct wl_resource *resource;
 	struct wl_client *client;
 	struct weston_compositor *compositor;
-	struct weston_wm *wm;
 	struct wl_listener destroy_listener;
-};
 
-struct weston_wm {
-	xcb_connection_t *conn;
-	const xcb_query_extension_reply_t *xfixes;
-	struct wl_event_source *source;
-	xcb_screen_t *screen;
-	struct hash_table *window_hash;
-	struct weston_xserver *server;
-	xcb_window_t wm_window;
-	struct weston_wm_window *focus_window;
-	struct weston_wm_window *focus_latest;
-	struct theme *theme;
-	xcb_cursor_t *cursors;
-	int last_cursor;
-	xcb_render_pictforminfo_t format_rgb, format_rgba;
+	/* window manager related */
+	int wm_fd, wm_xfd;
+	struct {
+		struct weston_process process;
+		struct wl_client *client;
+	} wm_child;
+	struct wl_resource *wm_resource;
+	struct wl_resource *wm_conn_resource;
 	struct wl_listener activate_listener;
-	struct wl_listener kill_listener;
-
-	xcb_window_t selection_window;
-	xcb_window_t selection_owner;
-	int incr;
-	int data_source_fd;
-	struct wl_event_source *property_source;
-	xcb_get_property_reply_t *property_reply;
-	int property_start;
-	struct wl_array source_data;
-	xcb_selection_request_event_t selection_request;
-	xcb_atom_t selection_target;
-	xcb_timestamp_t selection_timestamp;
-	int selection_property_set;
-	int flush_property_on_delete;
 	struct wl_listener selection_listener;
-
-	struct {
-		xcb_atom_t		 wm_protocols;
-		xcb_atom_t		 wm_take_focus;
-		xcb_atom_t		 wm_delete_window;
-		xcb_atom_t		 wm_state;
-		xcb_atom_t		 wm_s0;
-		xcb_atom_t		 wm_client_machine;
-		xcb_atom_t		 net_wm_name;
-		xcb_atom_t		 net_wm_pid;
-		xcb_atom_t		 net_wm_icon;
-		xcb_atom_t		 net_wm_state;
-		xcb_atom_t		 net_wm_state_fullscreen;
-		xcb_atom_t		 net_wm_user_time;
-		xcb_atom_t		 net_wm_icon_name;
-		xcb_atom_t		 net_wm_window_type;
-		xcb_atom_t		 net_wm_window_type_desktop;
-		xcb_atom_t		 net_wm_window_type_dock;
-		xcb_atom_t		 net_wm_window_type_toolbar;
-		xcb_atom_t		 net_wm_window_type_menu;
-		xcb_atom_t		 net_wm_window_type_utility;
-		xcb_atom_t		 net_wm_window_type_splash;
-		xcb_atom_t		 net_wm_window_type_dialog;
-		xcb_atom_t		 net_wm_window_type_dropdown;
-		xcb_atom_t		 net_wm_window_type_popup;
-		xcb_atom_t		 net_wm_window_type_tooltip;
-		xcb_atom_t		 net_wm_window_type_notification;
-		xcb_atom_t		 net_wm_window_type_combo;
-		xcb_atom_t		 net_wm_window_type_dnd;
-		xcb_atom_t		 net_wm_window_type_normal;
-		xcb_atom_t		 net_wm_moveresize;
-		xcb_atom_t		 net_supporting_wm_check;
-		xcb_atom_t		 net_supported;
-		xcb_atom_t		 motif_wm_hints;
-		xcb_atom_t		 clipboard;
-		xcb_atom_t		 clipboard_manager;
-		xcb_atom_t		 targets;
-		xcb_atom_t		 utf8_string;
-		xcb_atom_t		 wl_selection;
-		xcb_atom_t		 incr;
-		xcb_atom_t		 timestamp;
-		xcb_atom_t		 multiple;
-		xcb_atom_t		 compound_text;
-		xcb_atom_t		 text;
-		xcb_atom_t		 string;
-		xcb_atom_t		 text_plain_utf8;
-		xcb_atom_t		 text_plain;
-	} atom;
+	struct wl_list xserver_window_list;
 };
 
-void
-dump_property(struct weston_wm *wm, xcb_atom_t property,
-	      xcb_get_property_reply_t *reply);
-
-const char *
-get_atom_name(xcb_connection_t *c, xcb_atom_t atom);
-
-void
-weston_wm_selection_init(struct weston_wm *wm);
-int
-weston_wm_handle_selection_event(struct weston_wm *wm,
-				 xcb_generic_event_t *event);
-
 extern const struct xserver_interface xserver_implementation;
-
-struct weston_wm *
-weston_wm_create(struct weston_xserver *wxs);
-void
-weston_wm_destroy(struct weston_wm *wm);
-
-struct weston_seat *
-weston_wm_pick_seat(struct weston_wm *wm);
+extern const struct wm_interface wm_implementation;
