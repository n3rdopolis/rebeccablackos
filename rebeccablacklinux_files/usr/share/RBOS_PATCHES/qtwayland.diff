diff --git a/src/plugins/platforms/wayland/gl_integration/wayland_egl/qwaylandegldecoration.cpp b/src/plugins/platforms/wayland/gl_integration/wayland_egl/qwaylandegldecoration.cpp
new file mode 100644
index 0000000..5cf5239
--- /dev/null
+++ b/src/plugins/platforms/wayland/gl_integration/wayland_egl/qwaylandegldecoration.cpp
@@ -0,0 +1,65 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qwaylandegldecoration.h"
+
+#include "qwaylandeglwindow.h"
+
+#include <QtGui/QPainter>
+#include <QtGui/QOpenGLPaintDevice>
+
+QWaylandEglDecoration::QWaylandEglDecoration(QWaylandEglWindow *window)
+    : QWaylandDecoration(window)
+{
+}
+
+QWaylandEglDecoration::~QWaylandEglDecoration()
+{
+}
+
+void QWaylandEglDecoration::paintDecoration()
+{
+    glClearColor(backgroundColor().redF(), backgroundColor().greenF(), backgroundColor().blueF(), backgroundColor().alphaF());
+    glClear(GL_COLOR_BUFFER_BIT);
+
+    QOpenGLPaintDevice device(window()->frameGeometry().size());
+    paint(&device);
+}
diff --git a/src/plugins/platforms/wayland/gl_integration/wayland_egl/qwaylandegldecoration.h b/src/plugins/platforms/wayland/gl_integration/wayland_egl/qwaylandegldecoration.h
new file mode 100644
index 0000000..c1ef6d5
--- /dev/null
+++ b/src/plugins/platforms/wayland/gl_integration/wayland_egl/qwaylandegldecoration.h
@@ -0,0 +1,59 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QWAYLANDEGLDECORATION_H
+#define QWAYLANDEGLDECORATION_H
+
+#include "qwaylanddecoration.h"
+
+class QWaylandEglWindow;
+
+class QWaylandEglDecoration : public QWaylandDecoration
+{
+public:
+    QWaylandEglDecoration(QWaylandEglWindow *window);
+    ~QWaylandEglDecoration();
+
+    void paintDecoration();
+
+};
+
+#endif // QWAYLANDEGLDECORATION_H
diff --git a/src/plugins/platforms/wayland/gl_integration/wayland_egl/qwaylandeglwindow.cpp b/src/plugins/platforms/wayland/gl_integration/wayland_egl/qwaylandeglwindow.cpp
index e8599e4..2bf2c4f 100644
--- a/src/plugins/platforms/wayland/gl_integration/wayland_egl/qwaylandeglwindow.cpp
+++ b/src/plugins/platforms/wayland/gl_integration/wayland_egl/qwaylandeglwindow.cpp
@@ -43,11 +43,15 @@
 
 #include "qwaylandscreen.h"
 #include "qwaylandglcontext.h"
+#include "qwaylandegldecoration.h"
 
 #include <QtPlatformSupport/private/qeglconvenience_p.h>
 
+#include <QDebug>
 #include <QtGui/QWindow>
 #include <qpa/qwindowsysteminterface.h>
+#include <QOpenGLFramebufferObject>
+#include <QOpenGLContext>
 
 #ifdef QT_WAYLAND_WINDOWMANAGER_SUPPORT
 #include "windowmanager_integration/qwaylandwindowmanagerintegration.h"
@@ -56,11 +60,14 @@
 QWaylandEglWindow::QWaylandEglWindow(QWindow *window)
     : QWaylandWindow(window)
     , m_eglIntegration(static_cast<QWaylandEglIntegration *>(mDisplay->eglIntegration()))
-    , m_waylandEglWindow(wl_egl_window_create(mSurface,window->width(),window->height()))
+    , m_waylandEglWindow(0)
     , m_eglSurface(0)
     , m_eglConfig(0)
+    , m_contentFBO(0)
+    , m_resize(false)
     , m_format(window->format())
 {
+    setGeometry(window->geometry());
 }
 
 QWaylandEglWindow::~QWaylandEglWindow()
@@ -71,6 +78,8 @@ QWaylandEglWindow::~QWaylandEglWindow()
     }
 
     wl_egl_window_destroy(m_waylandEglWindow);
+
+    delete m_contentFBO;
 }
 
 QWaylandWindow::WindowType QWaylandEglWindow::windowType() const
@@ -78,16 +87,34 @@ QWaylandWindow::WindowType QWaylandEglWindow::windowType() const
     return QWaylandWindow::Egl;
 }
 
-void QWaylandEglWindow::setGeometry(const QRect &rect)
+void QWaylandEglWindow::redraw()
 {
-    int current_width, current_height;
-    wl_egl_window_get_attached_size(m_waylandEglWindow,&current_width,&current_height);
-    if (current_width != rect.width() || current_height != rect.height()) {
-        waitForFrameSync();
-        wl_egl_window_resize(m_waylandEglWindow, rect.width(), rect.height(), 0, 0);
+    createDecoration();
+    QMargins margins = frameMargins();
+    QSize sizeWithMargins = geometry().size() + QSize(margins.left() + margins.right(), margins.top() + margins.bottom());
+
+    if (m_waylandEglWindow) {
+        int current_width, current_height;
+        wl_egl_window_get_attached_size(m_waylandEglWindow,&current_width,&current_height);
+        if (current_width != sizeWithMargins.width() || current_height != sizeWithMargins.height()) {
+            waitForFrameSync();
+            wl_egl_window_resize(m_waylandEglWindow, sizeWithMargins.width(), sizeWithMargins.height(), mOffset.x(), mOffset.y());
+            mOffset = QPoint();
+
+            m_resize = true;
+        }
+    } else {
+        m_waylandEglWindow = wl_egl_window_create(mSurface, sizeWithMargins.width(), sizeWithMargins.height());
     }
-    QWaylandWindow::setGeometry(rect);
 }
+
+QRect QWaylandEglWindow::contentsRect() const
+{
+    QRect r = geometry();
+    QMargins m = frameMargins();
+    return QRect(m.left(), m.bottom(), r.width(), r.height());
+}
+
 QSurfaceFormat QWaylandEglWindow::format() const
 {
     return m_format;
@@ -95,6 +122,13 @@ QSurfaceFormat QWaylandEglWindow::format() const
 
 EGLSurface QWaylandEglWindow::eglSurface() const
 {
+    if (!m_waylandEglWindow) {
+        const_cast<QWaylandEglWindow *>(this)->createDecoration();
+        QMargins margins = frameMargins();
+        QSize sizeWithMargins = geometry().size() + QSize(margins.left() + margins.right(), margins.top() + margins.bottom());
+        m_waylandEglWindow = wl_egl_window_create(mSurface, sizeWithMargins.width(), sizeWithMargins.height());
+    }
+
     if (!m_eglSurface) {
         m_eglConfig = q_configFromGLFormat(m_eglIntegration->eglDisplay(), window()->format(), true);
         const_cast<QWaylandEglWindow *>(this)->m_format = q_glFormatFromConfig(m_eglIntegration->eglDisplay(),m_eglConfig);
@@ -106,3 +140,31 @@ EGLSurface QWaylandEglWindow::eglSurface() const
     return m_eglSurface;
 }
 
+GLuint QWaylandEglWindow::contentFBO() const
+{
+    if (m_resize || !m_contentFBO) {
+        QOpenGLFramebufferObject *old = m_contentFBO;
+        m_contentFBO = new QOpenGLFramebufferObject(geometry().width(), geometry().height(), QOpenGLFramebufferObject::CombinedDepthStencil);
+
+        delete old;
+        m_resize = false;
+    }
+
+    return m_contentFBO->handle();
+}
+
+GLuint QWaylandEglWindow::contentTexture() const
+{
+    return m_contentFBO->texture();
+}
+
+void QWaylandEglWindow::bindContentFBO()
+{
+    contentFBO();
+    m_contentFBO->bind();
+}
+
+void QWaylandEglWindow::createDecorationInstance()
+{
+    new QWaylandEglDecoration(this);
+}
diff --git a/src/plugins/platforms/wayland/gl_integration/wayland_egl/qwaylandeglwindow.h b/src/plugins/platforms/wayland/gl_integration/wayland_egl/qwaylandeglwindow.h
index 66b3d61..4a7b305 100644
--- a/src/plugins/platforms/wayland/gl_integration/wayland_egl/qwaylandeglwindow.h
+++ b/src/plugins/platforms/wayland/gl_integration/wayland_egl/qwaylandeglwindow.h
@@ -47,6 +47,7 @@
 #include "qwaylandeglintegration.h"
 
 class QWaylandGLContext;
+class QOpenGLFramebufferObject;
 
 class QWaylandEglWindow : public QWaylandWindow
 {
@@ -54,20 +55,32 @@ public:
     QWaylandEglWindow(QWindow *window);
     ~QWaylandEglWindow();
     WindowType windowType() const;
-    void setGeometry(const QRect &rect);
+
+    QRect contentsRect() const;
 
     EGLSurface eglSurface() const;
+    GLuint contentFBO() const;
+    GLuint contentTexture() const;
 
     QSurfaceFormat format() const;
 
+    void bindContentFBO();
+
+    void redraw();
+
+protected:
+    void createDecorationInstance();
+
 private:
     QWaylandEglIntegration *m_eglIntegration;
-    struct wl_egl_window *m_waylandEglWindow;
+    mutable struct wl_egl_window *m_waylandEglWindow;
 
     const QWaylandWindow *m_parentWindow;
 
     mutable EGLSurface m_eglSurface;
     mutable EGLConfig m_eglConfig;
+    mutable QOpenGLFramebufferObject *m_contentFBO;
+    mutable bool m_resize;
 
     QSurfaceFormat m_format;
 };
diff --git a/src/plugins/platforms/wayland/gl_integration/wayland_egl/qwaylandglcontext.cpp b/src/plugins/platforms/wayland/gl_integration/wayland_egl/qwaylandglcontext.cpp
index c869aae..8bc9abd 100644
--- a/src/plugins/platforms/wayland/gl_integration/wayland_egl/qwaylandglcontext.cpp
+++ b/src/plugins/platforms/wayland/gl_integration/wayland_egl/qwaylandglcontext.cpp
@@ -44,17 +44,22 @@
 #include "qwaylanddisplay.h"
 #include "qwaylandwindow.h"
 #include "qwaylandeglwindow.h"
+#include "qwaylanddecoration.h"
 
+#include <QDebug>
 #include <QtPlatformSupport/private/qeglconvenience_p.h>
+#include <QtGui/private/qopenglcontext_p.h>
 
 #include <qpa/qplatformopenglcontext.h>
 #include <QtGui/QSurfaceFormat>
+#include <QtGui/QOpenGLShaderProgram>
 
 QWaylandGLContext::QWaylandGLContext(EGLDisplay eglDisplay, const QSurfaceFormat &format, QPlatformOpenGLContext *share)
     : QPlatformOpenGLContext()
     , m_eglDisplay(eglDisplay)
     , m_config(q_configFromGLFormat(m_eglDisplay, format, true))
     , m_format(q_glFormatFromConfig(m_eglDisplay, m_config))
+    , m_blitProgram(0)
 {
     m_shareEGLContext = share ? static_cast<QWaylandGLContext *>(share)->eglContext() : EGL_NO_CONTEXT;
 
@@ -75,13 +80,23 @@ QWaylandGLContext::QWaylandGLContext(EGLDisplay eglDisplay, const QSurfaceFormat
 
 QWaylandGLContext::~QWaylandGLContext()
 {
+    delete m_blitProgram;
     eglDestroyContext(m_eglDisplay, m_context);
 }
 
 bool QWaylandGLContext::makeCurrent(QPlatformSurface *surface)
 {
-    EGLSurface eglSurface = static_cast<QWaylandEglWindow *>(surface)->eglSurface();
-    return eglMakeCurrent(m_eglDisplay, eglSurface, eglSurface, m_context);
+    QWaylandEglWindow *window = static_cast<QWaylandEglWindow *>(surface);
+    EGLSurface eglSurface = window->eglSurface();
+    if (!eglMakeCurrent(m_eglDisplay, eglSurface, eglSurface, m_context))
+        return false;
+
+    // FIXME: remove this as soon as https://codereview.qt-project.org/#change,38879 is merged
+    QOpenGLContextPrivate::setCurrentContext(context());
+
+    window->bindContentFBO();
+
+    return true;
 }
 
 void QWaylandGLContext::doneCurrent()
@@ -91,10 +106,83 @@ void QWaylandGLContext::doneCurrent()
 
 void QWaylandGLContext::swapBuffers(QPlatformSurface *surface)
 {
-    EGLSurface eglSurface = static_cast<QWaylandEglWindow *>(surface)->eglSurface();
+    QWaylandEglWindow *window = static_cast<QWaylandEglWindow *>(surface);
+    EGLSurface eglSurface = window->eglSurface();
+
+    makeCurrent(surface);
+
+    if (!m_blitProgram) {
+        m_blitProgram = new QOpenGLShaderProgram();
+        m_blitProgram->addShaderFromSourceCode(QOpenGLShader::Vertex, "attribute vec4 position;\n\
+                                                                       attribute vec4 texCoords;\n\
+                                                                       varying vec2 outTexCoords;\n\
+                                                                       void main()\n\
+                                                                       {\n\
+                                                                           gl_Position = position;\n\
+                                                                           outTexCoords = texCoords.xy;\n\
+                                                                       }");
+        m_blitProgram->addShaderFromSourceCode(QOpenGLShader::Fragment, "varying vec2 outTexCoords;\n\
+                                                                         uniform sampler2D texture;\n\
+                                                                         void main()\n\
+                                                                         {\n\
+                                                                             gl_FragColor = texture2D(texture, outTexCoords);\n\
+                                                                         }");
+
+        if (!m_blitProgram->link()) {
+            qDebug() << "Shader Program link failed.";
+            qDebug() << m_blitProgram->log();
+        }
+    }
+
+    glDisable(GL_DEPTH_TEST);
+    glBindFramebuffer(GL_FRAMEBUFFER, 0);
+
+    if (window->decoration())
+        window->decoration()->paintDecoration();
+
+    glActiveTexture(GL_TEXTURE0);
+    glBindTexture(GL_TEXTURE_2D, window->contentTexture());
+    QRect r = window->contentsRect();
+    glViewport(r.x(), r.y(), r.width(), r.height());
+
+    static const GLfloat squareVertices[] = {
+        -1.f, -1.f,
+        1.0f, -1.f,
+        -1.f,  1.0f,
+        1.0f,  1.0f,
+    };
+    static const GLfloat textureVertices[] = {
+        0.0f,  0.0f,
+        1.0f,  0.0f,
+        0.0f,  1.0f,
+        1.0f,  1.0f,
+    };
+
+    m_blitProgram->bind();
+
+    m_blitProgram->setUniformValue("texture", 0);
+
+    m_blitProgram->enableAttributeArray("position");
+    m_blitProgram->enableAttributeArray("texCoords");
+    m_blitProgram->setAttributeArray("position", squareVertices, 2);
+    m_blitProgram->setAttributeArray("texCoords", textureVertices, 2);
+
+    m_blitProgram->bind();
+
+    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+
+    m_blitProgram->disableAttributeArray("position");
+    m_blitProgram->disableAttributeArray("texCoords");
+    m_blitProgram->release();
+
     eglSwapBuffers(m_eglDisplay, eglSurface);
 }
 
+GLuint QWaylandGLContext::defaultFramebufferObject(QPlatformSurface *surface) const
+{
+    return static_cast<QWaylandEglWindow *>(surface)->contentFBO();
+}
+
 bool QWaylandGLContext::isSharing() const
 {
     return m_shareEGLContext != EGL_NO_CONTEXT;
diff --git a/src/plugins/platforms/wayland/gl_integration/wayland_egl/qwaylandglcontext.h b/src/plugins/platforms/wayland/gl_integration/wayland_egl/qwaylandglcontext.h
index f30b610..767f188 100644
--- a/src/plugins/platforms/wayland/gl_integration/wayland_egl/qwaylandglcontext.h
+++ b/src/plugins/platforms/wayland/gl_integration/wayland_egl/qwaylandglcontext.h
@@ -50,6 +50,7 @@
 
 class QWaylandWindow;
 class QWaylandGLWindowSurface;
+class QOpenGLShaderProgram;
 
 class QWaylandGLContext : public QPlatformOpenGLContext {
 public:
@@ -61,6 +62,8 @@ public:
     bool makeCurrent(QPlatformSurface *surface);
     void doneCurrent();
 
+    GLuint defaultFramebufferObject(QPlatformSurface *surface) const;
+
     bool isSharing() const;
     bool isValid() const;
 
@@ -78,6 +81,7 @@ private:
     EGLContext m_shareEGLContext;
     EGLConfig m_config;
     QSurfaceFormat m_format;
+    QOpenGLShaderProgram *m_blitProgram;
 };
 
 
diff --git a/src/plugins/platforms/wayland/gl_integration/wayland_egl/wayland_egl.pri b/src/plugins/platforms/wayland/gl_integration/wayland_egl/wayland_egl.pri
index 5bda007..08f42b4 100644
--- a/src/plugins/platforms/wayland/gl_integration/wayland_egl/wayland_egl.pri
+++ b/src/plugins/platforms/wayland/gl_integration/wayland_egl/wayland_egl.pri
@@ -8,8 +8,10 @@
 INCLUDEPATH += $$PWD
 SOURCES += $$PWD/qwaylandeglintegration.cpp \
            $$PWD/qwaylandglcontext.cpp \
-           $$PWD/qwaylandeglwindow.cpp
+           $$PWD/qwaylandeglwindow.cpp \
+           $$PWD/qwaylandegldecoration.cpp
 
 HEADERS += $$PWD/qwaylandeglintegration.h \
            $$PWD/qwaylandglcontext.h \
-           $$PWD/qwaylandeglwindow.h
+           $$PWD/qwaylandeglwindow.h \
+           $$PWD/qwaylandegldecoration.h
diff --git a/src/plugins/platforms/wayland/qwaylandcursor.cpp b/src/plugins/platforms/wayland/qwaylandcursor.cpp
index b26f866..6185e05 100644
--- a/src/plugins/platforms/wayland/qwaylandcursor.cpp
+++ b/src/plugins/platforms/wayland/qwaylandcursor.cpp
@@ -49,181 +49,204 @@
 #include <QtGui/QImageReader>
 #include <QDebug>
 
-#define DATADIR "/usr/share"
-
-static const struct pointer_image {
-    const char *filename;
-    int hotspot_x, hotspot_y;
-} pointer_images[] = {
-    /* FIXME: Half of these are wrong... */
-    /* Qt::ArrowCursor */
-    { DATADIR "/wayland/left_ptr.png",			10,  5 },
-    /* Qt::UpArrowCursor */
-    { DATADIR "/wayland/top_side.png",			18,  8 },
-    /* Qt::CrossCursor */
-    { DATADIR "/wayland/top_side.png",			18,  8 },
-    /* Qt::WaitCursor */
-    { DATADIR "/wayland/top_side.png",			18,  8 },
-    /* Qt::IBeamCursor */
-    { DATADIR "/wayland/xterm.png",			15, 15 },
-    /* Qt::SizeVerCursor */
-    { DATADIR "/wayland/top_side.png",			18,  8 },
-    /* Qt::SizeHorCursor */
-    { DATADIR "/wayland/bottom_left_corner.png",	 6, 30 },
-    /* Qt::SizeBDiagCursor */
-    { DATADIR "/wayland/bottom_right_corner.png",	28, 28 },
-    /* Qt::SizeFDiagCursor */
-    { DATADIR "/wayland/bottom_side.png",		16, 20 },
-    /* Qt::SizeAllCursor */
-    { DATADIR "/wayland/left_side.png",			10, 20 },
-    /* Qt::BlankCursor */
-    { DATADIR "/wayland/right_side.png",		30, 19 },
-    /* Qt::SplitVCursor */
-    { DATADIR "/wayland/sb_v_double_arrow.png",		15, 15 },
-    /* Qt::SplitHCursor */
-    { DATADIR "/wayland/sb_h_double_arrow.png",		15, 15 },
-    /* Qt::PointingHandCursor */
-    { DATADIR "/wayland/hand2.png",			14,  8 },
-    /* Qt::ForbiddenCursor */
-    { DATADIR "/wayland/top_right_corner.png",		26,  8 },
-    /* Qt::WhatsThisCursor */
-    { DATADIR "/wayland/top_right_corner.png",		26,  8 },
-    /* Qt::BusyCursor */
-    { DATADIR "/wayland/top_right_corner.png",		26,  8 },
-    /* Qt::OpenHandCursor */
-    { DATADIR "/wayland/hand1.png",			18, 11 },
-    /* Qt::ClosedHandCursor */
-    { DATADIR "/wayland/grabbing.png",			20, 17 },
-    /* Qt::DragCopyCursor */
-    { DATADIR "/wayland/dnd-copy.png",			13, 13 },
-    /* Qt::DragMoveCursor */
-    { DATADIR "/wayland/dnd-move.png",			13, 13 },
-    /* Qt::DragLinkCursor */
-    { DATADIR "/wayland/dnd-link.png",			13, 13 },
+#include <wayland-cursor.h>
+
+
+
+
+
+#define ARRAY_LENGTH(a) sizeof(a) / sizeof(a[0])
+
+/*
+ * The following correspondences between file names and cursors was copied
+ * from: https://bugs.kde.org/attachment.cgi?id=67313
+ */
+
+static const char *bottom_left_corners[] = {
+    "size_fdiag",
+    "bottom_left_corner",
+    "sw-resize"
+};
+
+static const char *bottom_right_corners[] = {
+    "size_bdiag",
+    "bottom_right_corner",
+    "se-resize"
+};
+
+static const char *bottom_sides[] = {
+    "bottom_side",
+    "s-resize"
+};
+
+static const char *grabbings[] = {
+    "grabbing",
+    "closedhand",
+    "208530c400c041818281048008011002"
+};
+
+static const char *left_ptrs[] = {
+    "left_ptr",
+    "default",
+    "top_left_arrow",
+    "left-arrow"
+};
+
+static const char *left_sides[] = {
+    "left_side",
+    "w-resize"
+};
+
+static const char *right_sides[] = {
+    "right_side",
+    "e-resize"
+};
+
+static const char *top_left_corners[] = {
+    "top_left_corner",
+    "nw-resize"
+};
+
+static const char *top_right_corners[] = {
+    "top_right_corner",
+    "ne-resize"
+};
+
+static const char *top_sides[] = {
+    "top_side",
+    "n-resize"
+};
+
+static const char *xterms[] = {
+    "xterm",
+    "ibeam",
+    "text"
+};
+
+static const char *hand1s[] = {
+    "hand1",
+    "pointer",
+    "pointing_hand",
+    "e29285e634086352946a0e7090d73106"
+};
+
+static const char *watches[] = {
+    "watch",
+    "wait",
+    "0426c94ea35c87780ff01dc239897213"
+};
+
+struct cursor_alternatives {
+    const char **names;
+    size_t count;
+};
+
+static const struct cursor_alternatives cursors[] = {
+    {left_ptrs, ARRAY_LENGTH(left_ptrs)},
+    {bottom_left_corners, ARRAY_LENGTH(bottom_left_corners)},
+    {bottom_right_corners, ARRAY_LENGTH(bottom_right_corners)},
+    {bottom_sides, ARRAY_LENGTH(bottom_sides)},
+    {grabbings, ARRAY_LENGTH(grabbings)},
+    {left_sides, ARRAY_LENGTH(left_sides)},
+    {right_sides, ARRAY_LENGTH(right_sides)},
+    {top_left_corners, ARRAY_LENGTH(top_left_corners)},
+    {top_right_corners, ARRAY_LENGTH(top_right_corners)},
+    {top_sides, ARRAY_LENGTH(top_sides)},
+    {xterms, ARRAY_LENGTH(xterms)},
+    {hand1s, ARRAY_LENGTH(hand1s)},
+    {watches, ARRAY_LENGTH(watches)},
 };
 
+
+
 QWaylandCursor::QWaylandCursor(QWaylandScreen *screen)
-    : mBuffer(0)
-    , mDisplay(screen->display())
-    , mSurface(0)
+    : mDisplay(screen->display())
 {
-}
+    mCursorTheme = wl_cursor_theme_load("default", 32, mDisplay->shm());
+    mCursors = new wl_cursor*[ARRAY_LENGTH(cursors)];
 
-QWaylandCursor::~QWaylandCursor()
-{
-    if (mSurface)
-        wl_surface_destroy(mSurface);
+    for (uint i = 0; i < ARRAY_LENGTH(cursors); i++) {
+        struct wl_cursor *cursor = NULL;
+        for (uint j = 0; !cursor && j < cursors[i].count; ++j)
+            cursor = wl_cursor_theme_get_cursor(mCursorTheme, cursors[i].names[j]);
 
-    delete mBuffer;
-}
+        if (!cursor)
+            qDebug() << "could not load cursor" << cursors[i].names[0];
 
-void QWaylandCursor::ensureSurface(const QSize &size)
-{
-    if (!mBuffer || mBuffer->size() != size) {
-        delete mBuffer;
-        mBuffer = new QWaylandShmBuffer(mDisplay, size,
-                                        QImage::Format_ARGB32);
+        mCursors[i] = cursor;
     }
+}
 
-    if (!mSurface)
-        mSurface = mDisplay->createSurface(0);
-
-    wl_surface_attach(mSurface, mBuffer->buffer(), 0, 0);
+QWaylandCursor::~QWaylandCursor()
+{
+    wl_cursor_theme_destroy(mCursorTheme);
+    delete[] mCursors;
 }
 
 void QWaylandCursor::changeCursor(QCursor *cursor, QWindow *window)
 {
-    const struct pointer_image *p;
-
-    if (window == NULL)
-        return;
-
-    p = NULL;
-    bool isBitmap = false;
+    Q_UNUSED(window)
 
+    int pointer = 0;
     switch (cursor->shape()) {
-    case Qt::ArrowCursor:
-        p = &pointer_images[cursor->shape()];
-        break;
     case Qt::UpArrowCursor:
     case Qt::CrossCursor:
     case Qt::WaitCursor:
         break;
     case Qt::IBeamCursor:
-        p = &pointer_images[cursor->shape()];
-        break;
-    case Qt::SizeVerCursor:	/* 5 */
+    case Qt::SizeVerCursor: /* 5 */
     case Qt::SizeHorCursor:
     case Qt::SizeBDiagCursor:
+        pointer = 2;
+        break;
     case Qt::SizeFDiagCursor:
+        pointer = 1;
+        break;
     case Qt::SizeAllCursor:
-    case Qt::BlankCursor:	/* 10 */
+    case Qt::BlankCursor:   /* 10 */
         break;
     case Qt::SplitVCursor:
+        pointer = 3;
+        break;
     case Qt::SplitHCursor:
-    case Qt::PointingHandCursor:
-        p = &pointer_images[cursor->shape()];
+        pointer = 6;
         break;
+    case Qt::PointingHandCursor:
     case Qt::ForbiddenCursor:
-    case Qt::WhatsThisCursor:	/* 15 */
+    case Qt::WhatsThisCursor:   /* 15 */
     case Qt::BusyCursor:
-        break;
     case Qt::OpenHandCursor:
     case Qt::ClosedHandCursor:
+        pointer = 4;
+        break;
     case Qt::DragCopyCursor:
     case Qt::DragMoveCursor: /* 20 */
     case Qt::DragLinkCursor:
-        p = &pointer_images[cursor->shape()];
-        break;
-
     case Qt::BitmapCursor:
-        isBitmap = true;
-        break;
-
     default:
         break;
     }
 
-    if (!p && !isBitmap) {
-        p = &pointer_images[0];
-        qWarning("unhandled cursor %d", cursor->shape());
-    }
+    struct wl_cursor *cur = mCursors[pointer];
+    if (!cur)
+        return;
 
-    if (isBitmap && !cursor->pixmap().isNull()) {
-        setupPixmapCursor(cursor);
-    } else if (isBitmap && cursor->bitmap()) {
-        qWarning("unsupported QBitmap cursor");
-    } else {
-        QImageReader reader(p->filename);
-        if (!reader.canRead())
-            return;
-        ensureSurface(reader.size());
-        reader.read(mBuffer->image());
-        mDisplay->setCursor(mSurface, p->hotspot_x, p->hotspot_y);
-    }
-}
+    struct wl_cursor_image *image = cur->images[0];
 
-void QWaylandCursor::setupPixmapCursor(QCursor *cursor)
-{
-    if (!cursor) {
-        delete mBuffer;
-        mBuffer = 0;
+    struct wl_buffer *buffer = wl_cursor_image_get_buffer(image);
+    if (!buffer)
         return;
-    }
-    ensureSurface(cursor->pixmap().size());
-    QImage src = cursor->pixmap().toImage().convertToFormat(QImage::Format_ARGB32);
-    for (int y = 0; y < src.height(); ++y)
-        memcpy(mBuffer->image()->scanLine(y), src.scanLine(y), src.bytesPerLine());
-    mDisplay->setCursor(mSurface, cursor->hotSpot().x(), cursor->hotSpot().y());
+
+    mDisplay->setCursor(buffer, image);
 }
 
-void QWaylandDisplay::setCursor(wl_surface *surface, int32_t x, int32_t y)
+void QWaylandDisplay::setCursor(struct wl_buffer *buffer, struct wl_cursor_image *image)
 {
     /* Qt doesn't tell us which input device we should set the cursor
      * for, so set it for all devices. */
     for (int i = 0; i < mInputDevices.count(); i++) {
         QWaylandInputDevice *inputDevice = mInputDevices.at(i);
-        inputDevice->setCursor(surface, x, y);
+        inputDevice->setCursor(buffer, image);
     }
 }
 
diff --git a/src/plugins/platforms/wayland/qwaylandcursor.h b/src/plugins/platforms/wayland/qwaylandcursor.h
index a8ab408..aa8dbfb 100644
--- a/src/plugins/platforms/wayland/qwaylandcursor.h
+++ b/src/plugins/platforms/wayland/qwaylandcursor.h
@@ -44,10 +44,9 @@
 
 #include <qpa/qplatformcursor.h>
 
-class QWaylandShmBuffer;
 class QWaylandDisplay;
 class QWaylandScreen;
-struct wl_surface;
+struct wl_cursor_theme;
 
 class QWaylandCursor : public QPlatformCursor
 {
@@ -60,15 +59,10 @@ public:
     QPoint pos() const;
     void setPos(const QPoint &pos);
 
-    void setupPixmapCursor(QCursor *cursor);
-
-    QWaylandShmBuffer *mBuffer;
-    QWaylandDisplay *mDisplay;
-    wl_surface *mSurface;
-
 private:
-    void ensureSurface(const QSize &size);
-
+    QWaylandDisplay *mDisplay;
+    struct wl_cursor_theme *mCursorTheme;
+    struct wl_cursor **mCursors;
     QPoint mLastPos;
 };
 
diff --git a/src/plugins/platforms/wayland/qwaylanddecoration.cpp b/src/plugins/platforms/wayland/qwaylanddecoration.cpp
index 01de8be..3fcc7bb 100644
--- a/src/plugins/platforms/wayland/qwaylanddecoration.cpp
+++ b/src/plugins/platforms/wayland/qwaylanddecoration.cpp
@@ -42,7 +42,6 @@
 #include "qwaylanddecoration.h"
 
 #include "qwaylandwindow.h"
-#include "qwaylandshmbackingstore.h"
 #include "qwaylandshellsurface.h"
 #include "qwaylandinputdevice.h"
 
@@ -50,13 +49,14 @@
 #include <QtGui/QCursor>
 #include <QtGui/QPainter>
 #include <QtGui/QRadialGradient>
-QWaylandDecoration::QWaylandDecoration(QWindow *window, QWaylandShmBackingStore *backing_store)
-    : m_window(window)
-    , m_wayland_window(static_cast<QWaylandWindow *>(window->handle()))
-    , m_backing_store(backing_store)
-    , m_margins(3,30,3,3)
+
+QWaylandDecoration::QWaylandDecoration(QWaylandWindow *window)
+    : m_window(window->window())
+    , m_wayland_window(window)
+    , m_margins(3,27,3,3)
     , m_hasSetCursor(false)
     , m_mouseButtons(Qt::NoButton)
+    , m_backgroundColor(90, 90, 100)
 {
     m_wayland_window->setDecoration(this);
     QTextOption option(Qt::AlignHCenter | Qt::AlignVCenter);
@@ -69,22 +69,22 @@ QWaylandDecoration::~QWaylandDecoration()
     m_wayland_window->setDecoration(0);
 }
 
-void QWaylandDecoration::paintDecoration()
+void QWaylandDecoration::paint(QPaintDevice *device)
 {
-    QRect surfaceRect(QPoint(), m_backing_store->entireSurface()->size());
+    QRect surfaceRect(QPoint(), window()->frameGeometry().size());
     QRect clips[] =
     {
-        QRect(0, 0, surfaceRect.width(), m_margins.top()),
-        QRect(0, surfaceRect.height() - m_margins.bottom(), surfaceRect.width(), m_margins.bottom()),
-        QRect(0, m_margins.top(), m_margins.left(), surfaceRect.height() - m_margins.top() - m_margins.bottom()),
-        QRect(surfaceRect.width() - m_margins.right(), m_margins.top(), m_margins.left(), surfaceRect.height() - m_margins.top() - m_margins.bottom())
+        QRect(0, 0, surfaceRect.width(), margins().top()),
+        QRect(0, surfaceRect.height() - margins().bottom(), surfaceRect.width(), margins().bottom()),
+        QRect(0, margins().top(), margins().left(), surfaceRect.height() - margins().top() - margins().bottom()),
+        QRect(surfaceRect.width() - margins().right(), margins().top(), margins().left(), surfaceRect.height() - margins().top() - margins().bottom())
     };
     QRect top = clips[0];
-    QPainter p(m_backing_store->entireSurface());
+    QPainter p(device);
     p.setRenderHint(QPainter::Antialiasing);
     QPoint gradCenter(top.center()+ QPoint(30,60));
     QRadialGradient grad(gradCenter, top.width() / 2, gradCenter);
-    QColor base(90, 90, 100);
+    QColor base(backgroundColor());
     grad.setColorAt(1, base);
     grad.setColorAt(0, base.lighter(123));
     QPainterPath roundedRect;
@@ -97,7 +97,7 @@ void QWaylandDecoration::paintDecoration()
     }
 
 
-    QString windowTitleText = m_window->windowTitle();
+    QString windowTitleText = window()->windowTitle();
     if (!windowTitleText.isEmpty()) {
         if (m_windowTitle.text() != windowTitleText) {
             m_windowTitle.setText(windowTitleText);
@@ -114,30 +114,68 @@ void QWaylandDecoration::paintDecoration()
         p.drawStaticText(windowTitlePoint,m_windowTitle);
         p.restore();
     }
+
+    QRectF rect(closeButtonRect());
+    QPen pen(QColor(0xee,0xee,0xee));
+    p.setPen(pen);
+    p.drawRect(rect);
+
+    float crossSize = rect.height() / 2.f;
+    QPointF c(rect.center());
+    QRectF cross(c.x() - crossSize / 2.f, c.y() - crossSize / 2.f, crossSize, crossSize);
+
+    p.save();
+    pen.setWidth(2);
+    p.setPen(pen);
+    p.drawLine(cross.topLeft(), cross.bottomRight());
+    p.drawLine(cross.bottomLeft(), cross.topRight());
+    p.restore();
+
+
+    rect = maximizeButtonRect();
+    p.drawRect(rect);
+}
+
+QRectF QWaylandDecoration::closeButtonRect() const
+{
+    const float width = 25;
+    const float margin = 5;
+    return QRectF(window()->frameGeometry().width() - width - margin, margin, width, margins().top() - 2 * margin);
 }
 
-void QWaylandDecoration::handleMouse(QWaylandInputDevice *inputDevice, const QPointF &local, const QPointF &global, Qt::MouseButtons b, Qt::KeyboardModifiers mods)
+QRectF QWaylandDecoration::maximizeButtonRect() const
+{
+    const float width = 25;
+    const float margin = 5;
+    return QRectF(window()->frameGeometry().width() - 2 * width - 2 * margin, margin, width, margins().top() - 2 * margin);
+}
+
+bool QWaylandDecoration::handleMouse(QWaylandInputDevice *inputDevice, const QPointF &local, const QPointF &global, Qt::MouseButtons b, Qt::KeyboardModifiers mods)
 
 {
     Q_UNUSED(global);
     //figure out what area mouse is in
     if (local.y() <= m_margins.top()) {
         processMouseTop(inputDevice,local,b,mods);
-    } else if (local.y() > m_window->height() - m_margins.bottom()) {
+    } else if (local.y() > m_window->height() - m_margins.bottom() + m_margins.top()) {
         processMouseBottom(inputDevice,local,b,mods);
     } else if (local.x() <= m_margins.left()) {
         processMouseLeft(inputDevice,local,b,mods);
-    } else if (local.x() > m_window->width() - m_margins.right()) {
+    } else if (local.x() > m_window->width() - m_margins.right() + m_margins.left()) {
         processMouseRight(inputDevice,local,b,mods);
     } else {
         restoreMouseCursor();
+        return false;
     }
+
     m_mouseButtons = b;
+    return true;
 }
 
 void QWaylandDecoration::restoreMouseCursor()
 {
     if (m_hasSetCursor) {
+        overrideCursor(Qt::ArrowCursor);
         QGuiApplication::restoreOverrideCursor();
         m_hasSetCursor = false;
     }
@@ -167,12 +205,22 @@ void QWaylandDecoration::startMove(QWaylandInputDevice *inputDevice, Qt::MouseBu
 void QWaylandDecoration::processMouseTop(QWaylandInputDevice *inputDevice, const QPointF &local, Qt::MouseButtons b, Qt::KeyboardModifiers mods)
 {
     Q_UNUSED(mods);
-    if (local.y() <= m_margins.bottom()) {
+    if (closeButtonRect().contains(local)) {
+        if (isLeftClicked(b)) {
+            QCoreApplication::quit();
+        }
+    } else if (maximizeButtonRect().contains(local)) {
+        if (isLeftClicked(b)) {
+            m_wayland_window->shellSurface()->toggleMaximize();
+        }
+    } else if (local.y() <= m_margins.bottom()) {
         if (local.x() <= margins().left()) {
             //top left bit
+            overrideCursor(Qt::SizeFDiagCursor);
             startResize(inputDevice,WL_SHELL_SURFACE_RESIZE_TOP_LEFT,b);
         } else if (local.x() > m_window->width() - margins().right()) {
             //top right bit
+            overrideCursor(Qt::SizeBDiagCursor);
             startResize(inputDevice,WL_SHELL_SURFACE_RESIZE_TOP_RIGHT,b);
         } else {
             //top reszie bit
@@ -191,10 +239,12 @@ void QWaylandDecoration::processMouseBottom(QWaylandInputDevice *inputDevice, co
     Q_UNUSED(mods);
     if (local.x() <= margins().left()) {
         //bottom left bit
+        overrideCursor(Qt::SizeBDiagCursor);
         startResize(inputDevice, WL_SHELL_SURFACE_RESIZE_BOTTOM_LEFT,b);
     } else if (local.x() > m_window->width() - margins().right()) {
         //bottom right bit
-            startResize(inputDevice, WL_SHELL_SURFACE_RESIZE_BOTTOM_RIGHT,b);
+        overrideCursor(Qt::SizeFDiagCursor);
+        startResize(inputDevice, WL_SHELL_SURFACE_RESIZE_BOTTOM_RIGHT,b);
     } else {
         //bottom bit
         overrideCursor(Qt::SplitVCursor);
@@ -231,3 +281,8 @@ bool QWaylandDecoration::isLeftReleased(Qt::MouseButtons newMouseButtonState)
         return true;
     return false;
 }
+
+void QWaylandDecoration::setBackgroundColor(const QColor &c)
+{
+    m_backgroundColor = c;
+}
diff --git a/src/plugins/platforms/wayland/qwaylanddecoration.h b/src/plugins/platforms/wayland/qwaylanddecoration.h
index 6098013..e88ebd9 100644
--- a/src/plugins/platforms/wayland/qwaylanddecoration.h
+++ b/src/plugins/platforms/wayland/qwaylanddecoration.h
@@ -46,7 +46,7 @@
 #include <QtCore/QPointF>
 #include <QtGui/QGuiApplication>
 #include <QtGui/QCursor>
-#include <QtGui/QImage>
+#include <QtGui/QColor>
 #include <QtGui/QStaticText>
 
 #include <wayland-client.h>
@@ -58,22 +58,32 @@ class QPaintDevice;
 class QPainter;
 class QEvent;
 class QWaylandWindow;
-class QWaylandShmBackingStore;
 class QWaylandInputDevice;
 
 class QWaylandDecoration
 {
 public:
-    QWaylandDecoration(QWindow *window, QWaylandShmBackingStore *backing_store);
-    ~QWaylandDecoration();
-    void paintDecoration();
-    void handleMouse(QWaylandInputDevice *inputDevice, const QPointF &local, const QPointF &global,Qt::MouseButtons b,Qt::KeyboardModifiers mods);
+    QWaylandDecoration(QWaylandWindow *window);
+    virtual ~QWaylandDecoration();
+
+    virtual void paintDecoration() = 0;
+
+    bool handleMouse(QWaylandInputDevice *inputDevice, const QPointF &local, const QPointF &global,Qt::MouseButtons b,Qt::KeyboardModifiers mods);
     void restoreMouseCursor();
     bool inMouseButtonPressedState() const;
 
     void startResize(QWaylandInputDevice *inputDevice,enum wl_shell_surface_resize resize, Qt::MouseButtons buttons);
     void startMove(QWaylandInputDevice *inputDevice, Qt::MouseButtons buttons);
     QMargins margins() const;
+    QWindow *window() const;
+    QWaylandWindow *waylandWindow() const;
+
+    void setBackgroundColor(const QColor &c);
+    inline QColor backgroundColor() const;
+
+protected:
+    void paint(QPaintDevice *device);
+
 private:
     void overrideCursor(Qt::CursorShape shape);
 
@@ -85,18 +95,19 @@ private:
     bool isLeftClicked(Qt::MouseButtons newMouseButtonState);
     bool isLeftReleased(Qt::MouseButtons newMouseButtonState);
 
+    QRectF closeButtonRect() const;
+    QRectF maximizeButtonRect() const;
+
     QWindow *m_window;
     QWaylandWindow *m_wayland_window;
-    QWaylandShmBackingStore *m_backing_store;
 
     QMargins m_margins;
     bool m_hasSetCursor;
     Qt::CursorShape m_cursorShape;
     Qt::MouseButtons m_mouseButtons;
 
+    QColor m_backgroundColor;
     QStaticText m_windowTitle;
-
-    QImage m_borderImage;
 };
 
 inline QMargins QWaylandDecoration::margins() const
@@ -104,6 +115,21 @@ inline QMargins QWaylandDecoration::margins() const
     return m_margins;
 }
 
+inline QWindow *QWaylandDecoration::window() const
+{
+    return m_window;
+}
+
+inline QWaylandWindow *QWaylandDecoration::waylandWindow() const
+{
+    return m_wayland_window;
+}
+
+inline QColor QWaylandDecoration::backgroundColor() const
+{
+    return m_backgroundColor;
+}
+
 inline void QWaylandDecoration::overrideCursor(Qt::CursorShape shape)
 {
     if (m_hasSetCursor) {
diff --git a/src/plugins/platforms/wayland/qwaylanddisplay.cpp b/src/plugins/platforms/wayland/qwaylanddisplay.cpp
index 4b01f3e..f921946 100644
--- a/src/plugins/platforms/wayland/qwaylanddisplay.cpp
+++ b/src/plugins/platforms/wayland/qwaylanddisplay.cpp
@@ -177,10 +177,21 @@ void QWaylandDisplay::createNewScreen(struct wl_output *output)
     mScreens.append(waylandScreen);
 }
 
+void QWaylandDisplay::scheduleRedraw(QWaylandWindow *window)
+{
+    if (!mWindows.contains(window))
+        mWindows << window;
+}
+
 void QWaylandDisplay::flushRequests()
 {
     wl_display_dispatch_pending(mDisplay);
     wl_display_flush(mDisplay);
+
+    foreach (QWaylandWindow *w, mWindows) {
+        w->redraw();
+    }
+    mWindows.clear();
 }
 
 void QWaylandDisplay::readEvents()
diff --git a/src/plugins/platforms/wayland/qwaylanddisplay.h b/src/plugins/platforms/wayland/qwaylanddisplay.h
index 5d2374a..0e55118 100644
--- a/src/plugins/platforms/wayland/qwaylanddisplay.h
+++ b/src/plugins/platforms/wayland/qwaylanddisplay.h
@@ -64,6 +64,7 @@ class QWaylandSubSurfaceExtension;
 class QWaylandOutputExtension;
 class QWaylandTouchExtension;
 class QWaylandQtKeyExtension;
+class QWaylandWindow;
 
 typedef void (*RegistryListener)(void *data,
                                  struct wl_registry *registry,
@@ -92,7 +93,7 @@ public:
     QWaylandWindowManagerIntegration *windowManagerIntegration();
 #endif
 
-    void setCursor(wl_surface *surface, int32_t x, int32_t y);
+    void setCursor(struct wl_buffer *buffer, struct wl_cursor_image *image);
 
     struct wl_display *wl_display() const { return mDisplay; }
     struct wl_registry *wl_registry() const { return mRegistry; }
@@ -122,6 +123,8 @@ public:
 
     void forceRoundTrip();
 
+    void scheduleRedraw(QWaylandWindow *window);
+
 public slots:
     void createNewScreen(struct wl_output *output);
     void readEvents();
@@ -147,6 +150,7 @@ private:
     QList<QPlatformScreen *> mScreens;
     QList<QWaylandInputDevice *> mInputDevices;
     QList<Listener> mRegistryListeners;
+    QList<QWaylandWindow *> mWindows;
     QWaylandInputDevice *mLastKeyboardFocusInputDevice;
     QWaylandDataDeviceManager *mDndSelectionHandler;
     QWaylandSurfaceExtension *mWindowExtension;
diff --git a/src/plugins/platforms/wayland/qwaylandinputdevice.cpp b/src/plugins/platforms/wayland/qwaylandinputdevice.cpp
index 1dcf656..7eb6234 100644
--- a/src/plugins/platforms/wayland/qwaylandinputdevice.cpp
+++ b/src/plugins/platforms/wayland/qwaylandinputdevice.cpp
@@ -54,6 +54,8 @@
 #include <unistd.h>
 #include <fcntl.h>
 
+#include <wayland-cursor.h>
+
 #include <QtGui/QGuiApplication>
 
 #ifndef QT_NO_WAYLAND_XKB
@@ -158,6 +160,7 @@ void QWaylandInputDevice::seat_capabilities(void *data, struct wl_seat *seat, ui
 
     if (caps & WL_SEAT_CAPABILITY_POINTER) {
         self->mDeviceInterfaces.pointer = wl_seat_get_pointer(seat);
+        self->mDeviceInterfaces.pointerSurface = self->mQDisplay->createSurface(self);
         wl_pointer_add_listener(self->mDeviceInterfaces.pointer, &pointerListener, self);
     }
 
@@ -198,15 +201,20 @@ void QWaylandInputDevice::removeMouseButtonFromState(Qt::MouseButton button)
     mButtons = mButtons & !button;
 }
 
-void QWaylandInputDevice::setCursor(wl_surface *surface, int x, int y)
+void QWaylandInputDevice::setCursor(struct wl_buffer *buffer, struct wl_cursor_image *image)
 {
-    if (mCaps & WL_SEAT_CAPABILITY_POINTER)
-        wl_pointer_set_cursor(mDeviceInterfaces.pointer, mTime, surface, x, y);
+    if (mCaps & WL_SEAT_CAPABILITY_POINTER) {
+        wl_pointer_set_cursor(mDeviceInterfaces.pointer, mEnterSerial, mDeviceInterfaces.pointerSurface,
+                              image->hotspot_x, image->hotspot_y);
+        wl_surface_attach(mDeviceInterfaces.pointerSurface, buffer, 0, 0);
+        wl_surface_damage(mDeviceInterfaces.pointerSurface, 0, 0, image->width, image->height);
+        wl_surface_commit(mDeviceInterfaces.pointerSurface);
+    }
 }
 
 void QWaylandInputDevice::pointer_enter(void *data,
                                         struct wl_pointer *pointer,
-                                        uint32_t time, struct wl_surface *surface,
+                                        uint32_t serial, struct wl_surface *surface,
                                         wl_fixed_t sx, wl_fixed_t sy)
 {
     Q_UNUSED(pointer);
@@ -217,11 +225,21 @@ void QWaylandInputDevice::pointer_enter(void *data,
     if (!surface)
         return;
 
+    QGuiApplication::setOverrideCursor(QCursor(Qt::ArrowCursor));
+
     QWaylandWindow *window = (QWaylandWindow *) wl_surface_get_user_data(surface);
     window->handleMouseEnter();
+    window->handleMouse(inputDevice,
+                        inputDevice->mTime,
+                        inputDevice->mSurfacePos,
+                        inputDevice->mGlobalPos,
+                        inputDevice->mButtons,
+                        Qt::NoModifier);
     inputDevice->mPointerFocus = window;
 
-    inputDevice->mTime = time;
+    inputDevice->mTime = QWaylandDisplay::currentTimeMillisec();
+    inputDevice->mSerial = serial;
+    inputDevice->mEnterSerial = serial;
 }
 
 void QWaylandInputDevice::pointer_leave(void *data,
@@ -236,6 +254,8 @@ void QWaylandInputDevice::pointer_leave(void *data,
     if (!surface)
         return;
 
+    QGuiApplication::restoreOverrideCursor();
+
     QWaylandWindow *window = (QWaylandWindow *) wl_surface_get_user_data(surface);
     window->handleMouseLeave();
     inputDevice->mPointerFocus = 0;
@@ -289,7 +309,6 @@ void QWaylandInputDevice::pointer_button(void *data,
     QWaylandWindow *window = inputDevice->mPointerFocus;
     Qt::MouseButton qt_button;
 
-
     // translate from kernel (input.h) 'button' to corresponding Qt:MouseButton.
     // The range of mouse values is 0x110 <= mouse_button < 0x120, the first Joystick button.
     switch (button) {
@@ -318,6 +337,7 @@ void QWaylandInputDevice::pointer_button(void *data,
         inputDevice->mButtons &= ~qt_button;
 
     inputDevice->mTime = time;
+    inputDevice->mSerial = serial;
 
     if (window) {
         window->handleMouse(inputDevice,
diff --git a/src/plugins/platforms/wayland/qwaylandinputdevice.h b/src/plugins/platforms/wayland/qwaylandinputdevice.h
index 71bb038..7163438 100644
--- a/src/plugins/platforms/wayland/qwaylandinputdevice.h
+++ b/src/plugins/platforms/wayland/qwaylandinputdevice.h
@@ -72,7 +72,7 @@ public:
 
     struct wl_seat *wl_seat() const { return mSeat; }
 
-    void setCursor(wl_surface *surface, int x, int y);
+    void setCursor(struct wl_buffer *buffer, struct wl_cursor_image *image);
     void handleWindowDestroyed(QWaylandWindow *window);
 
     void setTransferDevice(struct wl_data_device *device);
@@ -80,6 +80,8 @@ public:
 
     void removeMouseButtonFromState(Qt::MouseButton button);
 
+    uint32_t serial() const;
+
 private:
     QWaylandDisplay *mQDisplay;
     struct wl_display *mDisplay;
@@ -89,6 +91,7 @@ private:
 
     struct {
         struct wl_pointer *pointer;
+        struct wl_surface *pointerSurface;
         struct wl_keyboard *keyboard;
         struct wl_touch *touch;
     } mDeviceInterfaces;
@@ -102,6 +105,8 @@ private:
     QPointF mSurfacePos;
     QPointF mGlobalPos;
     uint32_t mTime;
+    uint32_t mSerial;
+    uint32_t mEnterSerial;
 
     static const struct wl_seat_listener seatListener;
 
@@ -113,7 +118,7 @@ private:
 
     static void pointer_enter(void *data,
                               struct wl_pointer *pointer,
-                              uint32_t time, struct wl_surface *surface,
+                              uint32_t serial, struct wl_surface *surface,
                               wl_fixed_t sx, wl_fixed_t sy);
     static void pointer_leave(void *data,
                               struct wl_pointer *pointer,
@@ -202,6 +207,11 @@ private:
     friend class QWaylandQtKeyExtension;
 };
 
+inline uint32_t QWaylandInputDevice::serial() const
+{
+    return mSerial;
+}
+
 QT_END_NAMESPACE
 
 #endif
diff --git a/src/plugins/platforms/wayland/qwaylandshellsurface.cpp b/src/plugins/platforms/wayland/qwaylandshellsurface.cpp
index f9a3ee5..724fe4a 100644
--- a/src/plugins/platforms/wayland/qwaylandshellsurface.cpp
+++ b/src/plugins/platforms/wayland/qwaylandshellsurface.cpp
@@ -45,12 +45,14 @@
 #include "qwaylandwindow.h"
 #include "qwaylandinputdevice.h"
 #include "qwaylanddecoration.h"
+#include "qwaylandscreen.h"
 
 #include <QtCore/QDebug>
 
 QWaylandShellSurface::QWaylandShellSurface(struct wl_shell_surface *shell_surface, QWaylandWindow *window)
     : m_shell_surface(shell_surface)
     , m_window(window)
+    , m_maximized(false)
 {
     wl_shell_surface_add_listener(m_shell_surface,&m_shell_surface_listener,this);
 }
@@ -63,7 +65,7 @@ QWaylandShellSurface::~QWaylandShellSurface()
 void QWaylandShellSurface::resize(QWaylandInputDevice *inputDevice, enum wl_shell_surface_resize edges)
 {
     wl_shell_surface_resize(m_shell_surface,inputDevice->wl_seat(),
-                            QWaylandDisplay::currentTimeMillisec(),
+                            inputDevice->serial(),
                             edges);
 }
 
@@ -71,7 +73,20 @@ void QWaylandShellSurface::move(QWaylandInputDevice *inputDevice)
 {
     wl_shell_surface_move(m_shell_surface,
                           inputDevice->wl_seat(),
-                          QWaylandDisplay::currentTimeMillisec());
+                          inputDevice->serial());
+}
+
+void QWaylandShellSurface::toggleMaximize()
+{
+    if (!m_maximized) {
+        m_savedSize = m_window->window()->frameGeometry().size();
+        wl_shell_surface_set_maximized(m_shell_surface, 0);
+    } else {
+        wl_shell_surface_set_toplevel(m_shell_surface);
+        m_window->configure(0, m_savedSize.width(), m_savedSize.height());
+    }
+
+    m_maximized = !m_maximized;
 }
 
 void QWaylandShellSurface::setTopLevel()
diff --git a/src/plugins/platforms/wayland/qwaylandshellsurface.h b/src/plugins/platforms/wayland/qwaylandshellsurface.h
index 4772e69..16d1f5b 100644
--- a/src/plugins/platforms/wayland/qwaylandshellsurface.h
+++ b/src/plugins/platforms/wayland/qwaylandshellsurface.h
@@ -58,6 +58,7 @@ public:
 
     void resize(QWaylandInputDevice *inputDevice, enum wl_shell_surface_resize edges);
     void move(QWaylandInputDevice *inputDevice);
+    void toggleMaximize();
 
     void setTopLevel();
     void updateTransientParent(QWindow *parent);
@@ -69,6 +70,8 @@ public:
 private:
     struct wl_shell_surface *m_shell_surface;
     QWaylandWindow *m_window;
+    bool m_maximized;
+    QSize m_savedSize;
 
     static void ping(void *data,
                      struct wl_shell_surface *wl_shell_surface,
diff --git a/src/plugins/platforms/wayland/qwaylandshmbackingstore.cpp b/src/plugins/platforms/wayland/qwaylandshmbackingstore.cpp
index bd6c33d..981f806 100644
--- a/src/plugins/platforms/wayland/qwaylandshmbackingstore.cpp
+++ b/src/plugins/platforms/wayland/qwaylandshmbackingstore.cpp
@@ -134,9 +134,9 @@ QWaylandShmBackingStore::QWaylandShmBackingStore(QWindow *window)
     , mBackBuffer(0)
     , mFrontBufferIsDirty(false)
     , mPainting(false)
-    , mWindowDecoration(0)
     , mFrameCallback(0)
 {
+
 }
 
 QWaylandShmBackingStore::~QWaylandShmBackingStore()
@@ -155,9 +155,9 @@ QWaylandShmBackingStore::~QWaylandShmBackingStore()
 
 QPaintDevice *QWaylandShmBackingStore::paintDevice()
 {
-    if (!mWindowDecoration)
+    if (!windowDecoration())
         return mBackBuffer->image();
-    return mBackBuffer->imageInsideMargins(mWindowDecoration->margins());
+    return mBackBuffer->imageInsideMargins(windowDecorationMargins());
 }
 
 void QWaylandShmBackingStore::beginPaint(const QRegion &)
@@ -180,30 +180,8 @@ void QWaylandShmBackingStore::endPaint()
 
 void QWaylandShmBackingStore::ensureSize()
 {
-    bool decoration = false;
-    switch (window()->windowType()) {
-        case Qt::Window:
-    case Qt::Widget:
-    case Qt::Dialog:
-    case Qt::Tool:
-    case Qt::Drawer:
-        decoration = true;
-        break;
-    default:
-        break;
-    }
-    if (window()->windowFlags() & Qt::FramelessWindowHint) {
-        decoration = false;
-    }
-
-    if (decoration) {
-        if (!mWindowDecoration) {
-            mWindowDecoration = new QWaylandDecoration(window(), this);
-        }
-    } else {
-        delete mWindowDecoration;
-        mWindowDecoration = 0;
-    }
+    waylandWindow()->setBackingStore(this);
+    waylandWindow()->createDecoration();
     resize(mRequestedSize);
 }
 
@@ -224,16 +202,23 @@ void QWaylandShmBackingStore::flush(QWindow *window, const QRegion &region, cons
     wl_callback_add_listener(mFrameCallback,&frameCallbackListener,this);
     QMargins margins = windowDecorationMargins();
 
+    bool damageAll = false;
     if (waylandWindow()->attached() != mFrontBuffer) {
         delete waylandWindow()->attached();
-        waylandWindow()->attach(mFrontBuffer);
+        waylandWindow()->attachOffset(mFrontBuffer);
+        damageAll = true;
     }
 
-    QVector<QRect> rects = region.rects();
-    for (int i = 0; i < rects.size(); i++) {
-        QRect rect = rects.at(i);
-        rect.translate(margins.left(),margins.top());
-        waylandWindow()->damage(rect);
+    if (damageAll) {
+        //need to damage it all, otherwise the attach offset may screw up
+        waylandWindow()->damage(QRect(QPoint(0,0),mFrontBuffer->size()));
+    } else {
+        QVector<QRect> rects = region.rects();
+        for (int i = 0; i < rects.size(); i++) {
+            QRect rect = rects.at(i);
+            rect.translate(margins.left(),margins.top());
+            waylandWindow()->damage(rect);
+        }
     }
     mFrontBufferIsDirty = false;
 }
@@ -245,7 +230,6 @@ void QWaylandShmBackingStore::resize(const QSize &size, const QRegion &)
 
 void QWaylandShmBackingStore::resize(const QSize &size)
 {
-
     QMargins margins = windowDecorationMargins();
     QSize sizeWithMargins = size + QSize(margins.left()+margins.right(),margins.top()+margins.bottom());
 
@@ -260,8 +244,8 @@ void QWaylandShmBackingStore::resize(const QSize &size)
 
     mBackBuffer = new QWaylandShmBuffer(mDisplay, sizeWithMargins, format);
 
-    if (mWindowDecoration)
-        mWindowDecoration->paintDecoration();
+    if (windowDecoration())
+        windowDecoration()->paintDecoration();
 }
 
 QImage *QWaylandShmBackingStore::entireSurface() const
@@ -276,14 +260,16 @@ void QWaylandShmBackingStore::done(void *data, wl_callback *callback, uint32_t t
             static_cast<QWaylandShmBackingStore *>(data);
     if (callback != self->mFrameCallback) // others, like QWaylandWindow, may trigger callbacks too
         return;
-    QWaylandWindow *window = self->waylandWindow();
+    QWaylandShmWindow *window = self->waylandWindow();
     wl_callback_destroy(self->mFrameCallback);
     self->mFrameCallback = 0;
+
     if (self->mFrontBuffer != window->attached()) {
         delete window->attached();
-        window->attach(self->mFrontBuffer);
     }
 
+    window->attachOffset(self->mFrontBuffer);
+
     if (self->mFrontBufferIsDirty && !self->mPainting) {
         self->mFrontBufferIsDirty = false;
         self->mFrameCallback = wl_surface_frame(window->wl_surface());
diff --git a/src/plugins/platforms/wayland/qwaylandshmbackingstore.h b/src/plugins/platforms/wayland/qwaylandshmbackingstore.h
index 4ed5874..1eadb5e 100644
--- a/src/plugins/platforms/wayland/qwaylandshmbackingstore.h
+++ b/src/plugins/platforms/wayland/qwaylandshmbackingstore.h
@@ -45,7 +45,7 @@
 #include "qwaylandbuffer.h"
 
 #include "qwaylanddecoration.h"
-#include "qwaylandwindow.h"
+#include "qwaylandshmwindow.h"
 
 #include <qpa/qplatformbackingstore.h>
 #include <QtGui/QImage>
@@ -84,11 +84,13 @@ public:
     void beginPaint(const QRegion &);
     void endPaint();
 
+    QWaylandDecoration *windowDecoration() const;
+
     QMargins windowDecorationMargins() const;
     QImage *entireSurface() const;
     void ensureSize();
 
-    QWaylandWindow *waylandWindow() const;
+    QWaylandShmWindow *waylandWindow() const;
     void iterateBuffer();
 
 private:
@@ -98,7 +100,6 @@ private:
     bool mFrontBufferIsDirty;
     bool mPainting;
 
-    QWaylandDecoration *mWindowDecoration;
     QSize mRequestedSize;
     Qt::WindowFlags mCurrentWindowFlags;
 
@@ -109,16 +110,21 @@ private:
     struct wl_callback *mFrameCallback;
 };
 
+inline QWaylandDecoration *QWaylandShmBackingStore::windowDecoration() const
+{
+    return waylandWindow()->decoration();
+}
+
 inline QMargins QWaylandShmBackingStore::windowDecorationMargins() const
 {
-    if (mWindowDecoration)
-        return mWindowDecoration->margins();
+    if (windowDecoration())
+        return windowDecoration()->margins();
     return QMargins();
 }
 
-inline QWaylandWindow *QWaylandShmBackingStore::waylandWindow() const
+inline QWaylandShmWindow *QWaylandShmBackingStore::waylandWindow() const
 {
-    return static_cast<QWaylandWindow *>(window()->handle());
+    return static_cast<QWaylandShmWindow *>(window()->handle());
 }
 
 QT_END_NAMESPACE
diff --git a/src/plugins/platforms/wayland/qwaylandshmdecoration.cpp b/src/plugins/platforms/wayland/qwaylandshmdecoration.cpp
new file mode 100644
index 0000000..6c93730
--- /dev/null
+++ b/src/plugins/platforms/wayland/qwaylandshmdecoration.cpp
@@ -0,0 +1,60 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qwaylandshmdecoration.h"
+
+#include "qwaylandshmwindow.h"
+#include "qwaylandshmbackingstore.h"
+
+QWaylandShmDecoration::QWaylandShmDecoration(QWaylandShmWindow *window)
+    : QWaylandDecoration(window)
+{
+
+}
+
+QWaylandShmDecoration::~QWaylandShmDecoration()
+{
+}
+
+void QWaylandShmDecoration::paintDecoration()
+{
+    paint(static_cast<QWaylandShmWindow *>(waylandWindow())->backingStore()->entireSurface());
+}
diff --git a/src/plugins/platforms/wayland/qwaylandshmdecoration.h b/src/plugins/platforms/wayland/qwaylandshmdecoration.h
new file mode 100644
index 0000000..4ff0da3
--- /dev/null
+++ b/src/plugins/platforms/wayland/qwaylandshmdecoration.h
@@ -0,0 +1,59 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3.0 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU General Public License version 3.0 requirements will be
+** met: http://www.gnu.org/copyleft/gpl.html.
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QWAYLANDSHMDECORATION_H
+#define QWAYLANDSHMDECORATION_H
+
+#include "qwaylanddecoration.h"
+
+class QWaylandShmWindow;
+
+class QWaylandShmDecoration : public QWaylandDecoration
+{
+public:
+    QWaylandShmDecoration(QWaylandShmWindow *window);
+    ~QWaylandShmDecoration();
+
+    void paintDecoration();
+
+};
+
+#endif // QWAYLANDSHMDECORATION_H
diff --git a/src/plugins/platforms/wayland/qwaylandshmwindow.cpp b/src/plugins/platforms/wayland/qwaylandshmwindow.cpp
index 165df50..b7ec9d2 100644
--- a/src/plugins/platforms/wayland/qwaylandshmwindow.cpp
+++ b/src/plugins/platforms/wayland/qwaylandshmwindow.cpp
@@ -42,6 +42,7 @@
 #include "qwaylandshmwindow.h"
 
 #include "qwaylandbuffer.h"
+#include "qwaylandshmdecoration.h"
 
 #include <QtCore/QVector>
 
@@ -49,6 +50,7 @@
 
 QWaylandShmWindow::QWaylandShmWindow(QWindow *window)
     : QWaylandWindow(window)
+    , mBackingStore(0)
 {
 }
 
@@ -62,3 +64,13 @@ QWaylandWindow::WindowType QWaylandShmWindow::windowType() const
     return QWaylandWindow::Shm;
 }
 
+void QWaylandShmWindow::setBackingStore(QWaylandShmBackingStore *backingStore)
+{
+    mBackingStore = backingStore;
+}
+
+void QWaylandShmWindow::createDecorationInstance()
+{
+    new QWaylandShmDecoration(this);
+}
+
diff --git a/src/plugins/platforms/wayland/qwaylandshmwindow.h b/src/plugins/platforms/wayland/qwaylandshmwindow.h
index 53b8096..ef5e5db 100644
--- a/src/plugins/platforms/wayland/qwaylandshmwindow.h
+++ b/src/plugins/platforms/wayland/qwaylandshmwindow.h
@@ -45,6 +45,8 @@
 #include "qwaylandwindow.h"
 #include <QtGui/QRegion>
 
+class QWaylandShmBackingStore;
+
 class QWaylandShmWindow : public QWaylandWindow
 {
 public:
@@ -53,6 +55,20 @@ public:
 
     WindowType windowType() const;
     QSurfaceFormat format() const { return QSurfaceFormat(); }
+
+    void setBackingStore(QWaylandShmBackingStore *backingStore);
+    QWaylandShmBackingStore *backingStore() const;
+
+protected:
+    void createDecorationInstance();
+
+private:
+    QWaylandShmBackingStore *mBackingStore;
 };
 
+inline QWaylandShmBackingStore *QWaylandShmWindow::backingStore() const
+{
+    return mBackingStore;
+}
+
 #endif // QWAYLANDSHMWINDOW_H
diff --git a/src/plugins/platforms/wayland/qwaylandwindow.cpp b/src/plugins/platforms/wayland/qwaylandwindow.cpp
index c07ae03..700eadc 100644
--- a/src/plugins/platforms/wayland/qwaylandwindow.cpp
+++ b/src/plugins/platforms/wayland/qwaylandwindow.cpp
@@ -148,6 +148,8 @@ void QWaylandWindow::setGeometry(const QRect &rect)
 
     if (shellSurface() && window()->transientParent())
         shellSurface()->updateTransientParent(window()->transientParent());
+
+    mDisplay->scheduleRedraw(this);
 }
 
 void QWaylandWindow::setVisible(bool visible)
@@ -195,19 +197,45 @@ void QWaylandWindow::configure(uint32_t edges, int32_t width, int32_t height)
     heightWithoutMargins = qMax(heightWithoutMargins, window()->minimumSize().height());
     QRect geometry = QRect(0,0,
                            widthWithoutMargins, heightWithoutMargins);
+
+    int x = 0;
+    int y = 0;
+    QSize size = this->geometry().size();
+    if (edges == WL_SHELL_SURFACE_RESIZE_LEFT || edges == WL_SHELL_SURFACE_RESIZE_BOTTOM_LEFT ||
+                                                 edges ==  WL_SHELL_SURFACE_RESIZE_TOP_LEFT) {
+        x = size.width() - geometry.width();
+    }
+    if (edges == WL_SHELL_SURFACE_RESIZE_TOP || edges == WL_SHELL_SURFACE_RESIZE_TOP_LEFT ||
+                                                edges == WL_SHELL_SURFACE_RESIZE_TOP_RIGHT) {
+        y = size.height() - geometry.height();
+    }
+    mOffset += QPoint(x, y);
+
     setGeometry(geometry);
     QWindowSystemInterface::handleGeometryChange(window(), geometry);
+    QWindowSystemInterface::flushWindowSystemEvents();
 }
 
-void QWaylandWindow::attach(QWaylandBuffer *buffer)
+void QWaylandWindow::redraw()
+{
+
+}
+
+void QWaylandWindow::attach(QWaylandBuffer *buffer, int x, int y)
 {
     mBuffer = buffer;
 
     if (window()->isVisible()) {
-        wl_surface_attach(mSurface, mBuffer->buffer(),0,0);
+        wl_surface_attach(mSurface, mBuffer->buffer(), x, y);
     }
 }
 
+void QWaylandWindow::attachOffset(QWaylandBuffer *buffer)
+{
+    attach(buffer, mOffset.x(), mOffset.y());
+    mOffset = QPoint();
+}
+
 QWaylandBuffer *QWaylandWindow::attached() const
 {
     return mBuffer;
@@ -310,6 +338,36 @@ void QWaylandWindow::setWindowFlags(Qt::WindowFlags flags)
         mExtendedWindow->setWindowFlags(flags);
 }
 
+bool QWaylandWindow::createDecoration()
+{
+    bool decoration = false;
+    switch (window()->windowType()) {
+        case Qt::Window:
+        case Qt::Widget:
+        case Qt::Dialog:
+        case Qt::Tool:
+        case Qt::Drawer:
+            decoration = true;
+            break;
+        default:
+            break;
+    }
+    if (window()->windowFlags() & Qt::FramelessWindowHint) {
+        decoration = false;
+    }
+
+    if (decoration) {
+        if (!mWindowDecoration) {
+            createDecorationInstance();
+        }
+    } else {
+        delete mWindowDecoration;
+        mWindowDecoration = 0;
+    }
+
+    return mWindowDecoration;
+}
+
 QWaylandDecoration *QWaylandWindow::decoration() const
 {
     return mWindowDecoration;
@@ -354,10 +412,8 @@ void QWaylandWindow::handleMouseLeave()
 
 void QWaylandWindow::handleMouseEventWithDecoration(QWaylandInputDevice *inputDevice, ulong timestamp, const QPointF &local, const QPointF &global, Qt::MouseButtons b, Qt::KeyboardModifiers mods)
 {
-    if (mWindowDecoration->inMouseButtonPressedState()) {
-        mWindowDecoration->handleMouse(inputDevice,local,global,b,mods);
+    if (mWindowDecoration->handleMouse(inputDevice,local,global,b,mods))
         return;
-    }
 
     QMargins marg = frameMargins();
     QRect windowRect(0 + marg.left(),
diff --git a/src/plugins/platforms/wayland/qwaylandwindow.h b/src/plugins/platforms/wayland/qwaylandwindow.h
index 1d35a8c..b10490c 100644
--- a/src/plugins/platforms/wayland/qwaylandwindow.h
+++ b/src/plugins/platforms/wayland/qwaylandwindow.h
@@ -78,8 +78,10 @@ public:
 
     void configure(uint32_t edges, int32_t width, int32_t height);
 
-    void attach(QWaylandBuffer *buffer);
+    void attach(QWaylandBuffer *buffer, int x, int y);
+    void attachOffset(QWaylandBuffer *buffer);
     QWaylandBuffer *attached() const;
+    QPoint attachOffset() const;
 
     void damage(const QRect &rect);
 
@@ -113,7 +115,14 @@ public:
                      Qt::KeyboardModifiers mods);
     void handleMouseEnter();
     void handleMouseLeave();
+
+    bool createDecoration();
+
+    virtual void redraw();
+
 protected:
+    virtual void createDecorationInstance() {}
+
     QWaylandDisplay *mDisplay;
     struct wl_surface *mSurface;
     QWaylandShellSurface *mShellSurface;
@@ -131,6 +140,7 @@ protected:
     QWaitCondition mFrameSyncWait;
 
     bool mSentInitialResize;
+    QPoint mOffset;
 
 private:
     void handleMouseEventWithDecoration(QWaylandInputDevice *inputDevice,
@@ -145,5 +155,10 @@ private:
 
 };
 
+inline QPoint QWaylandWindow::attachOffset() const
+{
+    return mOffset;
+}
+
 
 #endif // QWAYLANDWINDOW_H
diff --git a/src/plugins/platforms/wayland/wayland.pro b/src/plugins/platforms/wayland/wayland.pro
index 6639feb..a912081 100644
--- a/src/plugins/platforms/wayland/wayland.pro
+++ b/src/plugins/platforms/wayland/wayland.pro
@@ -30,7 +30,8 @@ SOURCES =   main.cpp \
             qwaylandtouch.cpp \
             qwaylandqtkey.cpp \
             $$PWD/../../../shared/qwaylandmimehelper.cpp \
-            qwaylanddecoration.cpp
+            qwaylanddecoration.cpp \
+            qwaylandshmdecoration.cpp
 
 HEADERS =   qwaylandintegration.h \
             qwaylandnativeinterface.h \
@@ -54,7 +55,8 @@ HEADERS =   qwaylandintegration.h \
             qwaylandtouch.h \
             qwaylandqtkey.h \
             $$PWD/../../../shared/qwaylandmimehelper.h \
-            qwaylanddecoration.h
+            qwaylanddecoration.h \
+            qwaylandshmdecoration.h
 
 DEFINES += Q_PLATFORM_WAYLAND
 
@@ -81,9 +83,9 @@ OTHER_FILES += wayland.json
 INCLUDEPATH += $$PWD/../../../shared
 
 !contains(QT_CONFIG, no-pkg-config) {
-    PKGCONFIG += wayland-client
+    PKGCONFIG += wayland-client wayland-cursor
 } else {
-    LIBS += -lwayland-client
+    LIBS += -lwayland-client -lwayland-cursor
 }
 
 include ($$PWD/gl_integration/gl_integration.pri)
