#! /bin/bash
#    Copyright (c) 2012, 2013, 2014 nerdopolis (or n3rdopolis) <bluescreen_avenger@verzion.net>
#
#    This file is part of RebeccaBlackLinux.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

#This script is the WaylandLoginManager it handles a graphical login for the user, and allows the user to start multiple types of Wayland sessions, specified in wesession files, and it supports autologin, mounting of ecryptfs home directories, and user switching. It supports watching the active session until it fails, so that it swiches back to the needed TTY for the user.

#The main server it displays on is refered to as the loginmanagerdisplay. it runs as non root, as well as the zenity dialogs

#It depends on zenity and expect

#as well as:
#/usr/bin/wlm_ui
  #a helper script for exporting WLM_LD_LIBRARY_PATH as LD_LIBRARY_PATH for starting UI processess as a non root user, while this script runs as root. Because it uses sudo to start it as the specific user, which drops LD_LIBRARY_PATH.
#/opt/bin/weston-display-server
  #which is moved from /opt/bin/weston . /opt/bin/weston needs to be redirected to /opt/bin/weston-display-server because of weston-launch which is described later
#/opt/bin/weston-launch
  #Needs to be patched to NOT drop the environment variables, and patched to give access to users of the plugdev group, instead of the weston-launch group.
#/usr/bin/westonlaunchcaller 
  #Should be symlinked to /opt/bin/weston . This is needed to replace some functionality for weston-launch. it allows weston-launch to handle the execution of custom Wayland servers specified in /etc/waylandservers . It handles the resetting of environment variables, and it sends commands back to the waylandloginmanager FIFO to notify it of failure, to switch back to the loginmanager display tty.
  #/usr/bin/westonlaunchcaller makes it so that if the second argument passed to weston-launch (past the -- separator), the first argument is treated as the custom server, and then it must be in /etc/waylandservers
  #it also handles the environment file, which is documented within /usr/share/wsession/aboutwsessions.txt
#/etc/waylandloginmanager.conf
  #Otherwise it uses /etc/lightdm/lightdm.conf . the only supported key is 'autologin-user=$AUTOLOGINUSER', and it usually takes it from /etc/lightdm/lightdm.conf at first run. It only uses /etc/waylandloginmanager.conf, as another init script can cause the lightdm config to drop the configured autologin user on an unsafe shutdown
#/usr/libexec/wayland_login_helpers/*
  #These scripts are small utilities that send the approriate commands to the waylandloginmanager's FIFO. They need to be configured in the launchers of /etc/loginmanagerdisplay/.config/weston.ini. It's how the user interacts with the waylandloginmanager on the loginmanagerdisplay (other then the zenity dialogs)
  #These are optional as the waylandloginmanager displays a selection list with the same commands as well
#/etc/loginmanagerdisplay/.config/weston.ini
  #Configuration for the loginmanagerdisplay. This should add the launchers in /usr/lib/wayland_login_helpers to the launcher bar, which send commands to the FIFO for weston, or at least prevent the default terminal icon from appearing in the toolbar for security reasons.
  #The mainform makes this reqirement optional
#/usr/share/wsessions.d/*
  #These are .desktop files, (and .environment files as well) which describe how to start different Wayland servers or sessions
  #These files are documented in /usr/share/wsession/aboutwsessions.txt

#Log Files:
  #/var/log/waylandloginmanager : this is the main log for the waylandloginmanager
  #/var/log/waylandserver.log : This is the log file for the Weston server that is the loginmanagerdisplay
  #~/waylandserver.log : This is where all wayland servers get logged as the run as the user.

#Runtime Files:
  #/run/waylandloginmanager/usrbinwaylandloginmanager.lock: (the file name is generated by the path that this script is in, removing the slashes). this prevents two instances of the waylandloginmanager from starting. 
    #It is a symlink to /proc/$$/cmdline (where $$ is the pid of the waylandloginmanager). It is checked in two different ways to protect against a race condition
  #/run/waylandloginmanager/loginmanager_register : Only root can write to this FIFO to register sessions, and no one can read it (except root). Functions registering sessions must first write to this FIFO, and then send the RegisterSession command to the loginmanager_control FIFO
  #/run/waylandloginmanager/loginmanager_control : All users have write access, but and no one can read it, except the FIFOREADERUSER service account. A process running as PROBETESTUSER reads the data getting send to it, and filters out only valid commands to get sent to loginmanager_listener
  #/run/waylandloginmanager/loginmanager_listener : Only root has write access to it, and no one has read access to it (except root). Supported commands:
      #Switch : calls up a switch user dialog on the loginmanagerdisplay, switching to the tty (see documentation for function SwitchUserDialog)
      #Change : switches to the tty the loginmanagerdisplay is on 
      #Info : calls up a help dialog for the user on the loginmanagerdisplay (see documentation for function ShowInfo)
      #Leave : calls up a dialog with shutdown/restart/supend options on the loginmanagerdisplay (see documentation for function LeavePrompt)
      #Login : Starts the login process (see documentation for function GetUserCredentials)
      #RegisterSession : Tells the waylandloginmanager to read from the loginmanager_register FIFO. When this is called the process must be attempting to write to the loginmanager_register already. If there is nothing being written in the short .01 second timeout, it is ignored. (see documentation for function RegisterSession)

#Create the waylandloginmanager folder in /run for FIFOs and lockfiles
mkdir -p /run/waylandloginmanager

#Detect another instance, by creating a testing a lockfile, which is a symlink to /proc/pid/cmdline, and making sure the second line of /proc/pid/cmdline matches (as it's the path to the script).
SCRIPTPATH=$(readlink -f "$0")
SCRIPTNAME=$(echo "$SCRIPTPATH" | sed 's\/\\g')
LOCKSCRIPT=$(readlink -f "$(strings "/run/waylandloginmanager/$SCRIPTNAME.lock" | sed -n 2p)" )
if [[ "$SCRIPTPATH" != "$LOCKSCRIPT" ]]
then
  rm -r "/run/waylandloginmanager/$SCRIPTNAME.lock"
  ln -s /proc/"$$"/cmdline "/run/waylandloginmanager/$SCRIPTNAME.lock"
else
  logger -t waylandloginmanager "Error: Another instance is already running" -s  >>/var/log/waylandloginmanager 2>&1
  exit
fi
#second check to make sure this instance 'won' as a second instance could report success, and execute as the first instance is OK to run, but before it creates the lockfile
#this ensures that the linked /proc/pid/cmdline is this pid
LOCKPROCPATH=$(dirname $(readlink "/run/waylandloginmanager/$SCRIPTNAME.lock" ))
THISPROCPATH=/proc/$$
if [[ $LOCKPROCPATH != $THISPROCPATH ]]
then
  logger -t waylandloginmanager "Error: Another instance is already running" -s  >>/var/log/waylandloginmanager 2>&1
  exit
fi

#Require root privlages
if [[ $UID != 0 ]]
then
  echo "Must be run as root."
  exit
fi

#prevent the WaylandLoginManager from being killed with CTRL+C
trap '' 2

#Attempt to import fast user switching data from a crashed WaylandLoginManager
if [[ -e /run/waylandloginmanager/sessiondata ]]
then
  . /run/waylandloginmanager/sessiondata
else
  touch /run/waylandloginmanager/sessiondata
  chmod 700 /run/waylandloginmanager/sessiondata
fi

#Set up the needed environment variables
cd /run/waylandloginmanager
#The LOGINMANAGERDISPLAYHOME variable controls where the home directory for the user that calls the loginmanagerdisplay the weston.ini that has the fifo command helpers needs to be in $LOGINMANAGERDISPLAYHOME/.config/
export LOGINMANAGERDISPLAYHOME=/etc/loginmanagerdisplay/
#User that the zenity dialogs and the loginmanagerdisplay (weston instance for the waylandloginmanager runs as
export LOGINMANAGERDISPLAYUSER=daemon
#User that the su test in AuthenticateUser user runs as
export PROBETESTUSER=daemon
#User that reads from the loginmanager_control FIFO, and filters the command sent to it to loginmanager_listener
export FIFOREADERUSER=daemon
#Get the UID of the $LOGINMANAGERDISPLAYUSER
export LOGINMANAGERDISPLAYUID=$(id $LOGINMANAGERDISPLAYUSER -u)
#Set the default path for the weston-display-server
export DEFAULTWAYLANDSERVER=/opt/bin/weston-display-server
#Set Wayland/runtime vars
export PATH=/opt/bin:$PATH
export LD_LIBRARY_PATH=/opt/lib/$(dpkg-architecture -qDEB_HOST_MULTIARCH):/usr/local/lib/$(dpkg-architecture -qDEB_HOST_MULTIARCH):/usr/lib/$(dpkg-architecture -qDEB_HOST_MULTIARCH):/opt/lib:/usr/local/lib:/usr/lib
export GDK_BACKEND=wayland
export XDG_RUNTIME_DIR=/run/user/$LOGINMANAGERDISPLAYUID
export WAYLAND_DISPLAY=loginmanagerdisplay
#Specify where wsession files are found
export WSESSIONSPATH="/usr/share/wsessions.d"
export WESTON_PLUGIN_PATH=/opt/lib/$(dpkg-architecture -qDEB_HOST_MULTIARCH)/weston
#WLM_LD_LIBRARY_PATH is exported so that wlm_ui can set it as LD_LIBRARY_PATH, as the sudo command that starts it as the LOGINMANAGERDISPLAYUSER drops LD_LIBRARY_PATH, and do the same for PATH
export WLM_LD_LIBRARY_PATH=$LD_LIBRARY_PATH
export WLM_PATH=$PATH
#set LastTTY to be 7. this causes the first TTY to try to put the WaylandLoginManager on as tty8.
LastTTY=7
#default the number of sessions registered to be 0 if unset
if [[ -z $AllSessions ]]
then
  AllSessions=0
fi
#default ActiveSessionPID, which determines the pid for the waylandloginmanager to watch until it stops, to switch back to 0
ActiveSessionPID=0
#Array that stores all backend types that is supported by the hardware
SupportedBackends=()
#determine if weston is the normal weston, or if weston has been replaced by the westonlaunchcaller
westonresult=$(weston --version &>/dev/null; echo $?) 
if [[ $westonresult == 255 ]]
then
  SupportedBackends+=(WL)
fi

#Determine if this is running on a live instance, if the root filesystem is overlayfs.
FSTYPE=$(df / -T | awk '{print $2}' | grep -v Type)
if [[ $FSTYPE == overlayfs ]]
then
  ISLIVE=1
fi

#Detect presence of the wlm_ui zenity launcher, if it exists set the command to call zenity as one that starts it as the $LOGINMANAGERDISPLAYUSER. If it doesn't exist, default to zenity, and log this event.
if [[ ! -z /usr/bin/wlm_zenity ]]
then
  ZENITYCMD="sudo -E -u $LOGINMANAGERDISPLAYUSER wlm_ui zenity"
  TERMINALCMD="sudo -E -u $LOGINMANAGERDISPLAYUSER wlm_ui vte"
else
  ZENITYCMD="sudo -E -u $LOGINMANAGERDISPLAYUSER zenity"
  TERMINALCMD="sudo -E -u $LOGINMANAGERDISPLAYUSER vte"
fi

#Tell the plymouth splash to hide as the loginmanager is starting.
plymouth hide-splash

#Detect hardware abilities, first try to see if the system has kernel mode setting, then try framebuffer. if both aren't supported, bring up a text mode dialog
if [[ $(ls  /dev/dri/card* ) ]]
then 
  logger -t waylandloginmanager "Kernel mode setting found." -s  >>/var/log/waylandloginmanager 2>&1
  SupportedBackends+=(KMS)
  DefaultBackendType=KMS
  WESTONBACKEND="drm-backend.so --use-pixman"
  HardwareSupported=1
fi
if [[ $(ls  /dev/fb* ) ]]
then
  logger -t waylandloginmanager "No kernel mode setting found. Using the framebuffer" -s  >>/var/log/waylandloginmanager 2>&1
  # TODO: REMOVE WHEN https://bugs.freedesktop.org/show_bug.cgi?id=73782 IS RESOLVED
  setfacl -m "g:plugdev:rwx" /dev/fb*
  setfacl -m "g:$LOGINMANAGERDISPLAYUSER:rwx" /dev/fb*
  # ENDTODO
  SupportedBackends+=(FB)
  #If KMS not detected, but fbdev is, set weston-backend to fbdev-backend
  if [[ $HardwareSupported != 1 ]]
  then
    DefaultBackendType=FB
    WESTONBACKEND=fbdev-backend.so
  fi
  HardwareSupported=1
fi
#if there is no Framebuffer or Kernel mode setting, tell the user with a text mode dialog on TTY63, and restart.
#Depending if this is a live session or not, tell the user how to configure grub if it is installed, or to specify a boot option for the framebuffer from the menu if its live
if [[ $HardwareSupported != 1 ]]
then
  if [[ $ISLIVE == 1 ]]
  then
    logger -t waylandloginmanager "ERROR: No supportable hardware found" -s  >>/var/log/waylandloginmanager 2>&1
    openvt -c 63 -s -f -w -- dialog --msgbox "No Kernel Mode Setting, or Framebuffer device found.

This means your video card does not support KMS, and doesn't create a framebuffer by default. either of which are needed for Weston to work.

You can select a Framebuffer boot option when you start the Live CD, to force a boot with a framebuffer device." 20 50 --no-cancel
  else 
    openvt -c 63 -s -f -w -- dialog --msgbox "No Kernel Mode Setting, or Framebuffer device found.

This means your video card does not support KMS, and doesn't create a framebuffer by default. either of which are needed for Weston to work.

Will now start a utility to assist you in configuring your system to boot with a framebuffer device." 20 50 --no-cancel
    openvt -c 63 -s -f -w -- rbos-add-framebuffer
  fi
  openvt -c 63 -s -f -w -- dialog --msgbox "Can not start Weston.

Will now reboot." 20 50 --no-cancel
  dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Reboot boolean:true
  exit
fi

#if the user booted with a hidden option wlmforcefbdev, set the backend for Weston / Wayland server sessions to be fbdev
if [[ $(cat /proc/cmdline | grep -c wlmforcefbdev ) != 0 ]]
then
  logger -t waylandloginmanager "Manually override set to use to use the framebuffer" -s  >>/var/log/waylandloginmanager 2>&1
  if [[ $(ls /dev/fb* ) ]]
  then
    # TODO: REMOVE WHEN https://bugs.freedesktop.org/show_bug.cgi?id=73782 IS RESOLVED
    setfacl -m "g:plugdev:rwx" /dev/fb*
    setfacl -m "g:$LOGINMANAGERDISPLAYUSER:rwx" /dev/fb*
    # ENDTODO
    SupportedBackends=()
    if [[ $westonresult == 255 ]]
    then
      SupportedBackends+=(WL)
    fi
    SupportedBackends+=(FB)
    DefaultBackendType=FB
    WESTONBACKEND=fbdev-backend.so
  #if there is no Framebuffer, since it was manually specified, tell the user with a text mode dialog on TTY63, and restart.
  else
    logger -t waylandloginmanager "ERROR: No framebuffer device found for wlmforcefbdev override!" -s  >>/var/log/waylandloginmanager 2>&1
    openvt -c 63 -s -f -w -- dialog --msgbox "The wlmforcefbdev overide is set, but no framebuffer device is found!

Will now reboot" 20 50 --no-cancel
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Reboot boolean:true
  fi
fi


#This function creates an XDG_RUNTIME_DIR for the user, specified in the first argument
function Create_XDG_RUNTIME_DIR
{
  USERUID=$(id -u $1)
  USERGID=$(id -g $1)
  mkdir -p /run/user/$USERUID
  chown $USERUID /run/user/$USERUID
  chgrp $USERGID /run/user/$USERUID
  chmod 700 /run/user/$USERUID
}

#This function is used by the WaylandLoginManager to find the next availible tty, starting from LastTTY+1
#it prints the TTY number to stdio. takes no arguments. If it can't find an open tty, it returns -1
function GetNextTTY
{
  TTYNotInUse=0
  #cycle through all ttys, stopping at tty63, as tty63 is 'reserved' by the waylandloginmanager as the tty to switch to in between sessions, as there is issues switching directly between two Weston servers.
  while [[ $TTYNotInUse -ne 1 && $LastTTY -lt 62 ]]
  do
    ((LastTTY++))
    fuser -s /dev/tty$LastTTY
    TTYNotInUse=$?
  done

  if [[ $TTYNotInUse -ne 1 ]]
  then
    AvailibleTTY=-1
  else
    AvailibleTTY=$LastTTY
  fi

  echo $AvailibleTTY
}

#This function is called when the loginmanager_control FIFO recives the command "RegisterSession". This function will read the contents of loginmanager_register, which only root can write to. 
#Before a process calls RegisterSession to loginmanager_control, the process must also start an attempt to send the data to loginmanager_register, because the timeout period is .01 seconds. If nothing is in loginmanager_register, as if it's not called correctly, or because it's an underprivlaged process that can't write to loginmanager_register, it is ignored.
#it expects the data to be sent in fields seperated by the @ charachter in this order:
# TTY_Number@PID_of_Session_Process@User_Name@logind_Session_ID
#It also sets the ActiveSessionPID to be the PIS_Of_Session_Process, to watch for when that PID dies, to switch back to the loginmanagerdisplay tty.
function RegisterSession
{
  #get the data from loginmanager_register
  exec 1001<> /run/waylandloginmanager/loginmanager_register
  RegisterData=$(while read -n 100 -t .01 data <&1001; do echo $data; done| head -1)
  exec 1001>&-
  #get the register data, and put it into an array so it can be handled
  IFS='@'
  ArraySessionData=($RegisterData)
  unset IFS
  if [[ ! -z $RegisterData ]]
  then
    logger -t waylandloginmanager "received session data $RegisterData" -s  >>/var/log/waylandloginmanager 2>&1
    #Add the session data to the arrays that store info about the sessions.
    SessionTTY=${ArraySessionData[0]}
    SessionPID=${ArraySessionData[1]}
    SessionUser=${ArraySessionData[2]}
    SessionID=${ArraySessionData[3]}
    AllSessionTTYs[$AllSessions]=$SessionTTY
    AllSessionPIDs[$AllSessions]=$SessionPID
    AllSessionUsers[$AllSessions]=$SessionUser
    AllSessionIDs[$AllSessions]=$SessionID
    #Set the active sesssion PID to the session PID
    if [[ ! -z $SessionPID ]]
    then
      ActiveSessionPID=$SessionPID
    fi
    #increment the number of running sessions, now that one is added and running successfuly
    ((AllSessions++))

    #Export session data so the waylandloginmanager has user switching data in case of a reload
    declare -p AllSessions        > /run/waylandloginmanager/sessiondata
    declare -p AllSessionTTYs    >> /run/waylandloginmanager/sessiondata 
    declare -p AllSessionPIDs    >> /run/waylandloginmanager/sessiondata 
    declare -p AllSessionUsers   >> /run/waylandloginmanager/sessiondata 
    declare -p AllSessionIDs     >> /run/waylandloginmanager/sessiondata 
    declare -p ActiveSessionPID  >> /run/waylandloginmanager/sessiondata 
  else
    logger -t waylandloginmanager "register session requested, but no data was availible in the FIFO" -s  >>/var/log/waylandloginmanager 2>&1
  fi
}

#This function takes two arguments. The first is the number of seconds to wait, and the second is the string to show in the dialog. it shows a Zenity dialog with a progress bar to count down the specified time, with the string.
function DialogWait
{
  waitseconds=$1
  displaystring="$2"
  countseconds=0
  while [[ $countseconds -lt $waitseconds ]]
  do
    percent=$(( $countseconds * 100 / $waitseconds ))
    echo $percent
    ((countseconds++))
    sleep 1
  done | $ZENITYCMD --width=450 --title="Login Manager" --no-cancel --progress --auto-close --text="$displaystring" 2>/dev/null
}


#This is called by GetUserCredentials and by StartAutoLogin. This allows the user select the session they want to use, similar to how X login managers prompt for the session before the login.
#it exports the WSESSIONDATA variable, which contains arguments and varaibles and the command to run to start a session
function ChooseSessionType
{
  #The number of Session IDs start from 0. when a session is added, the number of running sessions is 1 for the next session. The second session gets the ID of 1 etc...
  export SESSIONID=$AllSessions
  export WAYLAND_HOST=wlhost-$SESSIONID
  export WAYLAND_GUEST=wayland-$SESSIONID

  #Parse the list of sessions specified, so that zenity can use it as a list of sessions
  #Find all executable files, in the wsessions path (and not in any of its subdirectories) 
  #The subshell outputs a multiline string with all session data. every session is a fixed number of lines.
  #ONLY the session lines should be set through stdio in the while loop. This string is sent to a zenity dialog.
  WSESSIONLIST=$(find $WSESSIONSPATH -maxdepth 1 -name "*\.desktop" -type f | sort | while read SESSIONFILE
  do
    IsExecutable=$(find $SESSIONFILE |wc -l)
    if [[ $IsExecutable == 0 ]]
    then
      logger -t waylandloginmanager "Warning: $SESSIONFILE is not executable, the session will not be availible for selection by the user." -s  >>/var/log/waylandloginmanager 2>&1
    fi
    #split away all the data from this file, starting at [Desktop Entry]
    DesktopFileData=$(awk '/^\[*\]$/{flag=0}flag;/^\[Desktop Entry\]$/{flag=1}' $SESSIONFILE | awk -F \# '{print $1}')
    #Read all the supported values that are specified in the wsession file
    Enabled=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "Enabled" {print $0}' | cut -d = -f2- | tail -1 )
    SessionName=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "Name" {print $0}' | cut -d = -f2- | tail -1 )
    Type=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "Type" {print $0}' | cut -d = -f2- | tail -1 )
    #Search for backends supported by the compositor, with the backends the hardware supports. Give presence to the first one found in the array of supported backend types, the best backend types are first in the array
    for (( element = 0 ; element < ${#SupportedBackends[@]} ; element++ ))
    do
      export BackendType=${SupportedBackends[$element]}
      SupportsBackend=$(echo "$DesktopFileData" | awk -v BackendType=$BackendType -F ' *= *' '$1 == "CompositorSupports"BackendType {print $0}' | cut -d = -f2- | tail -1 )
      #Once a supported backend is found, then stop.
      if [[ $SupportsBackend == 1 ]]
      then
	break
      fi
    done
    IsFallbackSession=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "IsFallbackSession" {print $0}' | cut -d = -f2- | tail -1 )
    if [[ -z $IsFallbackSession ]]
    then
      IsFallbackSession=0
    fi
    CompositorDisplayArgument=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "CompositorDisplayArgument" {print $0}' | cut -d = -f2- | tail -1 )
    BackendArguments=$(echo "$DesktopFileData" | awk -v BackendType=$BackendType -F ' *= *' '$1 == "Compositor"BackendType"Arguments" {print $0}' | cut -d = -f2- | tail -1 )
    SessionArgument=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "SessionArgument" {print $0}' | cut -d = -f2- | tail -1 )
    AdditionalArguments=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "AdditionalArguments" {print $0}' | cut -d = -f2-| tail -1 )
    CompositorExec=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "CompositorExec" {print $0}' | cut -d = -f2- | tail -1 )
    EnvironmentFile=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "EnvironmentFile" {print $0}' | cut -d = -f2- | tail -1 )
    #The strings in NeedsFile are expanded here, so that the script can later determine if the full expanded path exists.
    NeedsFile=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "NeedsFile" {print $0}' | cut -d = -f2- | perl -pe 's/\$(\w+)/$ENV{$1}/g')
    NeedsFile+=$'\n'
    NeedsFile+=$CompositorExec

    #Iterate through all NeedsFile values, to make sure that they exist. if one doesn't exist increment NotFoundCount.
    NotFoundCount=0
    while read FILE
    do
      if [[ ! -e $FILE && -n $FILE ]]
      then
	logger -t waylandloginmanager "Warning: Cannot find needed file $FILE for $SESSIONFILE , the session will not be availible for selection by the user." -s  >>/var/log/waylandloginmanager 2>&1
	((NotFoundCount++))
      fi
    done < <(echo "$NeedsFile")

    ServerApprovedCount=$(cat /etc/waylandservers | grep -c "^$CompositorExec$")
    if [[ $ServerApprovedCount == 0 ]]
    then 
      logger -t waylandloginmanager "Warning: $CompositorExec specified in $SESSIONFILE is not in /etc/waylandservers , the session will not be availible for selection by the user." -s  >>/var/log/waylandloginmanager 2>&1
    fi

    if [[ $Enabled != 1 ]]
    then
      logger -t waylandloginmanager "Warning: $SESSIONFILE is disabled, the session will not be availible for selection by the user." -s  >>/var/log/waylandloginmanager 2>&1
    fi

    if [[ $SupportsBackend != 1 ]]
    then
      logger -t waylandloginmanager "Warning: $SESSIONFILE can't run on any backends supported by this system: "${SupportedBackends[*]}" , the session will not be availible for selection by the user." -s  >>/var/log/waylandloginmanager 2>&1
    fi

    if [[ $Type != "WSession" ]]
    then
      logger -t waylandloginmanager "Warning: $SESSIONFILE does not have a Type of 'WSession' , the session will not be availible for selection by the user." -s  >>/var/log/waylandloginmanager 2>&1
    fi

    #if the session supports the CompositorDisplayArgument, for setting the WAYLAND_DISPLAY it should use, then ammend the WAYLAND_GUEST to the end of the command.
    if [[ ! -z $CompositorDisplayArgument ]]
    then
      CompositorDisplayArgument="$CompositorDisplayArgument$WAYLAND_GUEST"
    else 
      CompositorDisplayArgument=""
    fi

    #If the session is enabled, the backend is supported, all the files it needs are there, and its a wsession file, and is executable add the lines describing the session to the string.
    #This is sent through stdio which is added to teh WSESSIONLIST variable
    if [[ $NotFoundCount == 0 && $SupportsBackend == 1 && $Enabled == 1 && $Type == "WSession" && $IsExecutable != 0 ]]
    then
      echo "$CompositorExec"
      echo "$BackendArguments"
      echo "$SessionArgument"
      echo "$AdditionalArguments"
      echo "$CompositorDisplayArgument"
      echo "$EnvironmentFile"
      echo ""$BackendType"_"$DefaultBackendType"_"$IsFallbackSession"_"
      echo "$SessionName"
    fi
  done)


  #If wesessions where found above then show a zenity dialog. If there where none, use a default session.
  if [[ ! -z $WSESSIONLIST ]]
  then
    PROMPTED=1
    #select the session. Each line is handled as a column. currently there are 8 collumns. So line 1 is is column 1, line 2 is in collumn 2, and line 9 is in collumn 1 again
    #The zenity dialog then outputs the selected session's lines into the WSESSIONDATA variable. each collumn is a different aspect of the wsessions
    WSESSIONDATA=$(echo "$WSESSIONLIST" | $ZENITYCMD --title="Pick a Session..." --height=450 --list --text "Select a Wayland Desktop Environment to use" --column compositor --column backend --column session --column args --column displayargs --column environment --column backendtype --column name --hide-column=1,2,3,4,5,6,7 --print-column=1,2,3,4,5,6,7,8 --separator="\n" --hide-header 2>/dev/null )
    #Abort if the user selected cancel on the zenity dialog
    CancelOrOK=$?
    if [[ $CancelOrOK != 0 ]]
    then
      exit 1
    fi
  else 
    unset WSESSIONDATA
  fi

  #If there are wsessions, it does prompt the user, if the user doesn't select one, it tells the user that its falling back to the default. If there are no wsessions, it silently falls back to the default, by adding hardcoded values to the wsessiondata variable.
  if [[ -z $WSESSIONDATA ]]
  then 
    if [[ $PROMPTED == 1 ]]
    then
      $ZENITYCMD --warning --text="No session selected. Defaulting to the Default Weston Desktop Shell." 2>/dev/null
    else
      logger -t waylandloginmanager "No sessions installed in $WSESSIONSPATH or no sessions are enabled, or are missing files specified by NeedsFile values" -s  >>/var/log/waylandloginmanager 2>&1
    fi
    #There are different commands needed to support different backends
    if [[ $DefaultBackendType == KMS ]]
    then
      WSESSIONDATA="$DEFAULTWAYLANDSERVER"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--backend=drm-backend.so"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--modules=desktop-shell.so,xwayland.so,cms-colord.so"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--log=\$HOME/weston.log"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--socket=$WAYLAND_GUEST"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+=""
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="KMS_KMS_0_"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="Default Weston Desktop Shell"

    elif [[ $DefaultBackendType == FB ]]
    then 
      WSESSIONDATA="$DEFAULTWAYLANDSERVER"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--backend=fbdev-backend.so"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--modules=desktop-shell.so,xwayland.so,cms-colord.so"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--log=\$HOME/weston.log"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--socket=$WAYLAND_GUEST"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+=""
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="FB_FB_0_"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="Default Weston Desktop Shell"
    fi
    #export the WSESSIONDATA varaible
    export WSESSIONDATA
  fi
}


#This function displays a diagnostic login terminal, and temporarilly copies a setuid /bin/login so that the host terminal window doesn't have to run as root, and the setuid login binary isn't accessible to the rest of the system
function DiagnosticTerminal 
{
  mkdir -p /var/tmp/waylandloginmanager/logincmd
  chown $LOGINMANAGERDISPLAYUSER /var/tmp/waylandloginmanager/logincmd
  chmod 700 /var/tmp/waylandloginmanager/logincmd
  cp /bin/login /var/tmp/waylandloginmanager/logincmd
  chmod +s /var/tmp/waylandloginmanager/logincmd/login
  $TERMINALCMD -g 80x25 -c "screen -s /var/tmp/waylandloginmanager/logincmd/login"
  wait -n $TERMINALJOB
  rm /var/tmp/waylandloginmanager/logincmd/login
}

#This function is called when the loginmanager_control recives the Info command. It brings up a help dialog for the user, about the waylandloginmanager and the system.
function ShowInfo
{
  #If the backend type is FB, then add a string to tell the user that in the help dialog
  if [[ $DefaultBackendType == "FB" ]]
  then
    BACKENDSTRING="The framebuffer backend is being used.

This probably means the current video card drivers do not 
support the native kernel mode setting that is optimal for Weston or other Wayland servers.
or the system was started with the wlmforcefbdev argument."
  else
    BACKENDSTRING="Kernel mode setting is being used.

This is the optimal way to run Weston or other Wayland servers."
  fi
  $ZENITYCMD --title="Information" --no-wrap --info --text="This is a third party fan made distribution!

$BACKENDSTRING

The Login Manager Display is running on tty: $HostVT

The key icon brings up a login prompt
The arrow icon brings up a prompt to switch between running sessions
The red X icon brings up a shutdown prompt
The i icon shows this help prompt" 2>/dev/null

}

#This function is called when the loginmanager_control FIFO recives the command "Switch". It brings up a dialog containing the list of all running login sessions, to allow the user to pick and switch to start a mew session, by containing the FIFO.
function SwitchUserDialog 
{
  unset SessionList
  #get the number of registered sessions
  NumberOfSessions=${#AllSessionPIDs[@]}
  ((NumberOfSessions--))

  #go thorugh each session, reading the arrays containing information about the sessions. to build the SessionList variable
  #The session list variable is multiline, and used by a zenity dialog.
  #line 1 is the session number
  #line 2 is the TTY for the session
  #line 3 is the PID of the session
  #line 4 is the user name
  #line 5 is the logind session id.
  while [[ $NumberOfSessions -ge 0 ]]
  do
    #determine if the current session is alive, before adding it to the list
    if [[ -e /proc/${AllSessionPIDs[$NumberOfSessions]}/environ ]]
    then
      SessionList+="$NumberOfSessions
${AllSessionTTYs[$NumberOfSessions]}
${AllSessionPIDs[$NumberOfSessions]}
${AllSessionUsers[$NumberOfSessions]}
${AllSessionIDs[$NumberOfSessions]}
"
    fi
    ((NumberOfSessions--))
  done
  #Add a element with a sessionid of -1. When the selected element is -1, it prompts for a user login for a new session, with GetUserCredentials
  SessionList+="-1


New Session...

"


  unset ChangeSession
  #prompt for the list of running sessions, and return the session ID. (which is used in all of the arrays for Session PID, user name, etc)
  ChangeSession=$(echo "$SessionList"  | sed '$d'| $ZENITYCMD --title="Switch User" --height=450 --list --text "Select a running session to change into" --hide-header --column sessionid --column tty --column pid --column username --column ID --print-column=1 --hide-column=3,5 --separator="\n" 2>/dev/null )
  CancelOrOK=$?
  ChangeSession=$(echo "$ChangeSession" | head -1 )
  #Abort if the user selected cancel on the zenity dialog
  if [[ $CancelOrOK != 0 ]]
  then
    exit 1
  fi
  #if the chosen session is -1 then contact the FIFO with a login prompt, otherwise switch to the selected session
  if [[ $ChangeSession == "-1" ]]
  then
    echo -e "\nLogin" >/run/waylandloginmanager/loginmanager_control
  else 
    #if a session is selected, then get the PID, TTY, logind session ID with the selected Session ID as the array element number.
    if [[ $ChangeSession ]]
    then
      ChangeSessionPID=${AllSessionPIDs[$ChangeSession]}
      ChangeSessionTTY=${AllSessionTTYs[$ChangeSession]}
      ChangeSessionID=${AllSessionIDs[$ChangeSession]}

      #before switching into a session double check in case if the session crashed after it was listed ealier in the function.
      if [[ -e /proc/$ChangeSessionPID/environ ]]
      then
	#change to tty63, and then the destination TTY of the session ID as a workaround, as switching directly between two Weston session doesn't work.
	chvt 63 &
	sleep .1
	chvt $ChangeSessionTTY &
	#hand over the logind session ID to allow desktop permissions to work.
	loginctl activate $ChangeSessionID
	#set the active session pid for the script to watch to be the PID of the session
	ActiveSessionPID=$ChangeSessionPID
      else
	$ZENITYCMD --title="Switch User" --warning --text="The selected session was not found. The session may have quit." 2>/dev/null
      fi
    fi
  fi
}

#Function that starts the user sessions, which is called by AuthenticateUser, if the authentication is successful. It takes the 3 arguments, TTY number, user to start the session for, and the multiline string, WSESSIONDATA, which contains specific data about how to start paticular sessions
function StartUserSession 
{
  #ensure the loginmanager_control fd doesn't get leaked
  exec 1000>&-


  #unset most varaibles, except PATH and WAYLAND_HOST and WAYLAND_GUEST
  while read var
  do 
    unset "$var"
  done < <(env | awk -F = '{print $1}' | grep -Ev "^WAYLAND_HOST$|^WAYLAND_GUEST$|^PATH$" ) 

  #save the arguments passed to StartUserSession, and put the third argument into an array
  WSESSIONARGS=$(echo "$3" | sed 's/$/ /g')
  WESTONTTY=$1
  LOGINUSER=$2
  IFS=$'\n'
  WSESSIONDATA=($WSESSIONARGS)
  unset IFS

  #Change to the users homepath so weston starts in the right place, and set some varaibles for the user
  export HOME=$(eval echo ~$LOGINUSER)
  export LOGNAME=$LOGINUSER
  export USER=$LOGINUSER
  export USERNAME=$LOGINUSER
  cd $HOME

  #The array makes it easy to get the data out of WSESSIONDATA. any variables in the strings are expanded with perl
  #line 1 is the path to the compositor
  #line 2 is the argument to start with a paticular backend
  #line 3 is the argument to start the Wayland server with a specific WAYLAND_DISPLAY
  #line 4 is any other arguments needed
  #line 5 specifies the environment file which is process by westonlaunchcaller, which is documented at the top of the script, and in westonlaunchcaller.
  #line 6 specifies the backend data, which tells westonlaunchcaller what backend is being used, the default one, and if the session file is calling the session with fallback capabilies. This variable is broken up, and exported as BackendType, DefaultBackendType, and IsFallbackSession
  #line 7 specifies the session name for the user and for helpdialog to know what session is running. this is exported as a varaible.
  CompositorExec="$( echo "${WSESSIONDATA[0]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  BackendArguments="$( echo "${WSESSIONDATA[1]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  SessionArgument="$( echo "${WSESSIONDATA[2]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  AdditionalArguments="$( echo "${WSESSIONDATA[3]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  CompositorDisplayArgument="$( echo "${WSESSIONDATA[4]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  BackendData="$( echo "${WSESSIONDATA[6]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  export EnvironmentFile="$( echo "${WSESSIONDATA[5]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  export SessionName="$( echo "${WSESSIONDATA[7]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  IFS=_
  BackendData=($BackendData)
  unset IFS
  export BackendType=${BackendData[0]}
  export DefaultBackendType=${BackendData[1]}
  export IsFallbackSession=${BackendData[2]}

  #determine if weston is the normal weston, or if weston has been replaced by the westonlaunchcaller
  westonresult=$(weston --version &>/dev/null; echo $?) 

  #Call the server with the arguments specified by the selected session
  logger -t waylandloginmanager "Starting server $CompositorExec with the arguments of $BackendArguments $SessionArgument $AdditionalArguments $CompositorDisplayArgument for user $LOGINUSER on tty $WESTONTTY" -s  >>/var/log/waylandloginmanager 2>&1
  #change to tty63, before starting the session, as switching directly between two Weston session doesn't work.
  chvt 63 &
  sleep .1
  Create_XDG_RUNTIME_DIR $LOGINUSER
  #if the westonlaunchcaller is replacing weston, then call it with the arguments to specify the server to use, which is specified with $DEFAULTWAYLANDSERVER
  if [[ $westonresult == 255 ]]
  then
    export WAYLAND_DISPLAY=$WAYLAND_GUEST
    openvt -f -s -c $WESTONTTY -- weston-launch --user=$LOGINUSER --tty=/dev/tty$WESTONTTY -- "$CompositorExec" @@ "$BackendArguments"  "$SessionArgument" "$AdditionalArguments" "$CompositorDisplayArgument"
  #if the westonlaunchcaller does NOT exist, then call weston-launch as normal, and log the event.
  else
    logger -t waylandloginmanager "WARNING: the weston executable has not been replaced with westonlaunchcaller. Execution of custom Wayland servers will not work." -s  >>/var/log/waylandloginmanager 2>&1
    openvt -f -s -c $WESTONTTY -- weston-launch --user=$LOGINUSER --tty=/dev/tty$WESTONTTY -- "$BackendArguments"  "$SessionArgument" "$AdditionalArguments" "$CompositorDisplayArgument"
  fi
  sleep 5
  #Get the PID that was called, by seing which process is the 'leader pid' of the $WESTONTTY tty that the server was started. This is needed to know what TTY to switch to.
  WESTONPID=$(ps --tty /dev/tty$WESTONTTY | sed -n 2p | awk '{print $1}')
  #Find the logind session id, by trying to find out what session is lead by the $WESTONPID. This is needed to know what logind session needs to be switched to to enable desktop permissions
  SESSIONS=$(loginctl  list-sessions |grep "        c" |awk '{print $1}')
  while read SESSION
  do
    SessionPid=$(loginctl show-session $SESSION -p Leader |awk -F = '{print $2}')
    if [[ $SessionPid == $WESTONPID ]]
    then
      LOGINDSESSION=$SESSION
      break
    fi
  done < <(echo "$SESSIONS")

  #The logind session activation is needed to enable the desktop permissions for the user. (such as udisks, and shutting down the system, and NetworkManager)
  loginctl activate $LOGINDSESSION

  #Send the tty number, pid, user name, and logind session ID to loginmanager_register in the background, then tell loginmanager_control to read loginmanager_register.
  echo "$WESTONTTY@$WESTONPID@$LOGNAME@$LOGINDSESSION" > /run/waylandloginmanager/loginmanager_register &
  echo -e "\nRegisterSession" >/run/waylandloginmanager/loginmanager_control
}

#Test users credentials, by making sure the user name and password match by trying to test with su and expect.
#Expect has to be run as a non root user, otherwise it always reports success. Run it as the user specified with $PROBETESTUSER
#it returns failure or success
#This is called by GetUserCredentials, after it collects the user name and password for the user. It reads the password from stdin
function AuthenticateUser
{
  unset USERPASSWORD
  TryPassword=$(cat -)
  #Test the users login with an embedded expect script running as PROBETESTUSER
  echo "log_user 0
	spawn su $LOGINUSER -c /bin/true
	expect Password 
	send $TryPassword\r
	catch wait result
	exit [lindex \$result 3]" |sudo -u $PROBETESTUSER expect
  PasswordResult=$?
  #If the password is correct try to mount the users possible ecryptfs encrpted home folder with an emedded expect script.
  if [[ 0 == $PasswordResult ]]
  then
    export USERHOME=$(eval echo ~$LOGINUSER)
    if [[ -e $USERHOME/.ecryptfs ]]
    then
      echo "spawn login $LOGINUSER
	    expect Password 
	    send $TryPassword\r
	    sleep 30
	    exit" |expect &
      sleep 3
    fi
    #Remove the password from the environment
    unset TryPassword
    #if the password and username is correct, start the session
    logger -t waylandloginmanager "Opening a session for $LOGINUSER on TTY $SessionTTY" -s  >>/var/log/waylandloginmanager 2>&1
    DialogWait 3 "Login Successful.\rAttempting to start the selected session..."
    StartUserSession "$SessionTTY" "$LOGINUSER" "$WSESSIONDATA" &
    #report success
    return 0
  else
      #Remove the password from the environment
      unset TryPassword
      #report failure
      return 1
  fi
}


#Get the users username and password by allowing the user to select the username in a list, or enter it manually, and then enter thier password
#This function is called when the loginmanager_control FIFO recives the command "Login"
function GetUserCredentials
{
  #Get the list of nonsystem users, in each line, there is 1 user, with two feilds, the users 'friendly' name, and then the users system login name, seperated by a :
  #this finds the range of UIDs that are user UIDs, and then finds any users with theses UIDS.
  UIDMIN=$(cat /etc/login.defs | grep -e "^UID_MIN" | awk '{print $2}')
  UIDMAX=$(cat /etc/login.defs | grep -e "^UID_MAX" | awk '{print $2}')
  USERLIST=$(cat /etc/passwd | awk -v UIDMIN=$UIDMIN -v UIDMAX=$UIDMAX -F : '{ if ($3>=UIDMIN && $3 <=UIDMAX) print $5":"$1}')
  #sort the list
  USERLIST=$(echo "$USERLIST" | sort |uniq)
  #go through each line of users found, to handle the display of the real name (passwd gecos feild)
  while read USER
  do
    IFS=":"
    #handle the line as an array, with two elements
    UserData=($USER)
    #The passwd gecos feild is formated with username,buildingnumber,phonenumber,otherdata. only get the username subfeild.
    UserDisplayName=$(echo ${UserData[0]} | awk -F , '{print $1}')
    #The display in the zenity dialog should be "Firstname Lastname    (loginname)"
    UserDisplayName="$UserDisplayName   (${UserData[1]})" 
    UserName=${UserData[1]}
    #If the user has no display name, then set it to be the users login name
    if [[ -z $UserDisplayName ]]
    then
      UserDisplayName=$UserName
    fi
    unset IFS
    #add the data to the USERLISTSTRING that gets sent into zenity. Line 1 is the display name, line 2 is the user login name, and then line 3 is the display name of the next user...
    USERLISTSTRING+="$UserDisplayName"
    USERLISTSTRING+=$'\n'
    USERLISTSTRING+="$UserName"
    USERLISTSTRING+=$'\n'
  done < <(echo "$USERLIST")
  #Append a default value with the display string to enter the username with -1. When selected, this tells the script to bring up a dialog to allow the user to enter a manual name
  USERLISTSTRING+="Enter User Name..."
  USERLISTSTRING+=$'\n'
  USERLISTSTRING+="-1"

  #Prompt for the session type
  ChooseSessionType

  #present the list of the users to the system
  LOGINUSER=$(echo "$USERLISTSTRING" | $ZENITYCMD --title="Username" --height=450 --list --text "Select a user from the list to log into."  --column users --column usernames --hide-column 2 --print-column 2 --hide-header --separator="\n" 2>/dev/null )
  CancelOrOK=$?
  export LOGINUSER=$(echo "$LOGINUSER" | head -1)
  #Abort if the user selected cancel on the zenity dialog
  if [[ $CancelOrOK != 0 ]]
  then
    exit 1
  fi
  #if there is no user selected or if the LOGINUSER is -1, as in the user opted to enter a username manually prompt for the username with a text dialog
  if [[ -z $LOGINUSER || $LOGINUSER == -1 ]]
  then
    LOGINUSER=$($ZENITYCMD --title="Username" --entry --text="Enter the User Name:" 2>/dev/null)
    CancelOrOK=$?
    #Abort if the user selected cancel on the zenity dialog
    if [[ $CancelOrOK != 0 ]]
    then
      exit 1
    fi
  fi
  #get the TTY to start the session on
  export SessionTTY=$(GetNextTTY)
  if [[ $SessionTTY -ne -1 ]]
  then
    #Prompt for the users password
    USERPASSWORD=$( $ZENITYCMD --title="Password" --password --text "Type Password for $LOGINUSER" 2>/dev/null )
    CancelOrOK=$?
    #Abort if the user selected cancel on the zenity dialog
    if [[ $CancelOrOK != 0 ]]
    then
      exit 1
    fi
    #send the password to an AuthenticateUser function with stdin
    echo $USERPASSWORD | AuthenticateUser
    #get the result from AuthenticateUser in the pipe, (and not the echo command)
    passwordresult=${PIPESTATUS[1]}
    unset USERPASSWORD
    if [[ $passwordresult != 0 ]]
    then
      $ZENITYCMD --warning --text="Invalid password for $LOGINUSER, or username invalid" 2>/dev/null
      logger -t waylandloginmanager "Invalid password for $LOGINUSER, or username invalid" -s  >>/var/log/waylandloginmanager 2>&1
    fi
  else
    $ZENITYCMD --warning --text="Not Enough TTYs!" 2>/dev/null
    logger -t waylandloginmanager "Not Enough TTYs for user login!" -s  >>/var/log/waylandloginmanager 2>&1
  fi
}


#This function is called when the loginmanager_control FIFO recives the command "Leave". It brings up a zenity dialog for handling power options for the computer.
function LeavePrompt
{
  #The first line is sent to the zenity dialog is the actual command it sets the ACTION variable to be. the second line is what it appears as in the Zenity dialog for the user.
  CanPowerOff=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanPowerOff |grep -c yes)
  if [[ $CanPowerOff == 1 ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Shutdown"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Shutdown Computer"
  fi
  CanReboot=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanReboot |grep -c yes)
  if [[ $CanReboot == 1 ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Restart"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Restart Computer"
  fi
  CanSuspend=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanSuspend |grep -c yes)
  if [[ $CanSuspend == 1 ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Standby"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Standby Computer"
  fi
  CanHybridSleep=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanHybridSleep |grep -c yes)
  if [[ $CanHybridSleep == 1 ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Hybrid Sleep"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Hybrid Sleep Computer"
  fi
  CanHibernate=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanHibernate |grep -c yes)
  if [[ $CanHibernate == 1 ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Hibernate"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Hibernate Computer"
  fi
  ACTION=$(echo "$ACTIONSTRING" | $ZENITYCMD --title="Leave..." --height=450 --list  --hide-header --text="What do you want to do?" --separator="\n" --column 'action' --column 'useraction' --hide-column 1 --print-column=1  2>/dev/null | head -1)
  CancelOrOK=$?
  ACTION=$(echo "$ACTION" | head -1 )
  #Abort if the user selected cancel on the zenity dialog
  if [[ $CancelOrOK != 0 ]]
  then
    exit 1
  fi

  #Prompt the user if they are sure they want to execute the selected action
  $ZENITYCMD --title="Leave..." --question --text="Are you sure you want to $ACTION" 2>/dev/null
  CONFIRM=$?
  if [[ $CONFIRM != 0 ]]
  then
    exit 1
  fi

  #For all actions use the dbus commands to logind
  if [[ $ACTION == "Shutdown" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.PowerOff boolean:true
    RESULT=$?
  elif [[ $ACTION == "Restart" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Reboot boolean:true
    RESULT=$?
  elif [[ $ACTION == "Standby" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Suspend boolean:true
    RESULT=$?
  elif [[ $ACTION == "Hybrid Sleep" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.HybridSleep boolean:true
    RESULT=$?
  elif [[ $ACTION == "Hibernate" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Hibernate boolean:true
    RESULT=$?
  else
    exit
  fi
  #if the selected action failed, tell the user
  if [[ $RESULT != 0 ]]
  then
    $ZENITYCMD --title="Failure" --warning --text="Failed to $ACTION" 2>/dev/null
  fi
}


#This calls the loginmanagerdisplay weston session.  Everytime the weston session dies, wait 5 seconds, then try to call it back up
function LoginWestonLauncher
{
  Create_XDG_RUNTIME_DIR $LOGINMANAGERDISPLAYUSER
  for (( StartTimes = 0 ; StartTimes < 5 ;))
  do
    #This determines if the loginmanagerdisplay is running, by checking if the socket file is in use by a process or not.
    if [[ $(fuser -s /run/user/$LOGINMANAGERDISPLAYUID/loginmanagerdisplay; echo $?) == 1 ]]
    then 
      (( StartTimes++ ))
      chvt 63 &
      #determine if weston is the normal weston, or if weston has been replaced by the westonlaunchcaller
      westonresult=$(weston --version &>/dev/null; echo $?) 
      logger -t waylandloginmanager "Starting the loginmanagerdisplay on tty $HostVT" -s  >>/var/log/waylandloginmanager 2>&1
      #if the westonlaunchcaller is replacing weston, then call it with the arguments to specify the server to use, which is specified with $DEFAULTWAYLANDSERVER
      if [[ $westonresult == 255 ]]
      then
	openvt -w -f -s -c $HostVT -- weston-launch --tty=/dev/tty$HostVT --user=$LOGINMANAGERDISPLAYUSER -- "$DEFAULTWAYLANDSERVER" @@ --backend=$WESTONBACKEND --socket=loginmanagerdisplay --modules=desktop-shell.so --log=/var/log/loginmanagerdisplay.log
      else
	#if the westonlaunchcaller does NOT exist, then call weston-launch as normal, and log the event.
	logger -t waylandloginmanager "WARNING: the weston executable has not been replaced with westonlaunchcaller. Execution of custom Wayland servers will not work." -s  >>/var/log/waylandloginmanager 2>&1
	openvt -w -f -s -c $HostVT -- weston-launch --tty=/dev/tty$HostVT --user=$LOGINMANAGERDISPLAYUSER -- --backend=$WESTONBACKEND --socket=loginmanagerdisplay --modules=desktop-shell.so --log=/var/log/loginmanagerdisplay.log
      fi
    fi
  done
  logger -t waylandloginmanager "ERROR: Maximum restarts of the loginmanagerdisplay has been reached" -s  >>/var/log/waylandloginmanager 2>&1
  openvt -c 63 -s -f -w -- dialog --msgbox "The maximum number of restart attempts for the loginmanagerdisplay has been reached. 

Will show a menu with a few options for diagnosis." 20 50 --no-cancel

  openvt -c 63 -s -f -w -- rbos-failedboot
  exit
}



#This determines if the autologin user was specified by ubiquity, and then configures that value to /etc/waylandloginmanager.conf, as in an unsafe shutdown, the lightdm config file has sometimes dropped the autologin user.
#If autologin is specified, prompt to select the session type to start, then start the session as the autologin user
function StartAutoLogin
{
  #if /etc/waylandloginmanager.conf exists, use the autologin user specified in that file, if not try the lightdm config file
  if [[ -e /etc/waylandloginmanager.conf ]]
  then
    AUTOLOGINUSER=$(cat /etc/waylandloginmanager.conf | grep autologin-user= | awk -F = '{print $2}' | head -1 )
  else
    AUTOLOGINUSER=$(cat /etc/lightdm/lightdm.conf | grep autologin-user= | awk -F = '{print $2}' | head -1 )
    echo "autologin-user=$AUTOLOGINUSER" >> /etc/waylandloginmanager.conf
  fi

  #if autologin is specified
  if [[ ! -z $AUTOLOGINUSER ]]
  then
    sleep 5
    ChooseSessionType
    #Abort if the user selected cancel on the zenity dialog
    CancelOrOK=$?
    if [[ $CancelOrOK != 0 ]]
    then
      exit 1
    fi
    #get the TTY to start the autologin session on
    export AutoSessionTTY=$(GetNextTTY)
    DialogWait 3 "Attempting to start the selected session..."
    #if there is a tty for the autologin session, the autologin is configured, start the autologin session
    if [[ $AutoSessionTTY -ne -1 ]]
    then
      logger -t waylandloginmanager "Starting Autologin session for $AUTOLOGINUSER on TTY $AutoSessionTTY" -s  >>/var/log/waylandloginmanager 2>&1
      StartUserSession "$AutoSessionTTY" "$AUTOLOGINUSER" "$WSESSIONDATA" &
    else
      $ZENITYCMD --warning --text="Not Enough TTYs for autologin!" 2>/dev/null
      logger -t waylandloginmanager "Not Enough TTYs for autologin!" -s  >>/var/log/waylandloginmanager 2>&1
    fi
  fi 
}

#This function is part of the startup for the waylandloginmanager. it creates the FIFO files, giving ONLY write access to loginmanager_control for ALL users, and only write access to loginmanager_register is given to root. Any other permissions, including read is denied.
#This also creates a symlink in $LOGINMANAGERDISPLAYHOME, that points to a log file in /run/waylandloginmanager, which gives permissions to the $LOGINMANAGERDISPLAYUSER, so that the log isn't placed in /etc
function SetupLoggingAndFIFO
{
  #Create communication fifo.
  rm -r /run/waylandloginmanager/loginmanager_control
  rm -r /run/waylandloginmanager/loginmanager_listener
  rm -r /run/waylandloginmanager/loginmanager_register
  mkfifo -m 622 /run/waylandloginmanager/loginmanager_control
  mkfifo -m 200 /run/waylandloginmanager/loginmanager_listener
  mkfifo -m 200 /run/waylandloginmanager/loginmanager_register
  chown $FIFOREADERUSER /run/waylandloginmanager/loginmanager_control
  #open the main FIFO that recives commands.
  exec 1000<> /run/waylandloginmanager/loginmanager_listener
  #Prepare logging for the loginmanagerdisplay
  touch /var/log/waylandserver.log
  touch /var/log/loginmanagerdisplay.log
  chown $LOGINMANAGERDISPLAYUSER /var/log/waylandserver.log
  chown $LOGINMANAGERDISPLAYUSER /var/log/loginmanagerdisplay.log
  rm $LOGINMANAGERDISPLAYHOME/waylandserver.log
  ln -s /var/log/waylandserver.log $LOGINMANAGERDISPLAYHOME/waylandserver.log
}

#This function displays a dialog containing actions for the Wayland Login Manager for the user, Shutdown, Switch User, login, and show a help dialog. It's optional, for in the case Weston isn't configured
function UserActionDialog
{
  #Loop forever
  while [ 1 ]
  do
    ActionMenu="Login\nLogin...\nSwitch\nSwitch User...\nLeave\nShutdown...\nInfo\nHelp..."
    if [[ $wlmdebug == 1 ]]
    then
      ActionMenu+="\nDebug\nTerminal Login..."
    fi
    USERACTION=$(echo -e "$ActionMenu"|$ZENITYCMD  --title="Login Manager" --height=300 --hide-column 1 --separator="\n" --list --column action --column display --hide-header --text "Select an Action" 2>/dev/null | head -1; exit ${PIPESTATUS[1]})
    ZENITYSTATUS=$?
  #If the useraction exists (the user did not click cancel), then send the command to the loginmanager_control
  if [[ ! -z $USERACTION ]]
  then
    echo -e "\n$USERACTION" > /run/waylandloginmanager/loginmanager_control
  else
    sleep .1
  fi
  done
  #If Zenity reports an error, sleep so that it doesn't thrash the CPU with failing instances every .1 seconds
  if [[ $ZENITYSTATUS != 0 ]]
  then
    sleep 5
  fi
}



function CommandFIFOProxy
{
  while [ 1 ]
  do
    sudo -u $FIFOREADERUSER bash -c "grep -Eo \"^Switch$|^Change$|^Login$|^Leave$|^RegisterSession$|^Info$|^Debug$|^$\" /run/waylandloginmanager/loginmanager_control" > /run/waylandloginmanager/loginmanager_listener
    sleep .1
  done
}

#This part of the script is constantly running, once it finishes setting up. This reads the loginmanager_control FIFO constantly, waiting for it to recive a command from a program called by the loginmanagerdisplay's weston desktop shell that sends approriate commands to it, or the westonlaunchcaller, waylandshutdown, or even some functions within this script.
#it also checks to see if the active sesssion is active, and if not, switches back to the tty of the loginmanagerdisplay.
function ReadCommandFIFO
{
  #loop 'forever'
  while [ 1 ]
  do

    #On each pass, if ActiveSessionPID isn't 0, that indicates a session is running. If one is it checks to see if the ActiveSessionPID, or the pid of the active session is still running. If it is down, then switch back to the TTY of the loginmanagerdisplay, and then reset it to indicate that no session is running
    if [[ $ActiveSessionPID != 0 && ! -e /proc/$ActiveSessionPID/environ ]]
    then
      if [[ $(fgconsole) != $HostVT ]]
      then
	#change to tty63, and then the destination TTY of the loginmanagerdisplay as a workaround, as switching directly between two Weston session doesn't work.
	chvt 63 &
	sleep .1
	chvt $HostVT &
      fi
      ActiveSessionPID=0
    fi
    #Read the next line that was sent to the FIFO. Allow a 1 second delay before it times out, and lets the loop run again. It only reads 20 bytes at a time.
    read -n 20 -t 1 COMMAND <&1000
    if [[ $COMMAND != "" ]]
    then
      logger -t waylandloginmanager "received command $COMMAND" -s  >>/var/log/waylandloginmanager 2>&1
    fi

    #If it recives a Switch command, then go back to the loginmanagerdisplay's TTY and bring up a switch user dialog and start a switch user job, only if there isn't another switchuserdialog job running
    if [[ $COMMAND == "Switch" ]]
    then
      if [[ $(fgconsole) != $HostVT ]]
      then
	#change to tty63, and then the destination TTY of the loginmanagerdisplay as a workaround, as switching directly between two Weston session doesn't work.
	chvt 63 &
	sleep .1
	chvt $HostVT &
      fi
      if [[ $(jobs -p -r | grep -c ^$LastSwitchPID$) == 0 ]]
      then
	SwitchUserDialog &
	LastSwitchPID=$!
      else
	logger -t waylandloginmanager "A handler for the command is already open" -s  >>/var/log/waylandloginmanager 2>&1
      fi
    #If the command is change, go back to the loginmanagerdisplay TTY, and don't do anything else. It only switches to the TTY if the TTY isn't active already.
    elif [[ $COMMAND == "Change" ]]
    then
      if [[ $(fgconsole) != $HostVT ]]
      then
	#change to tty63, and then the destination TTY of the loginmanagerdisplay as a workaround, as switching directly between two Weston session doesn't work.
	chvt 63 &
	sleep .1
	chvt $HostVT &
      fi
    #If it recives a Login command, then bring up a login dialog and start a login job, only if there isn't another login job running
    elif [[ $COMMAND == "Login" ]]
    then
      if [[ $(jobs -p -r | grep -c ^$LastLogonPID$) == 0  ]]
      then
	GetUserCredentials &
	LastLogonPID=$!
      else
	logger -t waylandloginmanager "A handler for the command is already open" -s  >>/var/log/waylandloginmanager 2>&1
      fi
    #If it recives a Leave command, then bring up a shutdown dialog and start a shutdown job, only if there isn't another shutdown job running
    elif [[ $COMMAND == "Leave" ]] 
    then
      if [[ $(jobs -p -r | grep -c ^$LastLeavePID$) == 0  ]]
      then
	LeavePrompt &
	LastLeavePID=$!
      else
	logger -t waylandloginmanager "A handler for the command is already open" -s  >>/var/log/waylandloginmanager 2>&1
      fi
    #if the command is RegisterSession, then attempt to read the loginmanager_register FIFO, and register any data sent to that FIFO.
    elif [[ $COMMAND = "RegisterSession" ]]
    then
      RegisterSession
    #If it recives a Info command, then bring up a info dialog and start a info job, only if there isn't another info job running
    elif [[ $COMMAND == "Info" ]]
    then
      if [[ $(jobs -p -r | grep -c ^$LastInfoPID$) == 0  ]]
      then
	ShowInfo &
	LastInfoPID=$!
      else
	logger -t waylandloginmanager "A handler for the command is already open" -s  >>/var/log/waylandloginmanager 2>&1
      fi
    #If the command is Debug, and wlmdebug was passed to the kernel, then show a login terminal window, only if there isn't another debug terminal window job running
    elif [[ $COMMAND == "Debug" ]]
    then
      if [[ $wlmdebug == 1 ]]
      then
	if [[ $(jobs -p -r | grep -c ^$LastDebugPID$) == 0  ]]
	then
	  DiagnosticTerminal &
	  LastDebugPID=$!
	  logger -t waylandloginmanager "Spawned a login terminal window on the loginmanagerdisplay" -s  >>/var/log/waylandloginmanager 2>&1
	else
	  logger -t waylandloginmanager "A handler for the command is already open" -s  >>/var/log/waylandloginmanager 2>&1
	fi
      else
	logger -t waylandloginmanager "Invalid command: $COMMAND received, but wlmdebug not passed to the kernel, or not in Live CD mode." -s  >>/var/log/waylandloginmanager 2>&1
      fi
    #if the command is empty, then execute bash's built in null command
    elif [[ $COMMAND == "" ]]
      then
      :
    #if the command is unknown, then log that.
    else
      logger -t waylandloginmanager "Invalid command: $COMMAND received" -s  >>/var/log/waylandloginmanager 2>&1
    fi
    #Sleep for a small amount of time, to allow fast service, but to try to reduce the possible CPU usage if someone tries to overload the FIFO
    sleep .0001
  done
}

#Get the TTY that will hold the Wayland server that displays the login screen.
OLDPID=$(fuser /run/user/$LOGINMANAGERDISPLAYUID/loginmanagerdisplay)
if [[ ! -z $OLDPID ]]
then
  HostVT=$(ps --no-headers $OLDPID | awk '{print $2}' | sed 's/tty//g')
else
  HostVT=$(GetNextTTY)
fi
LastTTY=$HostVT
if [[ $HostVT -eq -1 ]]
then
  logger -t waylandloginmanager "ERROR: Not Enough TTYs for login manager display!" -s  >>/var/log/waylandloginmanager 2>&1
  exit
fi

#Enable full alt+sysrq,and allow a debug login terminal window when wlmdebug is passed as a kernel argument, or when the system is in Live CD mode.
if [[ $(cat /proc/cmdline | grep -c wlmdebug ) != 0 || $ISLIVE == 1 ]]
then
  echo 1 > /proc/sys/kernel/sysrq
  logger -t waylandloginmanager "WARNING: The diagnostic 'wlmdebug' option has been passed to the kernel, or the system is in Live CD mode. This causes the waylandloginmanager to enable all magic sysrq keys, including the ability to kill processes, and the waylandloginmanager will respond to the Debug command when sent to the main control FIFO, by spawning a graphical login terminal window on the loginmanagerdisplay" -s  >>/var/log/waylandloginmanager 2>&1
  wlmdebug=1
fi

#Start the main loginmanagerdisplay Weston server
LoginWestonLauncher &

#Start the thread for the useraction dialog, which displays the main fourm for the waylandloginmanager
UserActionDialog &
sleep 1

#Start the autologin launcher, which will determine if there is an autologin user. Treat it as a login prompt, to not allow any other login prompts to start, until the job ends.
StartAutoLogin &
LastLogonPID=$!

#Setup the FIFO before anything starts using the fifo, and logging for the loginmanagerdisplay
SetupLoggingAndFIFO

#Start the filter proxy that will only send valid data to the main command FIFO
CommandFIFOProxy &

#Start the login managers FIFO reader, and function that determines if the ActiveSessionPID is still alive, and if it should switch back.
ReadCommandFIFO
