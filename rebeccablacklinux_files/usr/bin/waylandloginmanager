#! /bin/bash
#    Copyright (c) 2012, 2013, 2014 nerdopolis (or n3rdopolis) <bluescreen_avenger@verzion.net>
#
#    This file is part of RebeccaBlackLinux.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

#Create the waylandloginmanager folder in /run for FIFOs and lockfiles
mkdir -p /run/waylandloginmanager

#Detect another instance, by creating a testing a lockfile, which is a symlink to /proc/pid/cmdline, and making sure the second line matches.
SCRIPTPATH=$(readlink -f "$0")
SCRIPTNAME=$(echo "$SCRIPTPATH" | sed 's\/\\g')
LOCKSCRIPT=$(readlink -f "$(strings "/run/waylandloginmanager/$SCRIPTNAME.lock" | sed -n 2p)" )
if [[ "$SCRIPTPATH" != "$LOCKSCRIPT" ]]
then
  rm -r "/run/waylandloginmanager/$SCRIPTNAME.lock"
  ln -s /proc/"$$"/cmdline "/run/waylandloginmanager/$SCRIPTNAME.lock"
else
  logger -t waylandloginmanager "Error: Another instance is already running" -s  >>/var/log/waylandloginmanager 2>&1
  exit
fi
#second check to make sure this instance 'won' as a second instance could report success, and execute as the first instance is OK to run, but before it creates the lockfile
#this ensures that the linked /proc/pid/cmdline is this pid
LOCKPROCPATH=$(dirname $(readlink "/run/waylandloginmanager/$SCRIPTNAME.lock" ))
THISPROCPATH=/proc/$$
if [[ $LOCKPROCPATH != $THISPROCPATH ]]
then
  logger -t waylandloginmanager "Error: Another instance is already running" -s  >>/var/log/waylandloginmanager 2>&1
  exit
fi

#Require root privlages
if [[ $UID != 0 ]]
then
  echo "Must be run as root."
  exit
fi

#Set up the needed environment variables
cd /run/waylandloginmanager
export LOGINMANAGERDISPLAYHOME=/etc/loginmanagerdisplay/
export LOGINMANAGERDISPLAYUSER=daemon
export PROBETESTUSER=daemon
export LOGINMANAGERDISPLAYUID=$(id $LOGINMANAGERDISPLAYUSER -u)
export DEFAULTWAYLANDSERVER=/opt/bin/weston-display-server
export PATH=/opt/bin:$PATH
export LD_LIBRARY_PATH=/opt/lib/$(dpkg-architecture -qDEB_HOST_MULTIARCH):/usr/local/lib/$(dpkg-architecture -qDEB_HOST_MULTIARCH):/usr/lib/$(dpkg-architecture -qDEB_HOST_MULTIARCH):/opt/lib:/usr/local/lib:/usr/lib
export GDK_BACKEND=wayland
export XDG_RUNTIME_DIR=/run/user/$LOGINMANAGERDISPLAYUID
export WAYLAND_DISPLAY=loginmanagerdisplay
export WSESSIONSPATH="/usr/share/wsessions.d"
export WESTON_PLUGIN_PATH=/opt/lib/$(dpkg-architecture -qDEB_HOST_MULTIARCH)/weston
export WLM_LD_LIBRARY_PATH=$LD_LIBRARY_PATH
#set LastTTY to be 7. this causes the first TTY to try to put the WaylandLoginManager on as tty8.
LastTTY=7
AllSessions=0
ActiveSessionPID=0

#Determine if this is running on a live instance, if the root filesystem is overlayfs.
FSTYPE=$(df / -T | awk '{print $2}' | grep -v Type)
if [[ $FSTYPE == overlayfs ]]
then
  ISLIVE=1
fi

#Detect presence of zenity launcher, if it exists, call it as the loginmanagerdisplay user
if [[ ! -z /usr/bin/wlm_zenity ]]
then
  ZENITYCMD="sudo -E -u $LOGINMANAGERDISPLAYUSER wlm_zenity"
else
  ZENITYCMD='zenity'
fi

#Tell the plymouth splash to hide as the loginmanager is starting.
plymouth hide-splash

#Detect hardware abilities, first try using kernel mode setting, then try framebuffer
if [[ $(ls  /dev/dri/card* ) ]]
then 
  logger -t waylandloginmanager "Kernel mode setting found." -s  >>/var/log/waylandloginmanager 2>&1
  BackendType=KMS
  WESTONBACKEND=drm-backend.so
elif [[ $(ls  /dev/fb* ) ]]
then
  logger -t waylandloginmanager "No kernel mode setting found. Using the framebuffer" -s  >>/var/log/waylandloginmanager 2>&1
  # TODO: REMOVE WHEN https://bugs.freedesktop.org/show_bug.cgi?id=73782 IS RESOLVED
  setfacl -m "g:plugdev:rwx" /dev/fb*
  setfacl -m "g:$LOGINMANAGERDISPLAYUSER:rwx" /dev/fb*
  # ENDTODO
  BackendType=FB
  WESTONBACKEND=fbdev-backend.so
#if there is no Framebuffer or Kernel mode setting, tell the user with a text mode dialog on TTY13, and restart.
#Depending if this is a live session or not, tell the user how to configure grub if it is installed, or to specify a boot option for the framebuffer from the menu if its live
else
  FSTYPE=$(df / -T | awk '{print $2}' | grep -v Type)
  if [[ $ISLIVE == 1 ]]
  then
    logger -t waylandloginmanager "ERROR: No supportable hardware found" -s  >>/var/log/waylandloginmanager 2>&1
    openvt -c 13 -s -f -w -- dialog --msgbox "No Kernel Mode Setting, or Framebuffer device found.

This means your video card does not support KMS, and doesn't create a framebuffer by default. either of which are needed for Weston to work.

You can select a Framebuffer boot option when you start the Live CD, to force a boot with a framebuffer device." 20 50 --no-cancel
  else 
    openvt -c 13 -s -f -w -- dialog --msgbox "No Kernel Mode Setting, or Framebuffer device found.

This means your video card does not support KMS, and doesn't create a framebuffer by default. either of which are needed for Weston to work.

Will now start a utility to assist you in configuring your system to boot with a framebuffer device." 20 50 --no-cancel
    openvt -c 13 -s -f -w -- rbos-add-framebuffer
  fi
  openvt -c 13 -s -f -w -- dialog --msgbox "Can not start Weston.

Will now reboot." 20 50 --no-cancel
  reboot
  exit
fi

#if the user booted with a hidden option forcefbdev, set the backend for Weston / Wayland server sessions to be fbdev
if [[ $(cat /proc/cmdline | grep -c forcefbdev ) != 0 ]]
then
  logger -t waylandloginmanager "Manually override set to use to use the framebuffer" -s  >>/var/log/waylandloginmanager 2>&1
  if [[ $(ls /dev/fb* ) ]]
  then
    # TODO: REMOVE WHEN https://bugs.freedesktop.org/show_bug.cgi?id=73782 IS RESOLVED
    setfacl -m "g:plugdev:rwx" /dev/fb*
    setfacl -m "g:$LOGINMANAGERDISPLAYUSER:rwx" /dev/fb*
    # ENDTODO
    BackendType=FB
    WESTONBACKEND=fbdev-backend.so
  #if there is no Framebuffer, since it was manually specified, tell the user with a text mode dialog on TTY13, and restart.
  else
    logger -t waylandloginmanager "ERROR: No framebuffer device found for forcefbdev override!" -s  >>/var/log/waylandloginmanager 2>&1
    openvt -c 13 -s -f -w -- dialog --msgbox "The forcefbdev overide is set, but no framebuffer device is found!

Will now reboot" 20 50 --no-cancel
    reboot
  fi
fi


#This function is used by the WaylandLoginManager to find the next availible tty
#it prints the TTY number to stdio. takes no arguments
function GetNextTTY
{
  TTYNotInUse=0
  LastTTY=7
  while [[ $TTYNotInUse -ne 1 && $LastTTY -lt 62 ]]
  do
    ((LastTTY++))
    fuser -s /dev/tty$LastTTY
    TTYNotInUse=$?
  done

  if [[ $TTYNotInUse -ne 1 ]]
  then
    AvailibleTTY=-1
  else
    AvailibleTTY=$LastTTY
  fi

  echo $AvailibleTTY
}

#This function is called when the loginmanager_control FIFO recives the command "RegisterSession". This function will read the contents of loginmanager_register, which only root can write to. 
#Before a process calls RegisterSession to loginmanager_control, the process must also start an attempt to send the data to loginmanager_register, because the timeout period is .01 seconds. If nothing is in loginmanager_register, as if it's not called correctly, or because it's an underprivlaged process that can't write to loginmanager_register, it is ignored.
#it expects the data to be sent in fields seperated by the @ charachter in this order:
# TTY_Number@PID_of_Session_Process@User_Name@logind_Session_ID
#It also sets the ActiveSessionPID to be the PIS_Of_Session_Process, to watch for when that PID dies, to switch back to the loginmanagerdisplay tty.
function RegisterSession
{
  #get the data from loginmanager_register
  exec 1001<> /run/waylandloginmanager/loginmanager_register
  RegisterData=$(while read -n 100 -t .01 data <&1001; do echo $data; done| head -1)
  exec 1001>&-
  #get the register data, and put it into an array so it can be handled
  IFS='@'
  ArraySessionData=($RegisterData)
  unset IFS
  if [[ ! -z $RegisterData ]]
  then
    logger -t waylandloginmanager "received session data $RegisterData" -s  >>/var/log/waylandloginmanager 2>&1
    #Add the session data to the arrays that store info about the sessions.
    SessionTTY=${ArraySessionData[0]}
    SessionPID=${ArraySessionData[1]}
    SessionUser=${ArraySessionData[2]}
    SessionID=${ArraySessionData[3]}
    AllSessionTTYs[$AllSessions]=$SessionTTY
    AllSessionPIDs[$AllSessions]=$SessionPID
    AllSessionUsers[$AllSessions]=$SessionUser
    AllSessionIDs[$AllSessions]=$SessionID
    #Set the active sesssion PID to the session PID
    if [[ ! -z $SessionPID ]]
    then
      ActiveSessionPID=$SessionPID
    fi
    #increment the number of sessions
    ((AllSessions++))
  else
    logger -t waylandloginmanager "register session requested, but no data was availible in the FIFO" -s  >>/var/log/waylandloginmanager 2>&1
  fi
}

#This function takes an argument of a number of seconds, and shows a Zenity dialog with a progress bar to count down the specified time.
function DialogWait
{
  waitseconds=$1
  countseconds=0
  while [[ $countseconds -lt $waitseconds ]]
  do
    percent=$(( $countseconds * 100 / $waitseconds ))
    echo $percent
    ((countseconds++))
    sleep 1
  done | $ZENITYCMD --title="autologin" --no-cancel --progress --auto-close --text="Waiting for Autologin timeout..." 2>/dev/null
}

function ChooseSessionType
{
  export SESSIONID=$AllSessions

  #Parse the list of sessions specified, so that zenity can use it as a list of sessions
  WSESSIONLIST=$(find $WSESSIONSPATH -maxdepth 1 -name "*\.desktop" -type f -executable | sort | while read SESSIONFILE
  do 
    DesktopFileData=$(awk '/^\[*\]$/{flag=0}flag;/^\[Desktop Entry\]$/{flag=1}' $SESSIONFILE | awk -F \# '{print $1}')

    Enabled=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "Enabled" {print $0}' | cut -d = -f2- | tail -1 )
    SessionName=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "Name" {print $0}' | cut -d = -f2- | tail -1 )
    Type=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "Type" {print $0}' | cut -d = -f2- | tail -1 )
    SupportsBackend=$(echo "$DesktopFileData" | awk -v BackendType=$BackendType -F ' *= *' '$1 == "CompositorSupports"BackendType {print $0}' | cut -d = -f2- | tail -1 )
    CompositorDisplayArgument=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "CompositorDisplayArgument" {print $0}' | cut -d = -f2- | tail -1 )
    BackendArguments=$(echo "$DesktopFileData" | awk -v BackendType=$BackendType -F ' *= *' '$1 == "Compositor"BackendType"Arguments" {print $0}' | cut -d = -f2- | tail -1 )
    SessionArgument=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "SessionArgument" {print $0}' | cut -d = -f2- | tail -1 )
    AdditionalArguments=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "AdditionalArguments" {print $0}' | cut -d = -f2-| tail -1 )
    CompositorExec=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "CompositorExec" {print $0}' | cut -d = -f2- | tail -1 )
    EnvironmentFile=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "EnvironmentFile" {print $0}' | cut -d = -f2- | tail -1 )
    NeedsFile=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "NeedsFile" {print $0}' | cut -d = -f2- | perl -pe 's/\$(\w+)/$ENV{$1}/g')

    NotFoundCount=0
    while read FILE
    do
      if [[ ! -e $FILE ]]
      then
	((NotFoundCount++))
      fi
    done < <(echo "$NeedsFile")

    if [[ ! -z $CompositorDisplayArgument ]]
    then
      CompositorDisplayArgument="$CompositorDisplayArgument$SESSIONID"
    else 
      CompositorDisplayArgument=""
    fi

    if [[ $NotFoundCount == 0 && $SupportsBackend == 1 && $Enabled == 1 && $Type == "WSession" ]]
    then
      echo "$CompositorExec"
      echo "$BackendArguments"
      echo "$SessionArgument"
      echo "$AdditionalArguments"
      echo "$CompositorDisplayArgument"
      echo "$EnvironmentFile"
      echo "$BackendType"
      echo "$SessionName"
    fi
  done)

  if [[ ! -z $WSESSIONLIST ]]
  then
    PROMPTED=1
    #select the session
    WSESSIONDATA=$(echo "$WSESSIONLIST" | $ZENITYCMD --title="Pick a Session..." --height=450 --list --text "Select a Wayland Desktop Environment to use" --column compositor --column backend --column session --column args --column displayargs --column environment --column backendtype --column name --hide-column=1,2,3,4,5,6,7 --print-column=1,2,3,4,5,6,7,8 --separator="\n" --hide-header 2>/dev/null )
    CancelOrOK=$?
    if [[ $CancelOrOK != 0 ]]
    then
      exit 1
    fi
  else 
    unset WSESSIONDATA
  fi

  if [[ -z $WSESSIONDATA ]]
  then 
    if [[ $PROMPTED == 1 ]]
    then
      $ZENITYCMD --warning --text="No session selected. Defaulting to the Default Weston Desktop Shell." 2>/dev/null
    else
      logger -t waylandloginmanager "No sessions installed in $WSESSIONSPATH or no sessions are enabled, or are missing files specified by NeedsFile values" -s  >>/var/log/waylandloginmanager 2>&1
    fi
    if [[ $BackendType == KMS ]]
    then
      WSESSIONDATA="$DEFAULTWAYLANDSERVER"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--backend=drm-backend.so"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--modules=desktop-shell.so,xwayland.so,cms-colord.so"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--log=\$HOME/weston.log"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--socket=$SESSIONID"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+=""
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="KMS"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="Default Weston Desktop Shell"

    elif [[ $BackendType == FB ]]
    then 
      WSESSIONDATA="$DEFAULTWAYLANDSERVER"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--backend=fbdev-backend.so"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--modules=desktop-shell.so,xwayland.so,cms-colord.so"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--log=\$HOME/weston.log"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--socket=$SESSIONID"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+=""
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="FB"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="Default Weston Desktop Shell"
    fi
    export WSESSIONDATA
  fi
}


#This function is called when the loginmanager_control recives the Info command. It brings up a help dialog for the user.
function ShowInfo
{
  #If the backend type is FB, then add a string to tell the user that in the help dialog
  if [[ $BackendType == "FB" ]]
  then
    BACKENDSTRING="The framebuffer backend is being used.

This probably means the current video card drivers do not 
support the native kernel mode setting that is optimal for Weston or other Wayland servers.
or the system was started with the forcefbdev argument."
  else
    BACKENDSTRING="Kernel mode setting is being used.

This is the optimal way to run Weston or other Wayland servers."
  fi
  $ZENITYCMD --title="Information" --no-wrap --info --text="This is a third party fan made distribution!

$BACKENDSTRING

The Login Manager Display is running on tty: $HostVT

The key icon brings up a login prompt
The arrow icon brings up a prompt to switch between running sessions
The red X icon brings up a shutdown prompt
The i icon shows this help prompt" 2>/dev/null

}

function SwitchUserDialog 
{
  unset SessionList
  NumberOfSessions=${#AllSessionPIDs[@]}
  ((NumberOfSessions--))

  while [[ $NumberOfSessions -ge 0 ]]
  do
    if [[ -e /proc/${AllSessionPIDs[$NumberOfSessions]}/environ ]]
    then
      SessionList+="$NumberOfSessions
${AllSessionTTYs[$NumberOfSessions]}
${AllSessionPIDs[$NumberOfSessions]}
${AllSessionUsers[$NumberOfSessions]}
${AllSessionIDs[$NumberOfSessions]}
"
    fi
    ((NumberOfSessions--))
  done

  SessionList+="-1


New Session...

"


  unset ChangeSession
  ChangeSession=$(echo "$SessionList"  | sed '$d'| $ZENITYCMD --title="Switch User" --height=450 --list --text "Select a running session to change into" --hide-header --column sessionid --column tty --column pid --column username --column ID --print-column=1 --hide-column=3,5 --separator="\n" 2>/dev/null )
  CancelOrOK=$?
  ChangeSession=$(echo "$ChangeSession" | head -1 )
  if [[ $CancelOrOK != 0 ]]
  then
    exit 1
  fi
  if [[ $ChangeSession == "-1" ]]
  then
    echo -e "\nLogin" >/run/waylandloginmanager/loginmanager_control
  else 
    if [[ $ChangeSession ]]
    then
      ChangeSessionPID=${AllSessionPIDs[$ChangeSession]}
      ChangeSessionTTY=${AllSessionTTYs[$ChangeSession]}
      ChangeSessionID=${AllSessionIDs[$ChangeSession]}

      if [[ -e /proc/$ChangeSessionPID/environ ]]
      then
	chvt 63
	chvt $ChangeSessionTTY
	loginctl activate $ChangeSessionID
	ActiveSessionPID=$ChangeSessionPID
      else
	$ZENITYCMD --title="Switch User" --warning --text="The selected session was not found. The session may have quit." 2>/dev/null
      fi
    fi
  fi
}

#Function that starts the user sessions
function StartUserSession 
{
  exec 1000>&-
  export WAYLAND_DISPLAY=$SESSIONID
  #unset most varaibles
  while read var
  do 
    unset "$var"
  done < <(env | awk -F = '{print $1}' | grep -v ^PATH$ | grep -v ^WAYLAND_DISPLAY$ ) 
  WSESSIONARGS=$(echo "$3" | sed 's/$/ /g')
  WESTONTTY=$1
  LOGINUSER=$2
  IFS=$'\n'
  WSESSIONDATA=($WSESSIONARGS)
  unset IFS

  #Change to the users homepath so weston starts in the right place, and set some varaibles for the user
  export HOME=$(eval echo ~$LOGINUSER)
  export LOGNAME=$LOGINUSER
  export USER=$LOGINUSER
  export USERNAME=$LOGINUSER
  cd $HOME

  CompositorExec="$( echo "${WSESSIONDATA[0]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  BackendArguments="$( echo "${WSESSIONDATA[1]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  SessionArgument="$( echo "${WSESSIONDATA[2]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  AdditionalArguments="$( echo "${WSESSIONDATA[3]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  CompositorDisplayArgument="$( echo "${WSESSIONDATA[4]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  export EnvironmentFile="$( echo "${WSESSIONDATA[5]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  export BackendType="$( echo "${WSESSIONDATA[6]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  export SessionName="$( echo "${WSESSIONDATA[7]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"

  #determine if weston is the normal weston, or if weston has been replaced by the westonlaunchcaller
  westonresult=$(weston --version &>/dev/null; echo $?) 

  #Call the server
  logger -t waylandloginmanager "Starting server $CompositorExec with the arguments of $BackendArguments $SessionArgument $AdditionalArguments $CompositorDisplayArgument for user $LOGINUSER on tty $WESTONTTY" -s  >>/var/log/waylandloginmanager 2>&1
  chvt 63
  if [[ $westonresult == 255 ]]
  then
    openvt -f -s -c $WESTONTTY -- weston-launch --user=$LOGINUSER --tty=/dev/tty$WESTONTTY -- "$CompositorExec" @@ "$BackendArguments"  "$SessionArgument" "$AdditionalArguments" "$CompositorDisplayArgument"
  else
    logger -t waylandloginmanager "WARNING: the weston executable has not been replaced with westonlaunchcaller. Execution of custom Wayland servers will not work." -s  >>/var/log/waylandloginmanager 2>&1
    openvt -f -s -c $WESTONTTY -- weston-launch --user=$LOGINUSER --tty=/dev/tty$WESTONTTY -- "$BackendArguments"  "$SessionArgument" "$AdditionalArguments" "$CompositorDisplayArgument"
  fi
  sleep 5
  WESTONPID=$(ps --tty /dev/tty$WESTONTTY | sed -n 2p | awk '{print $1}')
  #Find the logind session id
  SESSIONS=$(loginctl  list-sessions |grep "        c" |awk '{print $1}')
  while read SESSION
  do
    SessionPid=$(loginctl show-session $SESSION -p Leader |awk -F = '{print $2}')
    if [[ $SessionPid == $WESTONPID ]]
    then
      LOGINDSESSION=$SESSION
      break
    fi
  done < <(echo "$SESSIONS")

  loginctl activate $LOGINDSESSION


  echo "$WESTONTTY@$WESTONPID@$LOGNAME@$LOGINDSESSION" > /run/waylandloginmanager/loginmanager_register &
  echo -e "\nRegisterSession" >/run/waylandloginmanager/loginmanager_control
}

#Test users credentials, by making sure the user name and password match by trying to test with su and expect.
#Expect has to be run as a non root user, otherwise it always reports success. Run it as the user specified with $PROBETESTUSER
#it returns failure or success
function AuthenticateUser
{
  unset USERPASSWORD
  TryPassword=$(cat -)
  echo "spawn su $LOGINUSER -c /bin/true
	expect Password 
	send $TryPassword\r
	catch wait result
	exit [lindex \$result 3]" |sudo -u $PROBETESTUSER expect
  PasswordResult=$?
  if [[ 0 == $PasswordResult ]]
  then
    export USERHOME=$(eval echo ~$LOGINUSER)
    if [[ -e $USERHOME/.ecryptfs ]]
    then
      echo "spawn login $LOGINUSER
	    expect Password 
	    send $TryPassword\r
	    sleep 30
	    exit" |expect &
      sleep 3
    fi
    #Remove the password from the environment
    unset TryPassword
    #if the password and username is correct, start the session
    logger -t waylandloginmanager "Opening a session for $LOGINUSER on TTY $SessionTTY" -s  >>/var/log/waylandloginmanager 2>&1
    StartUserSession "$SessionTTY" "$LOGINUSER" "$WSESSIONDATA" &
    #report success
    return 0
  else
      #Remove the password from the environment
      unset TryPassword
      #report failure
      return 1
  fi
}



#Attempt to get the users authentication
function GetUserCredentials
{
  #Get the list of nonsystem users
  UIDMIN=$(cat /etc/login.defs | grep -e "^UID_MIN" | awk '{print $2}')
  UIDMAX=$(cat /etc/login.defs | grep -e "^UID_MAX" | awk '{print $2}')
  USERLIST=$(cat /etc/passwd | awk -v UIDMIN=$UIDMIN -v UIDMAX=$UIDMAX -F : '{ if ($3>=UIDMIN && $3 <=UIDMAX) print $5":"$1}')
  USERLIST=$(echo "$USERLIST" | sort |uniq)
  while read USER
  do
    IFS=":"
    UserData=($USER)
    UserDisplayName=$(echo ${UserData[0]} | awk -F , '{print $1}')
    UserDisplayName="$UserDisplayName   (${UserData[1]})" 
    UserName=${UserData[1]}
    if [[ -z $UserDisplayName ]]
    then
      UserDisplayName=$UserName
    fi
    unset IFS
    USERLISTSTRING+="$UserDisplayName"
    USERLISTSTRING+=$'\n'
    USERLISTSTRING+="$UserName"
    USERLISTSTRING+=$'\n'
  done < <(echo "$USERLIST")
  USERLISTSTRING+="Enter User Name..."
  USERLISTSTRING+=$'\n'
  USERLISTSTRING+="-1"
  ChooseSessionType

  #present the list of the users to the system
  LOGINUSER=$(echo "$USERLISTSTRING" | $ZENITYCMD --title="Username" --height=450 --list --text "Select a user from the list to log into."  --column users --column usernames --hide-column 2 --print-column 2 --hide-header --separator="\n" 2>/dev/null )
  CancelOrOK=$?
  export LOGINUSER=$(echo "$LOGINUSER" | head -1)
  if [[ $CancelOrOK != 0 ]]
  then
    exit 1
  fi
  #if there is no user selected then show a dialog. If a user was selected, prompt for its login
  if [[ -z $LOGINUSER || $LOGINUSER == -1 ]]
  then
    LOGINUSER=$($ZENITYCMD --title="Username" --entry --text="Enter the User Name:" 2>/dev/null)
    CancelOrOK=$?
    if [[ $CancelOrOK != 0 ]]
    then
      exit 1
    fi
  fi
  export SessionTTY=$(GetNextTTY)
  if [[ $SessionTTY -ne -1 ]]
  then
    USERPASSWORD=$( $ZENITYCMD --title="Password" --password --text "Type Password for $LOGINUSER" 2>/dev/null )
    CancelOrOK=$?
    if [[ $CancelOrOK != 0 ]]
    then
      exit 1
    fi
    echo $USERPASSWORD | AuthenticateUser
    passwordresult=${PIPESTATUS[1]}
    unset USERPASSWORD
    if [[ $passwordresult != 0 ]]
    then
      $ZENITYCMD --warning --text="Invalid password for $LOGINUSER, or username invalid" 2>/dev/null
      logger -t waylandloginmanager "Invalid password for $LOGINUSER, or username invalid" -s  >>/var/log/waylandloginmanager 2>&1
    fi
  else
    $ZENITYCMD --warning --text="Not Enough TTYs!"
    logger -t waylandloginmanager "Not Enough TTYs for user login!" -s  >>/var/log/waylandloginmanager 2>&1
  fi
}


#Funtion for prompting for leave options
function LeavePrompt
{
  ACTION=$(echo "Shutdown
Shutdown Computer
Restart
Restart Computer
Standby
Standby Computer
Hybrid Sleep
Hybrid Sleep
Hibernate
Hibernate Computer" | $ZENITYCMD --title="Leave..." --height=450 --list  --hide-header --text="What do you want to do?" --separator="\n" --column 'action' --column 'useraction' --print-column=1 --hide-column=1 2>/dev/null )
  CancelOrOK=$?
  ACTION=$(echo "$ACTION" | head -1 )
  if [[ $CancelOrOK != 0 ]]
  then
    exit 1
  fi

  $ZENITYCMD --title="Leave..." --question --text="Are you sure you want to $ACTION"
  CONFIRM=$?
  if [[ $CONFIRM != 0 ]]
  then
    exit 1
  fi

  if [[ $ACTION == "Shutdown" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.PowerOff boolean:true
    RESULT=$?
  elif [[ $ACTION == "Restart" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Reboot boolean:true
    RESULT=$?
  elif [[ $ACTION == "Standby" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Suspend boolean:true
    RESULT=$?
  elif [[ $ACTION == "Hybrid Sleep" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.HybridSleep boolean:true
    RESULT=$?
  elif [[ $ACTION == "Hibernate" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Hibernate boolean:true
    RESULT=$?
  else
    exit
  fi
  if [[ $RESULT != 0 ]]
  then
    $ZENITYCMD --title="Failure" --warning --text="Failed to $ACTION" 2>/dev/null
  fi
}





#Call the host server for the login gui, running as a seperate user
function LoginWestonLauncher
{

  while [ 1 ]
  do

    if [[ $(fuser -s /run/user/$LOGINMANAGERDISPLAYUID/loginmanagerdisplay; echo $?) == 1 ]]
    then 
      #determine if weston is the normal weston, or if weston has been replaced by the westonlaunchcaller
      westonresult=$(weston --version &>/dev/null; echo $?) 
      logger -t waylandloginmanager "Starting the loginmanagerdisplay on tty $HostVT" -s  >>/var/log/waylandloginmanager 2>&1
      if [[ $westonresult == 255 ]]
      then
	openvt -f -s -c $HostVT -- weston-launch --tty=/dev/tty$HostVT --user=$LOGINMANAGERDISPLAYUSER -- "$DEFAULTWAYLANDSERVER" @@ --backend=$WESTONBACKEND --socket=loginmanagerdisplay --modules=desktop-shell.so
      else
	logger -t waylandloginmanager "WARNING: the weston executable has not been replaced with westonlaunchcaller. Execution of custom Wayland servers will not work." -s  >>/var/log/waylandloginmanager 2>&1
	openvt -f -s -c $HostVT -- weston-launch --tty=/dev/tty$HostVT --user=$LOGINMANAGERDISPLAYUSER -- --backend=$WESTONBACKEND --socket=loginmanagerdisplay --modules=desktop-shell.so
      fi
    fi
    sleep 15
  done
}




function StartAutoLogin
{
  if [[ -e /etc/waylandloginmanager.conf ]]
  then
    AUTOLOGINUSER=$(cat /etc/waylandloginmanager.conf | grep autologin-user= | awk -F = '{print $2}' | head -1 )
  else
    AUTOLOGINUSER=$(cat /etc/lightdm/lightdm.conf | grep autologin-user= | awk -F = '{print $2}' | head -1 )
    echo "autologin-user=$AUTOLOGINUSER" >> /etc/waylandloginmanager.conf
  fi

  if [[ ! -z $AUTOLOGINUSER ]]
  then
    sleep 5
    ChooseSessionType
    CancelOrOK=$?
    if [[ $CancelOrOK != 0 ]]
    then
      exit 1
    fi
    export AutoSessionTTY=$(GetNextTTY)
    if [[ $AutoSessionTTY -ne -1 ]]
    then
      logger -t waylandloginmanager "Starting Autologin session for $AUTOLOGINUSER on TTY $AutoSessionTTY" -s  >>/var/log/waylandloginmanager 2>&1
      StartUserSession "$AutoSessionTTY" "$AUTOLOGINUSER" "$WSESSIONDATA" &
    else
      $ZENITYCMD --warning --text="Not Enough TTYs for autologin!"
      logger -t waylandloginmanager "Not Enough TTYs for autologin!" -s  >>/var/log/waylandloginmanager 2>&1
    fi
  fi 
}

function SetupLoggingAndFIFO
{
  #Create communication fifo.
  rm -r /run/waylandloginmanager/loginmanager_control
  rm -r /run/waylandloginmanager/loginmanager_register
  mkfifo -m 222 /run/waylandloginmanager/loginmanager_control
  mkfifo -m 200 /run/waylandloginmanager/loginmanager_register
  exec 1000<> /run/waylandloginmanager/loginmanager_control
  #Prepare logging for the loginmanagerdisplay
  touch /run/waylandloginmanager/waylandserver.log
  chown $LOGINMANAGERDISPLAYUSER /run/waylandloginmanager/waylandserver.log
  rm $LOGINMANAGERDISPLAYHOME/waylandserver.log
  ln -s /run/waylandloginmanager/waylandserver.log $LOGINMANAGERDISPLAYHOME/waylandserver.log
}

#The part of the script that reads the FIFO for IPC from users logoff dialogs, the helper scripts on the login window, or the session startup scripts
function ReadCommandFIFO
{

  while [ 1 ]
  do

    if [[ $ActiveSessionPID != 0 && ! -e /proc/$ActiveSessionPID/environ ]]
    then
      if [[ $(fgconsole) != $HostVT ]]
      then
	chvt 63
	chvt $HostVT
      fi
      ActiveSessionPID=0
    fi
    read -n 20 -t 1 COMMAND <&1000
    if [[ $COMMAND != "" ]]
    then
      logger -t waylandloginmanager "received command $COMMAND" -s  >>/var/log/waylandloginmanager 2>&1
    fi

    if [[ $COMMAND == "Switch" ]]
    then
      if [[ $(fgconsole) != $HostVT ]]
      then
	chvt 63
	chvt $HostVT
      fi
      if [[ $(jobs -p -r | grep -c ^$LastSwitchPID$) == 0 ]]
      then
	SwitchUserDialog &
	LastSwitchPID=$!
      else
	logger -t waylandloginmanager "A handler for the command is already open" -s  >>/var/log/waylandloginmanager 2>&1
      fi
    elif [[ $COMMAND == "Change" ]]
    then
      if [[ $(fgconsole) != $HostVT ]]
      then
	chvt 63
	chvt $HostVT
      fi
    elif [[ $COMMAND == "Login" ]]
    then
      if [[ $(jobs -p -r | grep -c ^$LastLogonPID$) == 0  ]]
      then
	GetUserCredentials &
	LastLogonPID=$!
      else
	logger -t waylandloginmanager "A handler for the command is already open" -s  >>/var/log/waylandloginmanager 2>&1
      fi
    elif [[ $COMMAND == "Leave" ]] 
    then
      if [[ $(jobs -p -r | grep -c ^$LastLeavePID$) == 0  ]]
      then
	LeavePrompt &
	LastLeavePID=$!
      else
	logger -t waylandloginmanager "A handler for the command is already open" -s  >>/var/log/waylandloginmanager 2>&1
      fi
    elif [[ $COMMAND = "RegisterSession" ]]
    then
      RegisterSession
    elif [[ $COMMAND == "Info" ]]
    then
      if [[ $(jobs -p -r | grep -c ^$LastInfoPID$) == 0  ]]
      then
	ShowInfo &
	LastInfoPID=$!
      else
	logger -t waylandloginmanager "A handler for the command is already open" -s  >>/var/log/waylandloginmanager 2>&1
      fi
    elif [[ $COMMAND == "" ]]
      then
      :
    else
      logger -t waylandloginmanager "Invalid command: $COMMAND received" -s  >>/var/log/waylandloginmanager 2>&1
    fi
    sleep .0001
  done
}

#Get the TTY that will hold the Wayland server that displays the login screen.
HostVT=$(GetNextTTY)
LastTTY=$HostVT
if [[ $HostVT -eq -1 ]]
then
  logger -t waylandloginmanager "ERROR: Not Enough TTYs for login manager display!" -s  >>/var/log/waylandloginmanager 2>&1
  exit
fi

#Enable full alt+sysrq when wlmdebug is passed as a kernel argument
if [[ $(cat /proc/cmdline | grep -c wlmdebug ) != 0 ]]
then
echo 1 > /proc/sys/kernel/sysrq
logger -t waylandloginmanager "WARNING: The diagnostic 'wlmdebug' option has been passed to the kernel. This causes the waylandloginmanager to enable all magic sysrq keys, including the ability to kill processes" -s  >>/var/log/waylandloginmanager 2>&1
fi

#Start the main login Weston server
LoginWestonLauncher &

#Start the autologin launcher
StartAutoLogin &
LastLogonPID=$!

#Setup the FIFO before anything starts using the fifo, and logging for the loginmanagerdisplay
SetupLoggingAndFIFO

#Start the login managers IPC
ReadCommandFIFO
