#! /bin/bash
#    Copyright (c) 2012, 2013, 2014 nerdopolis (or n3rdopolis) <bluescreen_avenger@verzion.net>
#
#    This file is part of RebeccaBlackLinux.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

#Detect another instance
SCRIPTPATH=$(readlink -f "$0")
SCRIPTNAME=$(basename "$SCRIPTPATH")
LOCKSCRIPT=$(readlink -f "$(cat "/tmp/$SCRIPTNAME.lock" | xargs -0 echo | awk '{print $2}')" )
if [[ "$SCRIPTPATH" != "$LOCKSCRIPT" ]]
then
  rm -r "/tmp/$SCRIPTNAME.lock"
  ln -s /proc/"$$"/cmdline "/tmp/$SCRIPTNAME.lock"
else
  logger -t waylandloginmanager "Error: Another instance is already running" -s  >>/var/log/waylandloginmanager 2>&1
  exit
fi


#Require root privlages
if [[ $UID != 0 ]]
then
  echo "Must be run as root."
  exit
fi

cd /run
export DEFAULTWAYLANDSERVER=/opt/bin/weston-display-server
export PATH=/opt/bin:$PATH
export LD_LIBRARY_PATH=/opt/lib/$(dpkg-architecture -qDEB_HOST_MULTIARCH):/usr/local/lib/$(dpkg-architecture -qDEB_HOST_MULTIARCH):/usr/lib/$(dpkg-architecture -qDEB_HOST_MULTIARCH):/opt/lib:/usr/local/lib:/usr/lib
export GDK_BACKEND=wayland
export XDG_RUNTIME_DIR=/run/
export WAYLAND_DISPLAY=loginmanagerdisplay
export WSESSIONSPATH="/usr/share/wsessions.d"
export WESTON_PLUGIN_PATH=/opt/lib/$(dpkg-architecture -qDEB_HOST_MULTIARCH)/weston
LastTTY=7
AllSessions=0
ActiveSessionPID=0
export AttemptedSessionCount=0
FSTYPE=$(df / -T | awk '{print $2}' | grep -v Type)
if [[ $FSTYPE == overlayfs ]]
then
  ISLIVE=1
fi

plymouth hide-splash

#Detect hardware abilities
if [[ $(ls  /dev/dri/card* ) ]]
then 
  logger -t waylandloginmanager "Kernel mode setting found." -s  >>/var/log/waylandloginmanager 2>&1
  WESTONBACKEND=drm-backend.so
elif [[ $(ls  /dev/fb* ) ]]
then
  logger -t waylandloginmanager "No kernel mode setting found. Using the framebuffer" -s  >>/var/log/waylandloginmanager 2>&1
  WESTONBACKEND=fbdev-backend.so
else
  FSTYPE=$(df / -T | awk '{print $2}' | grep -v Type)
  if [[ $ISLIVE == 1 ]]
  then
    logger -t waylandloginmanager "ERROR: No supportable hardware found" -s  >>/var/log/waylandloginmanager 2>&1
    openvt -c 13 -s -f -w -- dialog --msgbox "No Kernel Mode Setting, or Framebuffer device found.

This means your video card does not support KMS, and doesn't create a framebuffer by default. either of which are needed for Weston to work.

You can select a Framebuffer boot option when you start the Live CD, to force a boot with a framebuffer device." 20 50 --no-cancel
  else 
    openvt -c 13 -s -f -w -- dialog --msgbox "No Kernel Mode Setting, or Framebuffer device found.

This means your video card does not support KMS, and doesn't create a framebuffer by default. either of which are needed for Weston to work.

Will now start a utility to assist you in configuring your system to boot with a framebuffer device." 20 50 --no-cancel
    openvt -c 13 -s -f -w -- rbos-add-framebuffer
  fi
  openvt -c 13 -s -f -w -- dialog --msgbox "Can not start Weston.

Will now reboot." 20 50 --no-cancel
  reboot
  exit
fi

#if the user booted with a hidden option forcefbdev
if [[ $(cat /proc/cmdline | grep -c forcefbdev ) != 0 ]]
then
  logger -t waylandloginmanager "Manually override set to use to use the framebuffer" -s  >>/var/log/waylandloginmanager 2>&1
  if [[ $(ls /dev/fb* ) ]]
  then
    WESTONBACKEND=fbdev-backend.so
  else
    logger -t waylandloginmanager "ERROR: No framebuffer device found for forcefbdev override!" -s  >>/var/log/waylandloginmanager 2>&1
    openvt -c 13 -s -f -w -- dialog --msgbox "The forcefbdev overide is set, but no framebuffer device is found!

Will now reboot" 20 50 --no-cancel
    reboot
  fi
fi


#Get the next TTY that is open for use
function GetNextTTY
{
  TTYNotInUse=0
  LastTTY=7
  while [[ $TTYNotInUse -ne 1 && $LastTTY -lt 62 ]]
  do
    ((LastTTY++))
    fuser -s /dev/tty$LastTTY
    TTYNotInUse=$?
  done

  if [[ $TTYNotInUse -ne 1 ]]
  then
    AvailibleTTY=-1
  else
    AvailibleTTY=$LastTTY
  fi

  echo $AvailibleTTY
}

function RegisterSession
{
  COMMANDSTRING=$1
  SessionTTY=$(echo "$COMMANDSTRING" | sed -ne 2p )
  SessionPID=$(echo "$COMMANDSTRING" | sed -ne 3p )
  SessionUser=$(echo "$COMMANDSTRING" | sed -ne 4p )
  SessionID=$(echo "$COMMANDSTRING" | sed -ne 5p )
  AllSessionTTYs[$AllSessions]=$SessionTTY
  AllSessionPIDs[$AllSessions]=$SessionPID
  AllSessionUsers[$AllSessions]=$SessionUser
  AllSessionIDs[$AllSessions]=$SessionID
  ActiveSessionPID=$SessionPID
  ((AllSessions++))
}

function DialogWait
{
  waitseconds=$1
  countseconds=0
  while [[ $countseconds -lt $waitseconds ]]
  do
    percent=$(( $countseconds * 100 / $waitseconds ))
    echo $percent
    ((countseconds++))
    sleep 1
  done | zenity --title="autologin" --no-cancel --progress --auto-close --text="Waiting for Autologin timeout..." 2>/dev/null
}

function ChooseSessionType
{
  export SESSIONID=$AttemptedSessionCount

  if [[ $WESTONBACKEND == "fbdev-backend.so" ]]
  then
    BackendType=FB
  elif [[ $WESTONBACKEND == "drm-backend.so" ]]
  then
    BackendType=KMS
  fi

  #Parse the list of sessions specified, so that zenity can use it as a list of sessions
  WSESSIONLIST=$(find $WSESSIONSPATH -name "*\.desktop" -type f -executable | sort | while read SESSIONFILE
  do 
    DesktopFileData=$(awk '/^\[*\]$/{flag=0}flag;/^\[Desktop Entry\]$/{flag=1}' $SESSIONFILE | awk -F \# '{print $1}')

    Enabled=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "Enabled" {print $0}' | cut -d = -f2- | tail -1 )
    SessionName=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "Name" {print $0}' | cut -d = -f2- | tail -1 )
    Type=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "Type" {print $0}' | cut -d = -f2- | tail -1 )
    SupportsBackend=$(echo "$DesktopFileData" | awk -v BackendType=$BackendType -F ' *= *' '$1 == "CompositorSupports"BackendType {print $0}' | cut -d = -f2- | tail -1 )
    CompositorDisplayArgument=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "CompositorDisplayArgument" {print $0}' | cut -d = -f2- | tail -1 )
    BackendArguments=$(echo "$DesktopFileData" | awk -v BackendType=$BackendType -F ' *= *' '$1 == "Compositor"BackendType"Arguments" {print $0}' | cut -d = -f2- | tail -1 )
    SessionArgument=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "SessionArgument" {print $0}' | cut -d = -f2- | tail -1 )
    AdditionalArguments=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "AdditionalArguments" {print $0}' | cut -d = -f2-| tail -1 )
    CompositorExec=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "CompositorExec" {print $0}' | cut -d = -f2- | tail -1 )
    EnvironmentFile=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "EnvironmentFile" {print $0}' | cut -d = -f2- | tail -1 )
    NeedsFile=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "NeedsFile" {print $0}' | cut -d = -f2- | perl -pe 's/\$(\w+)/$ENV{$1}/g')

    NotFoundCount=0
    while read FILE
    do
      if [[ ! -e $FILE ]]
      then
	((NotFoundCount++))
      fi
    done < <(echo "$NeedsFile")

    if [[ ! -z $CompositorDisplayArgument ]]
    then
      CompositorDisplayArgument="$CompositorDisplayArgument$SESSIONID"
    else 
      CompositorDisplayArgument=""
    fi

    if [[ $NotFoundCount == 0 && $SupportsBackend == 1 && $Enabled == 1 && $Type == "WSession" ]]
    then
      echo "$CompositorExec"
      echo "$BackendArguments"
      echo "$SessionArgument"
      echo "$AdditionalArguments"
      echo "$CompositorDisplayArgument"
      echo "$EnvironmentFile"
      echo "$BackendType"
      echo "$SessionName"
    fi
  done)

  if [[ ! -z $WSESSIONLIST ]]
  then
    PROMPTED=1
    #select the session
    WSESSIONDATA=$(echo "$WSESSIONLIST" | zenity --title="Pick a Session..." --height=450 --list --text "Select a Wayland Desktop Environment to use" --column compositor --column backend --column session --column args --column displayargs --column environment --column backendtype --column name --hide-column=1,2,3,4,5,6,7 --print-column=1,2,3,4,5,6,7,8 --separator="\n" --hide-header 2>/dev/null )
  else 
    unset WSESSIONDATA
  fi

  if [[ -z $WSESSIONDATA ]]
  then 
    if [[ $PROMPTED == 1 ]]
    then
      zenity --warning --text="No session selected. Defaulting to the Default Weston Desktop Shell." 2>/dev/null
    else
      logger -t waylandloginmanager "No sessions installed in $WSESSIONSPATH or no sessions are enabled, or are missing files specified by NeedsFile values" -s  >>/var/log/waylandloginmanager 2>&1
    fi
    export SelectedCompositorExec=weston
    if [[ $BackendType == KMS ]]
    then
      export WSESSIONDATA=$(echo "$DEFAULTWAYLANDSERVER
--backend=drm-backend.so
--modules=desktop-shell.so,xwayland.so,cms-colord.so
--log=\$HOME/weston.log
--socket=$SESSIONID

KMS
Default Weston Desktop Shell
")
    elif [[ $BackendType == FB ]]
    then 
      export WSESSIONDATA=$(echo "$DEFAULTWAYLANDSERVER
--backend=fbdev-backend.so
--modules=desktop-shell.so,xwayland.so,cms-colord.so
--log=\$HOME/weston.log
--socket=$SESSIONID

FB
Default Weston Desktop Shell
")
    fi
  fi
}

function ShowInfo
{
  if [[ $WESTONBACKEND == "fbdev-backend.so" ]]
  then
    BACKENDSTRING="Weston is using the framebuffer backend.

This probably means the current video card drivers do not 
support the native kernel mode setting that is optimal for Weston."
  else
    BACKENDSTRING="Your system is using Weston with Kernel mode setting.

This is the optimal way to run Weston."
  fi
  zenity --title="Information" --no-wrap --info --text="This is a third party fan made distribution!

$BACKENDSTRING

Login manager is running on tty: $HostVT

The key icon brings up a login prompt
The arrow icon brings up a prompt to swich between running sessions
The red X icon brings up a shutdown prompt
The i icon shows this help prompt" 2>/dev/null

}

function SwitchUserDialog 
{
  unset SessionList
  NumberOfSessions=${#AllSessionPIDs[@]}
  ((NumberOfSessions--))

  while [[ $NumberOfSessions -ge 0 ]]
  do
    if [[ -e /proc/${AllSessionPIDs[$NumberOfSessions]}/environ ]]
    then
      SessionList+="$NumberOfSessions
${AllSessionTTYs[$NumberOfSessions]}
${AllSessionPIDs[$NumberOfSessions]}
${AllSessionUsers[$NumberOfSessions]}
${AllSessionIDs[$NumberOfSessions]}
"
    fi
    ((NumberOfSessions--))
  done

  SessionList+="-1


New Session...

"


  unset ChangeSession
  ChangeSession=$(echo "$SessionList"  | sed '$d'| zenity --title="Switch User" --height=450 --list --text "Select a running session to change into" --hide-header --column sessionid --column tty --column pid --column username --column ID --print-column=1 --hide-column=3,5 --separator="\n" 2>/dev/null | head -1 )

  if [[ $ChangeSession == "-1" ]]
  then
    GetUserCredentials
  else 
    if [[ $ChangeSession ]]
    then
      ChangeSessionPID=${AllSessionPIDs[$ChangeSession]}
      ChangeSessionTTY=${AllSessionTTYs[$ChangeSession]}
      ChangeSessionID=${AllSessionIDs[$ChangeSession]}

      if [[ -e /proc/$ChangeSessionPID/environ ]]
      then
	chvt 63
	chvt $ChangeSessionTTY
	loginctl activate $ChangeSessionID
	ActiveSessionPID=$ChangeSessionPID
      else
	zenity --title="Switch User" --warning --text="The selected session was not found. The session may have quit." 2>/dev/null
      fi
    fi
  fi
}

#Function that starts the user sessions
function StartUserSession 
{
  #unset most varaibles
  while read var
  do 
    unset $var
  done < <(env | awk -F = '{print $1}' | grep -v ^PATH$ ) 
  WSESSIONARGS=$(echo "$3" | sed 's/$/ /g')
  WESTONTTY=$1
  LOGINUSER=$2
  IFS=$'\n'
  WSESSIONDATA=($WSESSIONARGS)
  unset IFS

  #Change to the users homepath so weston starts in the right place, and set some varaibles for the user
  export HOME=$(eval echo ~$LOGINUSER)
  export LOGNAME=$LOGINUSER
  export USER=$LOGINUSER
  export USERNAME=$LOGINUSER
  cd $HOME

  CompositorExec="$( echo "${WSESSIONDATA[0]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  BackendArguments="$( echo "${WSESSIONDATA[1]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  SessionArgument="$( echo "${WSESSIONDATA[2]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  AdditionalArguments="$( echo "${WSESSIONDATA[3]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  CompositorDisplayArgument="$( echo "${WSESSIONDATA[4]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  export EnvironmentFile="$( echo "${WSESSIONDATA[5]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  export BackendType="$( echo "${WSESSIONDATA[6]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  export SessionName="$( echo "${WSESSIONDATA[7]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"

  #determine if weston is the normal weston, or if weston has been replaced by the westonlaunchcaller
  westonresult=$(weston --version &>/dev/null; echo $?) 

  #Call the server
  logger -t waylandloginmanager "Starting server $CompositorExec with the arguments of $BackendArguments $SessionArgument $AdditionalArguments $CompositorDisplayArgument for user $LOGINUSER on tty $WESTONTTY" -s  >>/var/log/waylandloginmanager 2>&1
  chvt 63
  if [[ $westonresult == 255 ]]
  then
    openvt -f -s -c $WESTONTTY -- weston-launch --user=$LOGINUSER --tty=/dev/tty$WESTONTTY -- $CompositorExec @@ "$BackendArguments"  "$SessionArgument" "$AdditionalArguments" "$CompositorDisplayArgument" &>> /var/log/userwaylandsession.log
  else
    logger -t waylandloginmanager "WARNING: the weston executable has not been replaced with westonlaunchcaller. Execution of custom Wayland servers will not work." -s  >>/var/log/waylandloginmanager 2>&1
    openvt -f -s -c $WESTONTTY -- weston-launch --user=$LOGINUSER --tty=/dev/tty$WESTONTTY -- "$BackendArguments"  "$SessionArgument" "$AdditionalArguments" "$CompositorDisplayArgument" &>> /var/log/userwaylandsession.log
  fi
  sleep 5
  WESTONPID=$(ps --tty /dev/tty$WESTONTTY | sed -n 2p | awk '{print $1}')
  #Find the logind session id
  SESSIONS=$(loginctl  list-sessions |grep "        c" |awk '{print $1}')
  while read SESSION
  do
    SessionPid=$(loginctl show-session $SESSION -p Leader |awk -F = '{print $2}')
    if [[ $SessionPid == $WESTONPID ]]
    then
      LOGINDSESSION=$SESSION
      break
    fi
  done < <(echo "$SESSIONS")

  loginctl activate $LOGINDSESSION

  echo "RegisterSession
$WESTONTTY
$WESTONPID
$LOGNAME
$LOGINDSESSION" > /run/loginmanager_control
}

#Test users credentials
function AuthenticateUser
{
  PasswordSalt=$(cat /etc/shadow | awk -v LOGINUSER=$LOGINUSER -F ':' '$1 == LOGINUSER {print $2}')
  IFS=\$
  PasswordSaltData=($PasswordSalt)
  unset IFS

  PasswordSaltType=${PasswordSaltData[1]}
  PasswordSaltBytes=${PasswordSaltData[2]}
  if [[ ! -z $PasswordSaltBytes ]]
  then
    if [[ $PasswordSaltType == 1 ]]
    then
      PasswordSaltType="-m MD5"
    elif [[ $PasswordSaltType == 5 ]]
    then
      PasswordSaltType="-m SHA-256"
    elif [[ $PasswordSaltType == 6 ]]
    then
      PasswordSaltType="-m SHA-512"
    fi
  else 
    PasswordSaltType=""
    PasswordSaltBytes=$(echo $PasswordSaltData | cut -c -2 )
  fi
  TryPassword=$(cat -)
  TryPasswordSalt=$(echo $TryPassword | mkpasswd -s $PasswordSaltType -S $PasswordSaltBytes )
  unset PasswordSaltBytes
  unset PasswordSaltData
  unset PasswordSaltType
  if [[ $PasswordSalt == $TryPasswordSalt ]]
  then
    unset PasswordSalt
    unset TryPasswordSalt

    export USERHOME=$(eval echo ~$LOGINUSER)
    if [[ -e $USERHOME/.ecryptfs ]]
    then
      echo "spawn login $LOGINUSER
expect Password 
send $TryPassword\r
sleep 30
exit" |expect &
      sleep 3
    fi

    unset TryPassword

    StartUserSession "$SessionTTY" "$LOGINUSER" "$WSESSIONDATA" &
    return 0
  else
      unset TryPassword
      unset PasswordSalt
      unset TryPasswordSalt
      return 1
  fi
}



#Attempt to get the users authentication
function GetUserCredentials
{
  #Get the list of nonsystem users
  UIDMIN=$(cat /etc/login.defs | grep -e "^UID_MIN" | awk '{print $2}')
  UIDMAX=$(cat /etc/login.defs | grep -e "^UID_MAX" | awk '{print $2}')
  USERLIST=$(cat /etc/passwd | awk -v UIDMIN=$UIDMIN -v UIDMAX=$UIDMAX -F : '{ if ($3>=UIDMIN && $3 <=UIDMAX) print $1}')
  if [[ $ISLIVE == 1 ]]
  then
    LIVEUSER=$(cat /etc/passwd | awk -v UIDMIN=999 -v UIDMAX=999 -F : '{ if ($3>=UIDMIN && $3 <=UIDMAX) print $1}' )
    USERLIST+="
$LIVEUSER"
  fi
  USERLIST=$(echo "$USERLIST" | sort |uniq)

  ChooseSessionType

  #present the list of the users to the system
  export LOGINUSER=$(echo "$USERLIST" | zenity --title="Username" --height=450 --list --text "Select a user from the list to log into."  --column users  --hide-header --separator="\n" 2>/dev/null | head -1 | grep -v 'startup message: remove:')

  #if there is no user selected then show a dialog. If a user was selected, prompt for its login
  if [[ -z $LOGINUSER ]]
  then
    zenity --warning --text="No User selected" 2>/dev/null
  else
    export SessionTTY=$(GetNextTTY)
    if [[ $SessionTTY -ne -1 ]]
    then
      logger -t waylandloginmanager "Opening a session for $LOGINUSER on TTY $SessionTTY" -s  >>/var/log/waylandloginmanager 2>&1
      zenity --title="Password" --password --text "Type Password for $LOGINUSER" 2>/dev/null| grep -v 'startup message: remove:' | AuthenticateUser
      passwordresult=${PIPESTATUS[2]}

      if [[ $passwordresult != 0 ]]
      then
	zenity --warning --text="Invalid password for $LOGINUSER" 2>/dev/null
      fi
    else
      zenity --warning --text="Not Enough TTYs!"
      logger -t waylandloginmanager "Not Enough TTYs for user login!" -s  >>/var/log/waylandloginmanager 2>&1
    fi
  fi
}


#Funtion for prompting for leave options
function LeavePrompt
{
  ACTION=$(echo "Shutdown
Shutdown Computer
Restart
Restart Computer
Standby
Standby Computer
Hybrid Sleep
Hybrid Sleep
Hibernate
Hibernate Computer" | zenity --title="Leave..." --height=450 --list  --hide-header --text="What do you want to do?" --separator="\n" --column 'action' --column 'useraction' --print-column=1 --hide-column=1 2>/dev/null | head -1 | grep -v 'startup message: remove:' )
  if [[ $ACTION == "Shutdown" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.PowerOff boolean:true
    RESULT=$?
  elif [[ $ACTION == "Restart" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Reboot boolean:true
    RESULT=$?
  elif [[ $ACTION == "Standby" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Suspend boolean:true
    RESULT=$?
  elif [[ $ACTION == "Hybrid Sleep" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.HybridSleep boolean:true
    RESULT=$?
  elif [[ $ACTION == "Hibernate" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Hibernate boolean:true
    RESULT=$?
  else
    exit
  fi
  if [[ $RESULT != 0 ]]
  then
    zenity --title="Failure" --warning --text="Failed to $ACTION" 2>/dev/null
  fi
}





#Call the host server for the login gui, running as a seperate user
function LoginWestonLauncher
{

  while [ 1 ]
  do

    if [[ ! -e /run/loginmanagerdisplay ]]
    then 
      #determine if weston is the normal weston, or if weston has been replaced by the westonlaunchcaller
      westonresult=$(weston --version &>/dev/null; echo $?) 
      logger -t waylandloginmanager "Starting the loginmanagerdisplay on tty $HostVT" -s  >>/var/log/waylandloginmanager 2>&1
      if [[ $westonresult == 255 ]]
      then
	openvt -f -s -c $HostVT -- weston-launch --tty=/dev/tty$HostVT --user=root -- $DEFAULTWAYLANDSERVER @@ --backend=$WESTONBACKEND --socket=loginmanagerdisplay --modules=desktop-shell.so --log=/var/log/loginmanagerdisplay.log &>> /var/log/loginmanagerdisplay.log
      else
	logger -t waylandloginmanager "WARNING: the weston executable has not been replaced with westonlaunchcaller. Execution of custom Wayland servers will not work." -s  >>/var/log/waylandloginmanager 2>&1
	openvt -f -s -c $HostVT -- weston-launch --tty=/dev/tty$HostVT --user=root -- --backend=$WESTONBACKEND --socket=loginmanagerdisplay --modules=desktop-shell.so --log=/var/log/loginmanagerdisplay.log &>> /var/log/loginmanagerdisplay.log 
      fi
    fi
    sleep 15
  done
}




function StartAutoLogin
{
  if [[ -e /etc/waylandloginmanager.conf ]]
  then
    AUTOLOGINUSER=$(cat /etc/waylandloginmanager.conf | grep autologin-user= | awk -F = '{print $2}' | head -1 )
  else
    AUTOLOGINUSER=$(cat /etc/lightdm/lightdm.conf | grep autologin-user= | awk -F = '{print $2}' | head -1 )
    echo "autologin-user=$AUTOLOGINUSER" >> /etc/waylandloginmanager.conf
  fi

  if [[ ! -z $AUTOLOGINUSER ]]
  then
    sleep 5
    ChooseSessionType
    export AutoSessionTTY=$(GetNextTTY)
    if [[ $AutoSessionTTY -ne -1 ]]
    then
      logger -t waylandloginmanager "Starting Autologin session for $AUTOLOGINUSER on TTY $AutoSessionTTY" -s  >>/var/log/waylandloginmanager 2>&1
      StartUserSession "$AutoSessionTTY" "$AUTOLOGINUSER" "$WSESSIONDATA" &
    else
      zenity --warning --text="Not Enough TTYs for autologin!"
      logger -t waylandloginmanager "Not Enough TTYs for autologin!" -s  >>/var/log/waylandloginmanager 2>&1
    fi
  fi 
}

function SetupFIFO
{
  #Create communication fifo.
  rm -r /run/loginmanager_control
  mkfifo -m 777 /run/loginmanager_control
}

#This process wakes the fifo, at a given interval so that the main 'thread' can wake and perform maintenance tasks, that require access to the environment, that would require some type of environment syncing if it was in a subshell. 
function FIFOWaker
{
  while [ 1 ]
  do
    echo "Wake" > /run/loginmanager_control
    sleep 1
  done
}


#The part of the script that reads the FIFO for IPC from users logoff dialogs, the helper scripts on the login window, or the session startup scripts
function ReadCommandFIFO
{

  while [ 1 ]
  do

    if [[ $ActiveSessionPID != 0 && ! -e /proc/$ActiveSessionPID/environ ]]
    then
      if [[ $(fgconsole) != $HostVT ]]
      then
	chvt 63
	chvt $HostVT
      fi
      ActiveSessionPID=0
    fi

    COMMAND=$(cat /run/loginmanager_control)
    if [[ $COMMAND != "Wake" ]]
    then
      logger -t waylandloginmanager "received command $COMMAND" -s  >>/var/log/waylandloginmanager 2>&1
    fi

    if [[ $COMMAND == "Switch" ]]
    then
      if [[ $(fgconsole) != $HostVT ]]
      then
	chvt 63
	chvt $HostVT
      fi
      SwitchUserDialog &
    elif [[ $COMMAND == "Change" ]]
    then
      if [[ $(fgconsole) != $HostVT ]]
      then
	chvt 63
	chvt $HostVT
      fi
    elif [[ $COMMAND == "Login" ]]
    then
      export AttemptedSessionCount=$((AttemptedSessionCount+1))
      GetUserCredentials &
    elif [[ $COMMAND == "Leave" ]] 
    then
      LeavePrompt &
    elif [[ $COMMAND = RegisterSession* ]]
    then
      RegisterSession "$COMMAND"
    elif [[ $COMMAND == "Info" ]]
    then
      ShowInfo &
    elif [[ $COMMAND == "Wake" ]]
      then
      :
    else
      logger -t waylandloginmanager "Invalid command" -s  >>/var/log/waylandloginmanager 2>&1
    fi
  done
}

#Get the TTY that will hold the Wayland server that displays the login screen.
HostVT=$(GetNextTTY)
LastTTY=$HostVT
if [[ $HostVT -eq -1 ]]
then
  logger -t waylandloginmanager "ERROR: Not Enough TTYs for login manager display!" -s  >>/var/log/waylandloginmanager 2>&1
  exit
fi

#Start the main login Weston server
LoginWestonLauncher &

#Start the autologin launcher
export AttemptedSessionCount=$((AttemptedSessionCount+1))
StartAutoLogin &

#Setup the FIFO before anything starts using the fifo
SetupFIFO

#Start the loop that wakes the main FIFO at an interval so that the main loop can wake and perform tasks
FIFOWaker &

#Start the login managers IPC
ReadCommandFIFO
