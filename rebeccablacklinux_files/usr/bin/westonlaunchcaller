#! /bin/bash
#    Copyright (c) 2012, 2013, 2014 nerdopolis (or n3rdopolis) <bluescreen_avenger@verzion.net>
#
#    This file is part of RebeccaBlackLinux.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

#This file is called by weston-launch, it's meant to replace /opt/bin/weston (while /opt/bin/weston is redirected to /opt/bin/weston-display-server for example)
#This does some other things for waylandloginmanager, such as specify a different, but sanctioned server path in /etc/waylandservers, and send the Change command back to the Waylandloginmanager to make it switch back to the TTY if the server execution fails.
#Weston-launch assists with running commands as an arbitrary user, on a tty, and registering it as a new logind session, so while many other items in /etc/waylandservers are the server specific setuid helpers, weston-launch does more, and not all compositors have setuid helpers.

#This also handles specified environment files for the session, which are documented in /usr/share/wsession/aboutwsessions.txt

#This also handles the automatic execution of a host Wayland server, if the Wayland session runs on fullscreen-shell enabled servers as opposed to direct access to hardware

#Enable job control in this script
set -m

#Exit function. Sends the "change" command to the waylandloginmanager FIFO in case of failure
function SwitchBackExit
{
  echo -e "\nChange" > /run/waylandloginmanager/loginmanager_control
  exit
}

#Function to terminate the host server if the guest server dies, so the user isn't left with a blank screen. First argument is the PID of the guest server, second argument is the pid of the host server that gets terminated when the guest PID dies
function TerminateHostOnGuestTermination
{
  ServerStatus=0
  while [[ $? == 0 ]]
  do
    sleep 5
    ps -p $1 > /dev/null
  done
  kill -15 $2
}

#if called with --version as the first argument, exit with 255. This is used by the waylandloginmanager to test if this script is redirecting Weston.
if [[ $1 == "--version" ]]
then
  echo "waylandloginmanager weston-launch addon"
  exit 255
fi


#set up the environment for the user. Determine the user name, set Wayland variables, and if the current session has an environment file then handle it.
USER=$(id -u)
. /usr/bin/wlruntime_vars
BackendType=$(echo $BackendType | sed 's/^ *//;s/ *$//')
EnvironmentFile=$(echo $EnvironmentFile | sed 's/^ *//;s/ *$//')
if [[ -e $EnvironmentFile ]]
then
  #parse the session event file if specified, and it exists
  EnvironmentFileData=$(awk '/^\[*\]$/{flag=0}flag;/^\[EnvironmentFile\]$/{flag=1}' $EnvironmentFile | awk -F \# '{print $1}')
  while read LINE
  do
    #environment files are specified as action=var=data
    #Examples
    #set=varname=data sets variable called varname, with the content of data.
    #unset=varname unsets a variable called varname
    #unset=varname@FB unsets a variable called varname ONLY if the current backend is FB. waylandloginmanager tells this script what the current backend is
    VARACTION=$(echo $LINE    | awk -F ' *@ *' '{print $1}' | awk -F ' *= *' '{print $1}' | sed 's/^ *//;s/ *$//')
    VARNAME=$(echo $LINE      | awk -F ' *@ *' '{print $1}' | awk -F ' *= *' '{print $2}' | sed 's/^ *//;s/ *$//')
    VARDATA=$(echo $LINE      | awk -F ' *@ *' '{print $1}' | awk -F ' *= *' '{print $3}' | sed 's/^ *//;s/ *$//')
    VARBACKEND=$(echo $LINE   | awk -F ' *@ *' '{print $2}' | sed 's/^ *//;s/ *$//')

    #if the backend for this line is unspecified, OR if the backend on this line matches the current one running then handle the variable
    if [[ -z $VARBACKEND || $VARBACKEND == $BackendType ]]
    then
      #if it is set, then set the variable
      if [[ $VARACTION == "set" ]]
      then
	export $VARNAME=$VARDATA
      fi

      #if it is unset, then unset the variable
      if [[ $VARACTION == "unset" ]]
      then
	unset $VARNAME
      fi

    fi
  done < <(echo "$EnvironmentFileData")
fi

#set all arguments into an array
IFS=''
ArgArray=("$@")
unset IFS

#Clean up trailing white space from the end of all arguments
for (( element = 0 ; element < ${#ArgArray[@]} ; element++ ))
do
  ArgArray[$element]=$(echo "${ArgArray[$element]}" | sed 's/^ *//;s/ *$//')
done
SecondArg="${ArgArray[1]}"

#If the second argument is @@, that means run a custom server. Only run it if the server is specified in /etc/waylandservers
if [[ "$SecondArg" == "@@" ]]
then
  Server="${ArgArray[0]}"

  if [[ $USER != 0 ]]
  then
    #Detrermine if the server is safe
    ServerApprovedCount=$(cat /etc/waylandservers | grep -c "^$Server$")
  else
    ServerApprovedCount=1
  fi

  #if the server is not in /etc/waylandservers then exit. if it is, then run the server
  if [[ $ServerApprovedCount == 0 ]]
  then 
    echo "Unapproved Wayland Server $Server attempted to Execute. Server binary path will need to be added to /etc/waylandservers in order to run." |& tee -a $HOME/waylandserver.log
    SwitchBackExit
  else 
    if [[ $BackendType == WL ]]
    then
      if [[ $DefaultBackendType == FB ]]
      then
	HostBackendArgument="--backend=fbdev-backend.so"
      else
	HostBackendArgument="--backend=drm-backend.so"
	if [[ $IsFallbackSession == 1 ]]
	then
	  HostBackendArgument+=" --use-pixman"
	fi
      fi
      weston-display-server --no-config --shell=fullscreen-shell.so --socket=$WAYLAND_HOST --log=$HOME/waylandhost.log $HostBackendArgument &
      HostServerPID=$!
      export WAYLAND_DISPLAY=$WAYLAND_HOST
      WaitTimes=0
      #Wait for the server to start up for a maximum of 15 seconds. As soon as the socket is created, the wait loop ends
      while [[ ! -e $XDG_RUNTIME_DIR/$WAYLAND_DISPLAY && $WaitTimes<15 ]]
      do
	sleep 1
	((WaitTimes++))
      done
      #If the socket doesn't exist, then the server failed to start, and switch back
      if [[ ! -e $XDG_RUNTIME_DIR/$WAYLAND_DISPLAY ]]
      then
	SwitchBackExit
      fi
    else
      export WAYLAND_DISPLAY=$WAYLAND_GUEST
      unset WAYLAND_HOST
    fi
    STARTTIME=$(date +%s)
    #Execute the Wayland server, and log it to ~/waylandserver.log
    "${ArgArray[0]}" ${ArgArray[@]:2} |& tee -a $HOME/waylandserver.log &
    GuestServerPID=$!
    if [[ $BackendType == WL ]]
    then
      TerminateHostOnGuestTermination $GuestServerPID $HostServerPID &
    fi
    fg 1
    ENDTIME=$(date +%s)
    RUNTIME=$((ENDTIME-STARTTIME))
    #If the server only ran for 5 seconds, assume it crashed, and switch back. This should cover the time it would take until RegisterSession in Waylandloginmanager handles it. If it is longer than 5 seconds, don't switch back as the user could have another session active.
    if [[ $RUNTIME < 45 ]]
    then
      SwitchBackExit
    fi
  fi
#If @@ is not passed as the second argument, pass all arguments to weston-display-server by default
else
  weston-display-server ${ArgArray[@]}
fi