#! /bin/bash
#    Copyright (c) 2012, 2013, 2014 nerdopolis (or n3rdopolis) <bluescreen_avenger@verzion.net>
#
#    This file is part of RebeccaBlackLinux.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

#This script tries to convert upstart files into systemd files

#Require root privlages
if [[ $UID != 0 ]]
then
  echo "Must be run as root."
  exit
fi


#Where to put extracted scripts/environment files from upstart files, where upstart files are, where systemd files are
UnitHelperPath=/etc/upstart2systemd/
UpstartPath=/etc/init
SystemdPath=/etc/systemd

#Set up the environment for converting an upstart job, for each file
function PrepareEnvironment {

#Create an editable template with replaceable strings for AddToFile 
#SystemdUnitSkel is an array, and the element ID is the file template ID
  SystemdUnitSkel[SERVICE]="
[Unit]
@UNITABOVE@
@UNITBELOW@

[Service]
@SERVICEABOVE@
@SERVICEBELOW@

[Install]
@INSTALLABOVE@
@INSTALLBELOW@
"

}

#Get data from the unit files. This takes the argument of the upstart file to convert
function ParseUpstartFile {
  if [[ ! -e $1 ]]
  then
    echo "Upstart File Not Found"
    return 1
  fi
  #Get the contents of the file
  UNITDATA=$(cat $1)
  UnitFileName=$(basename $1 | awk -F .conf '{print $1}' )
  UnitHelperPath=$UnitHelperPath/$UnitFileName
  if [[ -e $SystemdPath/$UnitFileName.conf ]]
  then
    echo "$UnitFileName already converted"
    return 2
  else
    return 0
  fi
}

#Create a script file with data extracted from Upstart unit files, takes argument of script type (as in post-exec pre-stop)
function CreateExecScript {

}

#Takes an argument of one string, that should be the start on/ stop on conditions extracted from an upstart unit file
function HeuristicStartStopOn {

}

#get pre exec commands
function ConvertPreExec {
  ExecPreExecScript=$(echo "$UNITDATA" | sed -n "/pre-start\Wscript/,/end\Wscript/p" | sed "s/end\Wscript//g" | sed "s/pre-start\Wscript//g")
  if [[ -z $ExecPreExecScript ]]
  then

  ExecPreExecLine=$(echo "$UNITDATA" | sed -n "/pre-start\Wscript/p" | sed "s/pre-start\Wexec//g")
}


#get exec start commands 
function ConvertExec {
  ExecExecScript=$(echo "$UNITDATA" | sed -n "/^\Wscript/,/end\Wscript/p" | sed "s/end\Wscript//g" | sed "s/^\Wscript//g")
  ExecExecLine=$(echo "$UNITDATA" | sed -n "/exec/p" | sed "s/exec//g")
}

#get post exec commands
function ConvertPostExec {
  ExecPostExecScript=$(echo "$UNITDATA" | sed -n "/post-start\Wscript/,/end\Wscript/p"  | sed "s/end\Wscript//g" | sed "s/post-start\Wscript//g")
  ExecPostExecLine=$(echo "$UNITDATA" | sed -n "/post-start\Wscript/p" | sed "s/post-start\Wexec//g")
}


#get pre stop commands
function ConvertPreStop {
  ExecPreStopScript=$(echo "$UNITDATA" | sed -n "/pre-stop\Wscript/,/end\Wscript/p" | sed "s/end\Wscript//g" | sed "s/pre-stop\Wscript//g")
  ExecPreStopLine=$(echo "$UNITDATA" | sed -n "/pre-stop\Wscript/p" | sed "s/pre-stop\Wexec//g")
}

#get post stop commands
function ConvertPostStop {
  ExecPostStopScript=$(echo "$UNITDATA" | sed -n "/post-stop\Wscript/,/end\Wscript/p"  | sed "s/end\Wscript//g" | sed "s/post-stop\Wscript//g")
  ExecPostStopLine=$(echo "$UNITDATA" | sed -n "/post-stop\Wscript/p" | sed "s/post-stop\Wexec//g")
}


#get the environment strings
function ConvertEnvironment {
  EnvironmentStrings=$(echo "$UNITDATA" | sed -n "/env/ p")
}

#Get if the unit file specifies forking
function ConvertForkingStatus {
  IsForking=$(echo "$UNITDATA" | grep -Ec "expect\Wfork|expect\Wdaemon")
}

#Get all limit status
function ConvertLimitEntries {
  LimitData=$(echo "$UNITDATA" | sed -nE '/^limit\W/p')
  #Conversion for limit lines
  while read LINE
  do
    LimitLine=($LINE)
    LimitType=$(echo ${LimitLine[1]} | tr [:lower:] [:upper:])
    SoftLimit=${LimitLine[2]}
    HardLimit=${LimitLine[3]}
    if [[ -z $HardLimit ]]
    then
      HardLimit=$SoftLimit
    fi
    echo "limit$LimitType=$HardLimit"
  done < <(echo $LimitData)
}

#Get the unit files start on conditions
function ConvertStartOn {
  ParenthCount=0
  StartOnData=$(echo "$UNITDATA" | sed -n "/start\Won/,//p" |while read LINE
  do
    OpenCount=$(echo $LINE  | tr -cd '\(' | wc -c )
    CloseCount=$(echo $LINE | tr -cd '\)' | wc -c )
    ParenthCount=$(( ParenthCount + OpenCount ))
    ParenthCount=$(( ParenthCount - CloseCount ))
    echo $LINE
    #When all parenths are closed then thats the end of the start on info
    if [[ $ParenthCount == 0 ]]
    then
      break
    fi
  done)
  HeuristicStartStopOn $StartOnData
}


#Get the unit files stop on conditions
#function ConvertStopOn
#{
#  ParenthCount=0
#  StopOnData=$(echo "$UNITDATA" | sed -n "/stop\Won/,//p" |while read LINE
#  do
#    OpenCount=$(echo $LINE  | tr -cd '\(' | wc -c )
#    CloseCount=$(echo $LINE | tr -cd '\)' | wc -c )
#    ParenthCount=$(( ParenthCount + OpenCount ))
#    ParenthCount=$(( ParenthCount - CloseCount ))
#    echo $LINE
#    #When all parenths are closed then thats the end of the stop on info
#    if [[ $ParenthCount == 0 ]]
#    then
#      break
#    fi
#  done)
#  HeuristicStartStopOn $StopOnData
#}







#Function to add to the building unit file. first argument is INI segment (SERVICE UNIT or INSTALL), second argument is if it should be at the top or bottom of the segment, third argument is the file array that should be edited for example the SERVICE or the TARGET, fourth argument is the quoted string
function AddToFile {
  Segment=$(echo $1 | tr [:lower:] [:upper:])
  Destination=$(echo $2 | tr [:lower:] [:upper:])
  UnitSkel=$(echo $3 | tr [:lower:] [:upper:])
  IFS=$'\n'
  StringArray=($4)
  unset IFS

  if [[ $Destination == "BELOW" ]]
  then
    for (( element = 0 ; element < ${#StringArray[@]} ; element++ ))
    do
      InsString=$(echo ${StringArray[$element]} | sed -e 's/[]\/()$*.^|[]/\\&/g' | sed 's/\&/\\&/g')
      if [[ ! -z $InsString ]]
      then
	SystemdUnitSkel[$UnitSkel]=$(echo "${SystemdUnitSkel[$UnitSkel]}" | sed "s/@$Segment$Destination@/$InsString\n@$Segment$Destination@/g")
      fi
    done
  elif [[ $Destination == "ABOVE" ]]
  then
    for (( element = $(( ${#StringArray[@]} -1 )) ; element >= 0 ; element-- ))
    do
      InsString=$(echo ${StringArray[$element]} | sed -e 's/[]\/()$*.^|[]/\\&/g' | sed 's/\&/\\&/g')
      if [[ ! -z $InsString ]]
      then
	SystemdUnitSkel[$UnitSkel]=$(echo "${SystemdUnitSkel[$UnitSkel]}" | sed "s/@$Segment$Destination@/@$Segment$Destination@\n$InsString/g")
      fi
    done
  fi
}

#Remove the replaceable marker strings before the file is actually written
function FinalizeFiles {
  SystemdUnitSkel[$UnitSkel]=$(echo "${SystemdUnitSkel[$UnitSkel]}" | sed '/^@*@/d')
}


function ConvertOneFile {
  #Initilize
  PrepareEnvironment
  ParseUpstartFile $1
  ExitResult=$?
  if [[ $ExitResult != 2 ]]
  then
    #Finalize
    FinalizeFiles
  fi
}


#Convert all upstart jobs to systemd files if no argument specified, and if an argument is specified, convert the full path
if [[ ! -z $1 ]]
then
  find $UpstartPath | while read FILE
  do
    ConvertOneFile $FILE
  done
else
  ConvertOneFile $UpstartPath/$1
fi