#! /bin/bash
#    Copyright (c) 2012, 2013, 2014 nerdopolis (or n3rdopolis) <bluescreen_avenger@verzion.net>
#
#    This file is part of RebeccaBlackLinux.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

#This script tries to convert upstart files into systemd files

#Require root privlages
if [[ $UID != 0 ]]
then
  echo "Must be run as root."
  exit
fi

#Where to put extracted scripts/environment files from upstart files
UnitHelperPath=/etc/upstart2systemd/

SystemdUnitSkel[SERVICE]="
[Unit]
@UNITABOVE@
@UNITBELOW@

[Service]
@SERVICEABOVE@
@SERVICEBELOW@

[Install]
@INSTALLABOVE@
@INSTALLBELOW@
"

#Get data from the unit files
function ParseUpstartFile {
  #Get the contents of the file
  UNITDATA=$(cat $1)
  UnitFileName=$(basename $1 | awk -F .conf '{print $1}' )
  UnitHelperPath=$UnitHelperPath/$UnitFileName
}


#get pre exec commands
function ConvertPreExec {
  ExecPreExecScript=$(echo "$UNITDATA" | sed -n "/pre-start\Wscript/,/end\Wscript/p" | sed "s/end\Wscript//g" | sed "s/pre-start\Wscript//g")
  ExecPreExecLine=$(echo "$UNITDATA" | sed -n "/pre-start\Wscript/p" | sed "s/pre-start\Wexec//g")
}


#get exec start commands 
function ConvertExec {
  ExecExecScript=$(echo "$UNITDATA" | sed -n "/^\Wscript/,/end\Wscript/p" | sed "s/end\Wscript//g" | sed "s/^\Wscript//g")
  ExecExecLine=$(echo "$UNITDATA" | sed -n "/exec/p" | sed "s/exec//g")
}

#get post exec commands
function ConvertPostExec {
  ExecPostExecScript=$(echo "$UNITDATA" | sed -n "/post-start\Wscript/,/end\Wscript/p"  | sed "s/end\Wscript//g" | sed "s/post-start\Wscript//g")
  ExecPostExecLine=$(echo "$UNITDATA" | sed -n "/post-start\Wscript/p" | sed "s/post-start\Wexec//g")
}


#get pre stop commands
function ConvertPreStop {
  ExecPreStopScript=$(echo "$UNITDATA" | sed -n "/pre-stop\Wscript/,/end\Wscript/p" | sed "s/end\Wscript//g" | sed "s/pre-stop\Wscript//g")
  ExecPreStopLine=$(echo "$UNITDATA" | sed -n "/pre-stop\Wscript/p" | sed "s/pre-stop\Wexec//g")
}

#get post stop commands
function ConvertPostStop {
  ExecPostStopScript=$(echo "$UNITDATA" | sed -n "/post-stop\Wscript/,/end\Wscript/p"  | sed "s/end\Wscript//g" | sed "s/post-stop\Wscript//g")
  ExecPostStopLine=$(echo "$UNITDATA" | sed -n "/post-stop\Wscript/p" | sed "s/post-stop\Wexec//g")
}


#get the environment strings
function ConvertEnvironment {
  EnvironmentStrings=$(echo "$UNITDATA" | sed -n "/env/ p")
}

#Get if the unit file specifies forking
function ConvertForkingStatus {
  IsForking=$(echo "$UNITDATA" | grep -Ec "expect\Wfork|expect\Wdaemon")
}

#Get all limit status
function ConvertLimitEntries {
  LimitData=$(echo "$UNITDATA" | sed -nE '/^limit\W/p')
  #Conversion for limit lines
  while read LINE
  do
    LimitLine=($LINE)
    LimitType=$(echo ${LimitLine[1]} | tr [:lower:] [:upper:])
    SoftLimit=${LimitLine[2]}
    HardLimit=${LimitLine[3]}
    if [[ -z $HardLimit ]]
    then
      HardLimit=$SoftLimit
    fi
    echo "limit$LimitType=$HardLimit"
  done < <(echo $LimitData)
}

#Get the unit files start on conditions
function ConvertStartOn {
  ParenthCount=0
  StartOnData=$(echo "$UNITDATA" | sed -n "/start\Won/,//p" |while read LINE
  do
    OpenCount=$(echo $LINE  | tr -cd '\(' | wc -c )
    CloseCount=$(echo $LINE | tr -cd '\)' | wc -c )
    ParenthCount=$(( ParenthCount + OpenCount ))
    ParenthCount=$(( ParenthCount - CloseCount ))
    echo $LINE
    #When all parenths are closed then thats the end of the start on info
    if [[ $ParenthCount == 0 ]]
    then
      break
    fi
  done)
}


#Get the unit files stop on conditions
function ConvertStopOn
{
  ParenthCount=0
  StopOnData=$(echo "$UNITDATA" | sed -n "/stop\Won/,//p" |while read LINE
  do
    OpenCount=$(echo $LINE  | tr -cd '\(' | wc -c )
    CloseCount=$(echo $LINE | tr -cd '\)' | wc -c )
    ParenthCount=$(( ParenthCount + OpenCount ))
    ParenthCount=$(( ParenthCount - CloseCount ))
    echo $LINE
    #When all parenths are closed then thats the end of the stop on info
    if [[ $ParenthCount == 0 ]]
    then
      break
    fi
  done)
}







#Function to add to the building unit file. first argument is INI segment (SERVICE UNIT or INSTALL), second argument is if it should be at the top or bottom of the segment, third argument is the file array that should be edited for example the SERVICE or the TARGET, fourth argument is the quoted string
function AddToFile {
  Segment=$(echo $1 | tr [:lower:] [:upper:])
  Destination=$(echo $2 | tr [:lower:] [:upper:])
  UnitSkel=$(echo $3 | tr [:lower:] [:upper:])
  IFS=$'\n'
  StringArray=($4)
  unset IFS

  if [[ $Destination == "BELOW" ]]
  then
    for (( element = 0 ; element < ${#StringArray[@]} ; element++ ))
    do
      InsString=$(echo ${StringArray[$element]} | sed -e 's/[]\/()$*.^|[]/\\&/g')
      if [[ ! -z $InsString ]]
      then
	SystemdUnitSkel[$UnitSkel]=$(echo "${SystemdUnitSkel[$UnitSkel]}" | sed "s/@$Segment$Destination@/$InsString\n@$Segment$Destination@/g")
      fi
    done
  elif [[ $Destination == "ABOVE" ]]
  then
    for (( element = $(( ${#StringArray[@]} -1 )) ; element >= 0 ; element-- ))
    do
      InsString=$(echo ${StringArray[$element]} | sed -e 's/[]\/()$*.^|[]/\\&/g')
      if [[ ! -z $InsString ]]
      then
	SystemdUnitSkel[$UnitSkel]=$(echo "${SystemdUnitSkel[$UnitSkel]}" | sed "s/@$Segment$Destination@/@$Segment$Destination@\n$InsString/g")
      fi
    done
  fi
}

#Remove the replaceable marker strings before the file is actually written
function FinalizeFile {
  SystemdUnitSkel=$(echo "$SystemdUnitSkel" | sed '/^@*@/d')
}