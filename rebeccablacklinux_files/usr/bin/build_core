#! /bin/bash
#    Copyright (c) 2012, nerdopolis (or n3rdopolis) <bluescreen_avenger@version.net>
#
#    This file is part of RebeccaBlackLinux.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

export SOURCEDIR=/srcbuild
export REBUILDNEWREVISION=0

#Control variable used by the build scripts, on if to set the build script as 'build-only' or 'download-only'
export ACTION=$1

function RunDownloadAndOrBuild 
{

#Require root privlages
if [[ $UID != 0 ]]
then
echo "Must be run as root."
exit
fi

mkdir -p /usr/share/logs/build_core/$SOURCENAME

#Download source, unless the argument passed to the build script is 'build-only'
if [[ "$ACTION" != build-only ]]
then
#Download the source using specified variables.
DownloadSource 
fi


#Build the source and install it, unless the argument passed to the build script is 'download-only'
if [[ "$ACTION" != download-only ]]
then

#Start the compile or install Process
MakeAndInstall

fi
}



#Function to download git repos
function DownloadGIT()
{
OLDSOURCEURL=$(git --git-dir="$SOURCENAME"/.git remote -v | grep '(fetch)' | grep origin | awk '{print $2}' )
if [[ -z "$OLDSOURCEURL" || "$SOURCEURL" != "$OLDSOURCEURL" ]]
then
rm -rf "$SOURCENAME"

if [[ $MAKEDEBS == 1 ]]
then
rm "/$SOURCEDIR/buildoutput/control/$SOURCENAME"
rm "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt"
rm "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt.old"
fi

fi

git clone "$SOURCEURL" "$SOURCENAME"
mkdir -p "$SOURCENAME"
cd "$SOURCENAME"
git reset --hard 
git clean -fdx 
git checkout -f $SOURCEREVERSION 
git pull -s recursive -X theirs --no-edit

#Download submodules. set the revision name in the builder script, take the submodule name and add _REVISION to the end, for example SUBMODULENAME_REVISION=revisionno.
#For sub-sub-modules, change the slashes for the path to underscores SUBMODULE_RELATIVE_PATH_REVISION=revisionno

#go through each module and register and download them
git submodule update --init --recursive

git submodule  | awk '{print $2}' | while read MODULE
do
#get the current module folder name, and add '_REVISION' to the end of the name
REVISIONNAME=REVISION_"$(echo -n $MODULE | tr '[:punct:]' '_' | tr '[:space:]' '_')"
#use REVISIONNAME (foldername_REVISION as variable variable 
MODULEREVISION=${!REVISIONNAME}

mkdir -p $MODULE
cd $MODULE

git reset --hard 
git clean -fdx 
git checkout -f $MODULEREVISION
git pull -s recursive -X theirs --no-edit

mkdir -p "/$SOURCEDIR/$SOURCENAME"
cd "/$SOURCEDIR/$SOURCENAME"
done
}


#Function to download svn repos
function DownloadSVN()
{
OLDSOURCEURL=$(svn info "$SOURCENAME" | grep "^URL: " | awk '{print $2}')
if [[ -z "$OLDSOURCEURL" || "$SOURCEURL" != "$OLDSOURCEURL" ]]
then
rm -rf "$SOURCENAME"

if [[ $MAKEDEBS == 1 ]]
then
rm "/$SOURCEDIR/buildoutput/control/$SOURCENAME"
rm "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt"
rm "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt.old"
fi

fi

svn co "$SOURCEURL" "$SOURCENAME"
mkdir -p "$SOURCENAME"
cd "$SOURCENAME"
svn revert --recursive .
svn cleanup
svn update -r $SOURCEREVERSION
}


#Function to download bzr repos
function DownloadBZR()
{
OLDSOURCEURL=$(bzr info $SOURCENAME | grep "parent branch" | awk -F "branch: " '{print $2}')
if [[ -z "$OLDSOURCEURL" || "$SOURCEURL" != "$OLDSOURCEURL" ]]
then
rm -rf "$SOURCENAME"

if [[ $MAKEDEBS == 1 ]]
then
rm "/$SOURCEDIR/buildoutput/control/$SOURCENAME"
rm "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt"
rm "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt.old"
fi

fi

bzr branch "$SOURCEURL" "$SOURCENAME"
mkdir -p "$SOURCENAME"
cd "$SOURCENAME"
bzr revert
bzr clean-tree --force --detritus
bzr pull
bzr update -r $SOURCEREVERSION
}


#Function that calls download functions for GIT repos based on the repository type set by the main script
function DownloadSource()
{
mkdir -p "$SOURCEDIR"
cd "$SOURCEDIR"
REPOSITORYTYPE=$(echo $REPOSITORYTYPE |tr [:lower:] [:upper:])

STARTTIME=$(date +%s)
Download$REPOSITORYTYPE 2>&1 | tee "/usr/share/logs/build_core/$SOURCENAME/Download$REPOSITORYTYPE"
ENDTIME=$(date +%s)
echo "Download$REPOSITORYTYPE finished in $((ENDTIME-STARTTIME)) seconds" 2>&1 | tee -a "/usr/share/logs/build_core/$SOURCENAME/Download$REPOSITORYTYPE"

STARTTIME=$(date +%s)
PackageDownloadSource   2>&1 | tee "/usr/share/logs/build_core/$SOURCENAME/PackageDownloadSource"
ENDTIME=$(date +%s) 2>&1 | tee -a  "/usr/share/logs/build_core/$SOURCENAME/PackageDownloadSource"

}

#function to get the revison of GIT repos
function GetVersionGIT()
{
REVISIONSTRING="$SOURCENAME REVISION $(git rev-parse HEAD; git submodule | awk -v SOURCENAME=$SOURCENAME $'{print $2 " REVISION " $1 " ("SOURCENAME" submodule)"}')"
}

#function to get the revison of SVN repos
function GetVersionSVN()
{
REVISIONSTRING="$SOURCENAME REVISION $(svnversion .)"
}

#function to get the version of BZR repos
function GetVersionBZR()
{
REVISIONSTRING="$SOURCENAME REVISION $(bzr version-info | grep revno | awk '{print $2}')"
}


#function that calls functions to get version based on repository type
function GetSourceVersion()
{
GetVersion$REPOSITORYTYPE
echo "$REVISIONSTRING"

if [[ $MAKEDEBS == 1 ]]
then
mkdir -p "/$SOURCEDIR/buildoutput/versioninfo"
echo "$REVISIONSTRING" > "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt"
echo 
fi

}



#Function that calls common build preperations, and then calls upon the main builder scripts prepare function
function PrepareBuild()
{
#Create build variables
. /usr/bin/build_vars

mkdir -p "$SOURCEDIR"
cd "$SOURCEDIR"
mkdir -p "$SOURCENAME"
cd "$SOURCENAME"

STARTTIME=$(date +%s)
PackagePrepareBuild 2>&1 | tee "/usr/share/logs/build_core/$SOURCENAME/PackagePrepareBuild"
ENDTIME=$(date +%s)
echo "PackagePrepareBuild finished in $((ENDTIME-STARTTIME)) seconds" 2>&1 | tee -a "/usr/share/logs/build_core/$SOURCENAME/PackagePrepareBuild"
}

#Function that handles the build of the source, creation of the deb file, or installation of the source
function MakeAndInstall()
{
mkdir -p "$SOURCEDIR"
cd "$SOURCEDIR"
mkdir -p "$SOURCENAME"
cd "$SOURCENAME"
GetSourceVersion 2>&1 | tee "/usr/share/logs/build_core/$SOURCENAME/GetSourceVersion"
mkdir -p "$INSTALLDIR/share/aclocal"

#create a variable for the package name that is the source name converted to all lower case.
PACKAGESOURCENAME="$(echo $SOURCENAME | tr [:upper:] [:lower:])"

#If the script is set to always rebuild, then detect if the revision info changed.
if [[ $REBUILDNEWREVISION == 1 && $MAKEDEBS == 1 ]]
then
DIFFERENTREVISION="$(diff -q "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt" "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt.old" &>/dev/null ; echo $?)"
cat "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt" > "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt.old"
else 
DIFFERENTREVISION=0
fi

#If the deb file is gone, there is no control file, or the script is set to build a new revision and there is anew revision, or the scripts not configured to make deb files, then build the source
if [[ ! $(ls "/$SOURCEDIR/buildoutput/""$PACKAGESOURCENAME"-rbos_*.deb ) || ! -f "/$SOURCEDIR/buildoutput/control/$SOURCENAME" || $MAKEDEBS != 1 || $DIFFERENTREVISION != 0 ]]
then

#Call PrepareBuild functions
PrepareBuild 

#Complile the source
STARTTIME=$(date +%s)
PackageCompileSource 2>&1 | tee "/usr/share/logs/build_core/$SOURCENAME/PackageCompileSource"
ENDTIME=$(date +%s)
echo "PackageCompileSource finished in $((ENDTIME-STARTTIME)) seconds" 2>&1 | tee -a "/usr/share/logs/build_core/$SOURCENAME/PackageCompileSource"

#Empty any possible logs inside the source folder
rm "/$SOURCEDIR/$SOURCENAME/Logs/"* 

#Create a script file that will be called by checkinstall, or just called if no .deb files are being made. It exports the current build scripts PackageInstallSource and PackagePostInstall functions to the script.
echo "#! /bin/bash
mkdir -p \"/$SOURCEDIR/$SOURCENAME/Logs\"
$(declare -f PackageInstallSource)
$(declare -f PackagePostInstall)
export SOURCEDIR=$SOURCEDIR
export SOURCENAME=$SOURCENAME
export INSTALLDIR=$INSTALLDIR

STARTTIME=\$(date +%s)
PackageInstallSource 2>&1 | tee \"/$SOURCEDIR/$SOURCENAME/Logs/PackageInstallSource\"
ENDTIME=\$(date +%s)
echo \"PackageInstallSource finished in \$((ENDTIME-STARTTIME)) seconds\" 2>&1 | tee -a \"/$SOURCEDIR/$SOURCENAME/Logs/PackageInstallSource\"

STARTTIME=\$(date +%s)
PackagePostInstall 2>&1 | tee \"/$SOURCEDIR/$SOURCENAME/Logs/PackagePostInstall\"
ENDTIME=\$(date +%s)
echo \" PackagePostInstall finished in \$((ENDTIME-STARTTIME)) seconds\" 2>&1 | tee -a \"/$SOURCEDIR/$SOURCENAME/Logs/PackagePostInstall\"
" > packageinstallscript

cp "/$SOURCEDIR/$SOURCENAME/Logs/"* /usr/share/logs/build_core/$SOURCENAME/

#Make the script executable
chmod +x packageinstallscript


#if the script is configured to create debs then create the debs. If not, run the install routine as normal.
if [[ $MAKEDEBS == 1 ]]
then

#create directories for output
mkdir "/$SOURCEDIR/buildoutput/"
mkdir "/$SOURCEDIR/buildoutput/control"
#checkinstall wants a debian/control file, otherwise it exits out.
mkdir debian
touch debian/control

#Update database containing the list of files that belong to packages
update-dlocatedb

#Find all Executable files compiled in the source tree, get the dependancy Library files, and find the package the libraries belong to
DEPENDS=$(find /$SOURCEDIR/$SOURCENAME/ -type f -executable | while read FILE
do
ldd "$FILE" | awk '{print $3}'
done | sort | uniq | grep -v ^$ | grep -v dynamic | grep -v not | while read LIBRARY
do
dlocate -S --package-only "$LIBRARY"
done | sort | uniq)

DEPENDS=$(echo $DEPENDS | sed 's/ /,/g') 

#.spec file seem to cause problems with checkinstall
rm *.spec

#remove any old deb files for this package
rm "/$SOURCEDIR/buildoutput/""$PACKAGESOURCENAME"-rbos_*.deb

#create the new deb
STARTTIME=$(date +%s)
checkinstall -y -D --nodoc --dpkgflags=--force-overwrite --install=yes --backup=no --pkgname="$PACKAGESOURCENAME"-rbos --pkgversion=1 --pkgrelease=$(date +%s) --pkglicense="OSI_COMPLIANT" --maintainer=rbos@rbos --pkgsource=rbos --pkggroup=rbos --requires="$DEPENDS" ./packageinstallscript 2>&1 | tee "/usr/share/logs/build_core/$SOURCENAME/Checkinstall"
ENDTIME=$(date +%s)
echo "Checkinstall finished in $((ENDTIME-STARTTIME)) seconds" 2>&1 | tee -a "/usr/share/logs/build_core/$SOURCENAME/Checkinstall"

#copy the resulting deb file into the buildoutput tree.
cp *.deb "/$SOURCEDIR/buildoutput/"

#Create lock file that when removed forces the package to be rebuilt
touch "/$SOURCEDIR/buildoutput/control/$SOURCENAME"

else
./packageinstallscript
fi



#If the deb file exists, the control file exists, and the script is configured to make deb files, then just install the deb
else
STARTTIME=$(date +%s)
dpkg -i --force-overwrite "/$SOURCEDIR/buildoutput/""$PACKAGESOURCENAME"-rbos_*.deb 2>&1 | tee "/usr/share/logs/build_core/$SOURCENAME/DebInstall"
ENDTIME=$(date +%s)
echo "DebInstall finished in $((ENDTIME-STARTTIME)) seconds" 2>&1 | tee -a "/usr/share/logs/build_core/$SOURCENAME/DebInstall"
fi


}