#! /bin/bash
#    Copyright (c) 2012, nerdopolis (or n3rdopolis) <bluescreen_avenger@version.net>
#
#    This file is part of RebeccaBlackLinux.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

export SOURCEDIR=/srcbuild
export ALWAYSREBUILD=0


#Function to download git repos
function DownloadGIT()
{
OLDSOURCEURL=$(git --git-dir="$SOURCENAME"/.git remote -v | grep '(fetch)' | grep origin | awk '{print $2}' )
if [[ -z "$OLDSOURCEURL" || "$SOURCEURL" != "$OLDSOURCEURL" ]]
then
rm -rf "$SOURCENAME"
fi

git clone "$SOURCEURL"
cd "$SOURCENAME"
git checkout $SOURCEREVERSION
git reset --hard 
git clean -fdx 
git pull

#Download submodules. set the revision name in the builder script, take the submodule name and add _REVISION to the end, for example SUBMODULENAME_REVISION=revisionno.
#For sub-sub-modules, change the slashes for the path to underscores SUBMODULE_RELATIVE_PATH_REVISION=revisionno

#go through each module and register and download them
git submodule update --init --recursive

git submodule  | awk '{print $2}' | while read MODULE
do
#get the current module folder name, and add '_REVISION' to the end of the name
REVISIONNAME="$(echo $MODULE | sed 's/\//_/g')"_REVISION
#use REVISIONNAME (foldername_REVISION as variable variable 
MODULEREVISION=${!REVISIONNAME}

cd $MODULE

git checkout $MODULEREVISION
git reset --hard 
git clean -fdx 
git pull

cd /$SOURCEDIR/$SOURCENAME
done
}


#Function to download svn repos
function DownloadSVN()
{
OLDSOURCEURL=$(svn info "$SOURCENAME" | grep "^URL: " | awk '{print $2}')
if [[ -z "$OLDSOURCEURL" || "$SOURCEURL" != "$OLDSOURCEURL" ]]
then
rm -rf "$SOURCENAME"
fi

svn co "$SOURCEURL"
cd "$SOURCENAME"
svn revert --recursive .
svn-clean
svn update -r $SOURCEREVERSION
}


#Function to download bzr repos
function DownloadBZR()
{
OLDSOURCEURL=$(bzr info $SOURCENAME | grep "parent branch" | awk -F "branch: " '{print $2}')
if [[ -z "$OLDSOURCEURL" || "$SOURCEURL" != "$OLDSOURCEURL" ]]
then
rm -rf "$SOURCENAME"
fi

bzr branch "$SOURCEURL" "$SOURCENAME"
cd "$SOURCENAME"
bzr revert
bzr clean-tree --force --detritus
bzr pull
bzr update -r $SOURCEREVERSION
}


#Function that calls download functions for GIT repos based on the repository type set by the main script
function DownloadSource()
{
mkdir "$SOURCEDIR"
cd "$SOURCEDIR"
REPOSITORYTYPE=$(echo $REPOSITORYTYPE |tr [:lower:] [:upper:])
Download$REPOSITORYTYPE
}

#function to get the revison of GIT repos
function GetVersionGIT()
{
CURRENTREVISION=$(git rev-parse HEAD)
}

#function to get the revison of SVN repos
function GetVersionSVN()
{
CURRENTREVISION=$(svnversion .)
}

#function to get the version of BZR repos
function GetVersionBZR()
{
CURRENTREVISION=$(bzr revno)
}


#function that calls functions to get version based on repository type
function GetSourceVersion()
{
GetVersion$REPOSITORYTYPE
}



#Function that calls common build preperations, and then calls upon the main builder scripts prepare function
function PrepareBuild()
{
#Create build variables
export MAKEFLAGS="-j $(( $(cat /proc/cpuinfo | grep ^"processor" -c) ))"
export LD_LIBRARY_PATH=$INSTALLDIR/lib/$(dpkg-architecture -qDEB_HOST_MULTIARCH):/usr/local/lib/$(dpkg-architecture -qDEB_HOST_MULTIARCH):/usr/lib/$(dpkg-architecture -qDEB_HOST_MULTIARCH):$INSTALLDIR/lib:/usr/local/lib:/usr/lib
export PATH="/usr/lib/ccache:$INSTALLDIR/sbin:$INSTALLDIR/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/sbin:/bin:/usr/games"
export PKG_CONFIG_PATH=$INSTALLDIR/lib/$(dpkg-architecture -qDEB_HOST_MULTIARCH)/pkgconfig:$INSTALLDIR/lib/pkgconfig/:$INSTALLDIR/share/pkgconfig/
export ACLOCAL="aclocal -I $INSTALLDIR/share/aclocal"
export C_INCLUDE_PATH=$INSTALLDIR/include
export LIBRARY_PATH=$INSTALLDIR/lib
export PKG_CONFIG_ALLOW_SYSTEM_CFLAGS=1
export QT_PLUGIN_PATH=$INSTALLDIR/lib/plugins/
export CMAKE_PREFIX_PATH=$INSTALLDIR:$CMAKE_PREFIX_PATH

cd "$SOURCEDIR"
cd "$SOURCENAME"
GetSourceVersion
echo "REVISION $CURRENTREVISION"
mkdir -p "$INSTALLDIR/share/aclocal"
PackagePrepareBuild
}

#Function that handles the build of the source, creation of the deb file, or installation of the source
function MakeAndInstall()
{

#If the script is set to always rebuild, then delete the lock file.
if [[ $ALWAYSREBUILD == 1 && $MAKEDEBS == 1 ]]
then
rm "/$SOURCEDIR/buildoutput/control/$SOURCENAME"
fi

#If the deb file is gone, there is no control file, or the scripts not configured to make deb files, then build the source
if [[ ! $(ls "/$SOURCEDIR/buildoutput/""$SOURCENAME"_*.deb ) || ! -f "/$SOURCEDIR/buildoutput/control/$SOURCENAME" || $MAKEDEBS != 1 ]]
then
#Complile the source
PackageCompileSource

#if the script is configured to create debs then create the debs, and save the copied files outside of the debs to $SOURCEDIR/buildoutput/externalfiles. If not, run the install routine as normal.
if [[ $MAKEDEBS == 1 ]]
then
export INSTALLCACHEROOT="/$SOURCEDIR/buildoutput/externalfiles/$SOURCENAME"
#create directories for output
mkdir "/$SOURCEDIR/buildoutput/"
mkdir "/$SOURCEDIR/buildoutput/control"
#checkinstall wants a debian/control file, otherwise it exits out.
mkdir debian
touch debian/control
#remove any old deb files
rm "/$SOURCEDIR/buildoutput/""$SOURCENAME"_*.deb

#create the new deb
checkinstall -y -D --install=yes --pkgversion=1 --pkgrelease=1 make install -i

#copy the resulting deb file into the buildoutput tree.
cp *.deb "/$SOURCEDIR/buildoutput/"

else
export INSTALLCACHEROOT="/tmp/buildoutput/externalfiles/$SOURCENAME"
make install -i
fi

#If the deb file exists, the control file exists, and the script is configured to make deb files, then just install the deb
else
export INSTALLCACHEROOT="/$SOURCEDIR/buildoutput/externalfiles/$SOURCENAME"
dpkg -i "/$SOURCEDIR/buildoutput/""$SOURCENAME"_*.deb
fi

#Run the Package install routine, and copy the files out of INSTALLCACHEROOT into the actual root.
mkdir -p "/$INSTALLCACHEROOT"
PackagePostInstall
cp -a "/$INSTALLCACHEROOTROOT"/* /

#If the build script is set to not always rebuild, create the lock file
if [[ $ALWAYSREBUILD == 0 && $MAKEDEBS == 1 ]]
then
touch "/$SOURCEDIR/buildoutput/control/$SOURCENAME"
fi

}