#! /bin/bash
#    Copyright (c) 2012, nerdopolis (or n3rdopolis) <bluescreen_avenger@version.net>
#
#    This file is part of RebeccaBlackLinux.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

export SOURCEDIR=/srcbuild
export ALWAYSREBUILD=0

#Control variable used by the build scripts, on if to set the build script as 'build-only' or 'download-only'
export ACTION=$1

function RunDownloadAndOrBuild 
{
mkdir -p /usr/share/logs/build_core/$SOURCENAME

#Download source, unless the argument passed to the build script is 'build-only'
if [[ "$ACTION" != build-only ]]
then
#Download the source specified variables, using the DownloadSource function in /usr/bin/build_core
DownloadSource 
fi


#Build the source and install it, unless the argument passed to the build script is 'download-only'
if [[ "$ACTION" != download-only ]]
then
#Prepare the build using the PrepareBuild function in /usr/bin/build_core, which then calls this scripts PackagePrepareBuild function.

PrepareBuild 

#Compile the source using the MakeAndInstall function in /usr/bin/build_core, which calls PackageCompileSource from this script, then MakeAndInstall's install methods, and then PackagePostInstall from this script.
MakeAndInstall

fi
}



#Function to download git repos
function DownloadGIT()
{
OLDSOURCEURL=$(git --git-dir="$SOURCENAME"/.git remote -v | grep '(fetch)' | grep origin | awk '{print $2}' )
if [[ -z "$OLDSOURCEURL" || "$SOURCEURL" != "$OLDSOURCEURL" ]]
then
rm -rf "$SOURCENAME"
fi

git clone "$SOURCEURL"
cd "$SOURCENAME"
git checkout $SOURCEREVERSION
git reset --hard 
git clean -fdx 
git pull

#Download submodules. set the revision name in the builder script, take the submodule name and add _REVISION to the end, for example SUBMODULENAME_REVISION=revisionno.
#For sub-sub-modules, change the slashes for the path to underscores SUBMODULE_RELATIVE_PATH_REVISION=revisionno

#go through each module and register and download them
git submodule update --init --recursive

git submodule  | awk '{print $2}' | while read MODULE
do
#get the current module folder name, and add '_REVISION' to the end of the name
REVISIONNAME="$(echo $MODULE | sed 's/\//_/g' | sed 's/-/_/g')"_REVISION
#use REVISIONNAME (foldername_REVISION as variable variable 
MODULEREVISION=${!REVISIONNAME}

cd $MODULE

git checkout $MODULEREVISION
git reset --hard 
git clean -fdx 
git pull

cd /$SOURCEDIR/$SOURCENAME
done
}


#Function to download svn repos
function DownloadSVN()
{
OLDSOURCEURL=$(svn info "$SOURCENAME" | grep "^URL: " | awk '{print $2}')
if [[ -z "$OLDSOURCEURL" || "$SOURCEURL" != "$OLDSOURCEURL" ]]
then
rm -rf "$SOURCENAME"
fi

svn co "$SOURCEURL"
cd "$SOURCENAME"
svn revert --recursive .
svn cleanup
svn update -r $SOURCEREVERSION
}


#Function to download bzr repos
function DownloadBZR()
{
OLDSOURCEURL=$(bzr info $SOURCENAME | grep "parent branch" | awk -F "branch: " '{print $2}')
if [[ -z "$OLDSOURCEURL" || "$SOURCEURL" != "$OLDSOURCEURL" ]]
then
rm -rf "$SOURCENAME"
fi

bzr branch "$SOURCEURL" "$SOURCENAME"
cd "$SOURCENAME"
bzr revert
bzr clean-tree --force --detritus
bzr pull
bzr update -r $SOURCEREVERSION
}


#Function that calls download functions for GIT repos based on the repository type set by the main script
function DownloadSource()
{
mkdir "$SOURCEDIR"
cd "$SOURCEDIR"
REPOSITORYTYPE=$(echo $REPOSITORYTYPE |tr [:lower:] [:upper:])

STARTTIME=$(date +%s)
Download$REPOSITORYTYPE 2>&1 | tee /usr/share/logs/build_core/$SOURCENAME/Download$REPOSITORYTYPE
ENDTIME=$(date +%s)
echo "Download$REPOSITORYTYPE finished in $((ENDTIME-STARTTIME)) seconds" 2>&1 | tee -a /usr/share/logs/build_core/$SOURCENAME/Download$REPOSITORYTYPE

STARTTIME=$(date +%s)
PackageDownloadSource   2>&1 | tee /usr/share/logs/build_core/$SOURCENAME/PackageDownloadSource
ENDTIME=$(date +%s) 2>&1 | tee -a  /usr/share/logs/build_core/$SOURCENAME/PackageDownloadSource

}

#function to get the revison of GIT repos
function GetVersionGIT()
{
echo "REVISION $(git rev-parse HEAD)"
}

#function to get the revison of SVN repos
function GetVersionSVN()
{
echo "REVISION $(svnversion .)"
}

#function to get the version of BZR repos
function GetVersionBZR()
{
echo "REVISION $(bzr revno)"
}


#function that calls functions to get version based on repository type
function GetSourceVersion()
{
GetVersion$REPOSITORYTYPE
}



#Function that calls common build preperations, and then calls upon the main builder scripts prepare function
function PrepareBuild()
{
#Create build variables
. /usr/bin/build_vars

cd "$SOURCEDIR"
cd "$SOURCENAME"
GetSourceVersion 2>&1 | tee /usr/share/logs/build_core/$SOURCENAME/GetSourceVersion
mkdir -p "$INSTALLDIR/share/aclocal"

STARTTIME=$(date +%s)
PackagePrepareBuild 2>&1 | tee /usr/share/logs/build_core/$SOURCENAME/PackagePrepareBuild
ENDTIME=$(date +%s)
echo "PackagePrepareBuild finished in $((ENDTIME-STARTTIME)) seconds" 2>&1 | tee -a /usr/share/logs/build_core/$SOURCENAME/PackagePrepareBuild
}

#Function that handles the build of the source, creation of the deb file, or installation of the source
function MakeAndInstall()
{
#create a variable for the package name that is the source name converted to all lower case.
PACKAGESOURCENAME="$(echo $SOURCENAME | tr [:upper:] [:lower:])"

#If the script is set to always rebuild, then delete the lock file.
if [[ $ALWAYSREBUILD == 1 && $MAKEDEBS == 1 ]]
then
rm "/$SOURCEDIR/buildoutput/control/$SOURCENAME"
fi

#If the deb file is gone, there is no control file, or the scripts not configured to make deb files, then build the source
if [[ ! $(ls "/$SOURCEDIR/buildoutput/""$PACKAGESOURCENAME"-rbos_*.deb ) || ! -f "/$SOURCEDIR/buildoutput/control/$SOURCENAME" || $MAKEDEBS != 1 ]]
then
#Complile the source
STARTTIME=$(date +%s)
PackageCompileSource 2>&1 | tee /usr/share/logs/build_core/$SOURCENAME/PackageCompileSource
ENDTIME=$(date +%s)
echo "PackageCompileSource finished in $((ENDTIME-STARTTIME)) seconds" 2>&1 | tee -a /usr/share/logs/build_core/$SOURCENAME/PackageCompileSource


#Create a script file that will be called by checkinstall, or just called. It calls make with the specified variable, and exports the current build scripts PackagePostBuild and PackagePostInstall functions to the script.
echo "#! /bin/bash
make install $MAKEINSTALLARGS 2>&1 | tee /usr/share/logs/build_core/$SOURCENAME/MakeInstall
$(declare -f PackagePostBuild)
$(declare -f PackagePostInstall)
export SOURCEDIR=$SOURCEDIR
export SOURCENAME=$SOURCENAME
export INSTALLDIR=$INSTALLDIR

STARTTIME=\$(date +%s)
PackagePostBuild 2>&1 | tee /usr/share/logs/build_core/$SOURCENAME/PackagePostBuild
ENDTIME=\$(date +%s)
echo \"PackagePostBuild finished in \$((ENDTIME-STARTTIME)) seconds\" 2>&1 | tee -a /usr/share/logs/build_core/$SOURCENAME/PackagePostBuild

STARTTIME=\$(date +%s)
PackagePostInstall 2>&1 | tee /usr/share/logs/build_core/$SOURCENAME/PackagePostInstall
ENDTIME=\$(date +%s)
echo \" PackagePostInstall finished in \$((ENDTIME-STARTTIME)) seconds\" 2>&1 | tee -a /usr/share/logs/build_core/$SOURCENAME/PackagePostInstall
" > packageinstallscript

#Make the script executable
chmod +x packageinstallscript


#if the script is configured to create debs then create the debs. If not, run the install routine as normal.
if [[ $MAKEDEBS == 1 ]]
then

#create directories for output
mkdir "/$SOURCEDIR/buildoutput/"
mkdir "/$SOURCEDIR/buildoutput/control"
#checkinstall wants a debian/control file, otherwise it exits out.
mkdir debian
touch debian/control

#.spec file seem to cause problems with checkinstall
rm *.spec

#remove any old deb files
rm "/$SOURCEDIR/buildoutput/""$PACKAGESOURCENAME"-rbos_*.deb

#create the new deb
STARTTIME=$(date +%s)
checkinstall -y -D --install=yes --backup=no --pkgname="$PACKAGESOURCENAME"-rbos --pkgversion=1 --pkgrelease=1  --maintainer=rbos@rbos --pkgsource=rbos --pkggroup=rbos ./packageinstallscript 2>&1 | tee /usr/share/logs/build_core/$SOURCENAME/checkinstall
ENDTIME=$(date +%s)
echo "Checkinstall finished in $((ENDTIME-STARTTIME)) seconds" 2>&1 | tee -a /usr/share/logs/build_core/$SOURCENAME/Checkinstall

#copy the resulting deb file into the buildoutput tree.
cp *.deb "/$SOURCEDIR/buildoutput/"

else
./packageinstallscript
fi



#If the deb file exists, the control file exists, and the script is configured to make deb files, then just install the deb
else
dpkg -i "/$SOURCEDIR/buildoutput/""$PACKAGESOURCENAME"-rbos_*.deb
fi

#If the build script is set to not always rebuild, create the lock file
if [[ $ALWAYSREBUILD == 0 && $MAKEDEBS == 1 ]]
then
touch "/$SOURCEDIR/buildoutput/control/$SOURCENAME"
fi

}