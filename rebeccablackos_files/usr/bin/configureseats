#! /bin/bash
#    Copyright (c) 2012, 2013, 2014, 2015, 2016, 2017 nerdopolis (or n3rdopolis) <bluescreen_avenger@verzion.net>
#
#    This file is part of RebeccaBlackOS.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.


#This script is for configuring multiple seats in Weston. It matches the devices devpath, and the devices serial ID, and sets the ENV{WL_SEAT} and ENV{ID_SEAT} values, or the devices path ID and sets the ENV{ID_SEAT} value in a the udev file /lib/udev/rules.d/99-weston_seats_and_udev_seats.rules
#This makes it easier for users to configure multiple pointers and keyboard focuses, as well as multiple sessions.

#Require root privlages
if [[ $UID != 0 ]]
then
  echo "Must be run as root."
  exit
fi

#Move the old udev rules file to the new name, if it exists
if [[ -e /lib/udev/rules.d/99-westonseats.rules && ! -e /lib/udev/rules.d/weston_seats_and_udev_seats.rules ]]
then
  mv /lib/udev/rules.d/99-westonseats.rules /lib/udev/rules.d/99-weston_seats_and_udev_seats.rules
fi

#Allow Exclamation points to be used in commands by turning off the history
set +H

#Specify the maximum number of seats. This is a more for usability, for specifying how many seats are listed in the zenity dialog. There can be more, but if there are too many, it become a hastle for the user
MaxNumberOfSeats=10

#get the current tty so the script knows what TTY to switch back to
CurrentTTY=$(fgconsole)

NumberOfDevices=0
#Get all input devices from udev, and store attributes into an array
while read Device
do
  #Handle the display of the device type to the user. Some devices report themselves as multiple types such as a logitech transciver, will appear as "Mouse / Keyboard"
  unset DeviceType

  #get properties of the device
  DeviceProperties=$(udevadm info --query=property  --name=$Device)
  DeviceSessionSeatID=$(echo "$DeviceProperties" | awk -F ' *= *' '$1 == "ID_SEAT" {print $0}' | cut -d = -f2- | tail -1 )
  DeviceWLSeatID=$(echo "$DeviceProperties" | awk -F ' *= *' '$1 == "WL_SEAT" {print $0}' | cut -d = -f2- | tail -1 )
  IsDeviceInput=$(echo "$DeviceProperties" | awk -F ' *= *' '$1 == "ID_INPUT" {print $0}' | cut -d = -f2- | tail -1 )
  IsDeviceMouse=$(echo "$DeviceProperties" | awk -F ' *= *' '$1 == "ID_INPUT_MOUSE" {print $0}' | cut -d = -f2- | tail -1 )
  IsDeviceTouchscreen=$(echo "$DeviceProperties" | awk -F ' *= *' '$1 == "ID_INPUT_TOUCHSCREEN" {print $0}' | cut -d = -f2- | tail -1 )
  IsDeviceTouchpad=$(echo "$DeviceProperties" | awk -F ' *= *' '$1 == "ID_INPUT_TOUCHPAD" {print $0}' | cut -d = -f2- | tail -1 )
  IsDeviceKeyboard=$(echo "$DeviceProperties" | awk -F ' *= *' '$1 == "ID_INPUT_KEYBOARD" {print $0}' | cut -d = -f2- | tail -1 )
  DeviceConnection=$(echo "$DeviceProperties" | awk -F ' *= *' '$1 == "ID_PATH {print $0}' | cut -d = -f2- | tail -1 )
  if [[ $IsDeviceInput == 1 ]]
  then
    IsDeviceInput=1
    DeviceName=$(echo "$DeviceProperties" | awk -F ' *= *' '$1 == "ID_SERIAL" {print $0}' | cut -d = -f2- | tail -1 )
    DeviceDisplayName=$(udevadm info -q all --attribute-walk --name=$Device | sed -re '/=/!d' -e "s/^ *([a-zA-Z0-9])/\1/g" -e 's/==/=/g' -e 's/"//g' | awk -F ' *= *' '$1 == "ATTRS{name}" {print $0}' | cut -d = -f2- | tail -1 | sed 's/[^0-9a-zA-Z_ -]*//g')
  else
    IsDeviceInput=0
    DeviceName=$(echo "$DeviceProperties" | awk -F ' *= *' '$1 == "DEVNAME" {print $0}' | cut -d = -f2- | tail -1 )
    DeviceSubsystem=$(echo "$DeviceProperties" | awk -F ' *= *' '$1 == "SUBSYSTEM" {print $0}' | cut -d = -f2- | tail -1 )
    if [[ $DeviceSubsystem == "drm" ]]
    then
      DeviceType="KMS Graphics Card"
    fi
    if [[ $DeviceSubsystem == "graphics" ]]
    then
      DeviceType="Frame Buffer"
    fi
    DeviceDisplayName=$(udevadm info -q all --attribute-walk --name=$Device | sed -re '/=/!d' -e "s/^ *([a-zA-Z0-9])/\1/g" -e 's/==/=/g' -e 's/"//g' | awk -F ' *= *' '$1 == "DRIVERS" {print $0}' | cut -d = -f2- | head -1 | sed 's/[^0-9a-zA-Z_ -]*//g')
    DeviceDisplayName+=" $Device"
  fi
  #if the device doesn't have a serial ID, which usually tells the make and model, then display it as 'generic' to the user
  if [[ -z $DeviceDisplayName ]]
  then
    DeviceDisplayName=$(echo $DeviceName| sed 's/[^0-9a-zA-Z_ -]*//g')
    if [[ $DeviceDisplayName == "noserial" ]]
    then
      DeviceDisplayName="Generic"
    fi
  fi

  #if the device has no configured WL_SEAT value, then weston sees it as it being under the default seat
  if [[ -z $DeviceWLSeatID ]]
  then
    DeviceWLSeatID="default"
  fi

  #if the device has no configured ID_SEAT value, then udev sees it as it being under the seat0 seat
  if [[ -z $DeviceSessionSeatID ]]
  then
    DeviceSessionSeatID="seat0"
  fi

  #if the device is reported as a mouse, then add that to the device type string. if the device type string has a previous device type in it, prepend a / for the user
  if [[ -z $IsDeviceMouse ]]
  then
    IsDeviceMouse=0
  else
    if [[ ! -z $DeviceType ]]
    then
      DeviceType+=" / "
    fi
    DeviceType+="Mouse"
  fi

  #if the device is reported as a touchscreen, then add that to the device type string. if the device type string has a previous device type in it, prepend a / for the user
  if [[ -z $IsDeviceTouchscreen ]]
  then
    IsDeviceTouchscreen=0
  else
    if [[ ! -z $DeviceType ]]
    then
      DeviceType+=" / "
    fi
  DeviceType+="Touchscreen"
  fi

  #if the device is reported as a touchpad (as in a laptop touchpad), then add that to the device type string. if the device type string has a previous device type in it, prepend a / for the user
  if [[ -z $IsDeviceTouchpad ]]
  then
    IsDeviceTouchpad=0
  else
    if [[ ! -z $DeviceType ]]
    then
      DeviceType+=" / "
    fi
  DeviceType+="Touchpad"
  fi

  #if the device is reported as a keyboard, then add that to the device type string. if the device type string has a previous device type in it, prepend a / for the user
  if [[ -z $IsDeviceKeyboard ]]
  then
    IsDeviceKeyboard=0
  else
    if [[ ! -z $DeviceType ]]
    then
      DeviceType+=" / "
    fi
  DeviceType+="Keyboard"
  fi

  #if DeviceType exits, then add to the arrays. DeviceType only exists if the device is an input device, or graphics device. All other devices reported by udev, it will be empty and ignored. These devices are the only ones that concern weston multiseat, or udev multiseat.
  DeviceConnectionDuplicate=0
  for (( CurrentDeviceNumber=1; CurrentDeviceNumber<=$NumberOfDevices; CurrentDeviceNumber++ ))
  do
    DeviceDuplicateTest=${DeviceConnections[$CurrentDeviceNumber]}
    if [[ $DeviceDuplicateTest == $DeviceConnection ]]
    then
      DeviceConnectionDuplicate=1
      if [[ $IsDeviceInput == 0 ]]
      then
        DeviceTypes[$CurrentDeviceNumber]+="/$DeviceType"
        DeviceDisplayNames[$CurrentDeviceNumber]+=", $Device"
      fi
    fi
  done
  if [[ ! -z $DeviceType && $DeviceConnectionDuplicate == 0 ]]
  then
    ((NumberOfDevices++))
    DevicePaths[$NumberOfDevices]=$Device
    DeviceDisplayNames[$NumberOfDevices]=$DeviceDisplayName
    DeviceNames[$NumberOfDevices]=$DeviceName
    DeviceConnections[$NumberOfDevices]=$DeviceConnection
    DeviceSessionSeatIDs[$NumberOfDevices]=$DeviceSessionSeatID
    DeviceWLSeatIDs[$NumberOfDevices]=$DeviceWLSeatID
    DeviceTypes[$NumberOfDevices]=$DeviceType
    DeviceInputTypeFlags[$NumberOfDevices]=$IsDeviceInput
   fi

done < <(find /dev/input/event[0-9]* /dev/dri/card[0-9]* /dev/fb[0-9]*)

#Get a list of all devices for the main form
for (( CurrentDeviceNumber=1; CurrentDeviceNumber<=$NumberOfDevices; CurrentDeviceNumber++ ))
do
  DeviceList+="     ${DeviceTypes[$CurrentDeviceNumber]}:      ${DeviceDisplayNames[$CurrentDeviceNumber]}      (Connected to: ${DeviceConnections[$CurrentDeviceNumber]})
"
done

#Show a guide for the users on what devices they have attached to their system, and what will be configured
zenity --no-wrap --info --text "The changes made here will effect all users, as well as the loginmanager. Multipointer is not supported by all Wayland servers.

This will allow you to configure what seats devices belong to, for Wayland, and for sessions.
   -  Wayland 'Seats' are what belong to a separate mouse cursor and keyboard focus

   -  Session 'Seats' are a grouping of a monitor, and input devices for side-by-side user sessions
      on one physical computer

Input are remembered by the device's internal name (usually containing the make and model), and the port they are plugged into.
In order for the configuration to work each time you plug your devices, you need to plug them into the same port, (otherwise they will default to the default seat)

The default Seat for Wayland pointers is 'default', while the default seat for Session seats is 'seat0'
if you wish to return one to the default

This Dialog lists all the devices that will be configured by this wizard. You can close this dialog at anytime,
Closing with will not interfere with the wizard, as it just serves as a guide to tell you how many devices are left.

Please note that some devices have multiple internal components, and sometimes register themselves more than once.

Devices:
$DeviceList " --title="Multipointer and Seat Configuration" 2>/dev/null &
MainFormPID=$!
sleep 5


#Create the config file
touch /lib/udev/rules.d/99-weston_seats_and_udev_seats.rules

#Generate a list of wayland seats for the Zenity dialogs for selection
unset WLSeatList
WLSeatList="default"
for (( CurrentSeat=1; CurrentSeat<$MaxNumberOfSeats; CurrentSeat++ ))
do
  WLSeatList+="|"
  WLSeatList+="seat$CurrentSeat"
done

#Generate a list of session seats for the Zenity dialogs for selection
unset SessionSeatList
SessionSeatList="seat0"
for (( CurrentSeat=1; CurrentSeat<$MaxNumberOfSeats; CurrentSeat++ ))
do
  SessionSeatList+="|"
  SessionSeatList+="seat$CurrentSeat"
done


#Go through each probed input device and prompt for a the seata to add the device to
for (( CurrentDeviceNumber=1; CurrentDeviceNumber<=$NumberOfDevices; CurrentDeviceNumber++ ))
do
  unset NewWLSeatNumber
  unset NewSessionSeatNumber
  if [[ ${DeviceInputTypeFlags[$CurrentDeviceNumber]} == 1 ]]
  then
    NewSeatSelection=$(zenity  --forms --add-combo "Session Seat" --combo-values="$SessionSeatList" --add-combo "Wayland Seat/Pointer" --combo-values="$WLSeatList" --text="Multipointer and Seat Configuration (Device $CurrentDeviceNumber of $NumberOfDevices)

    Select a seat for ${DeviceTypes[$CurrentDeviceNumber]}: ${DeviceDisplayNames[$CurrentDeviceNumber]}
    Connected to: ${DeviceConnections[$CurrentDeviceNumber]}

    Current Session Seat: ${DeviceSessionSeatIDs[CurrentDeviceNumber]}
    Current Wayland Seat/Pointer: ${DeviceWLSeatIDs[CurrentDeviceNumber]}" --separator="@" --title "Multipointer and Seat Configuration (Device $CurrentDeviceNumber of $NumberOfDevices)" 2>/dev/null)
  else
    NewSeatSelection=$(zenity --forms --add-combo "Session Seat" --combo-values="$SessionSeatList" --text="Multipointer and Seat Configuration (Device $CurrentDeviceNumber of $NumberOfDevices)

    Select a seat for ${DeviceTypes[$CurrentDeviceNumber]}: ${DeviceDisplayNames[$CurrentDeviceNumber]}
    Connected to: ${DeviceConnections[$CurrentDeviceNumber]}

    Current Session Seat: ${DeviceSessionSeatIDs[CurrentDeviceNumber]}" --separator="@" --title "Multipointer and Seat Configuration (Device $CurrentDeviceNumber of $NumberOfDevices)" 2>/dev/null)
  fi
  IFS="@"
  NewSeatSelection=($NewSeatSelection)
  unset IFS
  NewSessionSeatNumber=(${NewSeatSelection[0]})
  NewWLSeatNumber=(${NewSeatSelection[1]})

  #only change the seat id in udev if the user specified to do so
  if [[ ! -z ${NewSeatSelection[0]} || ! -z ${NewSeatSelection[1]} ]]
  then
    if [[ -z $NewWLSeatNumber ]]
    then
      NewWLSeatNumber="${DeviceWLSeatIDs[CurrentDeviceNumber]}"
    fi
    if [[ -z $NewSessionSeatNumber ]]
    then
      NewSessionSeatNumber="${DeviceSessionSeatIDs[CurrentDeviceNumber]}"
    fi

    cat /lib/udev/rules.d/99-weston_seats_and_udev_seats.rules > /tmp/99-weston_seats_and_udev_seats.rules.work
    if [[ ${DeviceInputTypeFlags[$CurrentDeviceNumber]} == 1 ]]
    then
      if [[ ! -z ${DeviceNames[$CurrentDeviceNumber]} && ! -z ${DeviceConnections[$CurrentDeviceNumber]} ]]
      then
        awk "!/${DeviceNames[$CurrentDeviceNumber]}/ || !/${DeviceConnections[$CurrentDeviceNumber]}/" /tmp/99-weston_seats_and_udev_seats.rules.work > /lib/udev/rules.d/99-weston_seats_and_udev_seats.rules
      else
        if [[ ! -z ${DeviceNames[$CurrentDeviceNumber]} ]]
        then
          awk "!/${DeviceNames[$CurrentDeviceNumber]}/" /tmp/99-weston_seats_and_udev_seats.rules.work > /lib/udev/rules.d/99-weston_seats_and_udev_seats.rules
        fi
        if [[ ! -z ${DeviceConnections[$CurrentDeviceNumber]} ]]
        then
          awk "!/${DeviceConnections[$CurrentDeviceNumber]}/" /tmp/99-weston_seats_and_udev_seats.rules.work > /lib/udev/rules.d/99-weston_seats_and_udev_seats.rules
        fi
      fi
      echo "ENV{ID_SERIAL}==\"${DeviceNames[$CurrentDeviceNumber]}\", ENV{ID_PATH}==\"${DeviceConnections[$CurrentDeviceNumber]}\", ENV{ID_SEAT}=\"$NewSessionSeatNumber\", ENV{WL_SEAT}=\"$NewWLSeatNumber\"" >> /lib/udev/rules.d/99-weston_seats_and_udev_seats.rules
    else
      if [[ ! -z ${DeviceConnections[$CurrentDeviceNumber]} ]]
      then
        awk "!/${DeviceConnections[$CurrentDeviceNumber]}/" /tmp/99-weston_seats_and_udev_seats.rules.work > /lib/udev/rules.d/99-weston_seats_and_udev_seats.rules
      fi
      echo "ENV{ID_PATH}==\"${DeviceConnections[$CurrentDeviceNumber]}\", ENV{ID_SEAT}=\"$NewSessionSeatNumber\"" >> /lib/udev/rules.d/99-weston_seats_and_udev_seats.rules
    fi
    rm /tmp/99-weston_seats_and_udev_seats.rules.work
  fi
done

#Close the main zenity window that lists all devices when this script is exiting
kill -9 $MainFormPID

#tell the user that their session is going to 'flicker' as the tty is switched in and out so that the display server is forced to see the new Udev config (this works for weston)
zenity --info --text "Seat Configuration for all devices is now complete.

Press OK to apply all the changes. The screen may flicker for less than a second." --no-wrap --title="Multipointer and Seat Configuration" 2>/dev/null

#Reload the new configuration into udev
udevadm control --reload-rules

#Notify each input device about the change with udev, instead of doing a full trigger on all devices on the system
for (( CurrentDeviceNumber=1; CurrentDeviceNumber<=$NumberOfDevices; CurrentDeviceNumber++ ))
do
  udevadm trigger --sysname-match=$(basename ${DevicePaths[$CurrentDeviceNumber]})
done

#If the Wayland server is hosted 
if [[ ! -z $WAYLAND_HOST ]]
then
  WAYLAND_SERVER=$WAYLAND_HOST
else
  WAYLAND_SERVER=$WAYLAND_DISPLAY
fi

#Force the server to pickup the changes
chvt 63
sleep .1
chvt $CurrentTTY
