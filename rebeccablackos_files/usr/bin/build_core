#! /bin/bash
#    Copyright (c) 2012, 2013, 2014, 2015, 2016, 2017 nerdopolis (or n3rdopolis) <bluescreen_avenger@verzion.net>
#
#    This file is part of RebeccaBlackOS.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

#It depends on git, bzr, hg, svn, checkinstall, acl, and dlocate

#This script is called by all of the scripts in /usr/bin/Compile. It contains many functions so that it doesn't have to be duplicated throughout the multiple scripts. It handles downloading the source specified by the scripts, and running the build and install functions. It also passes the install process through checkinstall to create deb files out of the scripts if the environment variable is 1.
#
#These options are specified in the build scripts
#SOURCENAME: Set the name of the directory to save the source in, and the name of the deb if checkinstall is specified
#SOURCEURL: The download location of the file or source repo do download
#REPOSITORYTYPE: The type of source repo. Supported types are GIT, SVN, BZR, HG, and ARCHIVE (for archive files instead of a source repo)
#SOURCEREVISION: The revision to use from the source repo. This is ignored if the REPOSITORYTYPE is archive
#INSTALLDIR: This specifies the location to install the source. This variable must be used or must match when specified to autogen or cmake or the like.
#        It is used by build_vars to set the needed variables.
#REBUILDNEWREVISION: This is for MAKEDEBS. Some packages are worth rebuilding even if the deb file for this is already built, as it might be getting features faster, and is a smaller source package.


#GIT SUBMODULES
#This script specifies setting values for GIT submodules
#Specify any custom revisions for git submodules in the format shown below
# SUBMODULEREVISIONS=(examplesubmodule master 
# nested/submodule 1.0
# 'submodule with spaces' master
# commitsubmodule 0123456789abcdef )


#The following Functions for the build scripts are supported
#PackageDownloadSource: any additional downloads that are needed that might not be in the source repo. This is called after the routine for downloading the archive type
#PackagePrepareBuild: Any changes to the source. This is called first during a build.
#PackageCompileSource: Routine for compiling (but not installing the source). This is called second in a build.
#PackageInstallSource: Routine for installing the source. The actions here are intercepted by checkinstall if MAKEDEBS is specified. Changes to the source directory is not included in the Checkinstalled debs.
#PackagePostInstall: Routines after the source in installed. The actions here are intercepted by checkinstall if MAKEDEBS is specified. Changes to the source directory is not included in the Checkinstalled debs.

#Each function is started with the CWD as the source download folder. For example If PackageCompileSource cd's to ./build and make is called, then PackageInstallSource will also need to cd to ./build

#About MAKEDEBS. 
#MAKEDEBS causes debs to be built in /srcbuild/buildoutput fo the packages it compiles, with checkinstall, which watches the files touched and created by the install functions.
#It finds all built libraries and binaries in the source, finds what libraries they all depend on with ldd, and then finds what packages the depends are in, to give a rough dependancy manament for the built debs.
#When a deb is built, it installs the deb on the next run instead of a compile. UNLESS REBUILDNEWREVISION=1 is set, AND the revision number/ID based on the source revision control software changes.
#or the control file is deleted, or the deb is nonexistant or empty.

#removing /srcbuild/buildoutput/control/PACKAGENAME causes PACKAGENAME to be rebuilt manually

#buildcore also uses /tmp/buildcore_revisions.txt, when it is formatted from the list of all built revisions exported by the project. If it exists, the revision specified by the build script is overidden, and the exact commit is used instead

#Allow build core to directly run a specified build descriptor file. They all source build_core, prevent an infinate loop
if [[ $BUILDCOREDIRECTLYRUN == 1 ]]
then
  return 0
fi
BUILDCOREDIRECTLYRUN=1

#if the first argument is buildspec, a file is being sourced.
if [[ $1 == buildspec ]]
then
  function RunDownloadAndOrBuild { :; }
  FILESPEC=1
  . "$2"
  shift
  shift
fi

export NONROOTUSER=nobody
export SOURCEDIR=/srcbuild
export REBUILDNEWREVISION=0
export PACKAGESUFFIX=rbos
export NONROOTCOMMAND="sudo -Eu $NONROOTUSER"
export BUILDLOGDIR=/buildlogs/build_core

if [[ -x /usr/libexec/build_core/checkinstall ]]
then
  CHECKINSTALLCMD=/usr/libexec/build_core/checkinstall
else
  CHECKINSTALLCMD=checkinstall
fi

#Control variable used by the build scripts, on if to set the build script as 'build-only' or 'download-only'
export ACTION=$1

function SetACLPermissions
{
  echo "Setting permissions to allow non root user '$NONROOTUSER' to manage $SOURCENAME source"
  setfacl -Rm $NONROOTUSER:rwx -Rm mask::rwx -dRm $NONROOTUSER:rwx -dRm mask::rwx /"$SOURCEDIR"/"$SOURCENAME" "$SOURCEDIR"/buildhome/config/"$SOURCENAME" "$SOURCEDIR"/buildhome/sourcehome/"$SOURCENAME"
  setfacl -Rm $NONROOTUSER:rwx -Rm mask::rwx -dRm $NONROOTUSER:rwx -dRm mask::rwx "$SOURCEDIR"/buildhome/cargocache
}

#This is the main function of the script that must be called by the script that sources it in.  It determines if the action is to build, download, or do both.
function RunDownloadAndOrBuild 
{
  #Require root privlages
  if [[ $UID != 0 ]]
  then
    echo "Must be run as root."
    exit
  fi
  if [[ -z $SOURCENAME ]]
  then
    echo "SOURCENAME Not defined."
    exit
  fi

  export CARGO_HOME="$SOURCEDIR"/buildhome/cargocache
  rm -rf "$SOURCEDIR"/buildhome/sourcehome/"$SOURCENAME"
  rm -rf "$SOURCEDIR"/buildhome/config/"$SOURCENAME"

  export HOME="$SOURCEDIR"/buildhome/config/"$SOURCENAME"

  mkdir -p "$SOURCEDIR"/buildhome/config/"$SOURCENAME"
  mkdir -p "$BUILDLOGDIR/$SOURCENAME"
  mkdir -p "$SOURCEDIR"/buildhome/sourcehome/"$SOURCENAME"
  mkdir -p "$SOURCEDIR"/buildhome/cargocache

  #create a variable for the package name that is the source name converted to all lower case.
  export PACKAGESOURCENAME="$(echo $SOURCENAME | tr [:upper:] [:lower:] | sed 's/_/-/g')"

  SOURCENAMECHARS="${#SOURCENAME}"
  iterator=0
  export SAFESOURCENAME=$(for (( iterator=0; iterator < $SOURCENAMECHARS ; iterator++ ))
  do
    CHAR=$(echo -n ${SOURCENAME:$iterator:1})
    if [[ $CHAR == [a-Z0-9-_] ]]
    then
      echo -n $CHAR
    else
      printf '_%o' "'$CHAR"
    fi
  done)
  export EXTERNALBUILDHOME="$SOURCEDIR"/buildhome/sourcehome/"$SOURCENAME"
  export INTERNALBUILDHOME="$SOURCEDIR"/"$SOURCENAME"

  #Set ACL permissions to allow a non root user account manage the source repos
  setfacl -dm $NONROOTUSER:rwx /"$SOURCEDIR"
  setfacl -m $NONROOTUSER:rwx /"$SOURCEDIR"
  setfacl -dm mask::rwx /"$SOURCEDIR"
  setfacl -m mask::rwx /"$SOURCEDIR"

  #If the argument passed is cleanup, then cleanup the source only
  if [[ "$ACTION" == clean ]]
  then
    cd "$SOURCEDIR"
    Cleanup$REPOSITORYTYPE 2>&1 | tee -a "$BUILDLOGDIR/$SOURCENAME/Cleanup$REPOSITORYTYPE" | sed -e "s/^/$SOURCENAME: /"
    exit
  fi

  #Install the smaller version of the package
  if [[ "$ACTION" == installsmallpackage ]]
  then
    STARTTIME=$(date +%s)
    InstallDebFile "/$SOURCEDIR/buildoutput/smallpackages/""$PACKAGESOURCENAME"-"$PACKAGESUFFIX"_*.deb 2>&1 | tee "$BUILDLOGDIR/$SOURCENAME/SmallDebInstall"
    ENDTIME=$(date +%s)
    echo "SmallDebInstall finished in $((ENDTIME-STARTTIME)) seconds" 2>&1 | tee -a "$BUILDLOGDIR/$SOURCENAME/SmallDebInstall"
    exit
  fi
  
  #Download source, unless the argument passed to the build script is 'build-only'
  if [[ "$ACTION" != build-only && "$ACTION" != env-only ]]
  then
    #Download the source using specified variables.
    DownloadSource 2>&1 | sed -e "s/^/$SOURCENAME: /"
  fi

  #Build the source and install it, unless the argument passed to the build script is 'download-only'
  if [[ "$ACTION" != download-only && "$ACTION" != env-only ]]
  then
    #Start the compile or install Process
    MakeAndInstall 2>&1 | sed -e "s/^/$SOURCENAME: /"
  fi
}

#Function to install build_core built deb files
function InstallDebFile()
{
  dpkg -i --force-overwrite "$1"
}

#function to get the revison of GIT repos
function GetVersionGIT()
{
  SOURCEREVISION_EXPORT=$(git rev-parse HEAD)
  SOURCEREVISION=$(declare -p SOURCEREVISION_EXPORT)
  SUBMODULESTRING=$(git submodule | sed -e 's/+//g' -e 's/-//g' | awk '{print $2 "|" $1 "|" }')
  export IFS="|"$'\n'
  SUBMODULEREVISIONS_EXPORT=($SUBMODULESTRING)
  unset IFS
  SUBMODULEREVISIONS=$(declare -p SUBMODULEREVISIONS_EXPORT)
  FUNCTIONSTRING="{ $SOURCEREVISION ; SOURCEREVISION=\\\$SOURCEREVISION_EXPORT ; $SUBMODULEREVISIONS ; SUBMODULEREVISIONS=(\\\${SUBMODULEREVISIONS_EXPORT[*]}) ; : $SOURCENAME; }"
  REVISIONSTRING="eval \"OverrideRevisions_${SAFESOURCENAME}() $FUNCTIONSTRING\""
}

#Function to cleanup GIT repos
function CleanupGIT()
{
  $NONROOTCOMMAND mkdir -p "$SOURCENAME"
  cd "$SOURCENAME"
  git submodule foreach --recursive git reset --hard 
  git submodule foreach --recursive git clean -fdx
  git clean -fdx
  git reset --hard
  git clean -fdx
}

#Function to download git repos
function DownloadGIT()
{
  git config --global core.askpass /bin/true
  OLDSOURCEURL=$(git --git-dir="$SOURCENAME"/.git remote -v | grep '(fetch)' | grep origin | awk '{print $2}' )
  if [[ -z "$OLDSOURCEURL" || "$SOURCEURL" != "$OLDSOURCEURL" ]]
  then
    rm -rf "$SOURCENAME"

    if [[ $MAKEDEBS == 1 ]]
    then
      rm "/$SOURCEDIR/buildoutput/control/$SOURCENAME"
      rm "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt"
      rm "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt.old"
    fi
  fi

  $NONROOTCOMMAND git clone $SOURCEURL $SOURCENAME
  $NONROOTCOMMAND mkdir -p "$SOURCENAME"
  cd "$SOURCENAME"
  if [[ -z $SOURCEREVISION ]]
    then
      SOURCEREVISION=$(git rev-parse --abbrev-ref HEAD)
  fi
  find .git |grep index.lock|
  while read LOCKFILE
  do
    rm "$LOCKFILE"
  done
  $NONROOTCOMMAND git checkout -f $SOURCEREVISION 
  $NONROOTCOMMAND git reset --hard
  rm -rf .git/rebase-*/
  rm -rf .git/modules/*/rebase-*/
  $NONROOTCOMMAND git rebase -s ours
  $NONROOTCOMMAND git pull -f
  $NONROOTCOMMAND git rebase -s ours
  $NONROOTCOMMAND git checkout -f $SOURCEREVISION 
  git config user.email "$PACKAGESUFFIX"@"$PACKAGESUFFIX"
  $NONROOTCOMMAND git submodule sync --recursive
  $NONROOTCOMMAND git submodule deinit -f .
  $NONROOTCOMMAND git submodule update --recursive --force --init
  $NONROOTCOMMAND git pull -f

  #Get the number of revisions specified.
  SUBMODULEREVISIONCOUNT=$(( ${#SUBMODULEREVISIONS[@]} /2 * 2))
  for (( SUBMODULEREVISION=0; SUBMODULEREVISION < SUBMODULEREVISIONCOUNT; SUBMODULEREVISION=SUBMODULEREVISION+2 ))
  do
    MODULENAME=${SUBMODULEREVISIONS[$SUBMODULEREVISION]}
    MODULEREVISION=${SUBMODULEREVISIONS[$SUBMODULEREVISION+1]}

    cd "$SOURCEDIR"
    cd "$SOURCENAME"

    $NONROOTCOMMAND mkdir -p $MODULENAME
    cd $MODULENAME
    if [[ -z $MODULEREVISION ]]
    then
      MODULEREVISION=$(git rev-parse --abbrev-ref HEAD)
    fi
    $NONROOTCOMMAND git checkout -f $MODULEREVISION 
    $NONROOTCOMMAND git reset --hard
    
    $NONROOTCOMMAND git rebase
    $NONROOTCOMMAND git pull -f
    $NONROOTCOMMAND git rebase -s ours
    git config user.email "$PACKAGESUFFIX"@$"$PACKAGESUFFIX"
    $NONROOTCOMMAND git submodule sync --recursive
    $NONROOTCOMMAND git submodule init
    $NONROOTCOMMAND git submodule update --recursive --force
    $NONROOTCOMMAND git pull -f
  done

}

#function to get the revison of SVN repos
function GetVersionSVN()
{
  SOURCEREVISION_EXPORT=$(svnversion .)
  SOURCEREVISION=$(declare -p SOURCEREVISION_EXPORT)
  FUNCTIONSTRING="{ $SOURCEREVISION ; SOURCEREVISION=\\\$SOURCEREVISION_EXPORT ; : $SOURCENAME; }"
  REVISIONSTRING="eval \"OverrideRevisions_${SAFESOURCENAME}() $FUNCTIONSTRING\""
}

#Function to cleanup SVN repos
function CleanupSVN()
{
  $NONROOTCOMMAND mkdir -p "$SOURCENAME"
  cd "$SOURCENAME"
  svn revert --non-interactive --recursive .
  svn cleanup --non-interactive
}

#Function to download svn repos
function DownloadSVN()
{
  OLDSOURCEURL=$(svn info "$SOURCENAME" | grep "^URL: " | awk '{print $2}')
  if [[ -z "$OLDSOURCEURL" || "$SOURCEURL" != "$OLDSOURCEURL" ]]
  then
    rm -rf "$SOURCENAME"
    if [[ $MAKEDEBS == 1 ]]
    then
      rm "/$SOURCEDIR/buildoutput/control/$SOURCENAME"
      rm "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt"
      rm "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt.old"
    fi

  fi

  $NONROOTCOMMAND svn co --non-interactive "$SOURCEURL" "$SOURCENAME"
  $NONROOTCOMMAND mkdir -p "$SOURCENAME"
  cd "$SOURCENAME"
  $NONROOTCOMMAND svn update --non-interactive -r $SOURCEREVISION
}


#function to get the version of BZR repos
function GetVersionBZR()
{
  SOURCEREVISION_EXPORT=$(bzr version-info | grep revno | awk '{print $2}')
  SOURCEREVISION=$(declare -p SOURCEREVISION_EXPORT)
  FUNCTIONSTRING="{ $SOURCEREVISION ; SOURCEREVISION=\\\$SOURCEREVISION_EXPORT ; : $SOURCENAME; }"
  REVISIONSTRING="eval \"OverrideRevisions_${SAFESOURCENAME}() $FUNCTIONSTRING\""
}

#Function to cleanup BZR repos
function CleanupBZR()
{
  $NONROOTCOMMAND mkdir -p "$SOURCENAME"
  cd "$SOURCENAME"
  bzr revert
  bzr clean-tree --force
  bzr clean-tree --force --detritus
}

#Function to download bzr repos
function DownloadBZR()
{
  OLDSOURCEURL=$(bzr info $SOURCENAME | grep "parent branch" | awk -F "branch: " '{print $2}')
  if [[ -z "$OLDSOURCEURL" || "$SOURCEURL" != "$OLDSOURCEURL" ]]
  then
    rm -rf "$SOURCENAME"

    if [[ $MAKEDEBS == 1 ]]
    then
      rm "/$SOURCEDIR/buildoutput/control/$SOURCENAME"
      rm "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt"
      rm "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt.old"
    fi

  fi

  $NONROOTCOMMAND bzr branch "$SOURCEURL" "$SOURCENAME"
  $NONROOTCOMMAND mkdir -p "$SOURCENAME"
  cd "$SOURCENAME"
  $NONROOTCOMMAND bzr pull
  $NONROOTCOMMAND bzr update -r $SOURCEREVISION
}

#function to get the version of HG repos
function GetVersionHG()
{
  SOURCEREVISION_EXPORT=$(hg --debug id -i | sed 's/+//g')
  SOURCEREVISION=$(declare -p SOURCEREVISION_EXPORT)
  FUNCTIONSTRING="{ $SOURCEREVISION ; SOURCEREVISION=\\\$SOURCEREVISION_EXPORT ; : $SOURCENAME; }"
  REVISIONSTRING="eval \"OverrideRevisions_${SAFESOURCENAME}() $FUNCTIONSTRING\""
}

#Function to cleanup BZR repos
function CleanupHG()
{
  $NONROOTCOMMAND  mkdir -p "$SOURCENAME"
  cd "$SOURCENAME"
  hg --config trusted.users=$NONROOTUSER,root revert --all
  hg --config trusted.users=$NONROOTUSER,root --config extensions.purge= purge
}

#Function to download hg repos
function DownloadHG()
{
  OLDSOURCEURL=$(hg paths -R "$SOURCENAME" default)
  if [[ -z "$OLDSOURCEURL" || "$SOURCEURL" != "$OLDSOURCEURL" ]]
  then
    rm -rf "$SOURCENAME"

    if [[ $MAKEDEBS == 1 ]]
    then
      rm "/$SOURCEDIR/buildoutput/control/$SOURCENAME"
      rm "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt"
      rm "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt.old"
    fi

  fi

  
  $NONROOTCOMMAND hg clone "$SOURCEURL" "$SOURCENAME"
  $NONROOTCOMMAND mkdir -p "$SOURCENAME"
  cd "$SOURCENAME"
  $NONROOTCOMMAND hg --config trusted.users=$NONROOTUSER,root pull
  $NONROOTCOMMAND hg --config trusted.users=$NONROOTUSER,root update -C -r $SOURCEREVISION
}


#function to get the version of Archives
function GetVersionARCHIVE()
{
  SOURCEREVISION_EXPORT=$(echo "Non-versioned File Archive")
  SOURCEREVISION=$(declare -p SOURCEREVISION_EXPORT)
  FUNCTIONSTRING="{ $SOURCEREVISION ; SOURCEREVISION=\\\$SOURCEREVISION_EXPORT ; : $SOURCENAME; }"
  REVISIONSTRING="eval \"OverrideRevisions_${SAFESOURCENAME}() $FUNCTIONSTRING\""
}

#Function to cleanup archives
function CleanupARCHIVE()
{
  $NONROOTCOMMAND mkdir -p "$SOURCENAME"
  cd "$SOURCENAME"
  find | grep -v ./SOURCEFILE$ | grep -v ./SOURCEURL | sort -r | while read FILE
  do
    rm -rf $FILE
  done
}
#Function to download archives
function DownloadARCHIVE()
{
  OLDSOURCEURL=$(cat "$SOURCENAME/SOURCEURL")
  if [[ -z "$OLDSOURCEURL" || "$SOURCEURL" != "$OLDSOURCEURL" ]]
  then
    rm "$SOURCENAME/SOURCEFILE"

    if [[ $MAKEDEBS == 1 ]]
    then
      rm "/$SOURCEDIR/buildoutput/control/$SOURCENAME"
      rm "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt"
      rm "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt.old"
    fi
  fi

  if [[ ! -f "$SOURCENAME/SOURCEFILE" ]]
  then
    $NONROOTCOMMAND mkdir -p "$SOURCENAME"
    $NONROOTCOMMAND wget "$SOURCEURL" -O $SOURCENAME/SOURCEFILE
    echo "$SOURCEURL" > $SOURCENAME/SOURCEURL
  fi
  cd "$SOURCENAME"
  $NONROOTCOMMAND tar xaf SOURCEFILE -C .
}

#Function to go through all toml files in the PWD, and fetch the dependancies they need
function DownloadTOMLData()
{

  #Handle Cargo files for any potential rust programs
  find | grep /Cargo.toml$ | while read CARGOFILE
  do
    echo "Downloading dependancies defined by $CARGOFILE"
    #$CARGO_HOME/cargo update --aggressive --manifest-path $CARGOFILE
    $CARGO_HOME/cargo fetch --manifest-path $CARGOFILE
  done
}

#Function that calls download functions for GIT repos based on the repository type set by the main script
function DownloadSource()
{
  #If /tmp/buildcore_revisions.txt exists, then import it.
  #Copy the /tmp/buildcore_revisions.txt script into its own folder, and set that folder as the path for a restricted shell, running as nonroot
  #For that restricted shell, call the function for setting the SOURCEREVISION and SUBMODULEREVISIONS for the current sourcce name
  #Export the declare commands to a new script, and then source it in, to protect against rouge revision scripts
  if [[ -e /tmp/buildcore_revisions.txt ]]
  then
    BASHEXE=$(which bash)
    FOLDERDATE=$(date +%s)
    RANDSTR=$RANDOM
    mkdir /tmp/buildcore_secure_${FOLDERDATE}_${RANDSTR}
    chmod 700 /tmp/buildcore_secure_${FOLDERDATE}_${RANDSTR}
    chown $NONROOTUSER /tmp/buildcore_secure_${FOLDERDATE}_${RANDSTR}
    rm -rf /tmp/buildcore_secure_${FOLDERDATE}_${RANDSTR}/*
    cp /tmp/buildcore_revisions.txt /tmp/buildcore_secure_${FOLDERDATE}_${RANDSTR}/buildcore_revisions.txt
    chmod 755 /tmp/buildcore_secure_${FOLDERDATE}_${RANDSTR}/buildcore_revisions.txt
    sudo -u $NONROOTUSER PATH=/tmp/buildcore_secure_${FOLDERDATE}_${RANDSTR} $BASHEXE -r -c ". buildcore_revisions.txt 2>&- 1>&-; OverrideRevisions_$SAFESOURCENAME 2>&- 1>&-; POSIXLY_CORRECT=1; unset declare; \declare -p SOURCEREVISION; \declare -p SUBMODULEREVISIONS" > /tmp/buildcore_secure_${FOLDERDATE}_${RANDSTR}/revisiondata
    chmod +x /tmp/buildcore_secure_${FOLDERDATE}_${RANDSTR}/revisiondata
    . /tmp/buildcore_secure_${FOLDERDATE}_${RANDSTR}/revisiondata
    rm -rf /tmp/buildcore_secure_${FOLDERDATE}_${RANDSTR}
  fi
  mkdir -p "$SOURCEDIR"
  cd "$SOURCEDIR"
  REPOSITORYTYPE=$(echo $REPOSITORYTYPE |tr [:lower:] [:upper:])

  #count the number of non-empty debs for this package
  DEBFILECONTENTCOUNT=0
  while read DEBFILE
  do
    while read LINE
    do
     LINEARRAY=($LINE)
     if [[ ${LINEARRAY[5]} != "./usr/share/buildcore_revisions/buildresults/$SOURCENAME" ]]
     then
       ((DEBFILECONTENTCOUNT++))
     else
       DEBFILECONTENTCOUNT=0
       break
     fi
    done < <(dpkg-deb -c "$DEBFILE" 2>/dev/null | grep -v ^d | grep -v /include/ | grep -v "/usr/share/buildcore_revisions/$SOURCENAME" )
  done < <(find "/$SOURCEDIR/buildoutput/""$PACKAGESOURCENAME"-"$PACKAGESUFFIX"_*.deb -maxdepth 1 -type f )

  #If there is no deb file, no control file, debs aren't being built, or the package is set to rebuild on every try, run the download routine
  if [[ ! $(ls "/$SOURCEDIR/buildoutput/""$PACKAGESOURCENAME"-"$PACKAGESUFFIX"_*.deb ) || ! $(ls "/$SOURCEDIR/buildoutput/smallpackages/""$PACKAGESOURCENAME"-"$PACKAGESUFFIX"_*.deb ) || ! -f "/$SOURCEDIR/buildoutput/control/$SOURCENAME" || $MAKEDEBS != 1 || $REBUILDNEWREVISION != 0 || $DEBFILECONTENTCOUNT == 0 ]]
  then
    STARTTIME=$(date +%s)
    SetACLPermissions
    Cleanup$REPOSITORYTYPE 2>&1 | tee -a "$BUILDLOGDIR/$SOURCENAME/Cleanup$REPOSITORYTYPE"
    Download$REPOSITORYTYPE 2>&1 | tee "$BUILDLOGDIR/$SOURCENAME/Download$REPOSITORYTYPE"
    ENDTIME=$(date +%s)
    echo "Download$REPOSITORYTYPE finished in $((ENDTIME-STARTTIME)) seconds" 2>&1 | tee -a "$BUILDLOGDIR/$SOURCENAME/Download$REPOSITORYTYPE"

    #Download cargo bootstrap binary, to handle downloading cargo, only if the package has Cargo.toml files
    TOMLFILES=$(find "/$SOURCEDIR/$SOURCENAME" | grep /Cargo.toml$)
    if [[ ! -f $CARGO_HOME/cargo && ! -z $TOMLFILES ]]
    then
      DEBIAN_ARCH=$(dpkg --print-architecture)
      if [[ $DEBIAN_ARCH == i386 ]]
      then
        CARGOFILENAME=cargo-nightly-i686-unknown-linux-gnu
      fi
      if [[ $DEBIAN_ARCH == amd64 ]]
      then
        CARGOFILENAME=cargo-nightly-x86_64-unknown-linux-gnu
      fi
      $NONROOTCOMMAND wget https://static.rust-lang.org/dist/$CARGOFILENAME.tar.gz -O /srcbuild/buildhome/cargocache/$CARGOFILENAME.tar.gz
      tar -xzf /srcbuild/buildhome/cargocache/$CARGOFILENAME.tar.gz -C /srcbuild/buildhome/cargocache
      cp /srcbuild/buildhome/cargocache/$CARGOFILENAME/cargo/bin/cargo $CARGO_HOME
    fi

    #Create a script that will run as a nonroot user, to handle the scripts custom download actions after its been downloaded, and run cargo.
    echo "#! /bin/bash
    $(declare -f PackageDownloadSource)
    $(declare -f DownloadTOMLData)
    export SOURCEDIR=$SOURCEDIR
    export SOURCENAME=$SOURCENAME
    export INSTALLDIR=$INSTALLDIR

    cd "/$SOURCEDIR/$SOURCENAME"

    DownloadTOMLData
    PackageDownloadSource
    
" > "/$SOURCEDIR/$SOURCENAME/packagedownloadscript"
    chmod +x "/$SOURCEDIR/$SOURCENAME/packagedownloadscript"
    STARTTIME=$(date +%s)
    $NONROOTCOMMAND "/$SOURCEDIR/$SOURCENAME/packagedownloadscript"   2>&1 | tee "$BUILDLOGDIR/$SOURCENAME/PackageDownloadSource"

    ENDTIME=$(date +%s)
    echo "PackageDownloadSource finished in $((ENDTIME-STARTTIME)) seconds" 2>&1 | tee -a "$BUILDLOGDIR/$SOURCENAME/PackageDownloadSource"
    rm "/$SOURCEDIR/$SOURCENAME/packagedownloadscript"
  fi
}

#function that calls functions to get version based on repository type
function GetSourceVersion()
{
  GetVersion$REPOSITORYTYPE
  echo "$REVISIONSTRING"

  if [[ $MAKEDEBS == 1 ]]
  then
    mkdir -p "/$SOURCEDIR/buildoutput/versioninfo"
    mkdir -p "/$SOURCEDIR/buildoutput/smallpackages"
    echo "$REVISIONSTRING" > "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt"
    echo 
  fi
}


function SetBuildVariables()
{
  #Create build variables
  . /usr/bin/build_vars
}

#Function that calls common build preperations, and then calls upon the main builder scripts prepare function
function PrepareBuild()
{
  SetBuildVariables
  mkdir -p "$SOURCEDIR"
  cd "$SOURCEDIR"
  mkdir -p "$SOURCENAME"
  cd "$SOURCENAME"

  STARTTIME=$(date +%s)
  PackagePrepareBuild 2>&1 | tee "/$SOURCEDIR/$SOURCENAME/Logs/PackagePrepareBuild"
  ENDTIME=$(date +%s)
  echo "PackagePrepareBuild finished in $((ENDTIME-STARTTIME)) seconds" 2>&1 | tee -a "/$SOURCEDIR/$SOURCENAME/Logs/PackagePrepareBuild"
}

#Function that handles the build of the source, creation of the deb file, or installation of the source
function MakeAndInstall()
{
  mkdir -p "$SOURCEDIR"
  cd "$SOURCEDIR"
  mkdir -p "$SOURCENAME"
  cd "$SOURCENAME"
  mkdir -p "$INSTALLDIR/share/aclocal"
  mkdir -p "$INSTALLDIR/lib/$DEB_HOST_MULTIARCH"
  mkdir -p "$INSTALLDIR/libexec"
  mkdir -p "$INSTALLDIR/doc"
  mkdir -p "$INSTALLDIR/include"

  
  #Get all Source 
  if [[ ! -e /usr/share/buildcore_revisions.txt ]]
  then
    echo "#This script is used to specify the revisions of the repositories which the ISO was built with. See output of the main builder for how to use this file, if you want to build the exact revisions, instead of the latest ones" > /usr/share/buildcore_revisions.txt
  fi

  #Log the source version
  GetSourceVersion | tee -a /usr/share/buildcore_revisions.txt > "$BUILDLOGDIR/$SOURCENAME/GetSourceVersion"

  #If the script is set to always rebuild, then detect if the revision info changed.
  if [[ $REBUILDNEWREVISION == 1 && $MAKEDEBS == 1 ]]
  then
    DIFFERENTREVISION="$(diff -q "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt" "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt.old" &>/dev/null ; echo $?)"
    cat "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt" > "/$SOURCEDIR/buildoutput/versioninfo/$SOURCENAME.txt.old"
  else 
    DIFFERENTREVISION=0
  fi

  #count the number of non-empty debs for this package
  DEBFILECONTENTCOUNT=0
  while read DEBFILE
  do
    while read LINE
    do
     LINEARRAY=($LINE)
     if [[ ${LINEARRAY[5]} != "./usr/share/buildcore_revisions/buildresults/$SOURCENAME" ]]
     then
       ((DEBFILECONTENTCOUNT++))
     else
       DEBFILECONTENTCOUNT=0
       break
     fi
    done < <(dpkg-deb -c "$DEBFILE" 2>/dev/null | grep -v ^d | grep -v /include/ | grep -v "/usr/share/buildcore_revisions/$SOURCENAME" )
  done < <(find "/$SOURCEDIR/buildoutput/""$PACKAGESOURCENAME"-"$PACKAGESUFFIX"_*.deb -maxdepth 1 -type f )

  #If the deb file is gone, there is no control file, or the script is set to build a new revision and there is anew revision, or the scripts not configured to make deb files, then build the source
  if [[ ! $(ls "/$SOURCEDIR/buildoutput/""$PACKAGESOURCENAME"-"$PACKAGESUFFIX"_*.deb ) || ! $(ls "/$SOURCEDIR/buildoutput/smallpackages/""$PACKAGESOURCENAME"-"$PACKAGESUFFIX"_*.deb ) || ! -f "/$SOURCEDIR/buildoutput/control/$SOURCENAME" || $MAKEDEBS != 1 || $DIFFERENTREVISION != 0 || $DEBFILECONTENTCOUNT == 0 ]]
  then
    if [[ $MAKEDEBS == 1 ]]
    then
      rm "/$SOURCEDIR/buildoutput/control/$SOURCENAME" 2>/dev/null
    fi

    #Empty any possible logs inside the source folder
    rm "/$SOURCEDIR/$SOURCENAME/Logs/"*

    #Create a script that will be run as non root, to handle the custom configure and build options
    echo "#! /bin/bash
    mkdir -p \"/$SOURCEDIR/$SOURCENAME/Logs\"
    $(declare -f SetBuildVariables)
    $(declare -f PrepareBuild)
    $(declare -f PackagePrepareBuild)
    $(declare -f PackageCompileSource)
    export SOURCEDIR=$SOURCEDIR
    export SOURCENAME=$SOURCENAME
    export INSTALLDIR=$INSTALLDIR

    cd "/$SOURCEDIR/$SOURCENAME"
    #Call PrepareBuild functions
    PrepareBuild

    #Complile the source
    STARTTIME=\$(date +%s)
    PackageCompileSource 2>&1 | tee \"/$SOURCEDIR/$SOURCENAME/Logs/PackageCompileSource\"
    ENDTIME=\$(date +%s)
    echo "PackageCompileSource finished in '$((ENDTIME-STARTTIME))' seconds" 2>&1 | tee -a \"/$SOURCEDIR/$SOURCENAME/Logs/PackageCompileSource\"
" > "/$SOURCEDIR/$SOURCENAME/packagecompilescript"

    chmod +x "/$SOURCEDIR/$SOURCENAME/packagecompilescript"
    $NONROOTCOMMAND "/$SOURCEDIR/$SOURCENAME/packagecompilescript"

    #Create a script file that will be called by checkinstall, or just called if no .deb files are being made. It exports the current build scripts PackageInstallSource and PackagePostInstall functions to the script.
    echo "#! /bin/bash
    mkdir -p \"/$SOURCEDIR/$SOURCENAME/Logs\"
    $(declare -f SetBuildVariables)
    $(declare -f PackageInstallSource)
    $(declare -f PackagePostInstall)
    export SOURCEDIR=$SOURCEDIR
    export SOURCENAME=$SOURCENAME
    export INSTALLDIR=$INSTALLDIR

    mkdir \"/usr/share/buildcore_revisions/\"
    cp \"$BUILDLOGDIR/$SOURCENAME/GetSourceVersion\" \"/usr/share/buildcore_revisions/$SOURCENAME\"

    SetBuildVariables

    STARTTIME=\$(date +%s)
    PackageInstallSource 2>&1 | tee \"/$SOURCEDIR/$SOURCENAME/Logs/PackageInstallSource\"
    PackageInstallSourceResult=\${PIPESTATUS[0]}
    ENDTIME=\$(date +%s)
    echo \"PackageInstallSource finished in \$((ENDTIME-STARTTIME)) seconds\" 2>&1 | tee -a \"/$SOURCEDIR/$SOURCENAME/Logs/PackageInstallSource\"

    STARTTIME=\$(date +%s)
    PackagePostInstall 2>&1 | tee \"/$SOURCEDIR/$SOURCENAME/Logs/PackagePostInstall\"
    ENDTIME=\$(date +%s)
    echo \" PackagePostInstall finished in \$((ENDTIME-STARTTIME)) seconds with result \$PackageInstallSourceResult\" 2>&1 | tee -a \"/$SOURCEDIR/$SOURCENAME/Logs/PackagePostInstall\"
    if [[ \$PackageInstallSourceResult != 0 ]]
    then
      mkdir \"/usr/share/buildcore_revisions/buildresults/\"
      touch $SOURCENAME \"/usr/share/buildcore_revisions/buildresults/$SOURCENAME\"
      echo $SOURCENAME >> \"/$SOURCEDIR/$SOURCENAME/Logs/failedcompiles\"
    fi
    exit 0
" > "/$SOURCEDIR/$SOURCENAME/packageinstallscript"

    #Make the script executable
    chmod +x "/$SOURCEDIR/$SOURCENAME/packageinstallscript"

    #Create a script that will be called by checkinstall to build a second deb, with smaller binaries for the smaller ISO
    echo "#! /bin/bash
    dpkg -L "$PACKAGESOURCENAME"-"$PACKAGESUFFIX" | while read FILE
    do
      if [[ -e \"\$FILE\" ]]
      then
        FILETYPE=\$(file -b  \"\$FILE\" 2>/dev/null)
        if [[ \"\$FILE\" != $INSTALLDIR/include/* ]] && ! [[ \"\$FILETYPE\" == \"current ar archive\" && \"\$FILE\" == *.a ]]
        then
          FILELINKPATH=\$(readlink -f \"\$FILE\")
          if [[ \"\$FILE\" == \"\$FILELINKPATH\" ]]
          then
            touch \"\$FILE\"
          else
            FILELINKDEST=\$(readlink \"\$FILE\")
            rm \"\$FILE\"
            ln -s \"\$FILELINKDEST\" \"\$FILE\"
          fi
        fi
      fi
    done
    exit 0" > "/$SOURCEDIR/$SOURCENAME/packagereducescript"
    
    #Make the script executable
    chmod +x "/$SOURCEDIR/$SOURCENAME/packagereducescript"

    #if the script is configured to create debs then create the debs. If not, run the install routine as normal.
    if [[ $MAKEDEBS == 1 ]]
    then
      #create directories for output
      mkdir "/$SOURCEDIR/buildoutput/"
      mkdir "/$SOURCEDIR/buildoutput/control"
      #checkinstall wants a debian/control file, otherwise it exits out.
      mkdir debian
      touch debian/control

      #Set the build variables for ldd
      SetBuildVariables

      #Update database containing the list of files that belong to packages
      update-dlocatedb
      
      #Find All so file names, built within the package, so that they can be excluded from the list of dependant files. 
      BUILTSOFILES=$(find /$SOURCEDIR/$SOURCENAME/ |grep -e '\.so$' -e '\.so\.' |while read SOFILE
      do 
        SOFILE=$(basename "$SOFILE")
        IFS="."
        SOFILE=($SOFILE)
        unset IFS
        SOFILE=${SOFILE[0]}.${SOFILE[1]}
        echo $SOFILE
      done)

      #Find all Executable files compiled in the source tree, get the dependancy Library files, and find the package the libraries belong to
      echo "Evaluating dependancies, this might take some time..."
      DEPENDS=$(find /$SOURCEDIR/$SOURCENAME/ -type f -executable | while read FILE
      do
        FILETYPE=$(file -bi $FILE |awk -F / '{print $1}')
        if [[ $FILETYPE == application ]]
        then
          DIRECTDEPENDS=$(readelf -d "$FILE" 2>/dev/null | grep NEEDED |sed -e 's/\[//g' -e 's/]//g' |awk '{print $5}')
          DIRECTDEPENDS=$(echo $DIRECTDEPENDS | sed 's/ /\\\|/g')
          ALLDEPENDS=$(ldd "$FILE" 2>/dev/null | grep =\> | awk '{print $3}')
          echo "$ALLDEPENDS" | grep "$DIRECTDEPENDS" | grep -v "$BUILTSOFILES"
        fi
      done | sort | uniq | grep -v ^$ | while read LIBRARY
      do
        if [[ -e "$LIBRARY" ]]
        then
          DEPEND=$(dlocate -S --package-only "$LIBRARY"$)
          echo $DEPEND
          echo "$LIBRARY:$DEPEND" >> "$BUILDLOGDIR/$SOURCENAME/CheckinstallDepends"
        fi
      done | sort | uniq | grep -ve "\-dev:" -ve "\-dev$" -ve "\-dbg" -ve cmake -ve git -ve svn -ve bzr )

      DEPENDS=$(echo $DEPENDS | sed 's/ /,/g') 

      #.spec file seem to cause problems with checkinstall
      rm *.spec

      #remove any old deb files for this package from the local source dir, and backup the old version.
      #mkdir "/$SOURCEDIR/buildoutput/versionbackup"
      #mv "/$SOURCEDIR/buildoutput/""$PACKAGESOURCENAME"-"$PACKAGESUFFIX"_*.deb "/$SOURCEDIR/buildoutput/versionbackup"
      rm "/$SOURCEDIR/buildoutput/""$PACKAGESOURCENAME"-"$PACKAGESUFFIX"_*.deb
      rm "/$SOURCEDIR/buildoutput/smallpackages/""$PACKAGESOURCENAME"-"$PACKAGESUFFIX"_*.deb
      rm *.deb

      #create the new deb
      STARTTIME=$(date +%s)
      PACKAGEDATE=$(date +%s)
      $CHECKINSTALLCMD -y -D --install=no --fstrans=no --strip=no --stripso=no --nodoc --dpkgflags=--force-overwrite --install=no --backup=no --pkgname="$PACKAGESOURCENAME"-"$PACKAGESUFFIX" --pkgversion=1 --pkgrelease=$PACKAGEDATE --pkglicense="OSI_COMPLIANT" --maintainer="$PACKAGESUFFIX"@"$PACKAGESUFFIX" --pkgsource="$PACKAGESUFFIX" --pkggroup="$PACKAGESUFFIX" --requires="$DEPENDS" --exclude=/srcbuild,/tmp/srcbuild_overlay,/srcbuild/buildoutput,/home/remastersys,/var/tmp,/buildlogs "/$SOURCEDIR/$SOURCENAME/packageinstallscript" 2>&1 | tee "$BUILDLOGDIR/$SOURCENAME/Checkinstall"
      ENDTIME=$(date +%s)
      echo "Checkinstall finished in $((ENDTIME-STARTTIME)) seconds" 2>&1 | tee -a "$BUILDLOGDIR/$SOURCENAME/Checkinstall"

      #move the resulting deb file into the buildoutput tree.
      mv "$PACKAGESOURCENAME"-"$PACKAGESUFFIX"_*.deb "/$SOURCEDIR/buildoutput/"

      #Install the newly created deb file
      STARTTIME=$(date +%s)
      InstallDebFile "/$SOURCEDIR/buildoutput/""$PACKAGESOURCENAME"-"$PACKAGESUFFIX"_*.deb 2>&1 | tee "$BUILDLOGDIR/$SOURCENAME/BuiltDebInstall"
      ENDTIME=$(date +%s)
      echo "BuiltDebInstall finished in $((ENDTIME-STARTTIME)) seconds" 2>&1 | tee -a "$BUILDLOGDIR/$SOURCENAME/BuiltDebInstall"
    
      #Build the 2nd smaller deb without debugging symbols for the smaller ISO. This is not installed by build_core and fstrans prevents the binaries from being clobbered
      STARTTIME=$(date +%s)
      $CHECKINSTALLCMD -y -D --install=no --fstrans=no --strip=yes --stripso=yes --nodoc --dpkgflags=--force-overwrite  --backup=no --pkgname="$PACKAGESOURCENAME"-"$PACKAGESUFFIX" --pkgversion=1 --pkgrelease=$PACKAGEDATE --pkglicense="OSI_COMPLIANT" --maintainer="$PACKAGESUFFIX"@"$PACKAGESUFFIX" --pkgsource="$PACKAGESUFFIX" --pkggroup="$PACKAGESUFFIX" --requires="$DEPENDS" --exclude=/srcbuild,/tmp/srcbuild_overlay,/srcbuild/buildoutput,/home/remastersys,/var/tmp,/buildlogs "/$SOURCEDIR/$SOURCENAME/packagereducescript" 2>&1 | tee "$BUILDLOGDIR/$SOURCENAME/SmallCheckinstall"
      ENDTIME=$(date +%s)
      echo "SmallCheckinstall finished in $((ENDTIME-STARTTIME)) seconds" 2>&1 | tee -a "$BUILDLOGDIR/$SOURCENAME/SmallCheckinstall"
      
      #move the resulting deb file into the buildoutput tree.
      mv "$PACKAGESOURCENAME"-"$PACKAGESUFFIX"_*.deb "/$SOURCEDIR/buildoutput/smallpackages"

      #Create lock file that when removed forces the package to be rebuilt
      touch "/$SOURCEDIR/buildoutput/control/$SOURCENAME"

    else
      #call the package install script directly if MAKEDEBS isn't used
      "/$SOURCEDIR/$SOURCENAME/packageinstallscript"
    fi

    #Copy the source logs correctly
    cp  "/$SOURCEDIR/$SOURCENAME/Logs/PackagePrepareBuild" "$BUILDLOGDIR/$SOURCENAME/"
    cp  "/$SOURCEDIR/$SOURCENAME/Logs/PackageCompileSource" "$BUILDLOGDIR/$SOURCENAME/"
    cp  "/$SOURCEDIR/$SOURCENAME/Logs/PackageInstallSource" "$BUILDLOGDIR/$SOURCENAME/"
    cp  "/$SOURCEDIR/$SOURCENAME/Logs/PackagePostInstall" "$BUILDLOGDIR/$SOURCENAME/"
    if [[ -e "/$SOURCEDIR/$SOURCENAME/Logs/failedcompiles" ]]
    then
      cat "/$SOURCEDIR/$SOURCENAME/Logs/failedcompiles" >> "$BUILDLOGDIR/failedcompiles"
    fi

    #If the deb file exists, the control file exists, and the script is configured to make deb files, then just install the deb
  else
    STARTTIME=$(date +%s)
    InstallDebFile "/$SOURCEDIR/buildoutput/""$PACKAGESOURCENAME"-"$PACKAGESUFFIX"_*.deb 2>&1 | tee "$BUILDLOGDIR/$SOURCENAME/DebInstall"
    ENDTIME=$(date +%s)
    echo "DebInstall finished in $((ENDTIME-STARTTIME)) seconds" 2>&1 | tee -a "$BUILDLOGDIR/$SOURCENAME/DebInstall"
  fi
}

#Run RunDownloadAndOrBuild directly if a file is specified
if [[ $FILESPEC == 1 ]]
then
  RunDownloadAndOrBuild
fi
