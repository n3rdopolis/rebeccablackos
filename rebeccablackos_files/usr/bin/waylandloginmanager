#! /bin/bash
#    Copyright (c) 2012, 2013, 2014, 2015, 2016 nerdopolis (or n3rdopolis) <bluescreen_avenger@verzion.net>
#
#    This file is part of RebeccaBlackOS.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

#This script is the WaylandLoginManager it handles a graphical login for the user, and allows the user to start multiple types of Wayland sessions, specified in wesession files, and it supports autologin, mounting of ecryptfs home directories, and user switching. It supports watching the active session until it fails, so that it swiches back to the needed TTY for the user.

#The main server it displays on is refered to as the loginmanagerdisplay. it runs as non root, as well as the zenity dialogs

#It depends on zenity kbd, weston, and expect
#It also requires logger to log to syslog, but won't fail without it

#It depends on a small patch in weston for a workaround for bug https://bugs.freedesktop.org/show_bug.cgi?id=73782 on framebuffer devices, and the line
#SUBSYSTEM=="graphics", KERNEL=="fb*", TAG+="uaccess"
#in a udev rules file.
#or pass wlmglobalfbpermissions to the kernel

#It also requires /etc/pam.d/waylandloginmanager

#It needs a user account called waylandloginmanager

#as well as:
#At least systemd v227 as it has all the ability to launch Wayland sessions with systemd-run

#/etc/waylandloginmanager.conf
  #Otherwise it uses /etc/lightdm/lightdm.conf . the only supported key is 'autologin-user=$AUTOLOGINUSER', and it usually takes it from /etc/lightdm/lightdm.conf at first run. It only uses /etc/waylandloginmanager.conf, as another init script can cause the lightdm config to drop the configured autologin user on an unsafe shutdown
#/usr/libexec/wayland_login_helpers/*
  #These scripts are small utilities that send the approriate commands to the waylandloginmanager's FIFO. They need to be configured in the launchers of /etc/loginmanagerdisplay/weston.ini. It's how the user interacts with the waylandloginmanager on the loginmanagerdisplay (other then the zenity dialogs)
  #These are optional as the waylandloginmanager displays a selection list with the same commands as well
#/etc/loginmanagerdisplay/weston.ini
  #Configuration for the loginmanagerdisplay. This should add the launchers in /usr/lib/wayland_login_helpers to the launcher bar, which send commands to the FIFO for weston, or at least prevent the default terminal icon from appearing in the toolbar for security reasons.
  #The mainform makes this reqirement optional
#/usr/share/wsessions.d/*
  #These are .desktop files, (and .environment files as well) which describe how to start different Wayland servers or sessions
  #These files are documented in /usr/share/wsession/aboutwsessions.txt

#Log Files:
  #/var/log/waylandloginmanager : this is the main log for the waylandloginmanager
  #/var/log/loginmanagerdisplay.log : This is the log file for the Weston server that is the loginmanagerdisplay
  #~/wlsessionlogs/waylandsession_($DATESTAMP).log : This is where all wayland servers get logged as the run as the user.
  #~/wlsessionlogs/waylandhost.log : This log is for the host Wayland server that gets started for Wayland sessions that run on other Wayland servers

#Runtime Files:
  #/run/waylandloginmanager/sessiondata: Stores data for user switching so that the session list can be reloaded if waylandloginmanager restarts. As it's stored in /run which is a tmpfs, there should be no risk of one from a previous boot giving it false data
  #/run/waylandloginmanager/usrbinwaylandloginmanager.lock: (the file name is generated by the path that this script is in, removing the slashes). this prevents two instances of the waylandloginmanager from starting. 
    #It is a symlink to /proc/$$/cmdline (where $$ is the pid of the waylandloginmanager). It is checked in two different ways to protect against a race condition
  #/run/waylandloginmanager/loginmanager_register : Only root can write to this FIFO to register sessions, and no one can read it (except root). Functions registering sessions must first write to this FIFO, and then send the RegisterSession command to the loginmanager_control FIFO
  #/run/waylandloginmanager/loginmanager_control : All users have write access, but and no one can read it, except the FIFOREADERUSER service account. A process running as PROBETESTUSER reads the data getting send to it, and filters out only valid commands to get sent to loginmanager_listener
  #/run/waylandloginmanager/loginmanager_listener : Only root has write access to it, and no one has read access to it (except root). Supported commands:
      #Switch : calls up a switch user dialog on the loginmanagerdisplay, switching to the tty (see documentation for function SwitchUserDialog)
      #Change : switches to the tty the loginmanagerdisplay is on 
      #Info : calls up a help dialog for the user on the loginmanagerdisplay (see documentation for function ShowInfo)
      #Leave : calls up a dialog with shutdown/restart/supend options on the loginmanagerdisplay (see documentation for function LeavePrompt)
      #Login : Starts the login process (see documentation for function GetUserCredentials)
      #RegisterSession : Tells the waylandloginmanager to read from the loginmanager_register FIFO. When this is called the process must be attempting to write to the loginmanager_register already. If there is nothing being written in the short .01 second timeout, it is ignored. (see documentation for function RegisterSession)

#These functions are for the user session part of the waylandloginmanager

#Function that is run to start user sessions while running as the user (when started with the --usersession argument)
function UserSessionWorker
{
  #Enable job control
  set -m

  #set up the environment for the user. Determine the user name, set Wayland variables, and if the current session has an environment file then handle it.
  USER=$(id -u)
  export $(exec dbus-launch)
  export XDG_SESSION_TYPE=wayland
  . /usr/bin/wlruntime_vars &> /dev/null
  BackendType=$(echo $BackendType | sed 's/^ *//;s/ *$//')
  EnvironmentFile=$(echo $EnvironmentFile | sed 's/^ *//;s/ *$//')
  if [[ -e /usr/share/wsessions.d/default.environment ]]
  then
    ReadEnvironmentFile /usr/share/wsessions.d/default.environment
  fi

  if [[ -e $EnvironmentFile ]]
  then
    ReadEnvironmentFile "$EnvironmentFile"
  fi

  #Create a folder for the logs
  if [[ ! -e ~/wlsessionlogs ]]
  then
    mkdir ~/wlsessionlogs
  fi

  #Cleanup old log files
  LOGFILECOUNT=0
  ls -t ~/wlsessionlogs/waylandsession* 2>/dev/null | while read LOGFILE
  do
    ((LOGFILECOUNT++))
    if [[ $LOGFILECOUNT > 4 ]]
    then
      rm "$LOGFILE"
    fi
  done

  #set all arguments into an array
  ArgumentString=$(echo -en "$@")
  DATESTAMP=$(date +%s)
  echo "Started with the arguments: $ArgumentString" >> $HOME/wlsessionlogs/waylandsession_$DATESTAMP.log
  eval set -- $ArgumentString >> $HOME/wlsessionlogs/waylandsession_$DATESTAMP.log
  ArgArray=($ArgumentString)
  unset IFS

  #Clean up trailing white space from the end of all arguments
  for (( element = 0 ; element < ${#ArgArray[@]} ; element++ ))
  do
    ArgArray[$element]=$(echo " ${ArgArray[$element]}" | sed 's/^ *//;s/ *$//')
  done

  #if the user booted with wlmforceswrender, force software rendering to be enabled
  if [[ $(cat /proc/cmdline | grep -c "\bwlmforceswrender\b" ) != 0 ]]
  then
    export LIBGL_ALWAYS_SOFTWARE=1
  fi

  #if the user booted with wlmforcevblankoff, force vblank to be disabled
  if [[ $(cat /proc/cmdline | grep -c "\bwlmforcevblankoff\b" ) != 0 ]]
  then
    export vblank_mode=0
  fi

  if [[ $BackendType == WL ]]
  then
    if [[ $DefaultBackendType == FB ]]
    then
      HostBackendArgument="--backend=fbdev-backend.so"
    else
      HostBackendArgument="--backend=drm-backend.so"
    fi
    weston --no-config --shell=fullscreen-shell.so --socket=$WAYLAND_HOST $HostBackendArgument &>> $HOME/wlsessionlogs/waylandhost.log &
    HostServerPID=$!
    export WAYLAND_DISPLAY=$WAYLAND_HOST
    WaitTimes=0
    #Wait for the server to start up for a maximum of 15 seconds. As soon as the socket is created, the wait loop ends
    while [[ ! -e $XDG_RUNTIME_DIR/$WAYLAND_DISPLAY && $WaitTimes<15 ]]
    do
      sleep 1
      ((WaitTimes++))
    done
    #If the socket doesn't exist, then the server failed to start, and switch back
    if [[ ! -e $XDG_RUNTIME_DIR/$WAYLAND_DISPLAY ]]
    then
      echo "The host server failed to start. Will not start the guest server for this session. Please see $HOME/wlsessionlogs/waylandhost.log" &>> $HOME/wlsessionlogs/waylandsession_$DATESTAMP.log
      echo -e "\nChange" > /run/waylandloginmanager/loginmanager_control
      exit
    fi
  else
    export WAYLAND_DISPLAY=$WAYLAND_GUEST
    unset WAYLAND_HOST
    unset WAYLAND_GUEST
  fi
  STARTTIME=$(date +%s)
  #Execute the Wayland server, and log it to $HOME/wlsessionlogs/waylandsession_$DATESTAMP.log
  dbus-launch --exit-with-session -- ${ArgArray[@]} &>> $HOME/wlsessionlogs/waylandsession_$DATESTAMP.log &
  GuestServerPID=$!

  
  #Terminate the host server after the guest terminates
  if [[ $BackendType == WL ]]
  then
    fg 2
    echo "The guest session has ended. Terminating the host..." &>> $HOME/wlsessionlogs/waylandhost.log
    kill -15 $HostServerPID &> /dev/null
    sleep 3
    kill -9 $HostServerPID &> /dev/null
  else
    fg 1
  fi
  ENDTIME=$(date +%s)
  RUNTIME=$((ENDTIME-STARTTIME))
  #If the server only ran for 5 seconds, assume it crashed, and switch back. This should cover the time it would take until RegisterSession in Waylandloginmanager handles it. If it is longer than 5 seconds, don't switch back as the user could have another session active.
  if [[ $RUNTIME < 45 ]]
  then
    echo -e "\nChange" > /run/waylandloginmanager/loginmanager_control
    exit
  fi
}

#Function that takes the argument of an environment file, and handles the definitions (for --usersession)
function ReadEnvironmentFile
{
  #parse the session event file if specified, and it exists
  EnvironmentFileData=$(awk '/^\[*\]$/{flag=0}flag;/^\[EnvironmentFile\]$/{flag=1}' "$1" | awk -F \# '{print $1}')
  EnvironmentFileData+=$'\n'
  while read LINE
  do
    #environment files are specified as action=var=data
    #Examples
    #set=varname=data sets variable called varname, with the content of data.
    #unset=varname unsets a variable called varname
    #unset=varname@FB unsets a variable called varname ONLY if the current backend is FB. waylandloginmanager tells this script what the current backend is
    VARACTION=$(echo $LINE    | awk -F ' *@ *' '{print $1}' | awk -F ' *= *' '{print $1}' | sed 's/^ *//;s/ *$//')
    VARNAME=$(echo $LINE      | awk -F ' *@ *' '{print $1}' | awk -F ' *= *' '{print $2}' | sed 's/^ *//;s/ *$//')
    VARDATA=$(echo $LINE      | awk -F ' *@ *' '{print $1}' | awk -F ' *= *' '{print $3}' | sed 's/^ *//;s/ *$//')
    VARBACKEND=$(echo $LINE   | awk -F ' *@ *' '{print $2}' | sed 's/^ *//;s/ *$//')

    #Only expand some variables
    if [[ $VARDATA == "\$WAYLAND_DISPLAY" ]]
    then
      VARDATA=$WAYLAND_DISPLAY
    fi

    #if the backend for this line is unspecified, OR if the backend on this line matches the current one running then handle the variable
    if [[ -z $VARBACKEND || $VARBACKEND == $BackendType ]]
    then
      #if it is set, then set the variable
      if [[ $VARACTION == "set" ]]
      then
	export $VARNAME=$VARDATA
      fi

      #if it is unset, then unset the variable
      if [[ $VARACTION == "unset" ]]
      then
	unset $VARNAME
      fi

    fi
  done < <(echo "$EnvironmentFileData")
}

#All functions below this point are for the main operation of the waylandloginmanager

#Function that takes no arguments that does the first steps in setting up the environment, and detecting hardware support, and previous instances for starting up the login manager
function PrepareLoginManager
{
  #Create the waylandloginmanager folder in /run for FIFOs and lockfiles
  mkdir -p /run/waylandloginmanager
  
  #Detect another instance, by creating a testing a lockfile, which is a symlink to /proc/pid/cmdline, and making sure the second line of /proc/pid/cmdline matches (as it's the path to the script).
  SCRIPTPATH=$(readlink -f "$0")
  SCRIPTNAME=$(echo "$SCRIPTPATH" | sed 's\/\\g')
  LOCKSCRIPT=$(readlink -f "$(strings -a "/run/waylandloginmanager/$SCRIPTNAME.lock" | sed -n 2p)" )
  if [[ "$SCRIPTPATH" != "$LOCKSCRIPT" ]]
  then
    rm -r "/run/waylandloginmanager/$SCRIPTNAME.lock"
    ln -s /proc/"$$"/cmdline "/run/waylandloginmanager/$SCRIPTNAME.lock"
  else
    logger -t waylandloginmanager "Error: Another instance is already running" -s  >>/var/log/waylandloginmanager 2>&1
    exit
  fi
  #second check to make sure this instance 'won' as a second instance could report success, and execute as the first instance is OK to run, but before it creates the lockfile
  #this ensures that the linked /proc/pid/cmdline is this pid
  LOCKPROCPATH=$(dirname $(readlink "/run/waylandloginmanager/$SCRIPTNAME.lock" ))
  THISPROCPATH=/proc/$$
  if [[ $LOCKPROCPATH != $THISPROCPATH ]]
  then
    logger -t waylandloginmanager "Error: Another instance is already running" -s  >>/var/log/waylandloginmanager 2>&1
    exit
  fi

  #Require root privlages
  if [[ $UID != 0 ]]
  then
    echo "Must be run as root."
    exit
  fi
  
  #Configure missing things if they are missing. This can be turned on or off
  AutoConfig=1
  if [[ $AutoConfig == 1 ]]
  then

    #Create a user for non-privlaged commands for the waylandloginmanager if it doesn't exist
    if [[ $(id waylandloginmanager &>/dev/null; echo $? ) == 1 ]]
    then
      logger -t waylandloginmanager "Error: The user waylandloginmanager does NOT exist. Creating the user account..." -s  >>/var/log/waylandloginmanager 2>&1
      adduser --no-create-home --home=/etc/loginmanagerdisplay --shell=/bin/bash --disabled-password --system --group waylandloginmanager
    fi

    #Create needed PAM file
    if [[ ! -e /etc/pam.d/waylandloginmanager ]]
    then
        echo "#%PAM-1.0
session [success=ok ignore=ignore module_unknown=ignore default=bad] pam_selinux.so close
auth            optional        pam_group.so
auth            sufficient      pam_rootok.so
session         optional        pam_keyinit.so revoke
session         required        pam_limits.so
session         required        pam_unix.so
session         optional        pam_systemd.so type=wayland
session         optional        pam_ecryptfs.so unwrap
" > /etc/pam.d/waylandloginmanager
    fi
    
    if [[ ! -e /lib/udev/rules.d/70-uaccess-fbdev.rules ]]
    then
      echo "ACTION=="remove", GOTO="uaccess_fbdev_end"
ENV{MAJOR}=="", GOTO="uaccess_fbdev_end"


# Framebuffer devices
SUBSYSTEM=="graphics", KERNEL=="fb*", TAG+="uaccess"

LABEL="uaccess_fbdev_end"" > /lib/udev/rules.d/70-uaccess-fbdev.rules
    fi
  fi

  #prevent the WaylandLoginManager from being killed with CTRL+C
  trap '' 2

  #Attempt to import fast user switching data from a crashed WaylandLoginManager
  if [[ -e /run/waylandloginmanager/sessiondata ]]
  then
    . /run/waylandloginmanager/sessiondata
  else
    touch /run/waylandloginmanager/sessiondata
    chmod 700 /run/waylandloginmanager/sessiondata
  fi

  #Set up the needed environment variables
  cd /run/waylandloginmanager

  #Enable job control in this script
  set -m

  export XDG_CONFIG_HOME=/etc/loginmanagerdisplay/
  #User that the zenity dialogs and the loginmanagerdisplay (weston instance for the waylandloginmanager runs as
  export LOGINMANAGERDISPLAYUSER=waylandloginmanager
  #User that the su test in AuthenticateUser user runs as
  export PROBETESTUSER=waylandloginmanager
  #User that reads from the loginmanager_control FIFO, and filters the command sent to it to loginmanager_listener
  export FIFOREADERUSER=waylandloginmanager
  #Get the UID of the $LOGINMANAGERDISPLAYUSER
  export LOGINMANAGERDISPLAYUID=$(id $LOGINMANAGERDISPLAYUSER -u)
  #Set Wayland/runtime vars
  export PATH=/opt/bin:$PATH
  export LD_LIBRARY_PATH=/opt/lib/$(dpkg-architecture -qDEB_HOST_MULTIARCH):/usr/local/lib/$(dpkg-architecture -qDEB_HOST_MULTIARCH):/usr/lib/$(dpkg-architecture -qDEB_HOST_MULTIARCH):/opt/lib:/usr/local/lib:/usr/lib
  export GDK_BACKEND=wayland
  export XDG_RUNTIME_DIR=/run/user/$LOGINMANAGERDISPLAYUID
  export WAYLAND_DISPLAY=loginmanagerdisplay
  #Set the default path for weston
  export DEFAULTWAYLANDSERVER=$(which weston)
  #Specify where wsession files are found
  export WSESSIONSPATH="/usr/share/wsessions.d"
  export WESTON_PLUGIN_PATH=/opt/lib/$(dpkg-architecture -qDEB_HOST_MULTIARCH)/weston
  #WLM_LD_LIBRARY_PATH is exported so that it can set it as LD_LIBRARY_PATH, as the sudo command that starts it as the LOGINMANAGERDISPLAYUSER drops LD_LIBRARY_PATH, and do the same for PATH
  export WLM_LD_LIBRARY_PATH=$LD_LIBRARY_PATH
  export WLM_PATH=$PATH
  #if the user booted with a hidden option wlmforceswrender, force software rendering to be enabled
  if [[ $(cat /proc/cmdline | grep -c "\bwlmforceswrender\b" ) != 0 ]]
  then
    export LIBGL_ALWAYS_SOFTWARE=1
  fi
  #if the user booted with wlmforcevblankoff, force vblank to be disabled
  if [[ $(cat /proc/cmdline | grep -c "\bwlmforcevblankoff\b" ) != 0 ]]
  then
    export vblank_mode=0
  fi
  #set MinimumTTY to be 7. this causes the first TTY to try to put the WaylandLoginManager on as tty8.
  MinimumTTY=7
  #default the number of sessions registered to be 0 if unset
  if [[ -z $AllSessions ]]
  then
    export AllSessions=0
  fi
  #default ActiveSessionPID if unset, which determines the pid for the waylandloginmanager to watch until it stops, to switch back to 0
  if [[ -z $ActiveSessionPID ]]
  then
    export ActiveSessionPID=0
  fi
  #Array that stores all backend types that is supported by the hardware
  SupportedBackends=()

  #Determine if this is running on a live instance, if the root filesystem is overlayfs.
  FSTYPE=$(df / -T | awk '{print $2}' | grep -v Type)
  if [[ $FSTYPE =~ overlay ]]
  then
    ISLIVE=1
  fi

  ZENITYCMD="sudo -E -u $LOGINMANAGERDISPLAYUSER $0 --uihost zenity"
  TERMINALCMD="sudo -E -u $LOGINMANAGERDISPLAYUSER $0 --uihost vte"

  #Tell the plymouth splash to hide as the loginmanager is starting.
  plymouth hide-splash

  #Detect hardware abilities, first try to see if the system has kernel mode setting, then try framebuffer. if both aren't supported, bring up a text mode dialog
  if [[ $(ls  /dev/dri/card* ) && $(cat /proc/cmdline | grep -c "\bwlmforcefbdev\b" ) == 0 ]]
  then 
    logger -t waylandloginmanager "Kernel mode setting found." -s  >>/var/log/waylandloginmanager 2>&1
    SupportedBackends+=(KMS)
    DefaultBackendType=KMS
    WESTONBACKEND=drm-backend.so
    HardwareSupported=1
  else
    logger -t waylandloginmanager "No kernel mode setting found. Using the framebuffer" -s  >>/var/log/waylandloginmanager 2>&1
  fi
  SupportedBackends+=(WL)
  if [[ $(ls  /dev/fb* ) ]]
  then
    if [[ $(cat /proc/cmdline | grep -c "\bwlmglobalfbpermissions\b" ) != 0 ]]
    then
      logger -t waylandloginmanager "WARNING: The 'wlmglobalfbpermissions' option has been passed to the kernel. This causes the waylandloginmanager to give the plugdev group and $LOGINMANAGERDISPLAYUSER access to all framebuffer device files" -s  >>/var/log/waylandloginmanager 2>&1
      setfacl -m "g:plugdev:rwx" /dev/fb*
      setfacl -m "g:$LOGINMANAGERDISPLAYUSER:rwx" /dev/fb*
    fi
    SupportedBackends+=(FB)
    #If KMS not detected, but fbdev is, set weston-backend to fbdev-backend
    if [[ $HardwareSupported != 1 ]]
    then
      DefaultBackendType=FB
      WESTONBACKEND=fbdev-backend.so
    fi
    HardwareSupported=1
  else
    logger -t waylandloginmanager "No framebuffer support found" -s  >>/var/log/waylandloginmanager 2>&1
  fi


  #if the user booted with a hidden option wlmforcefbdev, set the backend for Weston / Wayland server sessions to be fbdev
  if [[ $(cat /proc/cmdline | grep -c "\bwlmforcefbdev\b" ) != 0 ]]
  then
    logger -t waylandloginmanager "Manually override set to use to use the framebuffer" -s  >>/var/log/waylandloginmanager 2>&1
    if [[ $HardwareSupported != 1 ]]
    then
      logger -t waylandloginmanager "ERROR: No framebuffer device found for wlmforcefbdev override!" -s  >>/var/log/waylandloginmanager 2>&1
      openvt -c 63 -s -f -w -- sudo -E -u $LOGINMANAGERDISPLAYUSER dialog --msgbox "The wlmforcefbdev overide is set, but no framebuffer device is found!

Will show a menu with a few options for diagnosis." 20 50 --no-cancel
      openvt -c 63 -s -f -- rbos-failedboot
      exit
    fi
  fi

  #if there is no Framebuffer or Kernel mode setting, tell the user with a text mode dialog on TTY63, and restart.
  #Depending if this is a live session or not, tell the user how to configure grub if it is installed, or to specify a boot option for the framebuffer from the menu if its live
  if [[ $HardwareSupported != 1 ]]
  then
    if [[ $ISLIVE == 1 ]]
    then
      logger -t waylandloginmanager "ERROR: No supportable hardware found" -s  >>/var/log/waylandloginmanager 2>&1
      openvt -c 63 -s -f -w -- sudo -E -u $LOGINMANAGERDISPLAYUSER dialog --msgbox "No Kernel Mode Setting, or Framebuffer device found.

This means your video card does not support KMS, and doesn't create a framebuffer by default. either of which are needed for Weston to work.

You can select a Framebuffer boot option when you start the Live CD, to force a boot with a framebuffer device." 20 50 --no-cancel
    else 
      openvt -c 63 -s -f -w -- sudo -E -u $LOGINMANAGERDISPLAYUSER dialog --msgbox "No Kernel Mode Setting, or Framebuffer device found.

This means your video card does not support KMS, and doesn't create a framebuffer by default. either of which are needed for Weston to work.

Will now start a utility to assist you in configuring your system to boot with a framebuffer device." 20 50 --no-cancel
      openvt -c 63 -s -f -w -- rbos-add-framebuffer
    fi
    openvt -c 63 -s -f -w -- sudo -E -u $LOGINMANAGERDISPLAYUSER dialog --msgbox "Can not start Weston.

Will now reboot." 20 50 --no-cancel
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Reboot boolean:true
    exit
  fi

  #Get the TTY that will hold the Wayland server that displays the login screen.
  OLDPID=$(fuser /run/user/$LOGINMANAGERDISPLAYUID/loginmanagerdisplay)
  if [[ ! -z $OLDPID ]]
  then
    HostVT=$(ps --no-headers $OLDPID | awk '{print $2}' | sed 's/tty//g')
  else
    HostVT=$(GetNextTTY)
  fi
  MinimumTTY=$HostVT
  if [[ $HostVT -eq -1 ]]
  then
    logger -t waylandloginmanager "ERROR: Not Enough TTYs for login manager display!" -s  >>/var/log/waylandloginmanager 2>&1
    exit
  fi

  #Enable full alt+sysrq, and allow a debug login terminal window when wlmdebug is passed as a kernel argument, or when the system is in Live CD mode.
  if [[ $(cat /proc/cmdline | grep -c "\bwlmdebug\b" ) != 0 || $ISLIVE == 1 ]]
  then
    echo 1 > /proc/sys/kernel/sysrq
    logger -t waylandloginmanager "WARNING: The diagnostic 'wlmdebug' option has been passed to the kernel, or the system is in Live CD mode. This causes the waylandloginmanager to enable all magic sysrq keys, including the ability to kill processes, and the waylandloginmanager will respond to the Debug command when sent to the main control FIFO, by spawning a graphical login terminal window on the loginmanagerdisplay" -s  >>/var/log/waylandloginmanager 2>&1
    wlmdebug=1
  fi

  #Enable full alt+sysrq, and allow a debug root terminal window when wlmdebuginsecure is passed as a kernel argument,
  if [[ $(cat /proc/cmdline | grep -c "\bwlmdebuginsecure\b" ) != 0 ]]
  then
    echo 1 > /proc/sys/kernel/sysrq
    logger -t waylandloginmanager "WARNING: The diagnostic and insecure 'wlmdebuginsecure' option has been passed to the kernel, or the system is in Live CD mode. This causes the waylandloginmanager to enable all magic sysrq keys, including the ability to kill processes, and the waylandloginmanager will respond to the Debug command when sent to the main control FIFO, by spawning a graphical ROOT terminal window on the loginmanagerdisplay" -s  >>/var/log/waylandloginmanager 2>&1
    wlmdebug=1
    wlmdebuginsecure=1
  fi
}

#This function creates an XDG_RUNTIME_DIR for the user, specified in the first argument
function Create_XDG_RUNTIME_DIR
{
  USERUID=$(id -u $1)
  USERGID=$(id -g $1)
  mkdir -p /run/user/$USERUID
  chown $USERUID /run/user/$USERUID
  chgrp $USERGID /run/user/$USERUID
  chmod 700 /run/user/$USERUID
}

#This function is used by the WaylandLoginManager to find the next availible tty, starting from CalcTTY+1
#it prints the TTY number to stdio. takes no arguments. If it can't find an open tty, it returns -1
function GetNextTTY
{
  TTYNotInUse=0
  CalcTTY=$MinimumTTY
  #cycle through all ttys, stopping at tty63, as tty63 is 'reserved' by the waylandloginmanager as the tty to switch to in between sessions, as there is issues switching directly between two Weston servers.
  while [[ $TTYNotInUse -ne 1 && $CalcTTY -lt 62 ]]
  do
    ((CalcTTY++))
    fuser -s /dev/tty$CalcTTY
    TTYNotInUse=$?
  done

  if [[ $TTYNotInUse -ne 1 ]]
  then
    AvailibleTTY=-1
  else
    AvailibleTTY=$CalcTTY
  fi

  echo $AvailibleTTY
}

#This function is called when the loginmanager_control FIFO recives the command "RegisterSession". This function will read the contents of loginmanager_register, which only root can write to. 
#Before a process calls RegisterSession to loginmanager_control, the process must also start an attempt to send the data to loginmanager_register, because the timeout period is .01 seconds. If nothing is in loginmanager_register, as if it's not called correctly, or because it's an underprivlaged process that can't write to loginmanager_register, it is ignored.
#it expects the data to be sent in fields seperated by the @ charachter in this order:
# TTY_Number@PID_of_Session_Process@User_Name@logind_Session_ID
#It also sets the ActiveSessionPID to be the PID_Of_Session_Process, to watch for when that PID dies, to switch back to the loginmanagerdisplay tty.
function RegisterSession
{
  #get the data from loginmanager_register
  exec 1001<> /run/waylandloginmanager/loginmanager_register
  RegisterData=$(while read -n 100 -t .01 data <&1001; do echo $data; done| head -1)
  exec 1001>&-
  #get the register data, and put it into an array so it can be handled
  IFS='@'
  ArraySessionData=($RegisterData)
  unset IFS
  if [[ ! -z $RegisterData ]]
  then
    logger -t waylandloginmanager "received session data $RegisterData" -s  >>/var/log/waylandloginmanager 2>&1
    #Add the session data to the arrays that store info about the sessions.
    SessionTTY=${ArraySessionData[0]}
    SessionPID=${ArraySessionData[1]}
    SessionUser=${ArraySessionData[2]}
    SessionID=${ArraySessionData[3]}
    AllSessionTTYs[$AllSessions]=$SessionTTY
    AllSessionPIDs[$AllSessions]=$SessionPID
    AllSessionUsers[$AllSessions]=$SessionUser
    AllSessionIDs[$AllSessions]=$SessionID
    #Set the active sesssion PID to the session PID
    if [[ ! -z $SessionPID ]]
    then
      ActiveSessionPID=$SessionPID
    fi
    #increment the number of running sessions, now that one is added and running successfuly
    ((AllSessions++))

    #Export session data so the waylandloginmanager has user switching data in case of a reload
    declare -p AllSessions        > /run/waylandloginmanager/sessiondata
    declare -p AllSessionTTYs    >> /run/waylandloginmanager/sessiondata 
    declare -p AllSessionPIDs    >> /run/waylandloginmanager/sessiondata 
    declare -p AllSessionUsers   >> /run/waylandloginmanager/sessiondata 
    declare -p AllSessionIDs     >> /run/waylandloginmanager/sessiondata 
    declare -p ActiveSessionPID  >> /run/waylandloginmanager/sessiondata 
    sed -i 's/declare/declare -g/g' /run/waylandloginmanager/sessiondata
  else
    logger -t waylandloginmanager "register session requested, but no data was availible in the FIFO" -s  >>/var/log/waylandloginmanager 2>&1
  fi
}

#This function takes two arguments. The first is the number of seconds to wait, and the second is the string to show in the dialog. it shows a Zenity dialog with a progress bar to count down the specified time, with the string.
function DialogWait
{
  waitseconds=$1
  displaystring="$2"
  countseconds=0
  while [[ $countseconds -lt $waitseconds ]]
  do
    percent=$(( $countseconds * 100 / $waitseconds ))
    echo $percent
    ((countseconds++))
    sleep 1
  done | $ZENITYCMD --width=450 --title="Login Manager" --no-cancel --progress --auto-close --text="$displaystring" 2>/dev/null
}

#This function takes no arguments and waits for the loginmanagerdisplay to startup
function DisplayServerWait
{
  while [[ $(fuser -s /run/user/$LOGINMANAGERDISPLAYUID/loginmanagerdisplay &>/dev/null; echo $?) == 1 ]]
  do
    sleep 1
  done
}

#This is called by GetUserCredentials and by StartAutoLogin. This allows the user select the session they want to use, similar to how X login managers prompt for the session before the login.
#it exports the WSESSIONDATA variable, which contains arguments and varaibles and the command to run to start a session
function ChooseSessionType
{
  #The number of Session IDs start from 0. when a session is added, the number of running sessions is 1 for the next session. The second session gets the ID of 1 etc...
  export SESSIONID=${AllSessions}000
  export WAYLAND_HOST=wlhost-$SESSIONID
  export WAYLAND_GUEST=wayland-$SESSIONID

  unset WSESSIONLIST
  FirstRunNotRan=0
  #Parse the list of sessions specified, so that zenity can use it as a list of sessions
  #Find all executable files, in the wsessions path (and not in any of its subdirectories) 
  #The subshell outputs a multiline string with all session data. every session is a fixed number of lines.
  #ONLY the session lines should be set through stdio in the while loop. This string is sent to a zenity dialog.
  while read SESSIONFILE
  do
    IsExecutable=$(find $SESSIONFILE |wc -l)
    if [[ $IsExecutable == 0 ]]
    then
      logger -t waylandloginmanager "Warning: $SESSIONFILE is not executable, the session will not be availible for selection by the user." -s  >>/var/log/waylandloginmanager 2>&1
    fi
    #split away all the data from this file, starting at [Desktop Entry]
    DesktopFileData=$(awk '/^\[*\]$/{flag=0}flag;/^\[Desktop Entry\]$/{flag=1}' $SESSIONFILE | awk -F \# '{print $1}')
    #Read all the supported values that are specified in the wsession file
    Enabled=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "Enabled" {print $0}' | cut -d = -f2- | tail -1 )
    SessionName=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "Name" {print $0}' | cut -d = -f2- | tail -1 )
    Type=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "Type" {print $0}' | cut -d = -f2- | tail -1 )
    #Search for backends supported by the compositor, with the backends the hardware supports. Give presence to the first one found in the array of supported backend types, the best backend types are first in the array
    for (( element = 0 ; element < ${#SupportedBackends[@]} ; element++ ))
    do
      export BackendType=${SupportedBackends[$element]}
      SupportsBackend=$(echo "$DesktopFileData" | awk -v BackendType=$BackendType -F ' *= *' '$1 == "CompositorSupports"BackendType {print $0}' | cut -d = -f2- | tail -1 )
      #Once a supported backend is found, then stop.
      if [[ $SupportsBackend == 1 ]]
      then
	break
      fi
    done
    IsFallbackSession=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "IsFallbackSession" {print $0}' | cut -d = -f2- | tail -1 )
    if [[ -z $IsFallbackSession ]]
    then
      IsFallbackSession=0
    fi
    CompositorDisplayArgument=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "CompositorDisplayArgument" {print $0}' | cut -d = -f2- | tail -1 )
    BackendArguments=$(echo "$DesktopFileData" | awk -v BackendType=$BackendType -F ' *= *' '$1 == "Compositor"BackendType"Arguments" {print $0}' | cut -d = -f2- | tail -1 )
    SessionArgument=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "SessionArgument" {print $0}' | cut -d = -f2- | tail -1 )
    AdditionalArguments=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "AdditionalArguments" {print $0}' | cut -d = -f2-| tail -1 )
    CompositorExec=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "CompositorExec" {print $0}' | cut -d = -f2- | tail -1 )
    EnvironmentFile=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "EnvironmentFile" {print $0}' | cut -d = -f2- | tail -1 )
    #The strings in NeedsFile are expanded here, so that the script can later determine if the full expanded path exists.
    NeedsFile=$(echo "$DesktopFileData" | awk -F ' *= *' '$1 == "NeedsFile" {print $0}' | cut -d = -f2- | perl -pe 's/\$(\w+)/$ENV{$1}/g')
    NeedsFile+=$'\n'
    NeedsFile+=$CompositorExec

    #Iterate through all NeedsFile values, to make sure that they exist. if one doesn't exist increment NotFoundCount.
    NotFoundCount=0
    while read FILE
    do
      if [[ ! -e $FILE && -n $FILE ]]
      then
	logger -t waylandloginmanager "Warning: Cannot find needed file $FILE for $SESSIONFILE , the session will not be availible for selection by the user." -s  >>/var/log/waylandloginmanager 2>&1
	((NotFoundCount++))
      fi
    done < <(echo "$NeedsFile")

    if [[ $Enabled != 1 ]]
    then
      logger -t waylandloginmanager "Warning: $SESSIONFILE is disabled, the session will not be availible for selection by the user." -s  >>/var/log/waylandloginmanager 2>&1
    fi

    if [[ $SupportsBackend != 1 ]]
    then
      logger -t waylandloginmanager "Warning: $SESSIONFILE can't run on any backends supported by this system: "${SupportedBackends[*]}" , the session will not be availible for selection by the user." -s  >>/var/log/waylandloginmanager 2>&1
    fi

    if [[ $Type != "WSession" ]]
    then
      logger -t waylandloginmanager "Warning: $SESSIONFILE does not have a Type of 'WSession' , the session will not be availible for selection by the user." -s  >>/var/log/waylandloginmanager 2>&1
    fi

    #if the session supports the CompositorDisplayArgument, for setting the WAYLAND_DISPLAY it should use, then ammend the WAYLAND_GUEST to the end of the command.
    if [[ ! -z $CompositorDisplayArgument ]]
    then
      CompositorDisplayArgument="$CompositorDisplayArgument$WAYLAND_GUEST"
    else 
      CompositorDisplayArgument=""
    fi

    #If the session is enabled, the backend is supported, all the files it needs are there, and its a wsession file, and is executable add the lines describing the session to the string.
    #This is sent through stdio which is added to teh WSESSIONLIST variable
    if [[ $NotFoundCount == 0 && $SupportsBackend == 1 && $Enabled == 1 && $Type == "WSession" && $IsExecutable != 0 ]]
    then
      if [[ $FirstRunNotRan == 0 ]]
      then
        FirstRunNotRan=1
      else
        WSESSIONLIST+=$'\n'
      fi
      WSESSIONLIST+="$CompositorExec"$'\n'
      WSESSIONLIST+="$BackendArguments"$'\n'
      WSESSIONLIST+="$SessionArgument"$'\n'
      WSESSIONLIST+="$CompositorDisplayArgument"$'\n'
      WSESSIONLIST+="$AdditionalArguments"$'\n'
      WSESSIONLIST+="$EnvironmentFile"$'\n'
      WSESSIONLIST+=""$BackendType"_"$DefaultBackendType"_"$IsFallbackSession"_"$'\n'
      WSESSIONLIST+="$SessionName"
    fi
  done < <(find $WSESSIONSPATH -maxdepth 1 -name "*\.desktop" -type f | sort )


  #If wesessions where found above then show a zenity dialog. If there where none, use a default session.
  if [[ ! -z $WSESSIONLIST ]]
  then
    PROMPTED=1
    #select the session. Each line is handled as a column. currently there are 8 collumns. So line 1 is is column 1, line 2 is in collumn 2, and line 9 is in collumn 1 again
    #The zenity dialog then outputs the selected session's lines into the WSESSIONDATA variable. each collumn is a different aspect of the wsessions
    WSESSIONDATA=$(echo "$WSESSIONLIST" | $ZENITYCMD --title="Pick a Session..." --height=450 --list --text "Select a Wayland Desktop Environment to use" --column compositor --column backend --column session --column displayargs --column args --column environment --column backendtype --column name --hide-column=1,2,3,4,5,6,7 --print-column=1,2,3,4,5,6,7,8 --separator="\n" --hide-header 2>/dev/null )
    #Abort if the user selected cancel on the zenity dialog
    CancelOrOK=$?
    if [[ $CancelOrOK != 0 ]]
    then
      exit 1
    fi
  else 
    unset WSESSIONDATA
  fi

  #If there are wsessions, it does prompt the user, if the user doesn't select one, it tells the user that its falling back to the default. If there are no wsessions, it silently falls back to the default, by adding hardcoded values to the wsessiondata variable.
  if [[ -z $WSESSIONDATA ]]
  then 
    if [[ $PROMPTED == 1 ]]
    then
      $ZENITYCMD --width=500 --warning --text="No session selected. Defaulting to the Default Weston Desktop Shell." 2>/dev/null
    else
      logger -t waylandloginmanager "No sessions installed in $WSESSIONSPATH or no sessions are enabled, or are missing files specified by NeedsFile values" -s  >>/var/log/waylandloginmanager 2>&1
    fi
    #There are different commands needed to support different backends
    if [[ $DefaultBackendType == KMS ]]
    then
      WSESSIONDATA="$DEFAULTWAYLANDSERVER"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--backend=drm-backend.so"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--modules=xwayland.so,cms-colord.so"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--socket=$WAYLAND_GUEST"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+=""
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+=""
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="KMS_KMS_0_"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="Default Weston Desktop Shell"

    elif [[ $DefaultBackendType == FB ]]
    then 
      WSESSIONDATA="$DEFAULTWAYLANDSERVER"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--backend=fbdev-backend.so"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--modules=xwayland.so,cms-colord.so"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--socket=$WAYLAND_GUEST"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+=""
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+=""
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="FB_FB_0_"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="Default Weston Desktop Shell"
    fi
    #export the WSESSIONDATA varaible
    export WSESSIONDATA
  fi
}


#This function displays a diagnostic terminal. depending on if the more secure debug option was passed, wlmdebug it, temporarilly copies a setuid /bin/login so that the host terminal window doesn't have to run as root, and the setuid login binary isn't accessible to the rest of the system, and opens the login terminal window running as a service user. If the more insecure wlmdebuginsecure option was passed, then it starts the terminal as root, with a root terminal.
function DiagnosticTerminal 
{
  if [[ $wlmdebuginsecure == 1 ]]
  then
    vte -g 500x300
  else
    mkdir -p /var/tmp/waylandloginmanager/logincmd
    chown $LOGINMANAGERDISPLAYUSER /var/tmp/waylandloginmanager/logincmd
    chmod 700 /var/tmp/waylandloginmanager/logincmd
    cp /bin/login /var/tmp/waylandloginmanager/logincmd
    chmod +s /var/tmp/waylandloginmanager/logincmd/login
    $TERMINALCMD -g 500x300 -c "screen -s /var/tmp/waylandloginmanager/logincmd/login"
    wait -n $TERMINALJOB
    rm /var/tmp/waylandloginmanager/logincmd/login
  fi
}

#This function is called when the loginmanager_control recives the Info command. It brings up a help dialog for the user, about the waylandloginmanager and the system.
function ShowInfo
{
  #If the backend type is FB, then add a string to tell the user that in the help dialog
  if [[ $DefaultBackendType == "FB" ]]
  then
    BACKENDSTRING="The framebuffer backend is being used.

This probably means the current video card drivers do not 
support the native kernel mode setting that is optimal for Weston or other Wayland servers.
or the system was started with the wlmforcefbdev argument."
  else
    BACKENDSTRING="Kernel mode setting is being used.

This is the optimal way to run Weston or other Wayland servers."
  fi
  $ZENITYCMD --title="Information" --no-wrap --info --text="This is a third party fan made distribution!

$BACKENDSTRING

The Login Manager Display is running on tty: $HostVT

The key icon brings up a login prompt
The arrow icon brings up a prompt to switch between running sessions
The red X icon brings up a shutdown prompt
The i icon shows this help prompt" 2>/dev/null

}

#This function is called when the loginmanager_control FIFO recives the command "Switch". It brings up a dialog containing the list of all running login sessions, to allow the user to pick and switch to start a mew session, by containing the FIFO.
function SwitchUserDialog 
{
  unset SessionList
  #get the number of registered sessions
  NumberOfSessions=${#AllSessionPIDs[@]}
  ((NumberOfSessions--))

  #go thorugh each session, reading the arrays containing information about the sessions. to build the SessionList variable
  #The session list variable is multiline, and used by a zenity dialog.
  #line 1 is the session number
  #line 2 is the TTY for the session
  #line 3 is the PID of the session
  #line 4 is the user name
  #line 5 is the logind session id.
  while [[ $NumberOfSessions -ge 0 ]]
  do
    #determine if the current session is alive, before adding it to the list
    if [[ -e /proc/${AllSessionPIDs[$NumberOfSessions]}/environ ]]
    then
      SessionList+="$NumberOfSessions
${AllSessionTTYs[$NumberOfSessions]}
${AllSessionPIDs[$NumberOfSessions]}
${AllSessionUsers[$NumberOfSessions]}
${AllSessionIDs[$NumberOfSessions]}
"
    fi
    ((NumberOfSessions--))
  done
  #Add a element with a sessionid of -1. When the selected element is -1, it prompts for a user login for a new session, with GetUserCredentials
  SessionList+="-1


New Session...

"


  unset ChangeSession
  #prompt for the list of running sessions, and return the session ID. (which is used in all of the arrays for Session PID, user name, etc)
  ChangeSession=$(echo "$SessionList"  | sed '$d'| $ZENITYCMD --title="Switch User" --height=450 --list --text "Select a running session to change into" --hide-header --column sessionid --column tty --column pid --column username --column ID --print-column=1 --hide-column=3,5 --separator="\n" 2>/dev/null )
  CancelOrOK=$?
  #Abort if the user selected cancel on the zenity dialog
  if [[ $CancelOrOK != 0 ]]
  then
    exit 1
  fi
  #if the chosen session is -1 then contact the FIFO with a login prompt, otherwise switch to the selected session
  if [[ $ChangeSession == "-1" ]]
  then
    echo -e "\nLogin" >/run/waylandloginmanager/loginmanager_control
  else 
    #if a session is selected, then get the PID, TTY, logind session ID with the selected Session ID as the array element number.
    if [[ $ChangeSession ]]
    then
      ChangeSessionPID=${AllSessionPIDs[$ChangeSession]}
      ChangeSessionTTY=${AllSessionTTYs[$ChangeSession]}
      ChangeSessionID=${AllSessionIDs[$ChangeSession]}

      #before switching into a session double check in case if the session crashed after it was listed ealier in the function.
      if [[ -e /proc/$ChangeSessionPID/environ ]]
      then
	chvt $ChangeSessionTTY &
	#hand over the logind session ID to allow desktop permissions to work.
	loginctl activate $ChangeSessionID
	#set the active session pid for the script to watch to be the PID of the session
	ActiveSessionPID=$ChangeSessionPID
      else
	$ZENITYCMD --title="Switch User" --warning --text="The selected session was not found. The session may have quit." 2>/dev/null
      fi
    fi
  fi
}

#Function that starts the user sessions, which is called by AuthenticateUser, if the authentication is successful. It takes the 3 arguments, TTY number, user to start the session for, and the multiline string, WSESSIONDATA, which contains specific data about how to start paticular sessions
function StartUserSession 
{ 
  #ensure the loginmanager_control fd doesn't get leaked
  exec 1000>&-


  #unset most varaibles, except PATH and WAYLAND_HOST and WAYLAND_GUEST
  while read var
  do 
    unset "$var"
  done < <(env | awk -F = '{print $1}' | grep -Ev "^WAYLAND_HOST$|^WAYLAND_GUEST$|^PATH$|^SESSIONID$" ) 

  #save the arguments passed to StartUserSession, and put the third argument into an array
  WSESSIONARGS=$(echo "$3" | sed 's/$/ /g')
  USERSESSIONTTY=$1
  LOGINUSER=$2
  IFS=$'\n'
  WSESSIONDATA=($WSESSIONARGS)
  unset IFS

  #Change to the users homepath so weston starts in the right place, and set some varaibles for the user
  export HOME=$(eval echo ~$LOGINUSER)
  export LOGNAME=$LOGINUSER
  export USER=$LOGINUSER
  export USERNAME=$LOGINUSER
  cd $HOME

  #The array makes it easy to get the data out of WSESSIONDATA. any variables in the strings are expanded with perl
  #line 1 is the path to the compositor
  #line 2 is the argument to start with a paticular backend
  #line 3 is the argument to start the Wayland server with a specific WAYLAND_DISPLAY
  #line 4 is any other arguments needed
  #line 5 specifies the environment file which is processed by the user session, which is documented at the top of the script.
  #line 6 specifies the backend data, which tells the user session what backend is being used, the default one, and if the session file is calling the session with fallback capabilies. This variable is broken up, and exported as BackendType, DefaultBackendType, and IsFallbackSession
  #line 7 specifies the session name for the user and for helpdialog to know what session is running. this is exported as a varaible.
  CompositorExec="$( echo "${WSESSIONDATA[0]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  BackendArguments="$( echo "${WSESSIONDATA[1]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  SessionArgument="$( echo "${WSESSIONDATA[2]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  AdditionalArguments="$( echo "${WSESSIONDATA[3]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  CompositorDisplayArgument="$( echo "${WSESSIONDATA[4]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  BackendData="$( echo "${WSESSIONDATA[6]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  export EnvironmentFile="$( echo "${WSESSIONDATA[5]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  export SessionName="$( echo "${WSESSIONDATA[7]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  IFS=_
  BackendData=($BackendData)
  unset IFS
  export BackendType=${BackendData[0]}
  export DefaultBackendType=${BackendData[1]}
  export IsFallbackSession=${BackendData[2]}


  #Call the server with the arguments specified by the selected session
  logger -t waylandloginmanager "Starting server $CompositorExec with the arguments of $BackendArguments $SessionArgument $AdditionalArguments $CompositorDisplayArgument for user $LOGINUSER on tty $USERSESSIONTTY" -s  >>/var/log/waylandloginmanager 2>&1
  Create_XDG_RUNTIME_DIR $LOGINUSER
  chvt $USERSESSIONTTY &
  systemd-run --unit="$LOGINUSER-wayland-$SESSIONID" -p PAMName=waylandloginmanager -p User="$LOGINUSER" -p TTYPath=/dev/tty"$USERSESSIONTTY" -p StandardOutput=tty -p StandardError=tty -p StandardInput=tty -p WorkingDirectory=\~ --setenv=SessionName="$SessionName" --setenv=BackendType="$BackendType" --setenv=DefaultBackendType="$DefaultBackendType" --setenv=IsFallbackSession="$IsFallbackSession" --setenv=EnvironmentFile="$EnvironmentFile" --setenv=WAYLAND_GUEST=$WAYLAND_GUEST --setenv=WAYLAND_HOST="$WAYLAND_HOST" $0 --usersession $CompositorExec $BackendArguments  $SessionArgument $AdditionalArguments $CompositorDisplayArgument
  sleep 5
  #Get the PID that was called, by seing which process is the 'leader pid' of the $USERSESSIONTTY tty that the server was started. This is needed to know what TTY to switch to.
  USERSESSIONPID=$(ps --tty /dev/tty$USERSESSIONTTY | sed -n 2p | awk '{print $1}')
  #Find the logind session id, by trying to find out what session is lead by the $USERSESSIONPID. This is needed to know what logind session needs to be switched to to enable desktop permissions
  SESSIONS=$(loginctl  list-sessions |grep "        c" |awk '{print $1}')
  while read SESSION
  do
    SessionPid=$(loginctl show-session $SESSION -p Leader |awk -F = '{print $2}')
    if [[ $SessionPid == $USERSESSIONPID ]]
    then
      LOGINDSESSION=$SESSION
      break
    fi
  done < <(echo "$SESSIONS")

  #The logind session activation is needed to enable the desktop permissions for the user. (such as udisks, and shutting down the system, and NetworkManager)
  loginctl activate $LOGINDSESSION

  #Send the tty number, pid, user name, and logind session ID to loginmanager_register in the background, then tell loginmanager_control to read loginmanager_register.
  echo "$USERSESSIONTTY@$USERSESSIONPID@$LOGNAME@$LOGINDSESSION" > /run/waylandloginmanager/loginmanager_register &
  echo -e "\nRegisterSession" >/run/waylandloginmanager/loginmanager_control
}

#Test users credentials, by making sure the user name and password match by trying to test with su and expect.
#Expect has to be run as a non root user, otherwise it always reports success. Run it as the user specified with $PROBETESTUSER
#it returns failure or success
#This is called by GetUserCredentials, after it collects the user name and password for the user. It reads the password from stdin
function AuthenticateUser
{
  unset USERPASSWORD
  TryPassword=$(cat -)
  #Test the users login with an embedded expect script running as PROBETESTUSER
  echo "log_user 0
	spawn su $LOGINUSER -c /bin/true
	expect Password 
	send $TryPassword\r
	catch wait result
	exit [lindex \$result 3]" |sudo -u $PROBETESTUSER expect
  PasswordResult=$?
  unset TryPassword
  if [[ 0 == $PasswordResult ]]
  then
    export USERHOME=$(eval echo ~$LOGINUSER)
    #if the password and username is correct, start the session
    logger -t waylandloginmanager "Opening a session for $LOGINUSER on TTY $SessionTTY" -s  >>/var/log/waylandloginmanager 2>&1
    DialogWait 3 "Login Successful.\rAttempting to start the selected session..."
    StartUserSession "$SessionTTY" "$LOGINUSER" "$WSESSIONDATA" &
    #report success
    return 0
  else
      #report failure
      return 1
  fi
}


#Get the users username and password by allowing the user to select the username in a list, or enter it manually, and then enter thier password
#This function is called when the loginmanager_control FIFO recives the command "Login"
function GetUserCredentials
{
  #Get the list of nonsystem users, in each line, there is 1 user, with two feilds, the users 'friendly' name, and then the users system login name, seperated by a :
  #this finds the range of UIDs that are user UIDs, and then finds any users with theses UIDS.
  UIDMIN=$(cat /etc/login.defs | grep -e "^UID_MIN" | awk '{print $2}')
  if [[ $ISLIVE == 1 ]]
  then
    UIDMIN=999
  fi
  UIDMAX=$(cat /etc/login.defs | grep -e "^UID_MAX" | awk '{print $2}')
  USERLIST=$(cat /etc/passwd | awk -v UIDMIN=$UIDMIN -v UIDMAX=$UIDMAX -F : '{ if ($3>=UIDMIN && $3 <=UIDMAX) print $5":"$1}')
  #sort the list
  USERLIST=$(echo "$USERLIST" | sort |uniq)
  #go through each line of users found, to handle the display of the real name (passwd gecos feild)
  while read USER
  do
    IFS=":"
    #handle the line as an array, with two elements
    UserData=($USER)
    #The passwd gecos feild is formated with username,buildingnumber,phonenumber,otherdata. only get the username subfeild.
    UserDisplayName=$(echo ${UserData[0]} | awk -F , '{print $1}')
    UserName=${UserData[1]}
    #If the user has no display name, then set it to be the users login name
    if [[ -z $UserDisplayName ]]
    then
      UserDisplayName=$UserName
    fi
    #The display in the zenity dialog should be "Firstname Lastname    (loginname)"
    UserDisplayName="$UserDisplayName   (${UserData[1]})" 
    unset IFS
    #add the data to the USERLISTSTRING that gets sent into zenity. Line 1 is the display name, line 2 is the user login name, and then line 3 is the display name of the next user...
    USERLISTSTRING+="$UserDisplayName"
    USERLISTSTRING+=$'\n'
    USERLISTSTRING+="$UserName"
    USERLISTSTRING+=$'\n'
  done < <(echo "$USERLIST")
  #Append a default value with the display string to enter the username with -1. When selected, this tells the script to bring up a dialog to allow the user to enter a manual name
  USERLISTSTRING+="Enter User Name..."
  USERLISTSTRING+=$'\n'
  USERLISTSTRING+="-1"

  #Prompt for the session type
  ChooseSessionType

  #present the list of the users to the system
  LOGINUSER=$(echo "$USERLISTSTRING" | $ZENITYCMD --title="Username" --height=450 --list --text "Select a user from the list to log into."  --column users --column usernames --hide-column 2 --print-column 2 --hide-header --separator="\n" 2>/dev/null )
  CancelOrOK=$?
  export LOGINUSER
  #Abort if the user selected cancel on the zenity dialog
  if [[ $CancelOrOK != 0 ]]
  then
    exit 1
  fi
  #if there is no user selected or if the LOGINUSER is -1, as in the user opted to enter a username manually prompt for the username with a text dialog
  if [[ -z $LOGINUSER || $LOGINUSER == -1 ]]
  then
    LOGINUSER=$($ZENITYCMD --title="Username" --entry --text="Enter the User Name:" 2>/dev/null)
    CancelOrOK=$?
    #Abort if the user selected cancel on the zenity dialog
    if [[ $CancelOrOK != 0 ]]
    then
      exit 1
    fi
  fi
  #get the TTY to start the session on
  export SessionTTY=$(GetNextTTY)
  if [[ $SessionTTY -ne -1 ]]
  then
    #Prompt for the users password
    USERPASSWORD=$( $ZENITYCMD --title="Password" --password --text "Type Password for $LOGINUSER" 2>/dev/null )
    CancelOrOK=$?
    #Abort if the user selected cancel on the zenity dialog
    if [[ $CancelOrOK != 0 ]]
    then
      exit 1
    fi
    #send the password to an AuthenticateUser function with stdin
    echo $USERPASSWORD | AuthenticateUser
    #get the result from AuthenticateUser in the pipe, (and not the echo command)
    passwordresult=${PIPESTATUS[1]}
    unset USERPASSWORD
    if [[ $passwordresult != 0 ]]
    then
      $ZENITYCMD --warning --text="Invalid password for $LOGINUSER, or username invalid" 2>/dev/null
      logger -t waylandloginmanager "Invalid password for $LOGINUSER, or username invalid" -s  >>/var/log/waylandloginmanager 2>&1
    fi
  else
    $ZENITYCMD --warning --text="Not Enough TTYs!" 2>/dev/null
    logger -t waylandloginmanager "Not Enough TTYs for user login!" -s  >>/var/log/waylandloginmanager 2>&1
  fi
}


#This function is called when the loginmanager_control FIFO recives the command "Leave". It brings up a zenity dialog for handling power options for the computer.
function LeavePrompt
{
  #The first line is sent to the zenity dialog is the actual command it sets the ACTION variable to be. the second line is what it appears as in the Zenity dialog for the user.
  CanPowerOff=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanPowerOff |grep -c yes)
  if [[ $CanPowerOff == 1 ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Shutdown"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Shutdown Computer"
  fi
  CanReboot=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanReboot |grep -c yes)
  if [[ $CanReboot == 1 ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Restart"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Restart Computer"
  fi
  CanSuspend=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanSuspend |grep -c yes)
  if [[ $CanSuspend == 1 ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Standby"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Standby Computer"
  fi
  CanHybridSleep=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanHybridSleep |grep -c yes)
  if [[ $CanHybridSleep == 1 ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Hybrid Sleep"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Hybrid Sleep Computer"
  fi
  CanHibernate=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanHibernate |grep -c yes)
  if [[ $CanHibernate == 1 ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Hibernate"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Hibernate Computer"
  fi
  ACTION=$(echo "$ACTIONSTRING" | $ZENITYCMD --title="Leave..." --height=450 --list  --hide-header --text="What do you want to do?" --separator="\n" --column 'action' --column 'useraction' --hide-column 1 --print-column=1  2>/dev/null )
  CancelOrOK=$?
  #Abort if the user selected cancel on the zenity dialog
  if [[ $CancelOrOK != 0 ]]
  then
    exit 1
  fi

  #Prompt the user if they are sure they want to execute the selected action
  $ZENITYCMD --width=450 --title="Leave..." --question --text="Are you sure you want to $ACTION" 2>/dev/null
  CONFIRM=$?
  if [[ $CONFIRM != 0 ]]
  then
    exit 1
  fi

  #For all actions use the dbus commands to logind
  if [[ $ACTION == "Shutdown" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.PowerOff boolean:true
    RESULT=$?
  elif [[ $ACTION == "Restart" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Reboot boolean:true
    RESULT=$?
  elif [[ $ACTION == "Standby" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Suspend boolean:true
    RESULT=$?
  elif [[ $ACTION == "Hybrid Sleep" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.HybridSleep boolean:true
    RESULT=$?
  elif [[ $ACTION == "Hibernate" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Hibernate boolean:true
    RESULT=$?
  else
    exit
  fi
  #if the selected action failed, tell the user
  if [[ $RESULT != 0 ]]
  then
    $ZENITYCMD --title="Failure" --warning --text="Failed to $ACTION" 2>/dev/null
  fi
}


#This calls the loginmanagerdisplay weston session.  Everytime the weston session dies, wait 1 second, then try to call it back up
function StartLoginManagerDisplay
{
  Create_XDG_RUNTIME_DIR $LOGINMANAGERDISPLAYUSER
  for (( StartTimes = 0 ; StartTimes < 5 ;))
  do
    systemctl is-active wlm-loginmanagerdisplay.service &>/dev/null
    LOGINMANAGERDISPLAYSTATUS=$?
    #This determines if the loginmanagerdisplay is running, by checking if the socket file is in use by a process or not.
    if [[ $LOGINMANAGERDISPLAYSTATUS != 0 ]]
    then 
      (( StartTimes++ ))
      logger -t waylandloginmanager "Starting the loginmanagerdisplay on tty $HostVT" -s  >>/var/log/waylandloginmanager 2>&1
      if [[ -x "$DEFAULTWAYLANDSERVER" ]]
      then
        chvt $HostVT &
        systemd-run --unit=wlm-loginmanagerdisplay -p PAMName=waylandloginmanager -p User="$LOGINMANAGERDISPLAYUSER" -p TTYPath=/dev/tty"$HostVT" -p StandardOutput=tty -p StandardError=tty -p StandardInput=tty -p WorkingDirectory=\~ --setenv=LD_LIBRARY_PATH="$LD_LIBRARY_PATH" --setenv=PATH="$PATH" --setenv=XDG_CONFIG_HOME="$XDG_CONFIG_HOME" --setenv=HOME="$HOME" $DEFAULTWAYLANDSERVER --backend=$WESTONBACKEND --socket=loginmanagerdisplay --log=/var/log/loginmanagerdisplay.log
      else
        echo "$DEFAULTWAYLANDSERVER is not executable, or does not exist" #>> /var/log/loginmanagerdisplay.log
      fi
    fi
    sleep 1
  done
  logger -t waylandloginmanager "ERROR: Maximum restarts of the loginmanagerdisplay has been reached" -s  >>/var/log/waylandloginmanager 2>&1
  openvt -c 63 -s -f -w -- sudo -E -u $LOGINMANAGERDISPLAYUSER dialog --msgbox "The maximum number of restart attempts for the loginmanagerdisplay has been reached. 

Will show a menu with a few options for diagnosis." 20 50 --no-cancel

  openvt -c 63 -s -f -- rbos-failedboot
  exit
}



#This determines if the autologin user was specified by ubiquity, and then configures that value to /etc/waylandloginmanager.conf, as in an unsafe shutdown, the lightdm config file has sometimes dropped the autologin user.
#If autologin is specified, prompt to select the session type to start, then start the session as the autologin user
function StartAutoLogin
{
  #if /etc/waylandloginmanager.conf exists, use the autologin user specified in that file, if not try the lightdm config file
  if [[ -e /etc/waylandloginmanager.conf ]]
  then
    AUTOLOGINUSER=$(cat /etc/waylandloginmanager.conf | awk -F "#" '{print $1}' | grep autologin-user= | awk -F = '{print $2}' | head -1 )
  else
    AUTOLOGINUSER=$(cat /etc/lightdm/lightdm.conf | awk -F "#" '{print $1}' | grep autologin-user= | awk -F = '{print $2}' | head -1 )
    echo "autologin-user=$AUTOLOGINUSER" >> /etc/waylandloginmanager.conf
  fi

  #if autologin is specified
  if [[ ! -z $AUTOLOGINUSER ]]
  then
    #Wait until the loginmanagerdisplay becomes availible
    DisplayServerWait
    ChooseSessionType
    #Abort if the user selected cancel on the zenity dialog
    CancelOrOK=$?
    if [[ $CancelOrOK != 0 ]]
    then
      exit 1
    fi
    #get the TTY to start the autologin session on
    export AutoSessionTTY=$(GetNextTTY)
    DialogWait 3 "Attempting to start the selected session..."
    #if there is a tty for the autologin session, the autologin is configured, start the autologin session
    if [[ $AutoSessionTTY -ne -1 ]]
    then
      logger -t waylandloginmanager "Starting Autologin session for $AUTOLOGINUSER on TTY $AutoSessionTTY" -s  >>/var/log/waylandloginmanager 2>&1
      StartUserSession "$AutoSessionTTY" "$AUTOLOGINUSER" "$WSESSIONDATA" &
    else
      $ZENITYCMD --warning --text="Not Enough TTYs for autologin!" 2>/dev/null
      logger -t waylandloginmanager "Not Enough TTYs for autologin!" -s  >>/var/log/waylandloginmanager 2>&1
    fi
  fi 
}

#This function is part of the startup for the waylandloginmanager. it creates the FIFO files, giving ONLY write access to loginmanager_control for ALL users, and only write access to loginmanager_register is given to root. Any other permissions, including read is denied.
function SetupLoggingAndFIFO
{
  #Create communication fifo.
  rm -r /run/waylandloginmanager/loginmanager_control &> /dev/null
  rm -r /run/waylandloginmanager/loginmanager_listener &> /dev/null
  rm -r /run/waylandloginmanager/loginmanager_register &> /dev/null
  mkfifo -m 622 /run/waylandloginmanager/loginmanager_control
  mkfifo -m 200 /run/waylandloginmanager/loginmanager_listener
  mkfifo -m 200 /run/waylandloginmanager/loginmanager_register
  chown $FIFOREADERUSER /run/waylandloginmanager/loginmanager_control
  #open the main FIFO that recives commands.
  exec 1000<> /run/waylandloginmanager/loginmanager_listener
  #Prepare logging for the loginmanagerdisplay
  touch /var/log/loginmanagerdisplay.log
  chown $LOGINMANAGERDISPLAYUSER /var/log/loginmanagerdisplay.log
}

#This function displays a dialog containing actions for the Wayland Login Manager for the user, Shutdown, Switch User, login, and show a help dialog. It's optional, for in the case Weston isn't configured
function UserActionDialog
{
  #wait for the loginmanagerdisplay
  DisplayServerWait
  ActionMenu="Login\nLogin...\nSwitch\nSwitch User...\nLeave\nShutdown...\nInfo\nHelp..."
  if [[ $wlmdebuginsecure == 1 ]]
  then
    ActionMenu+="\nDebug\nRoot Terminal..."
  elif [[ $wlmdebug == 1 ]]
  then
    ActionMenu+="\nDebug\nTerminal Login..."
  fi
  USERACTION=$(echo -e "$ActionMenu"|$ZENITYCMD  --title="Login Manager" --height=300 --hide-column 1 --separator="\n" --list --column action --column display --hide-header --text "Select an Action" 2>/dev/null; exit ${PIPESTATUS[1]})
ZENITYSTATUS=$?
  #If the useraction exists (the user did not click cancel), then send the command to the loginmanager_control
  if [[ ! -z $USERACTION ]]
  then
    echo -e "\n$USERACTION" > /run/waylandloginmanager/loginmanager_control
  else
    sleep .1
  fi
  #if zenity segfaults, then something is wrong. wait longer
  if [[ $ZENITYSTATUS == 139 ]]
  then
    sleep 30
  fi
}


#This part of the script is constantly running. It reads what the user send to loginmanager_control running as a service account, and filters out only valid commands to loginmanager_listener, and only sends a limited number of lines.
function CommandFIFOProxy
{
  while [ 1 ]
  do
    sudo -u $FIFOREADERUSER bash -c "grep -Eom 3 \"^Switch$|^Change$|^Login$|^Leave$|^RegisterSession$|^Info$|^Debug$|^$\" /run/waylandloginmanager/loginmanager_control" > /run/waylandloginmanager/loginmanager_listener
    sleep .1
  done
}

#This part of the script is constantly running, once it finishes setting up. This reads the loginmanager_listener FIFO constantly, waiting for it to recive a command from a program called by the loginmanagerdisplay's weston desktop shell that sends approriate commands to it, or the user session, shutdowndialog, or even some functions within this script.
#it also checks to see if the active sesssion is active, and if not, switches back to the tty of the loginmanagerdisplay.
function ReadCommandFIFO
{
  #loop 'forever'
  while [ 1 ]
  do
    UIJobCount=0
    while read JOB
    do
      if [[ $JOB == $LastUserActionPID || $JOB == $LastSwitchPID || $JOB == $LastLogonPID || $JOB == $LastLeavePID || $JOB == $LastInfoPID ]]
      then
	((UIJobCount++))
      fi
    done < <(jobs -p -r)

    if [[ $UIJobCount == 0 ]]
    then
      UserActionDialog &
      LastUserActionPID=$!
    fi
    #On each pass, if ActiveSessionPID isn't 0, that indicates a session is running. If one is it checks to see if the ActiveSessionPID, or the pid of the active session is still running. If it is down, then switch back to the TTY of the loginmanagerdisplay, and then reset it to indicate that no session is running
    if [[ $ActiveSessionPID != 0 && ! -e /proc/$ActiveSessionPID/environ ]]
    then
      if [[ $(fgconsole) != $HostVT ]]
      then
	chvt $HostVT &
      fi
      ActiveSessionPID=0
    fi
    #Read the next line that was sent to the FIFO. Allow a 1 second delay before it times out, and lets the loop run again. It only reads 20 bytes at a time.
    read -n 20 -t 1 COMMAND <&1000
    if [[ $COMMAND != "" ]]
    then
      logger -t waylandloginmanager "received command $COMMAND" -s  >>/var/log/waylandloginmanager 2>&1
    fi

    #If it recives a Switch command, then go back to the loginmanagerdisplay's TTY and bring up a switch user dialog and start a switch user job, only if there isn't another switchuserdialog job running
    if [[ $COMMAND == "Switch" ]]
    then
      if [[ $(fgconsole) != $HostVT ]]
      then
	chvt $HostVT &
      fi
      if [[ $(jobs -p -r | grep -c ^$LastSwitchPID$) == 0 ]]
      then
        kill -15 -$LastUserActionPID &> /dev/null
	SwitchUserDialog &
	LastSwitchPID=$!
      else
	logger -t waylandloginmanager "A handler for the command is already open" -s  >>/var/log/waylandloginmanager 2>&1
      fi
    #If the command is change, go back to the loginmanagerdisplay TTY, and don't do anything else. It only switches to the TTY if the TTY isn't active already.
    elif [[ $COMMAND == "Change" ]]
    then
      if [[ $(fgconsole) != $HostVT ]]
      then
	chvt $HostVT &
      fi
    #If it recives a Login command, then bring up a login dialog and start a login job, only if there isn't another login job running
    elif [[ $COMMAND == "Login" ]]
    then
      if [[ $(jobs -p -r | grep -c ^$LastLogonPID$) == 0  ]]
      then
        kill -15 -$LastUserActionPID &> /dev/null
	GetUserCredentials &
	LastLogonPID=$!
      else
	logger -t waylandloginmanager "A handler for the command is already open" -s  >>/var/log/waylandloginmanager 2>&1
      fi
    #If it recives a Leave command, then bring up a shutdown dialog and start a shutdown job, only if there isn't another shutdown job running
    elif [[ $COMMAND == "Leave" ]] 
    then
      if [[ $(jobs -p -r | grep -c ^$LastLeavePID$) == 0  ]]
      then
        kill -15 -$LastUserActionPID &> /dev/null
	LeavePrompt &
	LastLeavePID=$!
      else
	logger -t waylandloginmanager "A handler for the command is already open" -s  >>/var/log/waylandloginmanager 2>&1
      fi
    #if the command is RegisterSession, then attempt to read the loginmanager_register FIFO, and register any data sent to that FIFO.
    elif [[ $COMMAND = "RegisterSession" ]]
    then
      RegisterSession
    #If it recives a Info command, then bring up a info dialog and start a info job, only if there isn't another info job running
    elif [[ $COMMAND == "Info" ]]
    then
      if [[ $(jobs -p -r | grep -c ^$LastInfoPID$) == 0  ]]
      then
        kill -15 -$LastUserActionPID &> /dev/null
	ShowInfo &
	LastInfoPID=$!
      else
	logger -t waylandloginmanager "A handler for the command is already open" -s  >>/var/log/waylandloginmanager 2>&1
      fi
    #If the command is Debug, and wlmdebug was passed to the kernel, then show a login terminal window, only if there isn't another debug terminal window job running
    elif [[ $COMMAND == "Debug" ]]
    then
      if [[ $wlmdebug == 1 ]]
      then
	if [[ $(jobs -p -r | grep -c ^$LastDebugPID$) == 0  ]]
	then
	  DiagnosticTerminal &
	  LastDebugPID=$!
	  logger -t waylandloginmanager "Spawned a login terminal window on the loginmanagerdisplay" -s  >>/var/log/waylandloginmanager 2>&1
	else
	  logger -t waylandloginmanager "A handler for the command is already open" -s  >>/var/log/waylandloginmanager 2>&1
	fi
      else
	logger -t waylandloginmanager "Invalid command: $COMMAND received, but wlmdebug not passed to the kernel, or not in Live CD mode." -s  >>/var/log/waylandloginmanager 2>&1
      fi
    #if the command is empty, then execute bash's built in null command
    elif [[ $COMMAND == "" ]]
      then
      :
    #if the command is unknown, then log that.
    else
      logger -t waylandloginmanager "Invalid command: $COMMAND received" -s  >>/var/log/waylandloginmanager 2>&1
    fi
    sleep .05
  done
}


#If the waylandloginmanager is started with no arguments assume default operation. 
#If it is started with --uihost, then all arguments after that are treated as a command, but to set LD_LIBRARY_PATH.
#If it is started with --usersession, then perform operations to start the user session, running as the user
if [[ $1 == "" ]]
then
  #Prepare the loginmanager
  PrepareLoginManager

  #Start the main loginmanagerdisplay Weston server
  StartLoginManagerDisplay &

  #Start the autologin launcher, which will determine if there is an autologin user. Treat it as a login prompt, to not allow any other login prompts to start, until the job ends.
  StartAutoLogin &
  LastLogonPID=$!

  #Setup the FIFO before anything starts using the fifo, and logging for the loginmanagerdisplay
  SetupLoggingAndFIFO

  #Start the filter proxy that will only send valid data to the main command FIFO
  CommandFIFOProxy &

  #Start the login managers FIFO reader, and function that determines if the ActiveSessionPID is still alive, and if it should switch back.
  ReadCommandFIFO
elif [[ $1 == "--uihost" ]]
then
  shift 
  export LD_LIBRARY_PATH=$WLM_LD_LIBRARY_PATH
  export PATH=$WLM_PATH
  "$@"
elif [[ $1 == "--usersession" ]]
then
  shift
  UserSessionWorker "$@"
else
  echo "waylandloginmanager: Please start with no arguments."
  exit
fi