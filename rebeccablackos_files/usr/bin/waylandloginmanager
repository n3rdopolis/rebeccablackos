#! /bin/bash
#    Copyright (c) 2012 - 2022 nerdopolis (or n3rdopolis) <bluescreen_avenger@verzion.net>
#
#    This file is part of RebeccaBlackOS.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

#This script is the WaylandLoginManager it handles a graphical login for the user, and allows the user to start multiple types of Wayland sessions, specified in wsession files, and it supports autologin, and user switching. It supports watching the active session until it fails, so that it swiches back to the needed TTY for the user.

#The main server it displays on is refered to as the loginmanagerdisplay. it runs as non root, as well as the zenity dialogs

#It depends on zenity kbd, weston, and expect

#User sessions can have /etc/wlprofile or ~/.local/wlprofile (similar to xprofile only for Wayland)

#For framebuffer support, and the wlmforcefbdev option to work, the line
#SUBSYSTEM=="graphics", KERNEL=="fb*", TAG+="uaccess"
#is needed in a udev rules file. However, this is optional now as there is generic kernel mode setting now.

#It also requires /etc/pam.d/waylandloginmanager
#and /etc/pam.d/waylandloginmanager-loginmanagerdisplay

#It needs a user account called waylandloginmanager
#or /usr/lib/sysusers.d/waylandloginmanager.conf

#and /etc/loginmanagerdisplay/loginmanagerdisplay.ini
#for the greeter

#Weston 10.0 or greater is required for support for launcher names in the tooltips for the loginmanagerdisplay. Weston 9.0 or greater is needed for the Kiosk Shell support, which permits some fallback. Otherwise for the multiseat functionality to work, Weston 5.0 or greater is an absolute must.

#as well as:
#At least systemd v235 as it has all the ability to launch Wayland sessions with systemd-run, and needs support for BindPaths (bugfix)

#/etc/waylandloginmanager.conf
  #Otherwise it uses /etc/lightdm/lightdm.conf . The supported key is 'autologin-user=$AUTOLOGINUSER', and it usually takes it from /etc/lightdm/lightdm.conf at first run. It only uses /etc/waylandloginmanager.conf, as another init script can cause the lightdm config to drop the configured autologin user on an unsafe shutdown
     #it can also have 
     #      autologin-user-{$SEAT}=$AUTOLOGINUSER
     #to set a different autologin user per seat or
     #      autologin-user-{$SEAT}=:
     #to turn off autologin for a seat
     #
     #It also supports setting
     #wlmforceswrender-{$SEAT}=1
     #to force software rendering on a seat or
     #wlmforceswrender=1
     #to force software rendering globally.
     #Specifing the option on the kernel command line overrides the config file

     #wlmforcepixman-{$SEAT}=1
     #to force the loginmanagerdisplay to use pixman
     #wlmforcepixman=1
     #to force using pixman globally.
     #Specifing the option on the kernel command line overrides the config file

     #wlmforcefbdev-{$SEAT}=1
     #to force framebuffer on a seat or
     #wlmforcefbdev=1
     #to force framebuffer globally.
     #Specifing the option on the kernel command line overrides the config file

     #wlmnofbdev-{$SEAT}=1
     #to disable using the  framebuffer on a seat or
     #wlmnofbdev=1
     #to disable using the framebuffer globally.
     #Specifing the option on the kernel command line overrides the config file

     #wlmneverpasswd-autologinuser-{$SEAT}=1
     #to allow the autologin user to not need a password ever on a seat, or
     #wlmneverpasswd-autologinuser=1
     #to allow the autologin user to not need a password ever globally
     #this is not read form the kernel command line, however this option is set to
     #enabled when detected as a livecd. This option applies to logging in as the
     #autologin user, after the first autologin session has already been started.

     #Auto session selection only takes place during autologin, if enabled with:
     #
     #defaultwsessionautoselect=1
     #
     #When enabled, it is automatically set by the last manual session selection for the user on the seat.
     #defaultwsession=Unquoted Session Name
     #to force a wsession (based off the Name= key)
     #to be the default session
     #or defaultwsession--{$USER_LOGNAME}=Unquoted Session Name
     #to force it for a paticular user only
     #or defaultwsession--{$USER_LOGNAME}=:
     #or defaultwsession-{$SEAT}=Unquoted Session Name
     #or defaultwsession-{$SEAT}-{$USER_LOGNAME}=Unquoted Session Name
     #set defaultwsession-{$SEAT}-{$USER_LOGNAME}=::
     #to make it always prompt for autologins
     #for setting it per seat, or per user per seat
     #to override setting any default sessions for a user, when the global one is set.

#/etc/loginmanagerdisplay/loginmanagerdisplay.ini
  #Configuration for the loginmanagerdisplay. This should add the launchers in /usr/lib/waylandloginmanager to the launcher bar, which send commands to the FIFO for weston, or at least prevent the default terminal icon from appearing in the toolbar for security reasons.
  #The mainform makes this reqirement optional

#/usr/share/wsessions.d/*
  #These are .desktop files, (and .environment files as well) which describe how to start different Wayland servers or sessions
  #These files are documented in /usr/share/wsession/aboutwsessions.txt

#$HOME/.local/share/wsessions.d
  #A user can specify and create their own wsessions. See /usr/share/wsession/aboutwsessions.txt
  #The *.desktop files must be executable.

#Log Files:
  #/var/log/waylandloginmanager/waylandloginmanager.log : this is the main log for the waylandloginmanager
  #/var/log/waylandloginmanager/loginmanagerdisplays/loginmanagerdisplay_{SEAT}.log : This is the log file for the Weston server that is the loginmanagerdisplay
  #~/.cache/wlsessionlogs/waylandsession_($SEAT)_($DATESTAMP).log : This is where all wayland servers get logged as the run as the user.
  #~/.cache/wlsessionlogs/waylandhost_($SEAT).log : This log is for the host Wayland server that gets started for Wayland sessions that run on other Wayland servers

#Runtime Files:
  #/run/waylandloginmanager/pidfile: an empty file waylandloginmanager attempts to open with file descriptor #1023 to assist with locking
  #/run/waylandloginmanager/waylandloginmanager.lock: a symlink to /proc/$$/fd/1023 , when the symlink is broken, waylandloginmanager is not running. (and fd 1023 is used to try to account for recycled pids)
  #/run/waylandloginmanager/autologinran: Denotes that the autologin process has run already, after startup (since /run is a tmpfs). This prevents autologin when the service is restarted
  #/run/waylandloginmanager/sessiondata: Stores data for user switching so that the session list can be reloaded if waylandloginmanager restarts. As it's stored in /run which is a tmpfs, there should be no risk of one from a previous boot giving it false data
  #/run/waylandloginmanager/usrbinwaylandloginmanager.lock: (the file name is generated by the path that this script is in, removing the slashes). this prevents two instances of the waylandloginmanager from starting. 
    #It is a symlink to /proc/$$/cmdline (where $$ is the pid of the waylandloginmanager). It is checked in two different ways to protect against a race condition
  #/run/waylandloginmanager/loginmanager_register : Only root can write to this FIFO to register sessions, and no one can read it (except root). Functions registering sessions must first write to this FIFO, and then send the ReadRegister command to the loginmanager_control FIFO
  #/run/waylandloginmanager/loginmanager_control : All users have write access, but and no one can read it, except the FIFOREADERUSER service account. A process running as PROBETESTUSER reads the data getting send to it, and filters out only valid commands to get sent to loginmanager_listener
  #/run/waylandloginmanager/loginmanager_listener : Only root has write access to it, and no one has read access to it (except root). Supported commands:
      #Switch : calls up a switch user dialog on the loginmanagerdisplay, switching to the tty (see documentation for function SwitchUserDialog)
      #Change : switches to the tty the loginmanagerdisplay is on 
      #Info : calls up a help dialog for the user on the loginmanagerdisplay (see documentation for function ShowInfo)
      #Leave : calls up a dialog with shutdown/restart/supend options on the loginmanagerdisplay (see documentation for function LeavePrompt)
      #Login : Starts the login process (see documentation for function GetUserCredentials)
      #ReadRegister : Tells the waylandloginmanager to read from the loginmanager_register FIFO. When this is called the process must be attempting to write to the loginmanager_register already. If there is nothing being written in the short .01 second timeout, it is ignored. (see documentation for function ReadRegister)
      #DetectSeats: Tells the waylandloginmanager to detect all running seats
  #Each command is then ended by a @ followed by the argument for the specified seat

#These functions are for the user session part of the waylandloginmanager

#Function that is run to start user sessions while running as the user (when started with the --usersession argument)
function UserSessionWorker
{
  #prevent the WaylandLoginManager from being killed with CTRL+C
  trap '' 2

  #Enable job control
  set -m

  #set up the environment for the user. Determine the user name, set Wayland variables, and if the current session has an environment file then handle it.
  USER=$(id -u)
  export XDG_SESSION_TYPE=wayland
  . /usr/bin/wlruntime_vars &> /dev/null

  #if the user booted with wlmforceswrender, or configured software rendering globally, or for the seat
  #force software rendering to be enabled
  GetConfigKey wlmforceswrender "$XDG_SEAT" 0 1 wlmforceswrender
  if [[ $wlmforceswrender != 0  ]]
  then
    WLM_USE_SOFTWARE=1
    export LIBGL_ALWAYS_SOFTWARE=1
    export GBM_ALWAYS_SOFTWARE=1
  else
    WLM_USE_SOFTWARE=0
  fi
  unset wlmforceswrender

  if [[ -e /usr/share/wsessions.d/default.environment ]]
  then
    ReadEnvironmentFile /usr/share/wsessions.d/default.environment
  fi

  if [[ -e $EnvironmentFile ]]
  then
    ReadEnvironmentFile "$EnvironmentFile"
  fi
  
  #instead of .xprofile handle ~/.local/wlprofile files
  if [[ -x /etc/wlprofile ]]
  then
    . /etc/wlprofile &> /dev/null
  fi
  if [[ -x ~/.local/wlprofile ]]
  then
    . ~/.local/wlprofile &> /dev/null
  fi

  #Create a folder for the logs
  if [[ ! -e ~/.cache/wlsessionlogs ]]
  then
    mkdir -p ~/.cache/wlsessionlogs
  fi

  #Cleanup old log files
  LOGFILECOUNT=0
  ls -t ~/.cache/wlsessionlogs/waylandsession_${WLM_SEAT}_* 2>/dev/null | while read -r LOGFILE
  do
    ((LOGFILECOUNT++))
    if [[ $LOGFILECOUNT > 4 ]]
    then
      rm "$LOGFILE" &> /dev/null
    fi
  done

  #set all arguments into an array
  ArgumentString=$(echo -en "$@")
  DATESTAMP=$(date +%s)
  export WLM_SESSION_LOG="$HOME"/.cache/wlsessionlogs/waylandsession_${WLM_SEAT}_${DATESTAMP}.log
  echo "Started with the arguments: $ArgumentString" >> $WLM_SESSION_LOG
  eval set -- $ArgumentString >> $WLM_SESSION_LOG
  ArgArray=($ArgumentString)
  unset IFS

  #if the user booted with wlmforcepixman, or configured to use pixman globally, or for the seat
  #force pixman to be enabled
  GetConfigKey wlmforcepixman "$XDG_SEAT" 0 1 wlmforcepixman
  if [[ $DefaultBackendType == KMS && $wlmforcepixman != 0  ]]
  then
    export PIXMANARGS="--use-pixman"
  else
    export PIXMANARGS=""
  fi
  unset wlmforcepixman

  if [[ $BackendType == WKS || $BackendType == WL ]]
  then
    export WLM_HOST_LOG="$HOME"/.cache/wlsessionlogs/waylandhost_${WLM_SEAT}.log
    if [[ $DefaultBackendType == FB ]]
    then
      HostBackendArgument="--backend=fbdev-backend.so"
    else
      HostBackendArgument="--backend=drm-backend.so"
    fi

    if [[ $BackendType == "WL" ]]
    then
      HostShellName=fullscreen-shell.so
    elif [[ $BackendType == "WKS" ]]
    then
      HostShellName=kiosk-shell.so
    fi

    weston --no-config $PIXMANARGS --shell=$HostShellName --socket=$WAYLAND_HOST $HostBackendArgument &>> $WLM_HOST_LOG &
    HostServerPID=$!
    export WAYLAND_DISPLAY=$WAYLAND_HOST
    WaitTimes=0
    if [[ ${WAYLAND_DISPLAY:0:1} == "/" ]]
    then
      WAYLANDDISPLAYPATH=$WAYLAND_DISPLAY
    else
      WAYLANDDISPLAYPATH=$XDG_RUNTIME_DIR/$WAYLAND_DISPLAY
    fi
    #Wait for the server to start up for a maximum of 15 seconds. As soon as the socket is created, the wait loop ends
    while [[ ! -e $WAYLANDDISPLAYPATH && $WaitTimes<15 ]]
    do
      $SLEEPCMD 1
      ((WaitTimes++))
    done
    #If the socket doesn't exist, then the server failed to start, and switch back
    if [[ ! -e $WAYLANDDISPLAYPATH ]]
    then
      echo "The host server failed to start. Will not start the guest server for this session. Please see $WLM_HOST_LOG" &>> $WLM_SESSION_LOG
      if [[ $(loginctl show-session --value -p State $XDG_SESSION_ID 2>/dev/null) == active ]]
      then
        SendSelfCommand Change "$XDG_SEAT"
      fi
      exit
    fi
  else
    unset WAYLAND_HOST
    unset WAYLAND_GUEST
  fi
  unset WLM_SEAT

  #Execute the Wayland server, and log it to $HOME/.cache/wlsessionlogs/waylandsession_${SEAT}_${DATESTAMP}.log
  dbus-run-session -- ${ArgArray[@]} &>> $WLM_SESSION_LOG &
  GuestServerPID=$!

  #Terminate the host server after the guest terminates
  if [[ $BackendType == WKS || $BackendType == WL ]]
  then
    wait $GuestServerPID
    SessionReturnCode=$?
    if [[ $(loginctl show-session --value -p State $XDG_SESSION_ID 2>/dev/null) == active ]]
    then
      SendSelfCommand Change "$XDG_SEAT"
    fi
    echo "The guest session has ended. Terminating the host..." &>> $WLM_HOST_LOG
    TerminateJobPID $HostServerPID 15 0
    $SLEEPCMD 3
    TerminateJobPID $HostServerPID 9 0
  else
    wait $GuestServerPID
    SessionReturnCode=$?
    if [[ $(loginctl show-session --value -p State $XDG_SESSION_ID 2>/dev/null) == active ]]
    then
      SendSelfCommand Change "$XDG_SEAT"
    fi
  fi

  #Write the error code and any Journal logs for this session into the logfile
  echo -e "\nSession exited with the error code: $SessionReturnCode\nSession's Journal Logs:" >> $WLM_SESSION_LOG
  journalctl -b _SYSTEMD_SESSION=$XDG_SESSION_ID >> $WLM_SESSION_LOG 2>/dev/null

  exit
}

#Function that uses a bash builtin to check the existance of files, it takes 2 arguments, the files to probe, the files may have wildcards and regex
#it returns 1 if the files exist, and 0 if there are no files, and the variable name to set the status to.
function ProbeFilesExist
{
  builtin compgen -G "$1" &> /dev/null
  if [[ $? == 0 ]]
  then
    ReturnStatus=1
  else
    ReturnStatus=0
  fi

  #Either return for use in a subshell if the 2nd argument is empty
  #Or return the value to the variable specified in the 2nd argument
  if [[ ! -z $2 ]]
  then
    builtin printf -v "$2" '%s' "$ReturnStatus" 2> /dev/null
  else
    echo $ReturnStatus
  fi
}

#Function that reads the waylandloginmanager config, and reports the value of it, if it exists.
#It takes 5 arguments, the first key to get the value of, the second is the subvalue (Value, Value-seat ; Value-Value-user), and the 3rd is the default value,
#the 4th is: 0 to consider just the config file, 1 to consider /proc/cmdline and the config file, or 2 to only consider /proc/cmdline, and the 5th is the variable to return to
function GetConfigKey
{
  CommandLineValue=""
  GlobalKeyValue=""
  ReturnKeyValue=""
  SeatKeyValue=""

  #Only allow /etc/waylandloginmanager.conf to be less that 16kb.
  if [[ -f /etc/waylandloginmanager.conf ]]
  then
    #read up to 16385 bytes from the config file, if it is 16385 bytes ignore it
    #The most accepted bytes is 16384, or 16KB, which is more than enough
    read -r -n 16385 -d $'\r' LoginManagerConfig 2>/dev/null </etc/waylandloginmanager.conf
    if [[ ${#LoginManagerConfig} == 16385 ]]
    then
      WriteToLog "/etc/waylandloginmanager.conf is too large"
      return
    fi
  fi

  #If specified to consider /proc/cmdline
  #This can only be boolean, and global, (for instance not wlmsomething=something or wlmsomething-seat0=something)
  #Just when wlmsomething is passed to /proc/cmdline, it returns 1
  if [[ $4 == 1 || $4 == 2 ]]
  then
    read -r -n 16385 -d $'\r' KernelCommandLine </proc/cmdline
    if [[ $KernelCommandLine =~ ([[:space:]]|^)"$1"([[:space:]]|$) ]]
    then
      CommandLineValue=1
    else
      if [[ $4 == 2 ]]
      then
        CommandLineValue=0
      fi
    fi
  fi

  #Convert to an array
  readarray -t LoginManagerConfig <<< "$LoginManagerConfig"

  #If the command line value overrides or not
  if [[ -z $CommandLineValue ]]
  then
    for LoginManagerConfigLine in "${LoginManagerConfig[@]}"
    do
      LoginManagerConfigLine="${LoginManagerConfigLine##*( )}"
      LoginManagerConfigLine="${LoginManagerConfigLine%%*( )}"

      LoginManagerConfigLineLastChar=${LoginManagerConfigLine:$((${#LoginManagerConfigLine} -1 )):1}
      IFS="="
      LoginManagerConfigLine=($LoginManagerConfigLine)
      unset IFS

      KeyName=""
      KeyValue=""

      KeyName=${LoginManagerConfigLine[0]}
      KeyName="${KeyName##*( )}"
      KeyName="${KeyName%%*( )}"

      if [[ ${#LoginManagerConfigLine[@]} -gt 1 ]]
      then
        printf -v KeyValue "=%s" "${LoginManagerConfigLine[@]:1}"
        KeyValue=${KeyValue:1}
        KeyValue="${KeyValue##*( )}"
        KeyValue="${KeyValue%%*( )}"
        if [[ $LoginManagerConfigLineLastChar == "=" ]]
        then
          KeyValue+=$LoginManagerConfigLineLastChar
        fi
      fi

      #Find the config value for all seats
      if [[  $KeyName == "$1" && -z $GlobalKeyValue ]]
      then
        GlobalKeyValue=$KeyValue
      fi

      #If a seat is specified as an argument and a config value is specifed for a seat, favor it
      if [[ ! -z $2 ]]
      then
        if [[  $KeyName == "$1-$2" && -z $SeatKeyValue ]]
        then
          SeatKeyValue=$KeyValue
          break
        fi
      fi
    done

    #Determine if the default value, global specified value, or seat specified value wins
    if [[ ! -z $SeatKeyValue ]]
    then
      ReturnKeyValue=$SeatKeyValue
    else
      ReturnKeyValue=$GlobalKeyValue
    fi
    if [[ -z $ReturnKeyValue ]]
    then
      ReturnKeyValue=$3
    fi
  else
    ReturnKeyValue=$CommandLineValue
  fi

  #Either return for use in a subshell if the 5th argument is empty
  #Or return the value to the variable specified in the 5th argument
  if [[ ! -z $5 ]]
  then
    builtin printf -v "$5" '%s' "$ReturnKeyValue"
  else
    echo $ReturnKeyValue
  fi
}

#Function to set values in /etc/waylandloginmanager.conf, takes 2 arguments, the key name, and the value
#Only full values are accepted
function SetConfigKey
{
  unset LoginManagerConfig
  #Only allow /etc/waylandloginmanager.conf to be less that 16kb.
  if [[ -f /etc/waylandloginmanager.conf ]]
  then
    #read up to 16385 bytes from the config file, if it is 16385 bytes ignore it
    #The most accepted bytes is 16384, or 16KB, which is more than enough
    read -r -n 16385 -d $'\r' LoginManagerConfig 2>/dev/null </etc/waylandloginmanager.conf
    if [[ ${#LoginManagerConfig} == 16385 ]]
    then
      WriteToLog "/etc/waylandloginmanager.conf is too large"
      return
    fi
  fi

  #Convert to an array
  readarray -t LoginManagerConfig <<< "$LoginManagerConfig"

  LoginManagerConfigOutput=""

  for LoginManagerConfigLine in "${LoginManagerConfig[@]}"
  do
    LoginManagerConfigLine="${LoginManagerConfigLine##*( )}"
    LoginManagerConfigLine="${LoginManagerConfigLine%%*( )}"

    IFS="="
    LoginManagerConfigLineArray=($LoginManagerConfigLine)
    unset IFS

    KeyName=""

    KeyName=${LoginManagerConfigLineArray[0]}
    KeyName="${KeyName##*( )}"
    KeyName="${KeyName%%*( )}"

    #Find the config value for all seats
    if [[  $KeyName != "$1" ]]
    then
      if [[ ! -z $LoginManagerConfigOutput ]]
      then
        LoginManagerConfigOutput+=$'\n'
      fi
      LoginManagerConfigOutput+="$LoginManagerConfigLine"
    fi
  done
  if [[ ! -z $1 ]]
  then
    if [[ ! -z $LoginManagerConfigOutput ]]
    then
      LoginManagerConfigOutput+=$'\n'
    fi
    LoginManagerConfigOutput+="${1}=${2}"
  fi
  echo "$LoginManagerConfigOutput" > /etc/waylandloginmanager.conf
}


#Function that takes the argument of an environment file, and handles the definitions (for --usersession)
function ReadEnvironmentFile
{
  unset EnvironmentFileLinesArray
  EnvironmentFilePath=$1
  #read up to 16385 bytes from the config file, if it is 16385 bytes ignore it
  #The most accepted bytes is 16384, or 16KB, which is more than enough
  if [[ -f "$EnvironmentFilePath" ]]
  then
    read -r -n 16385 -d $'\r' EnvironmentFileArray 2>/dev/null < "$EnvironmentFilePath"
  else
    echo "$EnvironmentFilePath is not a file"
    continue
  fi

  #If the file is too large
  if [[ ${#EnvironmentFileArray} -ge 16385 ]]
  then
    echo "$EnvironmentFilePath is too large, and will be ignored"
    continue
  fi

  #Convert the file data to an array
  readarray -t EnvironmentFileArray <<< "$EnvironmentFileArray"

  #Build the initial array for the NeedsFile list
  EnvironmentFileLinesArray=()

  #Handle all the valid lines in the file
  ParseINISegment=0
  for EnvironmentFileLine in "${EnvironmentFileArray[@]}"
  do
    #Remove whitespace
    EnvironmentFileLine="${EnvironmentFileLine##*( )}"
    EnvironmentFileLine="${EnvironmentFileLine%%*( )}"

    #Remove comments
    EnvironmentFileLine=${EnvironmentFileLine%%#*}

    if [[ $ParseINISegment == 1 && $EnvironmentFileLine =~ ^[[:space:]]*"["  ]]
    then
      ParseINISegment=0
    fi
    if [[ $EnvironmentFileLine == "[EnvironmentFile]" ]]
    then
      ParseINISegment=1
      continue
    fi
    if [[ $ParseINISegment == 0 ]]
    then
      continue
    fi

    KeyAction=""
    KeyName=""
    KeyValue=""
    KeyBackend=""
    [[ $EnvironmentFileLine =~ @([A-Z0-9]*) ]]
    if [[ ! -z ${BASH_REMATCH[1]} ]]
    then
      EnvironmentFileLine=${EnvironmentFileLine%%${BASH_REMATCH[0]}}
      KeyBackend=${BASH_REMATCH[1]}
    fi

    EnvironmentFileLineLastChar=${EnvironmentFileLine:$((${#EnvironmentFileLine} -1 )):1}
    IFS="="
    EnvironmentFileLine=($EnvironmentFileLine)
    unset IFS

    KeyAction=${EnvironmentFileLine[0]}
    KeyAction="${KeyAction##*( )}"
    KeyAction="${KeyAction%%*( )}"

    KeyName=${EnvironmentFileLine[1]}
    KeyName="${KeyName##*( )}"
    KeyName="${KeyName%%*( )}"

    if [[ ${#EnvironmentFileLine[@]} -gt 2 ]]
    then
      printf -v KeyValue "=%s" "${EnvironmentFileLine[@]:2}"
      KeyValue=${KeyValue:1}
      KeyValue="${KeyValue##*( )}"
      KeyValue="${KeyValue%%*( )}"
      if [[ $EnvironmentFileLineLastChar == "=" ]]
      then
        KeyValue+=$EnvironmentFileLineLastChar
      fi
    fi

    #Only expand some variables
    if [[ $KeyValue == "\$WAYLAND_DISPLAY" ]]
    then
      KeyValue=$WAYLAND_DISPLAY
    fi
    if [[ $KeyValue == "\$XDG_SEAT" ]]
    then
      KeyValue=$XDG_SEAT
    fi

    #if the backend for this line is unspecified, OR if the backend on this line matches the current one running then handle the variable
    if [[ $WLM_USE_SOFTWARE == 1 && $KeyBackend == SOFTWARE ]]
    then
      ADDSWVAR=1
    else
      ADDSWVAR=0
    fi

    if [[ -z $KeyBackend || $KeyBackend == $BackendType || $ADDSWVAR == 1 ]]
    then
      #if it is set, then set the variable
      if [[ $KeyAction == "set" ]]
      then
        export $KeyName=$KeyValue
      fi
      #if it is unset, then unset the variable
      if [[ $KeyAction == "unset" ]]
      then
        unset $KeyName
      fi
    fi
  done
  unset EnvironmentFileArray
}

#All functions below this point are for the main operation of the waylandloginmanager

#This function writes to the logs. It takes 1 argument, the string to log.
function WriteToLog
{
  builtin printf "%(%F %T %z)T: %s\n" -1 "$1"   >> /var/log/waylandloginmanager/waylandloginmanager.log 2>&1
}

#This function makes sure a specified PID belongs to a job, before terminating it.
#This is to ensure that with PID recyling, one that gets reused, and is no longer a subprocess, it does not get terminated
#It takes 3 arguments, 1 is the pid, 2 is the signal, 3 is 0 or 1, where 0 does not terminate the tree, while 1 terminates the tree
function TerminateJobPID
{
  PIDInJob=0
  TerminatePID=$1
  TerminateSignal=$2
  if [[ -z $TerminateSignal ]]
  then
    TerminateSignal=15
  fi
  TerminateTree=$3
  if [[ -z $TerminateTree ]]
  then
    TerminateTree=0
  fi

  for JOBPID in $(jobs -p)
  do
    if [[ $JOBPID == $TerminatePID ]]
    then
      PIDInJob=1
      break
    fi
  done

  if [[ $PIDInJob == 1 && -d /proc/$TerminatePID ]]
  then
    if [[ $TerminateTree == 0 ]]
    then
      builtin kill -$TerminateSignal -- $TerminatePID &> /dev/null
    else
      builtin kill -$TerminateSignal -- -$TerminatePID &> /dev/null
    fi
    wait $TerminatePID &> /dev/null
  fi
}

#Function that stores common configuration, for the waylandloginmanager running as a service, and for waylandloginmanager running for the shutdowndialog
function SetCommonConfig
{
  ######################################################
  export MAX_UI_ATTEMPTS=5
  ######################################################

  #User that the zenity dialogs and the loginmanagerdisplay (weston instance for the waylandloginmanager runs as
  export LOGINMANAGERDISPLAYUSER=waylandloginmanager
  #User that the su test in AuthenticateUser user runs as
  export PROBETESTUSER=waylandloginmanager
  #User that reads from the loginmanager_control FIFO, and filters the command sent to it to loginmanager_listener
  export FIFOREADERUSER=waylandloginmanager
}

#Function that takes no arguments that does the first steps in setting up the environment, and detecting hardware support, and previous instances for starting up the login manager
function PrepareLoginManager
{
  SetCommonConfig
  export XDG_CONFIG_HOME=/etc/loginmanagerdisplay/
  #Get the UID of the $LOGINMANAGERDISPLAYUSER
  export LOGINMANAGERDISPLAYUID=$(id $LOGINMANAGERDISPLAYUSER -u)
  export XDG_RUNTIME_DIR=/run/user/$LOGINMANAGERDISPLAYUID

  #Require root privlages
  if [[ $UID != 0 ]]
  then
    echo "Must be run as root."
    exit 1
  fi

  #Create the waylandloginmanager folder in /run for FIFOs and lockfiles
  mkdir -p /run/waylandloginmanager
  touch /run/waylandloginmanager/fifolock
  mkdir -p /var/log/waylandloginmanager/

  #Create and open an empty file, with file descriptor #1023.
  touch /run/waylandloginmanager/pidfile
  exec 1023<> /run/waylandloginmanager/pidfile

  #Detect another instance, testing if the lockfile path to the previous waylandloginmanager's file descriptor 1023 is invalid
  if [[  ! -e "/run/waylandloginmanager/waylandloginmanager.lock"  ]]
  then
    #Link this proccess's file descriptor #1023 to the lock file
    #When this path is valid, this check will not allow the new instance to run, because there already is one
    rm -r "/run/waylandloginmanager/waylandloginmanager.lock" 2>/dev/null
    ln -s /proc/"$$"/fd/1023 "/run/waylandloginmanager/waylandloginmanager.lock"
    Status=$?
    if [[ $Status != 0 ]]
    then
      WriteToLog "Failed to create a lock file."
      exit 1
    fi
  else
    WriteToLog "Error: Another instance is already running"
    exit 1
  fi
  #second check to make sure this instance 'won' as a second instance could report success, and execute as the first instance is OK to run, but before it creates the lockfile
  #this ensures that the linked /proc/pid/cmdline is this pid
  LOCKPROCPATH=$(readlink "/run/waylandloginmanager/waylandloginmanager.lock" )
  THISPROCPATH=/proc/$$/fd/1023
  if [[ $LOCKPROCPATH != $THISPROCPATH ]]
  then
    WriteToLog "Error: Another instance is already running"
    exit 1
  fi

  #Create home folder
  mkdir -p /run/waylandloginmanager/home
  export HOME=/run/waylandloginmanager/home
  chmod 700 /run/waylandloginmanager/home
  chown $LOGINMANAGERDISPLAYUSER /run/waylandloginmanager/home

  #Prepare logging for the loginmanagerdisplay

  #Older versions of the waylandloginmanager used to log to /var/log/waylandloginmanager , now /var/log/waylandloginmanager is a folder
  #Handle rare cases where an older version of waylandloginmanager would now prevent proper logging.
  if [[ -f /var/log/waylandloginmanager ]]
  then
    mv /var/log/waylandloginmanager /var/log/waylandloginmanager.log
  fi
  mkdir -p /var/log/waylandloginmanager/loginmanagerdisplays/

  #If /var/log/waylandloginmanager.log exists, or was renamed, move it into the correct, now created folder
  if [[ -f /var/log/waylandloginmanager.log ]]
  then
    mv /var/log/waylandloginmanager.log /var/log/waylandloginmanager/waylandloginmanager.log
  fi

  #Only save the last 1000 lines of /var/log/waylandloginmanager/waylandloginmanager.log
  if [[ -f /var/log/waylandloginmanager/waylandloginmanager.log ]]
  then
    echo "$(tail -n 1000 /var/log/waylandloginmanager/waylandloginmanager.log 2>/dev/null)" > /var/log/waylandloginmanager/waylandloginmanager.log 2>/dev/null
  fi

  #Only save last 1000 lines for the loginmanagerdisplay log files
  ProbeFilesExist "/var/log/waylandloginmanager/loginmanagerdisplays/loginmanagerdisplay_*.log" LoginManagerLogFileProbe
  if [[ $LoginManagerDisplayLogProbe == 1 ]]
  then
    for LoginManagerDisplayLog in /var/log/waylandloginmanager/loginmanagerdisplays/loginmanagerdisplay_*.log
    do
      echo "$(tail -n 1000 "$LoginManagerDisplayLog" 2>/dev/null)" > "$LoginManagerDisplayLog" 2>/dev/null
    done
  fi
  unset LoginManagerLogFileProbe

  chown $LOGINMANAGERDISPLAYUSER /var/log/waylandloginmanager/loginmanagerdisplays
  WriteToLog "Starting Up..."

  #prevent the WaylandLoginManager from being killed with CTRL+C
  trap '' 2

  #Seat0 is the only seat with TTYs, but if CONFIG_VT=no then there are no TTYs
  seat0CanTTY=$(loginctl show-seat seat0 -p CanTTY --value)
  if [[ $seat0CanTTY == "yes" ]]
  then
    seat0HasTTYs=1
  else
    seat0HasTTYs=0
  fi

  #Array that contains the time stamps of the creation date of the seats
  SeatCreationStrings=()

  #Attempt to import fast user switching data from a crashed WaylandLoginManager
  if [[ -e /run/waylandloginmanager/sessiondata ]]
  then
    . /run/waylandloginmanager/sessiondata
  else
    touch /run/waylandloginmanager/sessiondata
    chmod 700 /run/waylandloginmanager/sessiondata
  fi

  #Set up the needed environment variables
  cd /run/waylandloginmanager

  #Enable job control in this script
  set -m

  #Set Wayland/runtime vars
  export PATH=/opt/bin:$PATH
  export DEB_HOST_MULTIARCH=$(dpkg-architecture -qDEB_HOST_MULTIARCH 2>/dev/null)
  export LD_LIBRARY_PATH=/opt/lib/$DEB_HOST_MULTIARCH:/opt/lib:/usr/local/lib/$DEB_HOST_MULTIARCH:/usr/lib/$DEB_HOST_MULTIARCH:/usr/local/lib:/usr/lib
  export XDG_DATA_DIRS=/opt/share:/usr/share
  export GDK_BACKEND=wayland
  #Set the default path for weston
  export DEFAULTWAYLANDSERVER=$(which weston)
  #Specify where wsession files are found
  export WSESSIONSPATH="/usr/share/wsessions.d"
  export WESTON_PLUGIN_PATH=/opt/lib/$DEB_HOST_MULTIARCH/weston

  WestonFBDev=$(weston --help |& grep fbdev-backend.so -c)
  if [[ $WestonFBDev -gt 0 ]]
  then
    WestonSupportsFBDev=1
  else
    WriteToLog "Installed version of Weston does not have a framebuffer backend. The Framebuffer fallback is now disabled."
    WestonSupportsFBDev=0
  fi
  unset WestonFBDev

  #set MinimumTTY to be 7.
  MinimumTTY=7
  #default the number of sessions registered to be 0 if unset
  if [[ -z $AllSessions ]]
  then
    export AllSessions=0
  fi

  #Determine if this is running on a live instance, if booted with casper
  GetConfigKey wlmlivemode "" 0 0 LiveCDMode

  ZENITYCMD="runuser -u $LOGINMANAGERDISPLAYUSER -m -- zenity"
  TERMINALCMD="runuser -u $LOGINMANAGERDISPLAYUSER -m -- vte"
  WAYLANDINFOCMD="runuser -u $LOGINMANAGERDISPLAYUSER -m -- wayland-info"
  if [[ $seat0HasTTYs == 1 ]]
  then
    DIALOGCMD="systemd-run --unit="wlm-ttydialog" --wait -p CollectMode=inactive-or-failed -p TTYPath=/dev/tty63 -p User="$LOGINMANAGERDISPLAYUSER" -p StandardOutput=tty -p StandardError=tty -p StandardInput=tty dialog"
    TTYWIZARDCMD="systemd-run --unit="wlm-ttydialog" --wait -p CollectMode=inactive-or-failed -p TTYPath=/dev/tty63 -p StandardOutput=tty -p StandardError=tty -p StandardInput=tty"
  else
    DIALOGCMD=true
    TTYWIZARDCMD=true
  fi

  command -v zenity > /dev/null
  ZenityCommandFoundResult=$?

  #Detect hardware abilities, first try to see if the system has kernel mode setting, then try framebuffer. if both aren't supported, bring up a text mode dialog
  GetConfigKey wlmforcefbdev "" 0 1 wlmforcefbdev
  ProbeFilesExist "/dev/dri/card[0-9]*" KMSFileProbe
  if [[ $KMSFileProbe == 1 && $wlmforcefbdev == 0 ]]
  then 
    WriteToLog "Kernel mode setting found."
    HardwareSupported=1
  else
    WriteToLog "No kernel mode setting found. Using the framebuffer"
  fi
  unset KMSFileProbe

  GetConfigKey wlmnofbdev "" 0 1 wlmnofbdev
  ProbeFilesExist "/dev/fb[0-9]*" FBFileProbe
  if [[ $FBFileProbe == 1 && $wlmnofbdev == 0 && $WestonSupportsFBDev == 1 ]]
  then
    WriteToLog "Frame buffer support found."
    HardwareSupported=1
  else
    WriteToLog "No framebuffer support found, or framebuffer support not in Weston"
  fi

  if [[ $wlmnofbdev != 0 ]]
  then
    WriteToLog "Manually override set to disable detection of the framebuffer"
  fi
  unset wlmnofbdev

  #if the user booted with a hidden option wlmforcefbdev, set the backend for Weston / Wayland server sessions to be fbdev
  if [[ $wlmforcefbdev != 0 ]]
  then
    WriteToLog "Manually override set to use to use the framebuffer"
    if [[ $HardwareSupported != 1 ]]
    then
      systemd-notify --ready &> /dev/null
      WriteToLog "ERROR: No framebuffer device found for wlmforcefbdev override!"
      if [[ $seat0HasTTYs == 1 ]]
      then
        chvt 63
      fi
      $DIALOGCMD --no-cancel --msgbox "The wlmforcefbdev overide is set, but no framebuffer device is found!

Will show a menu with a few options for diagnosis." 20 50
      $TTYWIZARDCMD rbos-failedboot
      exit 0
    fi
  fi
  unset wlmforcefbdev

  #if there is no Framebuffer or Kernel mode setting, tell the user with a text mode dialog on TTY63, and restart.
  #Depending if this is a live session or not, tell the user how to configure grub if it is installed, or to specify a boot option for the framebuffer from the menu if its live
  if [[ $HardwareSupported != 1 ]]
  then
    systemd-notify ERRNO=1 &> /dev/null
    if [[ $seat0HasTTYs == 1 ]]
    then
      chvt 63
    fi
    WriteToLog "ERROR: No supportable hardware found"
    $DIALOGCMD --no-cancel --msgbox "No supported graphics device found.

This means your video card is not supported by any graphics driver, and your bootloader is misconfigured, preventing the fallback driver from working.

Please check your bootloader config, namely the boot resolution, and if gfxpayload=keep is set." 20 50
    if [[ $LiveCDMode == 1 ]]
    then
      $TTYWIZARDCMD rbos-failedboot
    else
      $TTYWIZARDCMD rbos-configure-simplegraphics
      $TTYWIZARDCMD rbos-failedboot
    fi
    exit 1
  fi

  ReadyNotifySent=0
  #Get the TTY that will hold the Wayland server that displays the login screen for seat0
  ProbeFilesExist "/run/user/$LOGINMANAGERDISPLAYUID/loginmanagerdisplay_*" LoginManagerDisplayFileProbe
  if [[ $LoginManagerDisplayFileProbe == 1 ]]
  then
    RUNNINGWLMCOUNT=$(systemctl show wlm-loginmanagerdisplay_*.service -p MainPID --value |& wc -l )
  else
    RUNNINGWLMCOUNT=0
  fi
  unset LoginManagerDisplayFileProbe

  if [[ $seat0HasTTYs == 1 ]]
  then
    OLDSEAT0WLMPID=$(systemctl show wlm-loginmanagerdisplay_seat0.service -p MainPID --value 2>/dev/null)
    if [[ $RUNNINGWLMCOUNT != 0 ]]
    then
      if [[ $OLDSEAT0WLMPID != 0 ]]
      then
        LOGINMANAGERDISPLAYTTY=$(systemctl show wlm-loginmanagerdisplay_seat0.service -p TTYPath --value | sed 's|/dev/tty||g')
      else
        LOGINMANAGERDISPLAYTTY=$(GetNextTTY)
      fi
      systemd-notify --ready &> /dev/null
    else
      LOGINMANAGERDISPLAYTTY=$(GetNextTTY)
    fi

    MinimumTTY=$LOGINMANAGERDISPLAYTTY
    if [[ $LOGINMANAGERDISPLAYTTY -eq -1 ]]
    then
      WriteToLog "ERROR: Not Enough TTYs for login manager display!"
      exit 1
    fi
  else
    systemd-notify --ready &> /dev/null
  fi

  #Enable full alt+sysrq, and allow a debug login terminal window when wlmdebug is passed as a kernel argument. This is for testing general issues with the waylandloginmanager
  GetConfigKey wlmdebug "" 0 2 wlmdebug
  if [[ $wlmdebug != 0 ]]
  then
    echo 1 > /proc/sys/kernel/sysrq
    WriteToLog "WARNING: The diagnostic 'wlmdebug' option has been passed to the kernel. This causes the waylandloginmanager to enable all magic sysrq keys, including the ability to kill processes, and the waylandloginmanager will respond to the Debug command when sent to the main control FIFO, by spawning a graphical login terminal window on the loginmanagerdisplay"
    wlmdebug=1
  fi

  #Enable full alt+sysrq, and allow a debug root terminal window when wlmdebuginsecure is passed as a kernel argument, this is for testing commands that need to be run within the same context as the waylandloginmanager
  GetConfigKey wlmdebuginsecure "" 0 2 wlmdebuginsecure
  if [[ $wlmdebuginsecure != 0 ]]
  then
    echo 1 > /proc/sys/kernel/sysrq
    WriteToLog "WARNING: The diagnostic and insecure 'wlmdebuginsecure' option has been passed to the kernel. This causes the waylandloginmanager to enable all magic sysrq keys, including the ability to kill processes, and the waylandloginmanager will respond to the Debug command when sent to the main control FIFO, by spawning a graphical ROOT terminal window on the loginmanagerdisplay"
    wlmdebug=1
    wlmdebuginsecure=1
  fi

  HOSTNAME=$(hostname)
  read -r -d $'\r' MACHINE_ID 2>/dev/null </var/lib/dbus/machine-id
}


#This function sends the KDSETMODE ioctl (0x4B3A) with the parameter KD_TEXT (0x00) to the TTY number specified in the first argument, then it sends the VT_SETMODE ioctl (0x5602) with the parameter VT_AUTO (0x00) to the active TTY
#This forces the TTY to be in a state that allows the kernel to switch the TTY (switching to VT_AUTO), instead of a process (VT_PROCESS), when it's in VT_PROCESS, and the process is defunct, the TTY switch fails.
function ResetTTYMode
{
    python3 -c "from array import array; \
from fcntl import ioctl; \
buf = array('h', [0]); \
buf[0] = 0; \
fd = open('/dev/tty$1', 'wb'); \
ioctl(fd, 0x4B3A, 0); \
ioctl(fd, 0x05602, buf); \
fd.close()" &>/dev/null
}

#This function sends the KDSETMODE ioctl (0x4B3A) with the parameter KD_GRAPHICS (0x01) to the TTY number specified in the first argument, to prevent keyboard input from appearing from between the time the switch to the TTY, and before the display server starts.
function SetTTYModeGraphics
{
    python3 -c "from array import array; \
from fcntl import ioctl; \
buf = array('h', [0]); \
buf[0] = 0; \
fd = open('/dev/tty$1', 'wb'); \
ioctl(fd, 0x4B3A, 1); \
fd.close()" &>/dev/null
}

#This function is used by the WaylandLoginManager to find the next availible tty, starting from CalcTTY+1
#it prints the TTY number to stdio. takes no arguments. If it can't find an open tty, it returns -1
function GetNextTTY
{
  SYSTEMDTTYS=()
  #Only seat0 has TTYs
  SESSIONS=($(loginctl show-seat seat0 -p Sessions --value 2>/dev/null ))
  for SESSION in ${SESSIONS[@]}
  do
    SYSTEMDTTYS+=($(loginctl show-session $SESSION -p VTNr --value 2>/dev/null))
  done

  TTYNotInLogind=0
  TTYNotInUse=0
  CalcTTY=$MinimumTTY
  while [[ ($TTYNotInUse -ne 1 && $CalcTTY -lt 64) || $TTYNotInLogind -gt 0 ]]
  do
    #Returns 1 when NOT in use.
    fuser -s /dev/tty$CalcTTY &>/dev/null
    TTYNotInUse=$?
    TTYNotInLogind=0
    for SYSTEMDTTY in ${SYSTEMDTTYS[@]}
    do
      if [[ $SYSTEMDTTY == "$CalcTTY" ]]
      then
        ((TTYNotInLogind++))
      fi
    done
    if [[ $TTYNotInUse -ne 1 ]]
    then
      ((CalcTTY++))
    fi
  done

  if [[ $TTYNotInUse -ne 1 ]]
  then
    AvailibleTTY=-1
  else
    AvailibleTTY=$CalcTTY
  fi

  echo $AvailibleTTY
}

#Export session data so the waylandloginmanager has user switching data in case of a reload
function ExportSessionData
{
  EXPORTSTRING=$(declare -p AllSessions AllSessionTTYs AllSessionPIDs AllSessionUsers AllSessionIDs AllSeatIDs SeatCreationStrings 2>/dev/null)
  echo "${EXPORTSTRING//declare/declare -g}" > /run/waylandloginmanager/sessiondata
}

#This function sends a command to the waylandloginmanager's own loginmanager_control FIFO. It takes 2 arguments, the command to send to the command FIFO, and the relevant seat
function SendSelfCommand
{
  SENDCOMMAND=$1
  SENDSEATARG=$2
  while [[ -e /run/waylandloginmanager/fifolock ]]
  do
    $SLEEPCMD 1
  done
  echo -e "\n$SENDCOMMAND@$SENDSEATARG" > /run/waylandloginmanager/loginmanager_control
}

#This function sends registration data to the waylandloginmanager's own loginmanager_register FIFO. It takes 1 argument, the data string to send to the registration FIFO.
#it appends a return character to the string
function SendSelfRegisterData
{
  SENDDATA=$1
  while [[ -e /run/waylandloginmanager/fifolock ]]
  do
    $SLEEPCMD 1
  done
  echo -n $'\u1E'"$SENDDATA"$'\u1F'$'\u1E' > /run/waylandloginmanager/loginmanager_register &
  SendSelfCommand ReadRegister
}

#This function is called when the loginmanager_control FIFO recives the command "ReadRegister". This function will read the contents of loginmanager_register, which only root can write to.
#Before a process calls ReadRegister to loginmanager_control, the process must also start an attempt to send the data to loginmanager_register, because the timeout period is .01 seconds. If nothing is in loginmanager_register, as if it's not called correctly, or because it's an underprivlaged process that can't write to loginmanager_register, it is ignored.
#Fields are separated by new lines ( \n ), while a set of feilds is ended by returns ( \r )
#Feilds are as follows.
# NEWSESSION<newline>TTY_Number<newline>PID_of_Session_Process<newline>User_Name<newline>logind_Session_ID<newline>SEAT<newline>DoLock
#OR
# SETCONFIGKEY<newline>keyname<newline>valuename
function ReadRegister
{
  #get the data from loginmanager_register
  exec 1001<> /run/waylandloginmanager/loginmanager_register
  RegisterDataLines=()
  while read -d $'\u1E' -r -n 288 -t .01 RegisterLineData <&1001
  do
    RegisterDataLines+=("$RegisterLineData")
  done
  exec 1001>&-

  #$'\u1E' is record separator (each row) $'\u1F' is unit separator (each field) $'\u1D'
  for RegisterData in "${RegisterDataLines[@]}"
  do
    #get the register data, and put it into an array so it can be handled
    IFS=$'\u1F'
    ArraySessionData=($RegisterData)
    unset IFS
    RegisterType=${ArraySessionData[0]}
    if [[ ! -z $RegisterData ]]
    then
      WriteToLog "received register data: ${RegisterData//$'\u1F'/||}"
      if [[ $RegisterType == NEWSESSION ]]
      then
        #Add the session data to the arrays that store info about the sessions.
        SessionTTY=${ArraySessionData[1]}
        SessionPID=${ArraySessionData[2]}
        SessionUser=${ArraySessionData[3]}
        SessionID=${ArraySessionData[4]}
        SessionSeatID=${ArraySessionData[5]}
        SessionDoLock=${ArraySessionData[6]}
        if [[ $SessionTTY != -1 && $SessionPID != -1 && ! -z $SessionUser && $SessionID != -1 ]]
        then
          AllSessionTTYs+=("$SessionTTY")
          AllSessionPIDs+=("$SessionPID")
          AllSessionUsers+=("$SessionUser")
          AllSessionIDs+=("$SessionID")
          AllSeatIDs+=("$SessionSeatID")
          #increment the number of running sessions, now that one is added and running successfuly
          ((AllSessions++))
          #Export the Session data
          ExportSessionData
          if [[ $SessionDoLock == 1 ]]
          then
            (sleep 30; loginctl lock-session $SessionID 2> /dev/null) &
          fi
        else
          WriteToLog "Session failed to start"
          SessionStartFailed=1
          if [[ $SessionTTY != 0 ]]
          then
            FailedSessionTTY=$SessionTTY
          fi
          FailedSessionSeat+=("$SessionSeatID")
        fi
      elif [[ $RegisterType == SETCONFIGKEY ]]
      then
        SetValueName=${ArraySessionData[1]}
        SetValueData=${ArraySessionData[2]}
        SetConfigKey "$SetValueName" "$SetValueData"
      fi
    fi
  done
}

#This function takes three arguments. The first is the number of seconds to wait, and the second is the string to show in the dialog. it shows a Zenity dialog with a progress bar to count down the specified time, with the string. The third is the seat to display it on
function DialogWait
{
  GetStartedSeatIndex $3
  SeatFileName=${SeatFileNames[$ReturnSeatIndex]}
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$SeatFileName"
  SetFallbackEnvironmentVariables $3
  waitseconds=$1
  displaystring="$2"
  countseconds=0
  while [[ $countseconds -lt $waitseconds ]]
  do
    percent=$(( $countseconds * 100 / $waitseconds ))
    echo $percent
    ((countseconds++))
    $SLEEPCMD 1
  done | $ZENITYCMD --width=450 --title="Login Manager" --no-cancel --progress --auto-close --text="$displaystring" 2>/dev/null
}

#This function takes 1 argument, the seat that the loginmanagerdisplay belongs to, and waits for the loginmanagerdisplay to startup
function DisplayServerWait
{
  CurrentSeat=$1
  GetStartedSeatIndex $CurrentSeat
  SeatFileName=${SeatFileNames[$ReturnSeatIndex]}

  while [[ ! -e /run/user/$LOGINMANAGERDISPLAYUID/loginmanagerdisplay_"$SeatFileName" ]]
  do
    $SLEEPCMD 1
  done

  export WAYLAND_DISPLAY=loginmanagerdisplay_"$SeatFileName"
  command -v wayland-info &> /dev/null
  WaylandInfoCommandExists=$?
  if [[ $WaylandInfoCommandExists == 0 ]]
  then
    while [[ $($WAYLANDINFOCMD &>/dev/null; echo $?) != 0 ]]
    do
      $SLEEPCMD 1
    done
  else
    while [[ $(fuser -s /run/user/$LOGINMANAGERDISPLAYUID/loginmanagerdisplay_"$SeatFileName" &>/dev/null; echo $?) == 1 ]]
    do
      $SLEEPCMD 1
    done
  fi
}

#This takes 1 argument, the user home dir to search for wsession files under $HOME/.local/share/wsessions.d/*.desktop.
#this splits all the wsession file data into fixed arrays usable for session selection
function ParseWSessionFiles
{
  WSessionUserHome=$1
  unset DesktopFileDataArrays
  unset NeedsFileArrays
  unset SeatBackendArrays

  WSESSIONFILES=()
  for WSESSIONFILE in "$WSESSIONSPATH"/*.desktop
  do
    WSESSIONFILES+=($WSESSIONFILE)
  done

  #Find user custom wsession files
  if [[ -d "$WSessionUserHome"/.local/share/wsessions.d ]]
  then
    for WSESSIONFILE in "$WSessionUserHome"/.local/share/wsessions.d/*.desktop
    do
      WSESSIONFILES+=($WSESSIONFILE)
    done
  fi

  SeatBackendArrayElementOffset=4
  for WSESSIONFILE in "${WSESSIONFILES[@]}"
  do
    #read up to 16385 bytes from the config file, if it is 16385 bytes ignore it
    #The most accepted bytes is 16384, or 16KB, which is more than enough
    if [[ -f "$WSESSIONFILE" ]]
    then
      read -r -n 16385 -d $'\r' WSESSIONFILEDATA 2>/dev/null < "$WSESSIONFILE"
    else
      WriteToLog "$WSESSIONFILE is not a file"
      continue
    fi

    #If the file is too large
    if [[ ${#WSESSIONFILEDATA} -ge 16385 ]]
    then
      WriteToLog "$WSESSIONFILE is too large, and will be ignored"
      continue
    fi

    #Convert the file data to an array
    readarray -t WSESSIONFILEDATA <<< "$WSESSIONFILEDATA"

    #Build the initial array for the main keys
    DesktopFileDataArray=""
    for Iterator in {000..012}
    do
      if [[ ! -z $DesktopFileDataArray ]]
      then
        DesktopFileDataArray+=$'\n'
      fi
      DesktopFileDataArray+=${Iterator}"#"
    done
    readarray -t DesktopFileDataArray <<< "$DesktopFileDataArray"
    DesktopFileDataArray[12]="012#$WSESSIONFILE"

    #Build the initial array for the NeedsFile list
    NeedsFileArray=()
    NeedsFileArray+=("001#$WSESSIONFILE")

    #Build the initial array for the backend support table
    SeatBackendArray=""
    for BACKEND in KMS WKS WL FB
    do
      for Iterator in {000..003}
      do
        if [[ ! -z $SeatBackendArray ]]
        then
          SeatBackendArray+=$'\n'
        fi
        SeatBackendArray+="000#"${Iterator}"#"${BACKEND}"#"
      done
    done
    readarray -t SeatBackendArray <<< "$SeatBackendArray"

    #Handle all the valid lines in the file
    ParseINISegment=0
    for WSESSIONLINE in "${WSESSIONFILEDATA[@]}"
    do
      #Remove whitespace
      WSESSIONLINE="${WSESSIONLINE##*( )}"
      WSESSIONLINE="${WSESSIONLINE%%*( )}"

      #Remove comments
      WSESSIONLINE=${WSESSIONLINE%%#*}

      if [[ $ParseINISegment == 1 && $WSESSIONLINE =~ ^[[:space:]]*"["  ]]
      then
        ParseINISegment=0
      fi
      if [[ $WSESSIONLINE == "[Desktop Entry]" ]]
      then
        ParseINISegment=1
        continue
      fi
      if [[ $ParseINISegment == 0 ]]
      then
        continue
      fi

      WSESSIONLINELASTCHAR=${WSESSIONLINE:$((${#WSESSIONLINE} -1 )):1}
      IFS="="
      WSESSIONLINE=($WSESSIONLINE)
      unset IFS

      KeyName=""
      KeyValue=""
      ChangeArrayElement=""
      ChangeArrayOffset=""
      OffsetID=""
      ChangeArrayMultiplicand=""

      KeyName=${WSESSIONLINE[0]}
      KeyName="${KeyName##*( )}"
      KeyName="${KeyName%%*( )}"

      if [[ ${#WSESSIONLINE[@]} -gt 1 ]]
      then
        printf -v KeyValue "=%s" "${WSESSIONLINE[@]:1}"
        KeyValue=${KeyValue:1}
        KeyValue="${KeyValue##*( )}"
        KeyValue="${KeyValue%%*( )}"
        if [[ $WSESSIONLINELASTCHAR == "=" ]]
        then
          KeyValue+=$WSESSIONLINELASTCHAR
        fi
      fi

      #Set the NeedFile
      if [[ $KeyName == NeedsFile ]]
      then
        NeedsFileArray+=("000#$KeyValue")
        continue
      fi

      ChangeArrayElement=-1
      case $KeyName in
        Enabled)
          ChangeArrayElement=0;;
        Name)
          ChangeArrayElement=1;;
        Comment)
          ChangeArrayElement=2;;
        Type)
          ChangeArrayElement=3;;
        IsFallbackSession)
          ChangeArrayElement=4;;
        CompositorDisplayArgument)
          ChangeArrayElement=5;;
        CompositorSeatArgument)
          ChangeArrayElement=6;;
        SessionArgument)
          ChangeArrayElement=7;;
        AdditionalArguments)
          ChangeArrayElement=8;;
        CompositorExec)
          ChangeArrayElement=9;;
        EnvironmentFile)
          ChangeArrayElement=10;;
        DebugSession)
          ChangeArrayElement=11;;
      esac

      if [[ $ChangeArrayElement != -1 ]]
      then
        printf -v OffsetID "%03d" $ChangeArrayElement
        if [[ ${DesktopFileDataArray[$ChangeArrayElement]} == "$OffsetID#" ]]
        then
          DesktopFileDataArray[$ChangeArrayElement]="$OffsetID#$KeyValue"
        fi
        continue
      fi

      #If the line is for a backend, determine what element to set on the backend array
      #Each backend has a number elements each, and are always in order KMS, WKS, WL, FB
      #The number of elements are fixed place for if it's supports the backend, arguments for the backend, if the backend supports seats, ect.
      if [[ $KeyName =~ [a-Z]*KMS[a-Z]* || $KeyName =~ [a-Z]*WKS[a-Z]* || $KeyName =~ [a-Z]*WL[a-Z]* || $KeyName =~ [a-Z]*FB[a-Z]* ]]
      then
        for BACKEND in KMS WKS WL FB
        do
          ChangeArrayOffset=-1
          if [[ $BACKEND == KMS ]]
          then
            ChangeArrayMultiplicand=0
          elif [[ $BACKEND == WKS ]]
          then
            ChangeArrayMultiplicand=1
          elif [[ $BACKEND == WL ]]
          then
            ChangeArrayMultiplicand=2
          elif [[ $BACKEND == FB ]]
          then
            ChangeArrayMultiplicand=3
          fi

          if [[ $KeyName =~ CompositorSupports${BACKEND} ]]
          then
            ChangeArrayOffset=0
          fi
          if [[ $KeyName =~ Compositor${BACKEND}Arguments ]]
          then
            ChangeArrayOffset=1
          fi
          if [[ $KeyName =~ Compositor${BACKEND}SeatAware ]]
          then
            ChangeArrayOffset=2
          fi
          if [[ $KeyName =~ Compositor${BACKEND}SeatArgument ]]
          then
            ChangeArrayOffset=3
          fi

          if [[ $ChangeArrayOffset != -1 ]]
          then
            printf -v OffsetID "%03d" $ChangeArrayOffset
            ChangeArrayElement=$(( (SeatBackendArrayElementOffset * ChangeArrayMultiplicand) + ChangeArrayOffset ))
            if [[ ${SeatBackendArray[$ChangeArrayElement]} == "000#$OffsetID#${BACKEND}#" ]]
            then
              SeatBackendArray[$ChangeArrayElement]="000#$OffsetID#${BACKEND}#$KeyValue"
            fi
          fi
        done
      fi
    done

    FirstElement=0
    for Element in "${DesktopFileDataArray[@]}"
    do
      if [[ $FirstElement != 0 ]]
      then
        DesktopFileDataArrays+=$'\n'
      fi
      DesktopFileDataArrays+=$Element
      FirstElement=1
    done
    DesktopFileDataArrays+=$'\r'
    unset DesktopFileDataArray

    FirstElement=0
    for Element in "${NeedsFileArray[@]}"
    do
      if [[ $FirstElement != 0 ]]
      then
        NeedsFileArrays+=$'\n'
      fi
      NeedsFileArrays+=$Element
      FirstElement=1
    done
    NeedsFileArrays+=$'\r'
    unset DesktopFileDataArray

    FirstElement=0
    for Element in "${SeatBackendArray[@]}"
    do
      if [[ $FirstElement != 0 ]]
      then
        SeatBackendArrays+=$'\n'
      fi
      SeatBackendArrays+=$Element
      FirstElement=1
    done
    SeatBackendArrays+=$'\r'
    unset DesktopFileDataArray

    unset WSESSIONFILEDATA
  done

  IFS=$'\r'
  DesktopFileDataArrays=($DesktopFileDataArrays)
  NeedsFileArrays=($NeedsFileArrays)
  SeatBackendArrays=($SeatBackendArrays)
  unset IFS
}


#This is called by GetUserCredentials and by StartAutoLogin. This allows the user select the session they want to use, similar to how X login managers prompt for the session before the login.
#it exports the WSESSIONDATA variable, which contains arguments and varaibles and the command to run to start a session
#It takes 4 arguments, the seat to show the dialogs on, the  user name (for reading configs for default sessions), the user home path, and if this is an autologin
function ChooseSessionType
{
  CurrentHandleSeat="$1"
  SessionUser="$2"
  SessionUserHome="$3"
  IsAutologin="$4"
  GetStartedSeatIndex $CurrentHandleSeat
  SeatFileName=${SeatFileNames[$ReturnSeatIndex]}
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$SeatFileName"
  SetFallbackEnvironmentVariables $CurrentHandleSeat
  #The number of Session IDs start from 0. when a session is added, the number of running sessions is 1 for the next session. The second session gets the ID of 1 etc...
  export SESSIONID=${AllSessions}000
  export WAYLAND_HOST=wlhost-$SESSIONID-$SeatFileName
  export WAYLAND_GUEST=wayland-$SESSIONID-$SeatFileName

  unset WSESSIONLIST
  FirstRunNotRan=0

  #Check the hardware in this seat, to see what backends will be supported
  SeatDefaultBackendType=""
  SeatSupportedBackends=()
  SeatSupportedBackendsString=""
  LoginctlSeatStatusString=$(loginctl seat-status "$CurrentHandleSeat" 2>/dev/null)
  GetConfigKey wlmforcefbdev "$CurrentHandleSeat" 0 1 wlmforcefbdev
  if [[ $wlmforcefbdev == 0 ]]
  then
    if [[ "$LoginctlSeatStatusString" =~ /drm/card[0-9]*[[:space:]] ]]
    then
      SeatSupportsKMS=1
    else
      SeatSupportsKMS=0
    fi
  else
    SeatSupportsKMS=0
  fi
  unset wlmforcefbdev
  GetConfigKey wlmnofbdev "$CurrentHandleSeat" 0 1 wlmnofbdev
  if [[ $wlmnofbdev == 0 ]]
  then
    if [[ "$LoginctlSeatStatusString" =~ /graphics/fb[0-9]*[[:space:]] ]]
    then
      SeatSupportsFB=1
    else
      SeatSupportsFB=0
    fi
  else
    SeatSupportsFB=0
  fi
  unset wlmnofbdev

  #Detect if /dev/fb0 is in this seat
  if [[ "$LoginctlSeatStatusString" =~ /graphics/fb0[[:space:]] ]]
  then
    FB0INSEAT=1
  else
    FB0INSEAT=0
  fi
  unset LoginctlSeatStatusString

  #If the kernel mode setting is disabled system wide globally, or just for this seat, do not include kernel mode setting
  #for this seat
  if [[ $SeatSupportsKMS != 0 ]]
  then
    SeatSupportedBackends+=(KMS)
    SeatSupportedBackendsString+="KMS "
    SeatDefaultBackendType=KMS
  fi
  #If Weston doesn't support a framebuffer backend, other desktop environments still might.
  #If there is no kernel mode setting support on a seat, and it supports framebuffers, and Weston is missing framebuffer support
  #Weston can't be used to run nested sessions
  if [[ $SeatSupportsKMS != 0 || ($SeatSupportsFB != 0 && $WestonSupportsFBDev == 1) ]]
  then
    SeatSupportedBackends+=(WKS)
    SeatSupportedBackendsString+="WKS "
    SeatSupportedBackends+=(WL)
    SeatSupportedBackendsString+="WL "
  else
    if [[ $FB0INSEAT != 0 && $WestonSupportsFBDev == 1 ]]
    then
      SeatSupportedBackends+=(WKS)
      SeatSupportedBackendsString+="WKS "
      SeatSupportedBackends+=(WL)
      SeatSupportedBackendsString+="WL "
    fi
  fi
  if [[ $SeatSupportsFB != 0 && $WestonSupportsFBDev == 1 ]]
  then
    SeatSupportedBackends+=(FB)
    SeatSupportedBackendsString+="FB "
    if [[ -z $SeatDefaultBackendType ]]
    then
      SeatDefaultBackendType=FB
    fi
  fi

  ParseWSessionFiles $SessionUserHome

  #Get the number of files in the array
  DesktopFileCount=${#DesktopFileDataArrays[@]}

  #Use the arrays created from parsing the wsession files, to determine if each is supported, and to construct the list that will be shown in the dialog
  for (( wsessionnum=0 ; wsessionnum < $DesktopFileCount ; wsessionnum++ ))
  do
    #The array with a fixed layout for the values, for this wsession.
    readarray -t DesktopFileDataArray <<< "${DesktopFileDataArrays[$wsessionnum]}"

    #The array of arrays (each line has three fields seperated by #, which is then treated as an array) describing the backends supported by the session
    readarray -t SeatBackendArray <<< "${SeatBackendArrays[$wsessionnum]}"

    #The array of all NeedsFile lines specified
    readarray -t NeedsFileArray <<< "${NeedsFileArrays[$wsessionnum]}"

    Enabled=${DesktopFileDataArray[0]:4}
    SessionName=${DesktopFileDataArray[1]:4}
    SessionComment=${DesktopFileDataArray[2]:4}
    Type=${DesktopFileDataArray[3]:4}

    if [[ -z $Type ]]
    then
      Type="WSession"
    fi

    #Search for backends supported by the compositor, with the backends the hardware supports. Give presence to the first one found in the array of supported backend types, the best backend types are first in the array
    #Get the hardware support status
    SupportsBackend=0
    for SEATBACKEND in "${SeatSupportedBackends[@]}"
    do
      export BackendType=$SEATBACKEND
      SupportsSeat=0
      unset BackendSeatArgument
      unset BackendArguments
      for (( element1 = 0 ; element1 < ${#SeatBackendArray[@]} ; element1=element1+4 ))
      do
        IFS="#"
        #Stores the values from the config file if this session supports a paticular backend in general
        BackendSupportedArray=(${SeatBackendArray[$element1]})
        #Stores the values from the config file on the arguments used to start the session with a paticular backend
        BackendArgumentArray=(${SeatBackendArray[$element1+1]})
        #Stores the values from the config file if each backend is seat aware
        BackendCanSeatArray=(${SeatBackendArray[$element1+2]})
        #Stores the arguments declared in the config file to specify the seat for each availible backend
        BackendSeatArgArray=(${SeatBackendArray[$element1+3]})
        unset IFS
        if [[ ${BackendSupportedArray[2]} == $BackendType ]]
        then
          #If this is seat0, then don't enforce seatawareness, if the first framebuffer device is in seat0
          if [[ $CurrentHandleSeat == seat0 && $BackendType == "FB" ]]
          then
            if [[ $FB0INSEAT == 1 ]]
            then
              SupportsSeat=1
            fi
          #If this is seat0, then this session is implied to be supported on this seat (since ones that don't only run on seat0).
          elif [[ $CurrentHandleSeat == seat0 && $BackendType != "FB" ]]
          then
            SupportsSeat=1
          #If the a wayland backend, (fullscreen shell or standard) is supported by this session, and the wayland backend is supported on this seat, then seats are supported, since the weston hosts are seat aware
          elif [[ $BackendType == "WKS" || $BackendType == "WL" ]]
          then
            SupportsSeat=1
          fi
          #If none of these seat support overrides declare that this session can run on this seat, get it's config value if it can run on the seat
          if [[ $SupportsSeat == 0 ]]
          then
            SupportsSeat=${BackendCanSeatArray[3]}
          fi
          SupportsBackend=${BackendSupportedArray[3]}
          if [[ $BackendType ==  "KMS" && $SupportsBackend != 0 && $SupportsSeat != 0 ]]
          then
            SupportsBackend=1
            SupportsSeat=1
          fi
          if [[ $SupportsBackend == 1 && $SupportsSeat == 1 ]]
          then
            BackendArguments=${BackendArgumentArray[3]}
            BackendSeatArgument=${BackendSeatArgArray[3]}
            break
          fi
        fi
      done
      if [[ $SupportsBackend == 1 && $SupportsSeat == 1 ]]
      then
        break
      fi
    done


    IsFallbackSession=${DesktopFileDataArray[4]:4}
    if [[ -z $IsFallbackSession ]]
    then
      IsFallbackSession=0
    fi
    CompositorDisplayArgument=${DesktopFileDataArray[5]:4}
    CompositorSeatArgument=${DesktopFileDataArray[6]:4}
    #The backend argument might be different. If one is set for this backend, override.
    if [[ ! -z $BackendSeatArgument ]]
    then
      CompositorSeatArgument=$BackendSeatArgument
    fi
    SessionArgument=${DesktopFileDataArray[7]:4}
    AdditionalArguments=${DesktopFileDataArray[8]:4}
    CompositorExec=${DesktopFileDataArray[9]:4}
    EnvironmentFile=${DesktopFileDataArray[10]:4}
    DebugSession=${DesktopFileDataArray[11]:4}
    WSessionFilePath=${DesktopFileDataArray[12]:4}

    if [[ -z $SessionName ]]
    then
      SessionName=$CompositorExec
    fi

    if [[ ! ($WSessionFilePath =~ ^$WSESSIONSPATH) ]]
    then
      SessionComment="[User Created Session] $SessionComment"
    fi

    if [[ ! -x $WSessionFilePath ]]
    then
      WriteToLog "Warning: $WSessionFilePath is not executable, the session will not be availible for selection by the user."
      IsExecutable=0
    else
      IsExecutable=1
    fi

    if [[ $IsExecutable != 0 ]]
    then
      if [[ ! -x $CompositorExec ]]
      then
        WriteToLog "Warning: CompositorExec \"$CompositorExec\" specified in $WSessionFilePath is not executable, the session will not be availible for selection by the user."
        IsExecutable=0
      else
        IsExecutable=1
      fi
    fi

    if [[ -z "$EnvironmentFile" ]]
    then
      EnvironmentFile=$WSessionFilePath
    fi

    #Iterate through all NeedsFile values, to make sure that they exist. if one doesn't exist increment NotFoundCount.
    NotFoundCount=0
    for NeedsFile in "${NeedsFileArray[@]}"
    do
      NeedsFile=${NeedsFile:4}
      if [[ ! -e $NeedsFile && -n $NeedsFile ]]
      then
        WriteToLog "Warning: Cannot find needed file $NeedsFile for $WSessionFilePath , the session will not be availible for selection by the user."
        ((NotFoundCount++))
      fi
    done

    if [[ $Enabled == 0 ]]
    then
      WriteToLog "Warning: $WSessionFilePath is disabled, the session will not be availible for selection by the user."
    fi

    if [[ $SupportsBackend != 1 ]]
    then
      WriteToLog "Warning: $WSessionFilePath can't run on any backends supported by seat, $CurrentHandleSeat which only handles: $SeatSupportedBackendsString , the session will not be availible for selection by the user."
    fi

    if [[ $SupportsBackend == 1 && $SupportsSeat != 1 ]]
    then
      WriteToLog "Warning: $WSessionFilePath backends $BackendType does not support seats for $CurrentHandleSeat , the session will not be availible for selection by the user."
    fi

    if [[ $Type != "WSession" ]]
    then
      WriteToLog "Warning: $WSessionFilePath does not have a Type of 'WSession' , the session will not be availible for selection by the user."
    fi

    #if the session supports the CompositorDisplayArgument, for setting the WAYLAND_DISPLAY it should use, then ammend the WAYLAND_GUEST to the end of the command.
    if [[ ! -z $CompositorDisplayArgument ]]
    then
      CompositorDisplayArgument="$CompositorDisplayArgument$WAYLAND_GUEST"
    else 
      CompositorDisplayArgument=""
    fi

    #if the session supports the CompositorSeatArgument, for setting the XDG_SEAT it should use, then ammend the CurrentHandleSeat to the end of the command.
    if [[ ! -z $CompositorSeatArgument && ($BackendType != "WKS" || $BackendType != "WL") ]]
    then
      CompositorSeatArgument="$CompositorSeatArgument$CurrentHandleSeat"
    else
      CompositorSeatArgument=""
    fi

    if [[ $wlmdebug != 0 ]]
    then
      ExcludeDebugSession=0
    else
      if [[ $DebugSession == 1 ]]
      then
        ExcludeDebugSession=1
      else
        ExcludeDebugSession=0
      fi
    fi

    #If the session is enabled, the backend is supported, all the files it needs are there, and its a wsession file, and is executable add the lines describing the session to the string.
    #This is sent through stdio which is added to teh WSESSIONLIST variable
    if [[ $NotFoundCount == 0 && $SupportsBackend == 1 && $SupportsSeat == 1 && $Enabled != 0 && $Type == "WSession" && $IsExecutable != 0 && $ExcludeDebugSession != 1 ]]
    then
      if [[ $FirstRunNotRan == 0 ]]
      then
        FirstRunNotRan=1
      else
        WSESSIONLIST+=$'\n'
      fi
      WSESSIONLIST+="$CompositorExec"$'\n'
      WSESSIONLIST+="$BackendArguments"$'\n'
      WSESSIONLIST+="$SessionArgument"$'\n'
      WSESSIONLIST+="$CompositorDisplayArgument"$'\n'
      WSESSIONLIST+="$CompositorSeatArgument"$'\n'
      WSESSIONLIST+="$AdditionalArguments"$'\n'
      WSESSIONLIST+="$EnvironmentFile"$'\n'
      WSESSIONLIST+=""$BackendType"_"$SeatDefaultBackendType"_"$IsFallbackSession"_"$'\n'
      WSESSIONLIST+="$SessionName"$'\n'
      WSESSIONLIST+="$SessionComment"
    fi
  done


  #If wsessions where found above then show a ui dialog. If there where none, use a default session.
  if [[ ! -z $WSESSIONLIST ]]
  then
    WSESSIONARRAY=()
    WSESSIONARRAYELEMENT=0
    while read -r LINE
    do
      WSESSIONARRAY[$WSESSIONARRAYELEMENT]="$LINE"
      ((WSESSIONARRAYELEMENT++))
    done <<< "$WSESSIONLIST"
    WSESSIONCOUNT=$((${#WSESSIONARRAY[@]}/10))

    GetConfigKey defaultwsessionautoselect "" 0 0 AUTOWSESSIONSELECT
    if [[ $AUTOWSESSIONSELECT == 1 ]]
    then
      WSESSIONKEY=":"
    else
      WSESSIONKEY="::"
    fi
    GetConfigKey defaultwsession "-$SessionUser" "$WSESSIONKEY" 0 GETDEFAULTWSESSION
    GetConfigKey defaultwsession-${CurrentHandleSeat} "$SessionUser" "$GETDEFAULTWSESSION" 0 GETDEFAULTWSESSION
    if [[ $IsAutologin == 1 ]]
    then
      SessionSelectionTitleHint="Autologin: Select the session for $SessionUser..."
      DEFAULTWSESSION="$GETDEFAULTWSESSION"
    else
      SessionSelectionTitleHint="Select the session for $SessionUser..."
      DEFAULTWSESSION=":"
    fi
    WSESSIONNUMBER=-1
    if [[ $DEFAULTWSESSION != ":" && $DEFAULTWSESSION != "::" ]]
    then
      for (( element=0; element<$WSESSIONCOUNT; element++ ))
      do
        if [[ "$DEFAULTWSESSION" == "${WSESSIONARRAY[$((8+element*10))]}" ]]
        then
          WSESSIONNUMBER=$element
          break
        fi
      done
      if [[ $WSESSIONNUMBER == -1 ]]
      then
        $ZENITYCMD --width=500 --error --title "Session Selection" --text="$DEFAULTWSESSION set as default session for $SessionUser, but was not found, configured correctly, or supported by the hardware in this seat." 2>/dev/null
        WriteToLog "$DEFAULTWSESSION set as default session for $SessionUser, but was not found in $WSESSIONSPATH, configured correctly, or supported by the hardware in this seat, $CurrentHandleSeat ."
        return 1
      fi
    fi

    if [[ $DEFAULTWSESSION == ":" || $DEFAULTWSESSION == "::" ]]
    then
      WSESSIONPICKLIST=""
      for (( element=0; element<$WSESSIONCOUNT; element++ ))
      do
        if [[ ! -z $WSESSIONPICKLIST ]]
        then
          WSESSIONPICKLIST+=$'\n'
        fi
        WSESSIONPICKLIST+=$element$"#"${WSESSIONARRAY[$((8+element*10))]}"#"${WSESSIONARRAY[$((9+element*10))]}
      done
      WSESSIONPICKLIST=$(echo "$WSESSIONPICKLIST" | sort -t "#" -k 2,2 | sed 's/#/\n/g')
      #select the session. Each line is handled as a column. currently there are 9 collumns. So line 1 is is column 1, line 2 is in collumn 2, and line 10 is in collumn 1 again
      #The zenity dialog then outputs the selected session's lines into the WSESSIONDATA variable. each collumn is a different aspect of the wsessions
      WSESSIONNUMBER=$(echo "$WSESSIONPICKLIST" | $ZENITYCMD --title="$SessionSelectionTitleHint" --height=450 --width=630 --list --text "Select a Wayland Desktop Environment to use" --column sessionnumber --column Name --column Comment --hide-column=1 --print-column=1 2>/dev/null )
      #Abort if the user selected cancel on the zenity dialog
      CancelOrOK=$?
      if [[ $CancelOrOK != 0 ]]
      then
        return 1
      fi
    fi
    WSESSIONDATA=${WSESSIONARRAY[$((0+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((1+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((2+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((3+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((4+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((5+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((6+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((7+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((8+WSESSIONNUMBER*10))]}$'\n'
    if [[ $GETDEFAULTWSESSION != "::" ]]
    then
      SendSelfRegisterData "SETCONFIGKEY"$'\u1F'"defaultwsession-${CurrentHandleSeat}-${SessionUser}"$'\u1F'"${WSESSIONARRAY[$((8+WSESSIONNUMBER*10))]}"
    fi

  else
    unset WSESSIONDATA
    unset WSESSIONNUMBER
    $ZENITYCMD --width=500 --error --title "Session Selection" --text="No sessions are installed, configured correctly, or supported by the hardware in this seat." 2>/dev/null
    WriteToLog "No sessions are installed in $WSESSIONSPATH, configured correctly, or supported by the hardware in this seat, $CurrentHandleSeat ."
    return 1
  fi
}


#This function displays a diagnostic terminal. It starts the terminal as root, with a root terminal. (only when wlmdebuginsecure is passed as a boot option)
#It takes 1 argument, the seat to display the terminal on
function DiagnosticTerminal 
{
  CurrentSeat=$1
  GetStartedSeatIndex $CurrentSeat
  SeatFileName=${SeatFileNames[$ReturnSeatIndex]}
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$SeatFileName"
  SetFallbackEnvironmentVariables $CurrentSeat
  if [[ $wlmdebuginsecure == 1 ]]
  then
    vte -N &>/dev/null
  fi
}

#This function is called when the loginmanager_control recives the Info command. It brings up a help dialog for the user, about the waylandloginmanager and the system.
#It takes 1 argument, the seat to display the dialog on
function ShowInfo
{
  CurrentSeat=$1
  GetStartedSeatIndex $CurrentSeat
  SeatIndexID=$ReturnSeatIndex
  SeatFileName=${SeatFileNames[$SeatIndexID]}
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$SeatFileName"
  SetFallbackEnvironmentVariables $CurrentSeat
  if [[ $CurrentSeat == seat0 && $seat0HasTTYs == 1 ]]
  then
    SEATSTRING="This Login Manager Display for seat seat0 is running on tty: $LOGINMANAGERDISPLAYTTY"
  else
    SEATSTRING="This Login Manager Display is for seat $CurrentSeat"
  fi
  SeatDefaultBackendType=${LoginManagerDisplayBackends[$SeatIndexID]}
  #If the backend type is FB, then add a string to tell the user that in the help dialog
  if [[ $SeatDefaultBackendType == "FB" ]]
  then
    BACKENDSTRING="The framebuffer backend is being used for this seat.

This probably means the current video card drivers do not 
support the native kernel mode setting that is optimal for Weston or other Wayland servers.
or the system was started with the wlmforcefbdev argument."
  else
    BACKENDSTRING="Kernel mode setting is being used for this seat.

This is the optimal way to run Weston or other Wayland servers."
  fi
  $ZENITYCMD --title="Information" --no-wrap --info --text="This is a third party fan made distribution!

$BACKENDSTRING

$SEATSTRING

The key icon brings up a login prompt
The arrow icon brings up a prompt to switch between running sessions
The red X icon brings up a shutdown prompt
The i icon shows this help prompt" &> /dev/null

}

#This function is called when the loginmanager_control FIFO recives the command "Switch". It brings up a dialog containing the list of all running login sessions, to allow the user to pick and switch to start a mew session, by containing the FIFO.
#It takes 1 argument, the seat to display the dialog on, and only the sessions belonging to the seat will be shown
function SwitchUserDialog 
{
  CurrentSeat=$1
  GetStartedSeatIndex $CurrentSeat
  SeatFileName=${SeatFileNames[$ReturnSeatIndex]}
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$SeatFileName"
  SetFallbackEnvironmentVariables $CurrentSeat
  unset SessionList
  #get the number of registered sessions
  NumberOfSessions=${#AllSessionPIDs[@]}
  ((NumberOfSessions--))

  #go thorugh each session, reading the arrays containing information about the sessions. to build the SessionList variable
  #The session list variable is multiline, and used by a zenity dialog.
  #line 1 is the session number
  #line 2 is the TTY for the session
  #line 3 is the PID of the session
  #line 4 is the user name
  #line 5 is the logind session id.
  RunningSeatSessions=($(loginctl show-seat "$CurrentSeat" -p Sessions --value 2>/dev/null))
  while [[ $NumberOfSessions -ge 0 ]]
  do
    #determine if the current session is alive, before adding it to the list
    SessionisRunning=0
    for RunningSeatSession in "${RunningSeatSessions[@]}"
    do
      if [[ $RunningSeatSession == ${AllSessionIDs[$NumberOfSessions]} ]]
      then
        SessionisRunning=1
        break
      fi
    done

    if [[ $SessionisRunning == 1 ]]
    then
      if [[ ${AllSeatIDs[$NumberOfSessions]} == "$CurrentSeat" ]]
      then
        if [[ ! -z $SessionList ]]
        then
          SessionList+=$'\n'
        fi
        SessionList+="$NumberOfSessions"$'\n'
        SessionList+="${AllSessionIDs[$NumberOfSessions]}"$'\n'
        SessionList+="${AllSessionPIDs[$NumberOfSessions]}"$'\n'
        SessionList+="${AllSessionUsers[$NumberOfSessions]}"$'\n'
        SessionList+="tty${AllSessionTTYs[$NumberOfSessions]}"
      fi
    fi
    ((NumberOfSessions--))
  done
  #Add a element with a sessionid of -1. When the selected element is -1, it prompts for a user login for a new session, with GetUserCredentials
  if [[ ! -z $SessionList ]]
  then
    SessionList+=$'\n'
  fi
  SessionList+="-1"$'\n'
  SessionList+=$'\n'
  SessionList+=$'\n'
  SessionList+="New Session..."$'\n'
  SessionList+=$'\n'




  unset ChangeSession
  #prompt for the list of running sessions, and return the session ID. (which is used in all of the arrays for Session PID, user name, etc)
  ChangeSession=$(echo "$SessionList"  | sed '$d'| $ZENITYCMD --title="Switch User" --height=450 --list --text "Select a running session to change into" --hide-header --column sessionid --column tty --column pid --column username --column ID --print-column=1 --hide-column=1,3,5 --separator="\n" 2>/dev/null )
  CancelOrOK=$?
  #Abort if the user selected cancel on the zenity dialog
  if [[ $CancelOrOK != 0 ]]
  then
    exit 0
  fi
  #if the chosen session is -1 then contact the FIFO with a login prompt, otherwise switch to the selected session
  if [[ $ChangeSession == "-1" ]]
  then
    SendSelfCommand Login "$CurrentSeat"
  else 
    #if a session is selected, then get the PID, TTY, logind session ID with the selected Session ID as the array element number.
    if [[ $ChangeSession ]]
    then
      ChangeSessionPID=${AllSessionPIDs[$ChangeSession]}
      ChangeSessionTTY=${AllSessionTTYs[$ChangeSession]}
      ChangeSessionID=${AllSessionIDs[$ChangeSession]}

      #before switching into a session double check in case if the session crashed after it was listed ealier in the function.
      ChangeSessionState=$(loginctl show-session "$ChangeSessionID" -p State --value 2>/dev/null)
      if [[ $ChangeSessionState == active || $ChangeSessionState == online ]]
      then
        #Only seat0 supports TTYs
        if [[ "$CurrentSeat" == "seat0" && $seat0HasTTYs == 1  ]]
        then
          chvt $ChangeSessionTTY &>/dev/null &
        fi
        #hand over the logind session ID to allow desktop permissions to work.
        loginctl activate $ChangeSessionID &>/dev/null
      else
        $ZENITYCMD --title="Switch User" --warning --text="The selected session was not found. The session may have quit." 2>/dev/null
      fi
    fi
  fi
}

#Function that starts the user sessions, which is called by AuthenticateUser, if the authentication is successful. It takes 5 arguments, TTY number, the seat, user to start the session for, to lock the screen upon session start, and the multiline string, WSESSIONDATA, which contains specific data about how to start paticular sessions
function StartUserSession 
{ 
  #ensure the loginmanager_control fd doesn't get leaked
  exec 1000>&-


  #unset most varaibles, except PATH and WAYLAND_HOST and WAYLAND_GUEST
  while read -r var
  do 
    unset "$var" &> /dev/null
  done < <(env | awk -F = '{print $1}' | grep -aEv "^WAYLAND_HOST$|^WAYLAND_GUEST$|^PATH$|^SESSIONID$" )

  #save the arguments passed to StartUserSession, and put the third argument into an array
  WSESSIONSTRING="$( echo -n "$5" | perl -pe 's/\$(\w+)/$ENV{$1}/g')"
  WSESSIONDATA=()
  WSESSIONARGUMENTELEMENT=0
  while read -r LINE
  do
    WSESSIONDATA[$WSESSIONARGUMENTELEMENT]="$LINE"
    ((WSESSIONARGUMENTELEMENT++))
  done <<< "$WSESSIONSTRING"
  USERSESSIONTTY=$1
  USERSEAT=$2
  LOGINUSER=$3
  STARTLOCKED=$4
  GetStartedSeatIndex $USERSEAT
  SeatFileName=${SeatFileNames[$ReturnSeatIndex]}

  #Change to the users homepath so weston starts in the right place, and set some varaibles for the user
  export HOME=$(eval echo ~$LOGINUSER)
  export LOGNAME=$LOGINUSER
  export USER=$LOGINUSER
  export USERNAME=$LOGINUSER
  cd "$HOME"

  #The array makes it easy to get the data out of WSESSIONDATA. any variables in the strings are expanded with perl
  #line 1 is the path to the compositor
  #line 2 is the argument to start with a paticular backend
  #line 3 is the argument with paticular session information
  #line 4 is the argument to start the Wayland server with a specific WAYLAND_DISPLAY
  #line 5 is the argument to start the Wayland server on a paticular XDG_SEAT
  #line 6 is any additional arguments needed
  #line 7 specifies the environment file which is processed by the user session, which is documented at the top of the script.
  #line 8 specifies the backend data, which tells the user session what backend is being used, the default one, and if the session file is calling the session with fallback capabilies. This variable is broken up, and exported as BackendType, DefaultBackendType, and IsFallbackSession
  #line 9 specifies the session name for the user and for helpdialog to know what session is running. this is exported as a varaible.
  CompositorExec="${WSESSIONDATA[0]}"
  BackendArguments="${WSESSIONDATA[1]}"
  SessionArgument="${WSESSIONDATA[2]}"
  CompositorDisplayArgument="${WSESSIONDATA[3]}"
  CompositorSeatArgument="${WSESSIONDATA[4]}"
  AdditionalArguments="${WSESSIONDATA[5]}"
  export EnvironmentFile="${WSESSIONDATA[6]}"
  BackendData="${WSESSIONDATA[7]}"
  export SessionName="${WSESSIONDATA[8]}"
  IFS=_
  BackendData=($BackendData)
  unset IFS
  export BackendType=${BackendData[0]}
  export DefaultBackendType=${BackendData[1]}
  export IsFallbackSession=${BackendData[2]}


  #Call the server with the arguments specified by the selected session
  if [[ "$USERSEAT" == seat0 && $seat0HasTTYs == 1  ]]
  then
    TTYSTRING=" on tty $USERSESSIONTTY"
  else
    TTYSTRING=""
  fi

  systemctl stop "$LOGINUSER-wayland-$SESSIONID-$SeatFileName" &> /dev/null
  systemctl reset-failed "$LOGINUSER-wayland-$SESSIONID-$SeatFileName" &> /dev/null
  #Only seat0 supports TTYs
  if [[ "$USERSEAT" == seat0 && $seat0HasTTYs == 1 ]]
  then
    #Reset the contents of the tty
    echo -n -e '\e[3J' > /dev/tty$USERSESSIONTTY
    #Disable cursor blinking on the TTY the display server will be started on
    echo -n -e '\e[?25l' > /dev/tty$USERSESSIONTTY
    chvt $USERSESSIONTTY &>/dev/null &
    SetTTYModeGraphics $USERSESSIONTTY
    OutputArgs="-p TTYPath=/dev/tty"$USERSESSIONTTY" -p StandardOutput=null -p StandardError=null -p StandardInput=tty"
  else
    OutputArgs=""
  fi

  WriteToLog "Starting server \"$CompositorExec\" with the arguments of \"$BackendArguments\" \"$SessionArgument\" \"$CompositorSeatArgument\" \"$AdditionalArguments\" \"$CompositorDisplayArgument\" for user $LOGINUSER $TTYSTRING on seat $USERSEAT"
  systemd-run --unit="$LOGINUSER-wayland-$SESSIONID-$SeatFileName" -p CollectMode=inactive-or-failed -p PrivateTmp=yes -p BindPaths=/tmp/.X11-unix/ -p PAMName=waylandloginmanager -p User="$LOGINUSER" $OutputArgs -p WorkingDirectory=\~ -p UtmpMode=user -p UtmpIdentifier="$SESSIONID-$SeatFileName" --setenv=SessionName="$SessionName" --setenv=BackendType="$BackendType" --setenv=DefaultBackendType="$DefaultBackendType" --setenv=IsFallbackSession="$IsFallbackSession" --setenv=EnvironmentFile="$EnvironmentFile" --setenv=WAYLAND_GUEST=$WAYLAND_GUEST --setenv=XDG_SEAT="$USERSEAT" --setenv=WLM_SEAT=$SeatFileName --setenv=WAYLAND_HOST="$WAYLAND_HOST" $0 --usersession $CompositorExec $BackendArguments  $SessionArgument $CompositorSeatArgument $AdditionalArguments $CompositorDisplayArgument &>/dev/null

  $SLEEPCMD 5
  #Get the PID that was called, by seing which process is the 'leader pid' of the $USERSESSIONTTY tty that the server was started. This is needed to know what TTY to switch to.
  USERSESSIONPID=$(systemctl show "$LOGINUSER-wayland-$SESSIONID-$SeatFileName" -p ExecMainPID --value 2>/dev/null)
  #Find the logind session id, by trying to find out what session is lead by the $USERSESSIONPID. This is needed to know what logind session needs to be switched to to enable desktop permissions
  SESSIONS=($(loginctl show-seat "$USERSEAT" -p Sessions --value 2>/dev/null ))
  for SESSION in "${SESSIONS[@]}"
  do
    SessionPid=$(loginctl show-session $SESSION -p Leader --value 2>/dev/null)
    if [[ $SessionPid == $USERSESSIONPID ]]
    then
      LOGINDSESSION=$SESSION
      break
    fi
  done < <(echo "$SESSIONS")

  USERREGISTERDISPLAYNAME=$(getent passwd $LOGINUSER | awk -F : '{print $5}' | awk -F , '{print $1}')
  if [[ -z $USERREGISTERDISPLAYNAME ]]
  then
    USERREGISTERDISPLAYNAME=$LOGINUSER
  else
    USERREGISTERDISPLAYNAME="$USERREGISTERDISPLAYNAME   ($LOGINUSER)"
  fi

  #The logind session activation is needed to enable the desktop permissions for the user. (such as udisks, and shutting down the system, and NetworkManager)
  loginctl activate $LOGINDSESSION &>/dev/null

  if [[ -z $USERSESSIONTTY ]]
  then
    USERSESSIONTTY=-1
  fi
  if [[ -z $USERSESSIONPID ]]
  then
    USERSESSIONPID=-1
  fi
  if [[ -z $USERREGISTERDISPLAYNAME ]]
  then
    USERREGISTERDISPLAYNAME=" "
  fi
  if [[ -z $LOGINDSESSION ]]
  then
    LOGINDSESSION=-1
  fi
  if [[ -z $USERSEAT ]]
  then
    USERSEAT=-1
  fi
  if [[ -z $STARTLOCKED ]]
  then
    STARTLOCKED=-1
  fi

  #Send the tty number, pid, user name, and logind session ID to loginmanager_register in the background, then tell loginmanager_control to read loginmanager_register.
  SendSelfRegisterData "NEWSESSION"$'\u1F'"$USERSESSIONTTY"$'\u1F'"$USERSESSIONPID"$'\u1F'"$USERREGISTERDISPLAYNAME"$'\u1F'"$LOGINDSESSION"$'\u1F'"$USERSEAT"$'\u1F'"$STARTLOCKED"

}

#Test users credentials, by making sure the user name and password match by trying to test with su and expect.
#Expect has to be run as a non root user, otherwise it always reports success. Run it as the user specified with $PROBETESTUSER
#it returns failure or success
#This is called by GetUserCredentials, after it collects the user name and password for the user. It reads the password from stdin
function AuthenticateUser
{
  unset USERPASSWORD
  TryPassword=$(cat -)
  TryPasswordEscaped=$(for ((Iterate=0; Iterate<${#TryPassword}; Iterate++))
  {
    printf "\\\u%x" "'${TryPassword:$Iterate:1}"
  })
  TryPassword=$TryPasswordEscaped
  unset TryPasswordEscaped

  #usernames should start with - anyway. If a username starts with - , don't attempt to use it
  if [[ ${LOGINUSER:0:1} == '-' ]]
  then
    return 1
  fi
  #Test the users login with an embedded expect script running as PROBETESTUSER
  echo "log_user 0
        spawn su \"$LOGINUSER\" -c /bin/true
        expect Password 
        send $TryPassword\r
        catch wait result
        exit [lindex \$result 3]" |runuser -u $PROBETESTUSER -m -- expect 2>/dev/null
  PasswordResult=$?
  unset TryPassword
  if [[ 0 == $PasswordResult ]]
  then
    return 0
  else
    #report failure
    return 1
  fi
}


#Get the users username and password by allowing the user to select the username in a list, or enter it manually, and then enter thier password
#This function is called when the loginmanager_control FIFO recives the command "Login"
#It takes 1 argument, the seat to display the login prompt on
function GetUserCredentials
{
  CurrentSeat=$1
  GetStartedSeatIndex $CurrentSeat
  SeatFileName=${SeatFileNames[$ReturnSeatIndex]}
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$SeatFileName"
  SetFallbackEnvironmentVariables $CurrentSeat
  #Get the list of nonsystem users, in each line, there is 1 user, with two feilds, the users 'friendly' name, and then the users system login name, seperated by a :
  #this finds the range of UIDs that are user UIDs, and then finds any users with theses UIDS.
  UIDMIN=$(grep -ae "^UID_MIN" /etc/login.defs| awk '{print $2}')
  if [[ $LiveCDMode == 1 ]]
  then
    UIDMIN=999
  fi
  UIDMAX=$(grep -ae "^UID_MAX" /etc/login.defs| awk '{print $2}')
  USERLIST=$(awk -v UIDMIN=$UIDMIN -v UIDMAX=$UIDMAX -F : '{ if ($3>=UIDMIN && $3 <=UIDMAX) print $5":"$1}' /etc/passwd)
  #sort the list
  USERLIST=$(echo "$USERLIST" | sort |uniq)
  #go through each line of users found, to handle the display of the real name (passwd gecos feild)
  while read -r USER
  do
    IFS=":"
    #handle the line as an array, with two elements
    UserData=($USER)
    #The passwd gecos feild is formated with username,buildingnumber,phonenumber,otherdata. only get the username subfeild.
    UserDisplayName=$(echo ${UserData[0]} | awk -F , '{print $1}')
    UserName=${UserData[1]}
    #If the user has no display name, then set it to be the users login name
    if [[ -z $UserDisplayName ]]
    then
      UserDisplayName=$UserName
    fi
    #The display in the zenity dialog should be "Firstname Lastname    (loginname)"
    UserDisplayName="$UserDisplayName   (${UserData[1]})" 
    unset IFS
    #add the data to the USERLISTSTRING that gets sent into zenity. Line 1 is the display name, line 2 is the user login name, and then line 3 is the display name of the next user...
    USERLISTSTRING+="$UserDisplayName"
    USERLISTSTRING+=$'\n'
    USERLISTSTRING+="$UserName"
    USERLISTSTRING+=$'\n'
  done < <(echo "$USERLIST")
  #Append a default value with the display string to enter the username with -1. When selected, this tells the script to bring up a dialog to allow the user to enter a manual name
  USERLISTSTRING+="Enter User Name..."
  USERLISTSTRING+=$'\n'
  USERLISTSTRING+="-1"


  #present the list of the users to the system
  LOGINUSER=$(echo "$USERLISTSTRING" | $ZENITYCMD --title="Username" --height=450 --list --text "Select a user from the list to log into."  --column users --column usernames --hide-column 2 --print-column 2 --hide-header --separator="\n" 2>/dev/null )
  CancelOrOK=$?
  export LOGINUSER
  #Abort if the user selected cancel on the zenity dialog
  if [[ $CancelOrOK != 0 ]]
  then
    exit 0
  fi
  #if there is no user selected or if the LOGINUSER is -1, as in the user opted to enter a username manually prompt for the username with a text dialog
  if [[ -z $LOGINUSER || $LOGINUSER == -1 ]]
  then
    LOGINUSER=$($ZENITYCMD --title="Username" --entry --text="Enter the User Name:" 2>/dev/null)
    CancelOrOK=$?
    #Abort if the user selected cancel on the zenity dialog
    if [[ $CancelOrOK != 0 ]]
    then
      exit 0
    fi
  fi
  #get the TTY to start the session on, only for seat0
  if [[ "$CurrentSeat" == "seat0"  && $seat0HasTTYs == 1 ]]
  then
    export SessionTTY=$(GetNextTTY)
  else
    SessionTTY=0
  fi
  if [[ $SessionTTY -ne -1 ]]
  then
    #By default the WaylandLoginManager only gives the autologin user one shot.
    #This option (also set in LiveCD mode), makes it so that user set to be the autologin-user never gets prompted for a password
    #This is NOT default when installed.
    GetConfigKey wlmneverpasswd-autologinuser "$CurrentSeat" "0" 0 AutoLoginUserNoPassword

    if [[ $LiveCDMode == 1 ]]
    then
      AutoLoginUserNoPassword=1
    fi

    GetConfigKey autologin-user "$CurrentSeat" ":" 0 SEATAUTOLOGINUSER
    if [[ $LOGINUSER == $SEATAUTOLOGINUSER && $AutoLoginUserNoPassword == 1 ]]
    then
      passwordresult=0
    else
      #Prompt for the users password
      USERPASSWORD=$( $ZENITYCMD --title="Login for $LOGINUSER" --password 2>/dev/null )
      CancelOrOK=$?
      #Abort if the user selected cancel on the zenity dialog
      if [[ $CancelOrOK != 0 ]]
      then
        exit 0
      fi

      #send the password to an AuthenticateUser function with stdin
      echo $USERPASSWORD | AuthenticateUser "$CurrentSeat"
      #get the result from AuthenticateUser in the pipe, (and not the echo command)
      passwordresult=${PIPESTATUS[1]}
      unset USERPASSWORD
    fi
    if [[ $passwordresult != 0 ]]
    then
      $ZENITYCMD --warning --text="Invalid password for $LOGINUSER, or username invalid" 2>/dev/null
      WriteToLog "Invalid password for $LOGINUSER, or username invalid"
    else
      export USERHOME=$(eval echo ~$LOGINUSER)
      #Prompt for the session type
      ChooseSessionType "$CurrentSeat" "$LOGINUSER" "$USERHOME" 0
      if [[ $? != 0 ]]
      then
        return 0
      fi

      #if the password and username is correct, start the session
      if [[ $CurrentSeat == seat0 && $seat0HasTTYs == 1 ]]
      then
        TTYSTRING="on TTY $SessionTTY"
      else
        TTYSTRING=""
      fi
      WriteToLog "Opening a session for $LOGINUSER $TTYSTRING on seat $CurrentSeat"
      DialogWait 3 "Attempting to start the selected session..." "$CurrentSeat" &
      DoSessionLock=0
      StartUserSession "$SessionTTY" "$CurrentSeat" "$LOGINUSER" $DoSessionLock "$WSESSIONDATA" &
    fi
  else
    $ZENITYCMD --warning --text="Not Enough TTYs!" 2>/dev/null
    WriteToLog "Not Enough TTYs for user login!"
  fi
}


#This function is called when the loginmanager_control FIFO recives the command "Leave". It brings up a zenity dialog for handling power options for the computer.
#It takes 1 optional argument, the seat to display the dialogs on
function LeavePrompt
{
  CurrentSeat=$1
  #If the prompt is on the loginmanagerdisplay, all sessions need to be warned about. If called from a user session, only warn if there is one or more in addition. 
  if [[ ! -z $CurrentSeat ]]
  then
    GetStartedSeatIndex $CurrentSeat
    SeatFileName=${SeatFileNames[$ReturnSeatIndex]}
    export WAYLAND_DISPLAY=loginmanagerdisplay_"$SeatFileName"
    SetFallbackEnvironmentVariables $CurrentSeat
    SessionPromptThreshold=1
  else
    SetCommonConfig
    ZENITYCMD=zenity
    SessionPromptThreshold=2

    ACTIONSTRING="Switch User"$'\n'"Switch User"$'\n'"Logoff"$'\n'"Logoff Session"
  fi

  #Get the number of running sessions
  RunningSessions=($(loginctl list-sessions --no-legend 2>/dev/null| awk '{print $1}'))
  RunningSessionTypes=($(loginctl show-session -p Class ${RunningSessions[@]} --value 2>/dev/null))
  RunningSessionItr=0
  RunningSessionCount=0
  for RunningSession in "${RunningSessions[@]}"
  do
    Include=1
    RunningSessionType=${RunningSessionTypes[$RunningSessionItr]}
    if [[ $RunningSessionType == "greeter"  || $RunningSessionType == "lock-screen" ]]
    then
      Include=0
    fi
    if [[ $Include == 1 ]]
    then
      ((RunningSessionCount++))
    fi
    ((RunningSessionItr++))
  done
  unset RunningSessions
  unset RunningSessionTypes

  #The first line is sent to the zenity dialog is the actual command it sets the ACTION variable to be. the second line is what it appears as in the Zenity dialog for the user.
  CanPowerOff=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanPowerOff)
  if [[ $CanPowerOff =~ " \"yes\"" ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Shutdown"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Shutdown Computer"
  fi
  CanReboot=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanReboot)
  if [[ $CanReboot =~ " \"yes\"" ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Restart"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Restart Computer"
  fi
  CanSuspend=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanSuspend)
  if [[ $CanSuspend =~ " \"yes\"" ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Standby"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Standby Computer"
  fi
  CanHybridSleep=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanHybridSleep)
  if [[ $CanHybridSleep =~ " \"yes\"" ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Hybrid Sleep"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Hybrid Sleep Computer"
  fi
  CanHibernate=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanHibernate)
  if [[ $CanHibernate =~ " \"yes\"" ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Hibernate"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Hibernate Computer"
  fi
  ACTION=$(echo "$ACTIONSTRING" | $ZENITYCMD --title="Leave..." --height=450 --list  --hide-header --text="What do you want to do?" --separator="\n" --column 'action' --column 'useraction' --hide-column 1 --print-column=1  2>/dev/null )
  CancelOrOK=$?
  #Abort if the user selected cancel on the zenity dialog
  if [[ $CancelOrOK != 0 ]]
  then
    exit 0
  fi

  if [[ $ACTION != "Logoff" && $ACTION != "Switch User" && $RunningSessionCount -ge $SessionPromptThreshold ]]
  then
    SESSIONINFO="Number of running sessions: $RunningSessionCount"
  else
    SESSIONINFO=""
  fi

  #Prompt the user if they are sure they want to execute the selected action
  $ZENITYCMD --width=450 --title="Leave..." --question --text="Are you sure you want to ${ACTION}? $SESSIONINFO" 2>/dev/null
  CONFIRM=$?
  if [[ $CONFIRM != 0 ]]
  then
    exit 1
  fi

  #For switch user, send the Switch command to the waylandloginmanager
  if [[ $ACTION == "Switch User" ]]
  then
    waylandloginmanager --sendcommand Switch
    RESULT=$?
  #If the request is logoff, tell the waylandloginmanager to switch to its TTY, and terminate the current server.
  elif [[ $ACTION == "Logoff" ]]
  then
    waylandloginmanager --sendcommand Change
    loginctl terminate-session $XDG_SESSION_ID
    RESULT=$?
  #For all other actions, use logind dbus commands
  elif [[ $ACTION == "Shutdown" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.PowerOff boolean:true
    RESULT=$?
  elif [[ $ACTION == "Restart" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Reboot boolean:true
    RESULT=$?
  elif [[ $ACTION == "Standby" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Suspend boolean:true
    RESULT=$?
  elif [[ $ACTION == "Hybrid Sleep" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.HybridSleep boolean:true
    RESULT=$?
  elif [[ $ACTION == "Hibernate" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Hibernate boolean:true
    RESULT=$?
  else
    exit
  fi
  #if the selected action failed, tell the user
  if [[ $RESULT != 0 ]]
  then
    $ZENITYCMD --title="Failure" --warning --text="Failed to $ACTION" 2>/dev/null
  fi
}

#This function gets the desired backend information for the specified seat for what backend should be used for the loginmanagerdisplay
#It takes 2 arguments, the seat, and second is the variable to set the string to
function GetSeatCapabilityString
{
  CurrentSeat=$1
  #Detect hardware abilities, of the seat
  LoginctlSeatStatusString=$(loginctl seat-status "$CurrentSeat" 2>/dev/null)
  GetConfigKey wlmforcefbdev "$CurrentSeat" 0 1 wlmforcefbdev
  if [[ $wlmforcefbdev == 0  ]]
  then
    if [[ "$LoginctlSeatStatusString" =~ /drm/card[0-9]*[[:space:]] ]]
    then
      SeatSupportsKMS=1
    else
      SeatSupportsKMS=0
    fi
  else
    SeatSupportsKMS=0
  fi
  unset wlmforcefbdev
  GetConfigKey wlmnofbdev "$CurrentSeat" 0 1 wlmnofbdev
  if [[ $wlmnofbdev == 0  ]]
  then
    if [[ "$LoginctlSeatStatusString" =~ /graphics/fb[0-9]*[[:space:]] && $WestonSupportsFBDev == 1 ]]
    then
      SeatSupportsFB=1
    else
      SeatSupportsFB=0
    fi
    #Detect if /dev/fb0 is in this seat
    if [[ "$LoginctlSeatStatusString" =~ /graphics/fb0[[:space:]] ]]
    then
      FB0INSEAT=1
    else
      FB0INSEAT=0
    fi
  else
    SeatSupportsFB=0
    FB0INSEAT=0
  fi
  unset wlmnofbdev
  unset LoginctlSeatStatusString

  #if the user booted with wlmforceswrender, or configured software rendering globally, or for the seat
  #force software rendering to be enabled
  GetConfigKey wlmforceswrender "$CurrentSeat" 0 1 wlmforceswrender
  if [[ $wlmforceswrender != 0  ]]
  then
    FORCESOFTWARE=1
  else
    FORCESOFTWARE=0
  fi
  unset wlmforceswrender

  #Determine the backend to use
  WESTONBACKEND=0
  WESTONUSEPIXMAN=0
  if [[ $SeatSupportsFB != 0 ]]
  then
    WESTONBACKEND=FB
  else
    if [[ $FB0INSEAT != 0 && $WestonSupportsFBDev == 1 ]]
    then
      SeatSupportsFB=1
      WESTONBACKEND=FB
    fi
  fi
  #If the kernel mode setting is disabled system wide globally, or just for this seat, do not include kernel mode setting
  #for this seat
  if [[ $SeatSupportsKMS != 0 ]]
  then
    WESTONBACKEND=KMS
  fi

  #if the user booted with wlmforcepixman, or configured to use pixman globally, or for the seat
  #force pixman to be enabled
  GetConfigKey wlmforcepixman "$CurrentSeat" 0 1 wlmforcepixman
  if [[ $WESTONBACKEND == KMS && $wlmforcepixman != 0  ]]
  then
    WESTONUSEPIXMAN=1
  else
    WESTONUSEPIXMAN=0
  fi
  unset wlmforcepixman

  if [[ $SeatSupportsKMS == 0 && $SeatSupportsFB == 0 ]]
  then
    WriteToLog "No usable display hardware found on seat $CurrentSeat ."
  fi
  if [[ $SeatSupportsKMS != 0 && $WESTONBACKEND == KMS ]]
  then
    WriteToLog "Kernel mode setting found for seat $CurrentSeat ."
  fi
  if [[ $SeatSupportsFB != 0 ]]
  then
    WriteToLog "Framebuffer found for seat $CurrentSeat ."
  fi


  #Return the seat compatibility info
  if [[ ! -z $2 ]]
  then
    printf -v "$2" '%s' "$WESTONBACKEND $WESTONUSEPIXMAN $FORCESOFTWARE"
  else
    echo "$WESTONBACKEND $WESTONUSEPIXMAN $FORCESOFTWARE"
  fi
}

#This calls the loginmanagerdisplay_(seat) weston sessions. It takes 2 arguments, the seat, and the seat index ID
function StartLoginManagerDisplay
{
  #Information about the seat
  CurrentSeat=$1
  SeatIndexID=$2
  SeatStartCount=${LoginManagerDisplayAttemptCounts[$SeatIndexID]}
  SeatWestonBackend=${LoginManagerDisplayBackends[$SeatIndexID]}
  SeatUsePixman=${LoginManagerDisplayPixmanFlags[$SeatIndexID]}
  SeatFileName=${SeatFileNames[$SeatIndexID]}
  DoStartLoginManagerDisplay=1
  LOGINMANAGERDISPLAYSTATUS=0

  #Detect if the socket for the loginmanagerdisplay exists, and if the service is running
  if [[ -e /proc/${LoginManagerDisplayPIDs[$SeatIndexID]}/stat ]]
  then
    read -r -a PidStats < /proc/${LoginManagerDisplayPIDs[$SeatIndexID]}/stat
    PidStartTime=${PidStats[21]}
  else
    PidStartTime=0
  fi

  if [[ $PidStartTime == ${LoginManagerDisplayStartTimes[$SeatIndexID]} && -e /proc/${LoginManagerDisplayPIDs[$SeatIndexID]} && ! -z ${LoginManagerDisplayPIDs[$SeatIndexID]} ]]
  then
    DoStartLoginManagerDisplay=0
    return
  fi

  #Handle the seat hardware information
  if [[ $SeatWestonBackend == KMS ]]
  then
    WESTONBACKENDSTRING="drm-backend.so"
  elif [[ $SeatWestonBackend == FB ]]
  then
    WESTONBACKENDSTRING="fbdev-backend.so"
  elif [[ $SeatWestonBackend == "" || $SeatWestonBackend == 0 ]]
  then
    DoStartLoginManagerDisplay=0
    SeatStartCount=-1
    LOGINMANAGERDISPLAYSTATUS=1
  fi

  if [[ $DoStartLoginManagerDisplay == 1 ]]
  then
    (( SeatStartCount-- ))
  fi
  if [[ $LOGINMANAGERDISPLAYSTATUS == 0 && $SeatStartCount -ge 0 && $DoStartLoginManagerDisplay == 1 ]]
  then
    if [[ $SeatUsePixman == 1 ]]
    then
      PIXMANARGS="--use-pixman"
    else
      unset PIXMANARGS
    fi

    if [[ "$CurrentSeat" == seat0  && $seat0HasTTYs == 1 ]]
    then
      WriteToLog "Starting the loginmanagerdisplay on tty $LOGINMANAGERDISPLAYTTY for seat $CurrentSeat (Attempts left: $SeatStartCount)"
      #Reset the contents of the tty
      echo -n -e '\e[3J' > /dev/tty$LOGINMANAGERDISPLAYTTY
      #Disable cursor blinking on the TTY the display server will be started on
      echo -n -e '\e[?25l' > /dev/tty$LOGINMANAGERDISPLAYTTY
      ResetTTYMode $LOGINMANAGERDISPLAYTTY
      SetTTYModeGraphics $LOGINMANAGERDISPLAYTTY
    else
      WriteToLog "Starting the loginmanagerdisplay for seat $CurrentSeat (Attempts left: $SeatStartCount)"
    fi
    if [[ -x "$DEFAULTWAYLANDSERVER" ]]
    then
      systemctl stop wlm-loginmanagerdisplay_$SeatFileName &> /dev/null
      systemctl reset-failed wlm-loginmanagerdisplay_$SeatFileName &> /dev/null
      if [[ $CurrentSeat == seat0  && $seat0HasTTYs == 1 ]]
      then
        chvt $LOGINMANAGERDISPLAYTTY &>/dev/null &
        OutputArgs="-p TTYPath=/dev/tty"$LOGINMANAGERDISPLAYTTY" -p StandardOutput=null -p StandardError=null -p StandardInput=tty"
      else
        OutputArgs=""
      fi
      SetFallbackEnvironmentVariables $CurrentSeat
      LOGINMANAGERDISPLAYENVSTRING=""
      if [[ ! -z $LIBGL_ALWAYS_SOFTWARE ]]
      then
        LOGINMANAGERDISPLAYENVSTRING+=" --setenv=LIBGL_ALWAYS_SOFTWARE=$LIBGL_ALWAYS_SOFTWARE "
      fi
      if [[ ! -z $GBM_ALWAYS_SOFTWARE ]]
      then
        LOGINMANAGERDISPLAYENVSTRING+=" --setenv=GBM_ALWAYS_SOFTWARE=$GBM_ALWAYS_SOFTWARE "
      fi
      systemd-run --unit=wlm-loginmanagerdisplay_$SeatFileName -p CollectMode=inactive-or-failed -p PrivateTmp=yes -p BindPaths=/tmp/.X11-unix/ -p PAMName=waylandloginmanager-loginmanagerdisplay -p User="$LOGINMANAGERDISPLAYUSER" $OutputArgs -p WorkingDirectory=\~ $LOGINMANAGERDISPLAYENVSTRING --setenv=LD_LIBRARY_PATH="$LD_LIBRARY_PATH" --setenv=PATH="$PATH" --setenv=XDG_CONFIG_HOME="$XDG_CONFIG_HOME" --setenv=XDG_SEAT=$CurrentSeat --setenv=HOME="$HOME" $DEFAULTWAYLANDSERVER --backend=$WESTONBACKENDSTRING $PIXMANARGS --socket=loginmanagerdisplay_$SeatFileName --log=/var/log/waylandloginmanager/loginmanagerdisplays/loginmanagerdisplay_$SeatFileName.log --config="$XDG_CONFIG_HOME/loginmanagerdisplay.ini" &>/dev/null

      LOGINMANAGERDISPLAYREADY=1
      TRYCOUNT=0
      while [[ $LOGINMANAGERDISPLAYREADY != 0 && $TRYCOUNT -le 5 ]]
      do
        LOGINMANAGERDISPLAYREADY=$(systemctl is-active wlm-loginmanagerdisplay_$SeatFileName.service &> /dev/null; echo $?)
        $SLEEPCMD 1
        ((TRYCOUNT++))
      done
      #Get the logind session of the weston instance running loginmanagerdisplay, and have it register to the main 'thread'
      NewLoginManagerDisplayInfo=$(GetLoginManagerDisplayInfo $CurrentSeat)
      IFS=@
      NewLoginManagerDisplayInfo=($NewLoginManagerDisplayInfo)
      unset IFS

      NewLoginManagerDisplayPID=${NewLoginManagerDisplayInfo[0]}
      NewLoginManagerDisplaySession=${NewLoginManagerDisplayInfo[1]}
      NewLoginManagerDisplayPIDStartTime=${NewLoginManagerDisplayInfo[2]}

      LoginManagerDisplayPIDs[$SeatIndexID]=$NewLoginManagerDisplayPID
      LoginManagerDisplaySessions[$SeatIndexID]=$NewLoginManagerDisplaySession
      LoginManagerDisplayStartTimes[$SeatIndexID]=$NewLoginManagerDisplayPIDStartTime

      if [[ ! -z $NewLoginManagerDisplaySession ]]
      then
        loginctl activate $NewLoginManagerDisplaySession &>/dev/null
        if [[ $ReadyNotifySent == 0 ]]
        then
          ReadyNotifySent=1
          TRYCOUNT=0
          while [[ ! -e /run/user/$LOGINMANAGERDISPLAYUID/loginmanagerdisplay_$SeatFileName && $TRYCOUNT -le 5 ]]
          do
            $SLEEPCMD 1
            ((TRYCOUNT++))
          done
          systemd-notify --ready &> /dev/null
          plymouth --wait &> /dev/null
        fi
      else
        #If the first loginmanagerdisplay fails to start on the first attempt
        #That should not happen, declare the service start as complete, and don't worry about the seamless startup
        if [[ $ReadyNotifySent == 0 ]]
        then
          ReadyNotifySent=1
          systemd-notify --ready &> /dev/null
        fi
      fi
    else
      WriteToLog "The DEFAULTWAYLANDSERVER, $DEFAULTWAYLANDSERVER is not executable, or does not exist. Could not start the loginmanagerdisplay for $CurrentSeat."
      echo "The DEFAULTWAYLANDSERVER, $DEFAULTWAYLANDSERVER is not executable, or does not exist." >> /var/log/waylandloginmanager/loginmanagerdisplays/loginmanagerdisplay_$SeatFileName.log
    fi
  fi
  if [[ $SeatStartCount == -1 && $LOGINMANAGERDISPLAYSTATUS != 1 ]]
  then
    WriteToLog "Maximum attempts to start the loginmanagerdisplay for $CurrentSeat has been reached"
  fi
  LoginManagerDisplayAttemptCounts[$SeatIndexID]=$SeatStartCount
}

#This function determines the PID, and the systemd session of the loginmanagerdisplay, it takes 1 argument, the seat.
function GetLoginManagerDisplayInfo
{
  LoginManagerDisplaySeat=$1
  GetStartedSeatIndex "$LoginManagerDisplaySeat"
  SeatFileName=${SeatFileNames[$ReturnSeatIndex]}

  #Get the pid of loginmanagerdisplay
  unset REGISTERDISPLAYSESSION
  LOGINMANAGERDISPLAYPID=$(systemctl show wlm-loginmanagerdisplay_"$SeatFileName".service -p MainPID --value 2>/dev/null)
  if [[ -z $LOGINMANAGERDISPLAYPID ]]
  then
    LOGINMANAGERDISPLAYPID=0
  fi

  IFS=" "
  #Get all logind sessions
  WLMLOGINDSESSIONS=($(loginctl show-seat "$LoginManagerDisplaySeat" -p Sessions --value 2>/dev/null ))
  unset IFS
  #Go thorugh each logind session, see the one where the main pid matches the pid of the loginmanagerdisplay
  for WLMLOGINDSESSION in "${WLMLOGINDSESSIONS[@]}"
  do
    WLMLOGINDSESSIONPID=$(loginctl show-session "$WLMLOGINDSESSION" -p Leader --value 2>/dev/null )
    if [[ $LOGINMANAGERDISPLAYPID == $WLMLOGINDSESSIONPID ]]
    then
      REGISTERDISPLAYSESSION=$WLMLOGINDSESSION
      break
    fi
  done

  if [[ -e /proc/$LOGINMANAGERDISPLAYPID/stat ]]
  then
    read -r -a PidStats < /proc/$LOGINMANAGERDISPLAYPID/stat
    LOGINMANAGERDISPLAYPIDSTARTTIME=${PidStats[21]}
  else
    LOGINMANAGERDISPLAYPIDSTARTTIME=0
  fi
  echo "$LOGINMANAGERDISPLAYPID@$REGISTERDISPLAYSESSION@$LOGINMANAGERDISPLAYPIDSTARTTIME"
}

#This function sets fallback environment variables such as LIBGL_ALWAYS_SOFTWARE if it is specified for the seat
#It takes 1 argument, the seat
function SetFallbackEnvironmentVariables
{
  GetStartedSeatIndex $1
  SeatIndexIDFallback=$ReturnSeatIndex
  SetFallbackSoftware=${SeatForceSWRenderFlags[$SeatIndexIDFallback]}
  if [[ $SetFallbackSoftware == 1 ]]
  then
    export LIBGL_ALWAYS_SOFTWARE=1
    export GBM_ALWAYS_SOFTWARE=1
  else
    unset LIBGL_ALWAYS_SOFTWARE
    unset GBM_ALWAYS_SOFTWARE
  fi

}

#This fuction starts an autologin session, and takes 2 arguments, the first is the seat to start the autologin session on, the second is the autologin user
function StartAutoLogin
{
  CurrentSeat=$1
  AUTOLOGINUSER=$2
  echo "$CurrentSeat" >> /run/waylandloginmanager/autologinran
  #Wait until the loginmanagerdisplay becomes availible
  DisplayServerWait "$CurrentSeat"
  AUTOLOGINUSERHOME=$(eval echo ~$AUTOLOGINUSER)
  ChooseSessionType "$CurrentSeat" "$AUTOLOGINUSER" "$AUTOLOGINUSERHOME" 1
  #Abort if the user selected cancel on the zenity dialog
  CancelOrOK=$?
  if [[ $CancelOrOK != 0 ]]
  then
    exit 0
  fi
  #get the TTY to start the autologin session on, only for seat0
  if [[ "$CurrentSeat" == seat0 && $seat0HasTTYs == 1 ]]
  then
    export AutoSessionTTY=$(GetNextTTY)
   else
    export AutoSessionTTY=0
  fi
  DialogWait 3 "Attempting to start the selected session..." "$1" &
  #if there is a tty for the autologin session, the autologin is configured, start the autologin session
  if [[ $AutoSessionTTY -ne -1 ]]
  then
    if [[ "$CurrentSeat" == seat0 && $seat0HasTTYs == 1 ]]
    then
      WriteToLog "Starting Autologin session for $AUTOLOGINUSER on TTY $AutoSessionTTY on seat $CurrentSeat"
    else
      WriteToLog "Starting Autologin session for $AUTOLOGINUSER on seat $CurrentSeat"
    fi

    GetConfigKey wlmneverpasswd-autologinuser "$CurrentSeat" "0" 0 AutoLoginUserNoPassword
    if [[ $LiveCDMode == 1 ]]
    then
      AutoLoginUserNoPassword=1
    fi
    if [[ $AutoLoginUserNoPassword == 1 ]]
    then
      DoSessionLock=0
    else
      DoSessionLock=1
    fi

    StartUserSession "$AutoSessionTTY" "$CurrentSeat" "$AUTOLOGINUSER" $DoSessionLock "$WSESSIONDATA" &
  else
    $ZENITYCMD --warning --text="Not Enough TTYs for autologin!" 2>/dev/null
    WriteToLog "Not Enough TTYs for autologin!"
  fi
}

#This function is part of the startup for the waylandloginmanager. it creates the FIFO files, giving ONLY write access to loginmanager_control for ALL users, and only write access to loginmanager_register is given to root. Any other permissions, including read is denied.
function SetupIPCFiles
{
  #Create communication fifo.
  rm -r /run/waylandloginmanager/loginmanager_control &> /dev/null
  rm -r /run/waylandloginmanager/loginmanager_listener &> /dev/null
  rm -r /run/waylandloginmanager/loginmanager_register &> /dev/null
  mkfifo -m 622 /run/waylandloginmanager/loginmanager_control
  mkfifo -m 200 /run/waylandloginmanager/loginmanager_listener
  mkfifo -m 200 /run/waylandloginmanager/loginmanager_register
  chown $FIFOREADERUSER /run/waylandloginmanager/loginmanager_control
  chown $FIFOREADERUSER /run/waylandloginmanager/loginmanager_listener
  #open the main FIFO that recives commands.
  exec 1000<> /run/waylandloginmanager/loginmanager_listener

  touch /run/waylandloginmanager/autologinran
  chmod 700 /run/waylandloginmanager/autologinran
  rm /run/waylandloginmanager/fifolock 2>/dev/null
}

#This function displays a dialog containing actions for the Wayland Login Manager for the user, Shutdown, Switch User, login, and show a help dialog. It's optional, for in the case Weston isn't configured
#It takes 1 argument, the seat.
function UserActionDialog
{
  CurrentSeat=$1
  GetStartedSeatIndex $CurrentSeat
  SeatFileName=${SeatFileNames[$ReturnSeatIndex]}
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$SeatFileName"
  SetFallbackEnvironmentVariables $CurrentSeat
  #wait for the loginmanagerdisplay
  DisplayServerWait "$CurrentSeat"
  ActionMenu="Login\nLogin...\n"
  ActionMenu+="Switch\nSwitch User...\n"
  ActionMenu+="Leave\nShutdown...\nInfo\nHelp..."
  if [[ $wlmdebuginsecure == 1 ]]
  then
    ActionMenu+="\nDebug\nRoot Terminal..."
  fi
  USERACTION=$(echo -e "$ActionMenu"|$ZENITYCMD  --title="Login Manager" --height=300 --hide-column 1 --separator="\n" --list --column action --column display --hide-header --text "Select an Action"  2>> /var/log/waylandloginmanager/loginmanagerdisplays/loginmanagerdisplay_"$SeatFileName".log; exit ${PIPESTATUS[1]})
ZENITYSTATUS=$?
  #If the useraction exists (the user did not click cancel), then send the command to the loginmanager_control
  if [[ ! -z $USERACTION ]]
  then
    SendSelfCommand $USERACTION "$CurrentSeat"
  else
    $SLEEPCMD .1
  fi
  #if zenity segfaults, then something is wrong. wait longer
  if [[ $ZENITYSTATUS == 139 ]]
  then
    $SLEEPCMD 5
  fi
  exit $ZENITYSTATUS
}

#Function to get the index number of the specified seat of the array "StartedSeats" for the specified seat. It takes 1 argument, the seat
#This is so per-seat information can be stored in arrays using the same index to refer to the data per-seat
function GetStartedSeatIndex
{
  CurrentSeat=$1
  ReturnSeatIndex="-1"
  StartedSeatCount=${#StartedSeats[@]}
  #Go through the StartedSeats array, untill the index matches the specified seat
  for (( StartIndex=0; StartIndex<$StartedSeatCount;  StartIndex=StartIndex+1 ))
  do
    if [[ ${StartedSeats[$StartIndex]} == $CurrentSeat ]]
    then
      ReturnSeatIndex=$StartIndex
      break
    fi
  done
}

#This part of the script is constantly running, once it finishes setting up. This reads the loginmanager_listener FIFO constantly, waiting for it to recive a command from a program called by the loginmanagerdisplay's weston desktop shell that sends approriate commands to it, or the user session, shutdowndialog, or even some functions within this script.
#it also checks to see if the active sesssion is active, and if not, switches back to the tty of the loginmanagerdisplay.
function WaylandLoginManagerMain
{
  LoginManagerFirstLoop=1
  SessionStartFailed=0
  MainLoopMinutes=0
  MainLoopMinuteQuarter=0
  LastMainLoopMinuteQuarter=0
  DoDetectSeats=1
  StartedSeats=()
  
  #Value is 1 for new seats, when a seat is removed, it is set to 0. This is for tracking if a seat is recreated.
  SeatInitializationStatuses=()
  
  #Arrays about running helper processes
  LastUserActionPIDs=()
  LastSwitchPIDs=()
  LastLoginPIDs=()
  LastLeavePIDs=()
  LastInfoPIDs=()
  LastDebugPIDs=()
  LoginManagerDisplaySessions=()
  LoginManagerDisplayPIDs=()
  LoginManagerDisplayStartTimes=()

  #Arrays about the seats, what hardware is supported
  #and how many times something related to the seat failed
  UserActionAttemptCounts=()
  UserActionFailSkips=()
  LoginManagerDisplayAttemptCounts=()
  LoginManagerDisplayBackends=()
  LoginManagerDisplayPixmanFlags=()
  SeatForceSWRenderFlags=()
  SeatFileNames=()


  #loop 'forever'
  while [ 1 ]
  do
    if [[ ! -d /proc/1 || ! -f /proc/stat ]]
    then
      WriteToLog "The /proc file system is not mounted. Exiting."
      exit 1
    fi

    #Detect all seats, and add them to the array.
    if [[ $SECONDS -gt 60 ]]
    then
      ((MainLoopMinutes++))
      SECONDS=0
    fi
    MainLoopMinuteQuarter=$(($SECONDS/15))

    if [[ $DoDetectSeats == 1 || $MainLoopMinutes -ge 120 ]]
    then
      DoDetectSeats=0
      MainLoopMinutes=0
      #Find what seats are new
      AllRunningSeats=()
      NewAllRunningSeats=($(loginctl --no-legend list-seats 2>/dev/null | sort))
      for NewRunningSeat in "${NewAllRunningSeats[@]}"
      do
        AllRunningSeats+=($NewRunningSeat)
      done

      #Find new seats by going the list of running ones, going through all stored ones
      #Then finding ones that have no matches
      for RunningSeat in "${AllRunningSeats[@]}"
      do
        IncludeSeat=1
        StartedSeatCount=${#StartedSeats[@]}
        for (( StartIndex=0; StartIndex<$StartedSeatCount;  StartIndex=StartIndex+1 ))
        do
          if [[ $RunningSeat == ${StartedSeats[$StartIndex]} ]]
          then
            IncludeSeat=0
            break
          fi
        done
        #Detect the age of the seat, by the date stamp of the last entry logged for the seat
        #As of now, this is the best way to get the creation time of a seat, since the attribute is not presented
        if [[ $RunningSeat != seat0 ]]
        then
          SeatCreationString="$(journalctl  -b _HOSTNAME=$HOSTNAME _MACHINE_ID=$MACHINE_ID SEAT_ID=$RunningSeat _SYSTEMD_UNIT=systemd-logind.service -o short-unix 2>/dev/null | tail -1 | awk  '{print $1}')@$RunningSeat"
        else
          SeatCreationString="seat0@seat0"
        fi
        SeatStringMismatch=0
        if [[ $LoginManagerFirstLoop == 1 ]]
        then
          #SeatCreationStrings is exported for waylandloginmanager reloads, and reimported
          #It is not a guarantee that the array will be in the same order after the reload
          for OldSeatCreationString in ${SeatCreationStrings[@]}
          do
            #If a seat with the same name was seen, but with a different date
            if [[ $OldSeatCreationString == *@$RunningSeat && $OldSeatCreationString != $SeatCreationString ]]
            then
              SeatStringMismatch=1
            fi
          done
        else
          #Less strict matching if this not the first loop.
          if [[ $SeatCreationString != ${SeatCreationStrings[$StartIndex]} && ! -z ${SeatCreationStrings[$StartIndex]} ]]
          then
            SeatStringMismatch=1
          fi
        fi
        #If the seat is new, detected to have been removed in the past, or if the seat string is different, (removed and readded before the detection interval)
        if [[ $IncludeSeat == 1 || ${SeatInitializationStatuses[$StartIndex]} == 0 || $SeatStringMismatch == 1 ]]
        then

          WriteToLog "New seat $RunningSeat"

          if [[ ${SeatInitializationStatuses[$StartIndex]} == 0 ]]
          then
            TerminateJobPID ${LastUserActionPIDs[$StartIndex]} 15 1
          else
            StartedSeats+=($RunningSeat)
          fi
          #Seats can be 255 characters long, file names can only be 255 characters long
          #If a seat is 64 characters or greater, use the hash. sha256 (hashes are 64 characters long)
          if [[ ${#RunningSeat} -gt 63 ]]
          then
            SeatFileName=$(echo -n $RunningSeat | sha256sum | awk '{print $1}')
          else
            SeatFileName=$RunningSeat
          fi
          SeatFileNames[$StartIndex]=$SeatFileName
          if [[ $SeatStringMismatch == 1 ]]
          then
            systemctl stop "wlm-loginmanagerdisplay_$SeatFileName" &> /dev/null
            rm /run/user/$LOGINMANAGERDISPLAYUID/loginmanagerdisplay_$SeatFileName &> /dev/null
          fi
          GetSeatCapabilityString $RunningSeat SeatCapabilityArr
          SeatCapabilityArr=($SeatCapabilityArr)
          SeatInitializationStatuses[$StartIndex]=1
          UserActionAttemptCounts[$StartIndex]=$MAX_UI_ATTEMPTS
          UserActionFailSkips[$StartIndex]=0
          SeatCreationStrings[$StartIndex]=$SeatCreationString
          LoginManagerDisplayBackends[$StartIndex]=${SeatCapabilityArr[0]}
          LoginManagerDisplayPixmanFlags[$StartIndex]=${SeatCapabilityArr[1]}
          SeatForceSWRenderFlags[$StartIndex]=${SeatCapabilityArr[2]}
          LoginManagerDisplayAttemptCounts[$StartIndex]=$MAX_UI_ATTEMPTS
          if [[ -f /run/waylandloginmanager/autologinran ]]
          then
            read -r -d $'\r' AUTOLOGINFILE 2>/dev/null </run/waylandloginmanager/autologinran
            if [[ $AUTOLOGINFILE =~ (^|$'\n')$RunningSeat($'\n'|$) ]]
            then
              SEATAUTOLOGINDONE=1
            else
              SEATAUTOLOGINDONE=0
            fi
            unset AUTOLOGINFILE
          fi
          GetConfigKey autologin-user "$RunningSeat" ":" 0 SEATAUTOLOGINUSER
          #if autologin is specified
          if [[ ! ${LoginManagerDisplayBackends[$StartIndex]} == "" && ! ${LoginManagerDisplayBackends[$StartIndex]} == 0 ]]
          then
            if [[ ! -z $SEATAUTOLOGINUSER && $SEATAUTOLOGINDONE == 0 && $SEATAUTOLOGINUSER != ':' ]]
            then
              StartAutoLogin $RunningSeat $SEATAUTOLOGINUSER &
              LastLoginPIDs[$StartIndex]=$!
            fi
          else
            UserActionAttemptCounts[$StartIndex]=-1
            UserActionFailSkips[$StartIndex]=1
          fi
        fi
      done

      #Find out what seats went away, and reset their fail counts
      #Go through the list of registred seats, the list of running seats
      #If there are no matches for the registered seat, then it is gone
      StartedSeatCount=${#StartedSeats[@]}
      for (( StartIndex=0; StartIndex<$StartedSeatCount;  StartIndex=StartIndex+1 ))
      do
        SeatRemoved=1
        for RunningSeat in "${AllRunningSeats[@]}"
        do
          if [[ $RunningSeat == ${StartedSeats[$StartIndex]} ]]
          then
            SeatRemoved=0
          fi
        done
        #Reset the fail count info for this seat in the arrays, it's possible the seat could be recreated
        if [[ $SeatRemoved == 1 && ${SeatInitializationStatuses[$StartIndex]} != 0 ]]
        then
          SeatFileName=${SeatFileNames[$StartIndex]}
          UserActionAttemptCounts[$StartIndex]=-1
          UserActionFailSkips[$StartIndex]=1
          LoginManagerDisplayAttemptCounts[$StartIndex]=-1
          WriteToLog "The seat ${StartedSeats[$StartIndex]} has been detected to have been removed"
          systemctl stop "wlm-loginmanagerdisplay_$SeatFileName" &> /dev/null
          SeatInitializationStatuses[$StartIndex]=0
          SeatCreationStrings[$StartIndex]=0
          TerminateJobPID ${LastUserActionPIDs[$StartIndex]} 15 1
          unset LastUserActionPIDs[$StartIndex]
        fi
      done

      #Export the Session Data
      ExportSessionData
    fi

    LoginManagerDisplayAttemptsMaxedOut=1
    UIPromptAttemptsMaxedOut=1
    #Handle the loginmanagerdisplay, and the main dialog for each seat
    for RunningSeat in "${AllRunningSeats[@]}"
    do
      UIJobCount=0
      GetStartedSeatIndex $RunningSeat
      SeatIndexID=$ReturnSeatIndex

      #Determine if there are any running UI jobs for the paticular seat
      if [[
      ( ! -z ${LastUserActionPIDs[$SeatIndexID]} && -d /proc/${LastUserActionPIDs[$SeatIndexID]}) ||
      ( ! -z ${LastSwitchPIDs[$SeatIndexID]} && -d /proc/${LastSwitchPIDs[$SeatIndexID]}) ||
      ( ! -z ${LastLoginPIDs[$SeatIndexID]} && -d /proc/${LastLoginPIDs[$SeatIndexID]}) ||
      ( ! -z ${LastLeavePIDs[$SeatIndexID]} && -d /proc/${LastLeavePIDs[$SeatIndexID]}) ||
      ( ! -z ${LastInfoPIDs[$SeatIndexID]} && -d /proc/${LastInfoPIDs[$SeatIndexID]}) ]]
      then
        ((UIJobCount++))
      fi

      #Start the loginmanagerdisplay
      if [[ $LoginManagerFirstLoop == 1 ]]
      then

        #The SeatCreationStrings array might have more elements than needed if the service was restarted.
        #Blank out elements that exceed the number of elements in RunningSeats
        RunningSeatsCount=${#StartedSeats[@]}
        SeatCreationStringsCount=${#SeatCreationStrings[@]}
        for (( ResetIndex=$RunningSeatsCount ; ResetIndex<$SeatCreationStringsCount ; ResetIndex++ ))
        do
          SeatCreationStrings[$ResetIndex]=0
        done
        #Export the Session Data
        ExportSessionData

        LoginManagerDisplayInfo=$(GetLoginManagerDisplayInfo $RunningSeat)
        IFS=@
        LoginManagerDisplayInfo=($LoginManagerDisplayInfo)
        unset IFS

        LoginManagerDisplayPIDs[$SeatIndexID]=${LoginManagerDisplayInfo[0]}
        LoginManagerDisplaySessions[$SeatIndexID]=${LoginManagerDisplayInfo[1]}
        LoginManagerDisplayStartTimes[$SeatIndexID]=${LoginManagerDisplayInfo[2]}
      fi
      StartLoginManagerDisplay $RunningSeat $SeatIndexID

      #Set default values for the element for this seat in the fail info arrays if they are not set
      if [[ -z ${UserActionAttemptCounts[$SeatIndexID]} ]]
      then
        UserActionAttemptCounts[$SeatIndexID]=$MAX_UI_ATTEMPTS
      fi
      if [[ -z ${UserActionFailSkips[$SeatIndexID]} ]]
      then
        UserActionFailSkips[$SeatIndexID]=0
      fi

      #If the PID for the seats UserActionDialog is not running, get the return status
      if [[ ! -z ${LastUserActionPIDs[$SeatIndexID]} && ! -e /proc/${LastUserActionPIDs[$SeatIndexID]} ]]
      then
        wait ${LastUserActionPIDs[$SeatIndexID]} 2> /dev/null
        UserActionResult=$?
        #If the return status is not 0 or 1 (1 is a valid press of cancel, and not a crash)
        #increase the fail count
        if [[ ($UserActionResult != 0 && $UserActionResult != 1) ]]
        then
          UserActionResult=0
          unset LastUserActionPIDs[$SeatIndexID]
          if [[ ${UserActionFailSkips[$SeatIndexID]} == 0 ]]
          then
            ((UserActionAttemptCounts[$SeatIndexID]--))
            if [[ ${UserActionAttemptCounts[$SeatIndexID]} -ge 0 ]]
            then
              WriteToLog "The prompt for the user action for seat $RunningSeat terminated incorrectly. Please see the loginmanagerdisplay log. (Attempts Left: ${UserActionAttemptCounts[$SeatIndexID]})"
            fi
          else
            UserActionAttemptCounts[$SeatIndexID]=$MAX_UI_ATTEMPTS
            UserActionFailSkips[$SeatIndexID]=0
          fi
        fi
        if [[ ${UserActionAttemptCounts[$SeatIndexID]} == -1 ]]
        then
          WriteToLog "The prompt for the user action for seat $RunningSeat has terminated incorrectly too many times in a row."
        fi
      fi

      #If the seat had the loginmanagerdisplay fail 5 times, declare it
      if [[ ${LoginManagerDisplayAttemptCounts[$SeatIndexID]} -ge 0 ]]
      then
        LoginManagerDisplayAttemptsMaxedOut=0
      fi
      #If the seat had the UserActionDialog fail 5 times, declare it
      if [[ ${UserActionAttemptCounts[$SeatIndexID]} -ge 0 ]]
      then
        UIPromptAttemptsMaxedOut=0
        if [[ $UIJobCount == 0 ]]
        then
          UserActionDialog $RunningSeat &
          LastUserActionPIDs[$SeatIndexID]=$!
        fi
      fi

      #If a seat without TTYs has no active session unexpectedly, fall back to the loginmanagerdisplay.
      if [[ ${LoginManagerDisplayBackends[$SeatIndexID]} != "" && ${LoginManagerDisplayBackends[$SeatIndexID]} != 0 ]]
      then
        if [[ ($RunningSeat == seat0 && $seat0HasTTYs == 0) || $RunningSeat != seat0 ]]
        then
          if [[ $LastMainLoopMinuteQuarter != $MainLoopMinuteQuarter ]]
          then
            ActiveLogindSession=$(loginctl show-seat $RunningSeat  -p ActiveSession --value)
            if [[ -z $ActiveLogindSession ]]
            then
              WriteToLog "Switching back to the loginmanagerdisplay for seat $RunningSeat unexpectedly has no active session."
              loginctl activate ${LoginManagerDisplaySessions[$SeatIndexID]} &>/dev/null
            fi
          fi
        fi
      fi
    done
    LastMainLoopMinuteQuarter=$MainLoopMinuteQuarter

    if [[ $ZenityCommandFoundResult != 0 ]]
    then
      WriteToLog "zenity is not installed"
      UIPromptAttemptsMaxedOut=1
    fi

    #If it is declared the loginmanagerdisplay service failed for all seats, then show a text mode dialog
    if [[ $LoginManagerDisplayAttemptsMaxedOut == 1 ]]
    then
      systemd-notify --ready &> /dev/null
      WriteToLog "ERROR: Maximum restarts of the loginmanagerdisplay has been reached for every seat"
      if [[ $seat0HasTTYs == 1 ]]
      then
        chvt 63
      fi
      $DIALOGCMD --no-cancel --msgbox "The maximum number of restart attempts for the loginmanagerdisplay for each seat has been reached.

Will show a menu with a few options for diagnosis." 20 50

      $TTYWIZARDCMD rbos-failedboot
      exit 1
    fi

    #If it is declared that the UserActionDialog process failed for all seats, then show a text mode dialog
    if [[ $UIPromptAttemptsMaxedOut == 1 ]]
    then
      WriteToLog "The prompt for the user action terminated incorrectly too many times in a row for every seat."
      if [[ $seat0HasTTYs == 1 ]]
      then
        chvt 63
      fi
      $DIALOGCMD --no-cancel --msgbox "The prompt for the user action terminated incorrectly too many times in a row for every seat.

Will show a menu with a few options for diagnosis." 20 50
      $TTYWIZARDCMD rbos-failedboot
      exit 1
    fi

    #Quickly find if any sessions are not running
    NotRunningSessions=0
    for SessionPid in "${AllSessionPIDs[@]}"
    do
      if [[ ! -e /proc/$SessionPid/environ ]]
      then
         ((NotRunningSessions++))
      fi
    done

    #If a session failed to start (it terminates before it can register the PID, and session ID), switch back to the loginmanagerdisplay
    if [[ $SessionStartFailed == 1 ]]
    then
      SessionStartFailed=0
      for FailSeat in "${FailedSessionSeat[@]}"
      do
        if [[ $FailSeat == seat0  && $seat0HasTTYs == 1 ]]
        then
          read -r -t 4 -n5 ActiveSystemTTY < /sys/class/tty/tty0/active
          ActiveSystemTTY=${ActiveSystemTTY:3}
          if [[ $FailedSessionTTY == $ActiveSystemTTY ]]
          then
            if [[ ! -z $FailedSessionTTY ]]
            then
              ResetTTYMode $FailedSessionTTY
            fi
          fi
        fi
        GetStartedSeatIndex $FailSeat
        SeatIndexID=$ReturnSeatIndex
        WriteToLog "Switching back to the loginmanagerdisplay for seat $FailSeat as a session failed to start"
        loginctl activate ${LoginManagerDisplaySessions[$SeatIndexID]} &>/dev/null
      done
    fi
    unset FailedSessionTTY
    FailedSessionSeat=()

    #Handle for when a session is detected to not be running
    #And also attempt to unlock the TTY, if applicable
    if [[ $NotRunningSessions != 0 ]]
    then
      if [[ $seat0HasTTYs == 1 ]]
      then
        read -r -t 4 -n5 ActiveSystemTTY < /sys/class/tty/tty0/active
        ActiveSystemTTY=${ActiveSystemTTY:3}
      fi

      #Create temporary arrays
      NewAllSessionTTYs=()
      NewAllSessionPIDs=()
      NewAllSessionUsers=()
      NewAllSessionIDs=()
      NewAllSeatIDs=()

      #Go through all sessions, and then rebuild the array to only store running sessions
      for (( element = 0 ; element < ${#AllSessionPIDs[@]} ; element++ ))
      do
        RunningSessionTTY=${AllSessionTTYs[$element]}
        RunningSessionPID=${AllSessionPIDs[$element]}
        RunningSessionUser=${AllSessionUsers[$element]}
        RunningSessionID=${AllSessionIDs[$element]}
        RunningSeatID=${AllSeatIDs[$element]}
        #If the session is alive, add its data to the new arrays
        if [[ -e /proc/$RunningSessionPID/environ ]]
        then
          NewAllSessionTTYs+=("$RunningSessionTTY")
          NewAllSessionPIDs+=("$RunningSessionPID")
          NewAllSessionUsers+=("$RunningSessionUser")
          NewAllSessionIDs+=("$RunningSessionID")
          NewAllSeatIDs+=("$RunningSeatID")
        else
          GetStartedSeatIndex $RunningSeatID
          SeatIndexID=$ReturnSeatIndex
          #If the session terminated, and then current system TTY is the same as the terminated sessions, go back to the loginmanagerdisplay
          if [[ $RunningSeatID != "seat0" || $seat0HasTTYs != 1 ]]
          then
            ActiveLogindSession=$(loginctl show-seat $RunningSeatID  -p ActiveSession --value)
            if [[ -z $ActiveLogindSession ]]
            then
              WriteToLog "Switching back to the loginmanagerdisplay for seat $RunningSeatID after $RunningSessionID terminated"
              loginctl activate ${LoginManagerDisplaySessions[$SeatIndexID]} &>/dev/null
            fi
          elif [[ $RunningSessionTTY == $ActiveSystemTTY ]]
          then
            if [[ ! -z $RunningSessionTTY ]]
            then
              ResetTTYMode $RunningSessionTTY
            fi
            WriteToLog "Switching back to the loginmanagerdisplay for seat $RunningSeatID after $RunningSessionID terminated"
            loginctl activate ${LoginManagerDisplaySessions[$SeatIndexID]} &>/dev/null
          fi
        fi
      done

      #Set the actual arrays to be the value of the temporary arrays
      AllSessionTTYs=("${NewAllSessionTTYs[@]}")
      AllSessionPIDs=("${NewAllSessionPIDs[@]}")
      AllSessionUsers=("${NewAllSessionUsers[@]}")
      AllSessionIDs=("${NewAllSessionIDs[@]}")
      AllSeatIDs=("${NewAllSeatIDs[@]}")

      #Export the Session Data
      ExportSessionData

      #Remove the temporary arrays
      unset NewAllSessionTTYs
      unset NewAllSessionPIDs
      unset NewAllSessionUsers
      unset NewAllSessionIDs
      unset NewAllSeatIDs
    fi


    #Read the next line that was sent to the FIFO. Allow a 1 second delay before it times out, and assumes a null command. the timeout allows detection for when sessions quit. It only reads 288 bytes at a time.
    #32 for the command, 1 for the delimiter, and 255 for the max logind seat name size
    read -r -n 288 -t 1 COMMANDDATA <&1000
    IFS=@
    COMMANDDATA=($COMMANDDATA)
    unset IFS
    COMMAND=${COMMANDDATA[0]}
    SEATARG=${COMMANDDATA[1]}

    #If a seat is specified, and it is not running, ignore the command
    if [[ ! -z $SEATARG ]]
    then
      GetStartedSeatIndex $SEATARG
      SeatIndexID=$ReturnSeatIndex
      SeatIsRunning=0
      #Go through the list of running seats, check if one of them matches the specified one
      for RunningSeat in "${AllRunningSeats[@]}"
      do
        if [[ $SEATARG == $RunningSeat ]]
        then
          SeatIsRunning=1
          break
        fi
      done
      if [[ $SeatIsRunning == 0 ]]
      then
        WriteToLog "Ignoring $COMMAND command as specified seat $SEATARG not running or invalid"
        COMMAND=""
      fi
    fi
    #If the command is empty, do nothing
    if [[ -z $COMMAND ]]
    then
      continue
    #If it recives a Switch command, then go back to the loginmanagerdisplay's TTY and bring up a switch user dialog and start a switch user job, only if there isn't another switchuserdialog job running
    elif [[ $COMMAND == "Switch" ]]
    then
      if [[ -z $SEATARG ]]
      then
        WriteToLog "received command $COMMAND with no seat specifed"
        continue
      else
        WriteToLog "received command $COMMAND for seat $SEATARG"
      fi
      LOGINMANAGERDISPLAYSESSION=${LoginManagerDisplaySessions[$SeatIndexID]}
      ACTIVESESSION=$(loginctl show-seat "$SEATARG" -p ActiveSession --value 2>/dev/null)
      if [[ $ACTIVESESSION != $LOGINMANAGERDISPLAYSESSION ]]
      then
        loginctl lock-session $(loginctl show-seat "$SEATARG" -p ActiveSession --value 2>/dev/null) &>/dev/null
        loginctl activate $LOGINMANAGERDISPLAYSESSION &>/dev/null
      fi
      if [[ ! $(jobs -p -r) =~ (^|[[:space:]])${LastSwitchPIDs[$SeatIndexID]}([[:space:]]|$) ]]
      then
        if [[ ! -z ${LastUserActionPIDs[$SeatIndexID]} ]]
        then
          TerminateJobPID ${LastUserActionPIDs[$SeatIndexID]} 15 1
          UserActionFailSkips[$SeatIndexID]=1
        fi
        SwitchUserDialog "$SEATARG" &
        LastSwitchPIDs[$SeatIndexID]=$!
      else
        WriteToLog "A handler for the Switch command is already open"
      fi
    #If the command is change, go back to the loginmanagerdisplay TTY, and don't do anything else. It only switches to the TTY if the TTY isn't active already.
    elif [[ $COMMAND == "Change" ]]
    then
      if [[ -z $SEATARG ]]
      then
        WriteToLog "received command $COMMAND with no seat specifed"
        continue
      else
        WriteToLog "received command $COMMAND for seat $SEATARG"
      fi
      LOGINMANAGERDISPLAYSESSION=${LoginManagerDisplaySessions[$SeatIndexID]}
      ACTIVESESSION=$(loginctl show-seat "$SEATARG" -p ActiveSession --value 2>/dev/null)
      if [[ $ACTIVESESSION != $LOGINMANAGERDISPLAYSESSION ]]
      then
        loginctl lock-session $(loginctl show-seat "$SEATARG" -p ActiveSession --value 2>/dev/null) &>/dev/null
        loginctl activate $LOGINMANAGERDISPLAYSESSION &>/dev/null
      fi
    #If it recives a Login command, then bring up a login dialog and start a login job, only if there isn't another login job running
    elif [[ $COMMAND == "Login" ]]
    then
      if [[ -z $SEATARG ]]
      then
        WriteToLog "received command $COMMAND with no seat specifed"
        continue
      else
        WriteToLog "received command $COMMAND for seat $SEATARG"
      fi
      if [[ ! $(jobs -p -r) =~ (^|[[:space:]])${LastLoginPIDs[$SeatIndexID]}([[:space:]]|$) ]]
      then
        if [[ ! -z ${LastUserActionPIDs[$SeatIndexID]} ]]
        then
          TerminateJobPID ${LastUserActionPIDs[$SeatIndexID]} 15 1
          UserActionFailSkips[$SeatIndexID]=1
        fi
        GetUserCredentials "$SEATARG" &
        LastLoginPIDs[$SeatIndexID]=$!
      else
        WriteToLog "A handler for the Login command is already open"
      fi
    #If it recives a Leave command, then bring up a shutdown dialog and start a shutdown job, only if there isn't another shutdown job running
    elif [[ $COMMAND == "Leave" ]] 
    then
      if [[ -z $SEATARG ]]
      then
        WriteToLog "received command $COMMAND with no seat specifed"
        continue
      else
        WriteToLog "received command $COMMAND for seat $SEATARG"
      fi
      if [[ ! $(jobs -p -r) =~ (^|[[:space:]])${LastLeavePIDs[$SeatIndexID]}([[:space:]]|$) ]]
      then
        if [[ ! -z ${LastUserActionPIDs[$SeatIndexID]} ]]
        then
          TerminateJobPID ${LastUserActionPIDs[$SeatIndexID]} 15 1
          UserActionFailSkips[$SeatIndexID]=1
        fi
        LeavePrompt $SEATARG &
        LastLeavePIDs[$SeatIndexID]=$!
      else
        WriteToLog "A handler for the Leave command is already open"
      fi
    #if the command is ReadRegister, then attempt to read the loginmanager_register FIFO, and register any data sent to that FIFO.
    elif [[ $COMMAND == "ReadRegister" ]]
    then
      WriteToLog "received command $COMMAND"
      ReadRegister
    #If the command id DetectSeats, then inventory seats on the next loop
    elif [[ $COMMAND == "DetectSeats" ]]
    then
      WriteToLog "received command $COMMAND"
      DoDetectSeats=1
    #If it recives a Info command, then bring up a info dialog and start a info job, only if there isn't another info job running
    elif [[ $COMMAND == "Info" ]]
    then
      if [[ -z $SEATARG ]]
      then
        WriteToLog "received command $COMMAND with no seat specifed"
        continue
      else
        WriteToLog "received command $COMMAND for seat $SEATARG"
      fi
      if [[ ! $(jobs -p -r) =~ (^|[[:space:]])${LastInfoPIDs[$SeatIndexID]}([[:space:]]|$) ]]
      then
        if [[ ! -z ${LastUserActionPIDs[$SeatIndexID]} ]]
        then
          TerminateJobPID ${LastUserActionPIDs[$SeatIndexID]} 15 1
          UserActionFailSkips[$SeatIndexID]=1
        fi
        ShowInfo "$SEATARG" &
        LastInfoPIDs[$SeatIndexID]=$!
      else
        WriteToLog "A handler for the Info command is already open"
      fi
    #If the command is Debug, and wlmdebug was passed to the kernel, then show a login terminal window, only if there isn't another debug terminal window job running
    elif [[ $COMMAND == "Debug" ]]
    then
      if [[ $wlmdebuginsecure == 1 ]]
      then
        if [[ -z $SEATARG ]]
        then
          WriteToLog "received command $COMMAND with no seat specifed"
          continue
        else
          WriteToLog "received command $COMMAND for seat $SEATARG"
        fi
        if [[ ! $(jobs -p -r) =~ (^|[[:space:]])${LastDebugPIDs[$SeatIndexID]}([[:space:]]|$) || $wlmdebuginsecure == 1  ]]
        then
          DiagnosticTerminal "$SEATARG" &
          LastDebugPIDs[$SeatIndexID]=$!
          WriteToLog "Spawned a root terminal window on the loginmanagerdisplay for $SEATARG"
        else
          WriteToLog "A handler for the Debug command is already open"
        fi
      else
        WriteToLog "Invalid command: $COMMAND for $SEATARG received, but wlmdebuginsecure not passed to the kernel."
      fi
    #if the command is unknown, then log that.
    else
      WriteToLog "Invalid command: $COMMAND received for seat $SEATARG"
    fi
    LoginManagerFirstLoop=0

  done
}

#Function to lookup XDG_SEAT and XDG_SESSION_ID in case if the variables are unset. It needs no arguments
function GetXDGVariables
{
  export XDG_SESSION_ID=$(busctl get-property org.freedesktop.login1 /org/freedesktop/login1/session/auto org.freedesktop.login1.Session Id | awk -F \" '{print $2}')
  export XDG_SEAT=$(busctl get-property org.freedesktop.login1 /org/freedesktop/login1/session/auto org.freedesktop.login1.Session Seat | awk -F \" '{print $2}')
}

#Use bash builtin sleep if availible
if [[ -f /usr/lib/bash/sleep ]]
then
  enable -f /usr/lib/bash/sleep sleep
  SLEEPCMD=\sleep
else
  SLEEPCMD=/bin/sleep
fi

#If the waylandloginmanager is started with no arguments assume default operation. 
#If it is started with --usersession, then perform operations to start the user session, running as the user
if [[ $1 == "" ]]
then
  #Prepare the loginmanager
  PrepareLoginManager

  #Create files used for ipc
  SetupIPCFiles

  #Start the filter that will only send valid data to the main command FIFO
  WLM_FIFO_READER=1 runuser -u $FIFOREADERUSER -m -- $0 --fifofilter &

  #Start the loginmanager
  WaylandLoginManagerMain
elif [[ $1 == "--usersession" ]]
then
  shift
  UserSessionWorker "$@" &> /dev/null
elif [[ $1 == "--sendcommand" ]]
then
  if [[ -z $3 ]]
  then
    GetXDGVariables
    SEAT=$XDG_SEAT
  else
    SEAT=$3
  fi
  SendSelfCommand $2 "$SEAT"
elif [[ $1 == "--udevtrigger" ]]
then
  if [[ $UID == 0 ]]
  then
    if [[ -f /run/waylandloginmanager/sessiondata ]]
    then
      SendSelfCommand DetectSeats
    fi
  fi
elif [[ $1 == "--getconfigkey" ]]
then
  GetConfigKey "$2" "$3" "$4" "$5"
elif [[ $1 == "--setconfigkey" ]]
then
  #Require root privlages
  if [[ $UID != 0 ]]
  then
    echo "Must be run as root."
    exit 1
  fi
  SetConfigKey "$2" "$3"
#This reads what the user send to loginmanager_control running as a limited account, and filters out only valid commands to loginmanager_listener, and only sends a limited number of lines.
elif [[ $1 == "--fifofilter" ]]
then
  #Require root privlages
  if [[ -z $WLM_FIFO_READER ]]
  then
    echo "Invalid option"
    exit 1
  fi
  while [ 1 ]
  do
    FIFOCommand=$(grep -aEom 3 "^Switch@[a-Z0-9_\-]*$|^Change@[a-Z0-9_\-]*$|^Login@[a-Z0-9_\-]*$|^Leave@[a-Z0-9_\-]*$|^ReadRegister@[a-Z0-9_\-]*$|^DetectSeats@[a-Z0-9_\-]*$|^Info@[a-Z0-9_\-]*$|^Debug@[a-Z0-9_\-]*$|^$" /run/waylandloginmanager/loginmanager_control 2>/dev/null)
    echo $'\0'$FIFOCommand$'\0' > /run/waylandloginmanager/loginmanager_listener 2>/dev/null
  done
elif [[ $1 == "--shutdowndialog" ]]
then
  GetXDGVariables
  LeavePrompt
elif [[ $1 == "--logoff" ]]
then
  GetXDGVariables
  loginctl terminate-session $XDG_SESSION_ID
elif [[ $1 == "--switchuser" ]]
then
  GetXDGVariables
  SendSelfCommand Switch $XDG_SEAT
else
  echo "waylandloginmanager: incorrect usage"
  echo "Useful options:"
  echo "   --shutdowndialog shows a shutdown dialog."
  echo "   --udevtrigger forces seats to be redetected"
  echo "   --logoff ends the current logind session"
  exit 1
fi
