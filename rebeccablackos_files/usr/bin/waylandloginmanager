#! /bin/bash
#    Copyright (c) 2012, 2013, 2014, 2015, 2016, 2017, 2018 nerdopolis (or n3rdopolis) <bluescreen_avenger@verzion.net>
#
#    This file is part of RebeccaBlackOS.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

#This script is the WaylandLoginManager it handles a graphical login for the user, and allows the user to start multiple types of Wayland sessions, specified in wsession files, and it supports autologin, mounting of ecryptfs home directories, and user switching. It supports watching the active session until it fails, so that it swiches back to the needed TTY for the user.

#The main server it displays on is refered to as the loginmanagerdisplay. it runs as non root, as well as the zenity dialogs

#It depends on zenity kbd, weston, and gawk, and expect


#It depends on the line
#SUBSYSTEM=="graphics", KERNEL=="fb*", TAG+="uaccess"
#in a udev rules file.
#or pass wlmglobalfbpermissions to the kernel

#It also requires /etc/pam.d/waylandloginmanager

#It needs a user account called waylandloginmanager

#Weston 5.0 or greater is required for multiseat support

#as well as:
#At least systemd v227 as it has all the ability to launch Wayland sessions with systemd-run

#/etc/waylandloginmanager.conf
  #Otherwise it uses /etc/lightdm/lightdm.conf . The supported key is 'autologin-user=$AUTOLOGINUSER', and it usually takes it from /etc/lightdm/lightdm.conf at first run. It only uses /etc/waylandloginmanager.conf, as another init script can cause the lightdm config to drop the configured autologin user on an unsafe shutdown
     #it can also have 
     #      autologin-user-{$SEAT}=$AUTOLOGINUSER
     #to set a different autologin user per seat or
     #      autologin-user-{$SEAT}=:
     #to turn off autologin for a seat
     #
     #It also supports setting
     #wlmforceswrender-{$SEAT}=1
     #to force software rendering on a seat or
     #wlmforceswrender=1
     #to force software rendering globally.
     #Specifing the option on the kernel command line overrides the config file

     #wlmforcepixman-{$SEAT}=1
     #to force the loginmanagerdisplay to use pixman
     #wlmforcepixman=1
     #to force using pixman globally.
     #Specifing the option on the kernel command line overrides the config file

     #wlmforcevblankoff-{$SEAT}=1
     #to force vblank off on a seat or
     #wlmforcevblankoff=1
     #to force vblank off globally.
     #Specifing the option on the kernel command line overrides the config file

     #wlmforcefbdev-{$SEAT}=1
     #to force framebuffer on a seat or
     #wlmforcefbdev=1
     #to force framebuffer globally.
     #Specifing the option on the kernel command line overrides the config file

     #wlmnofbdev-{$SEAT}=1
     #to disable using the  framebuffer on a seat or
     #wlmnofbdev=1
     #to disable using the framebuffer globally.
     #Specifing the option on the kernel command line overrides the config file

#/usr/libexec/wayland_login_helpers/*
  #These scripts are small utilities that send the approriate commands to the waylandloginmanager's FIFO. They need to be configured in the launchers of /etc/loginmanagerdisplay/weston.ini. It's how the user interacts with the waylandloginmanager on the loginmanagerdisplay (other then the zenity dialogs)
  #These are optional as the waylandloginmanager displays a selection list with the same commands as well
#/etc/loginmanagerdisplay/weston.ini
  #Configuration for the loginmanagerdisplay. This should add the launchers in /usr/lib/wayland_login_helpers to the launcher bar, which send commands to the FIFO for weston, or at least prevent the default terminal icon from appearing in the toolbar for security reasons.
  #The mainform makes this reqirement optional
#/usr/share/wsessions.d/*
  #These are .desktop files, (and .environment files as well) which describe how to start different Wayland servers or sessions
  #These files are documented in /usr/share/wsession/aboutwsessions.txt

#Log Files:
  #/var/log/waylandloginmanager/waylandloginmanager.log : this is the main log for the waylandloginmanager
  #/var/log/waylandloginmanager/loginmanagerdisplays/loginmanagerdisplay_{SEAT}.log : This is the log file for the Weston server that is the loginmanagerdisplay
  #~/wlsessionlogs/waylandsession_($SEAT)_($DATESTAMP).log : This is where all wayland servers get logged as the run as the user.
  #~/wlsessionlogs/waylandhost_($SEAT).log : This log is for the host Wayland server that gets started for Wayland sessions that run on other Wayland servers

#Runtime Files:
  #/run/waylandloginmanager/pidfile: an empty file waylandloginmanager attempts to open with file descriptor #1023 to assist with locking
  #/run/waylandloginmanager/waylandloginmanager.lock: a symlink to /proc/$$/fd/1023 , when the symlink is broken, waylandloginmanager is not running. (and fd 1023 is used to try to account for recycled pids)
  #/run/waylandloginmanager/autologinran: Denotes that the autologin process has run already, after startup (since /run is a tmpfs). This prevents autologin when the service is restarted
  #/run/waylandloginmanager/sessiondata: Stores data for user switching so that the session list can be reloaded if waylandloginmanager restarts. As it's stored in /run which is a tmpfs, there should be no risk of one from a previous boot giving it false data
  #/run/waylandloginmanager/usrbinwaylandloginmanager.lock: (the file name is generated by the path that this script is in, removing the slashes). this prevents two instances of the waylandloginmanager from starting. 
    #It is a symlink to /proc/$$/cmdline (where $$ is the pid of the waylandloginmanager). It is checked in two different ways to protect against a race condition
  #/run/waylandloginmanager/loginmanager_register : Only root can write to this FIFO to register sessions, and no one can read it (except root). Functions registering sessions must first write to this FIFO, and then send the RegisterSession command to the loginmanager_control FIFO
  #/run/waylandloginmanager/loginmanager_control : All users have write access, but and no one can read it, except the FIFOREADERUSER service account. A process running as PROBETESTUSER reads the data getting send to it, and filters out only valid commands to get sent to loginmanager_listener
  #/run/waylandloginmanager/loginmanager_listener : Only root has write access to it, and no one has read access to it (except root). Supported commands:
      #Switch : calls up a switch user dialog on the loginmanagerdisplay, switching to the tty (see documentation for function SwitchUserDialog)
      #Change : switches to the tty the loginmanagerdisplay is on 
      #Info : calls up a help dialog for the user on the loginmanagerdisplay (see documentation for function ShowInfo)
      #Leave : calls up a dialog with shutdown/restart/supend options on the loginmanagerdisplay (see documentation for function LeavePrompt)
      #Login : Starts the login process (see documentation for function GetUserCredentials)
      #RegisterSession : Tells the waylandloginmanager to read from the loginmanager_register FIFO. When this is called the process must be attempting to write to the loginmanager_register already. If there is nothing being written in the short .01 second timeout, it is ignored. (see documentation for function RegisterSession)
      #DetectSeats: Tells the waylandloginmanager to detect all running seats
  #Each command is then ended by a @ followed by the argument for the specified seat

#These functions are for the user session part of the waylandloginmanager

#Function that is run to start user sessions while running as the user (when started with the --usersession argument)
function UserSessionWorker
{
  #Enable job control
  set -m

  #set up the environment for the user. Determine the user name, set Wayland variables, and if the current session has an environment file then handle it.
  USER=$(id -u)
  export XDG_SESSION_TYPE=wayland
  . /usr/bin/wlruntime_vars &> /dev/null

  if [[ -e /usr/share/wsessions.d/default.environment ]]
  then
    ReadEnvironmentFile /usr/share/wsessions.d/default.environment
  fi

  if [[ -e $EnvironmentFile ]]
  then
    ReadEnvironmentFile "$EnvironmentFile"
  fi

  #Create a folder for the logs
  if [[ ! -e ~/wlsessionlogs ]]
  then
    mkdir ~/wlsessionlogs
  fi

  #Create a /tmp/.X11-unix/ folder, don't assume it exists
  mkdir /tmp/.X11-unix/

  #Cleanup old log files
  LOGFILECOUNT=0
  ls -t ~/wlsessionlogs/waylandsession_${WLM_SEAT}_* 2>/dev/null | while read LOGFILE
  do
    ((LOGFILECOUNT++))
    if [[ $LOGFILECOUNT > 4 ]]
    then
      rm "$LOGFILE" &> /dev/null
    fi
  done

  #set all arguments into an array
  ArgumentString=$(echo -en "$@")
  DATESTAMP=$(date +%s)
  export WLM_SESSION_LOG="$HOME"/wlsessionlogs/waylandsession_${WLM_SEAT}_${DATESTAMP}.log
  export WLM_HOST_LOG="$HOME"/wlsessionlogs/waylandhost_${WLM_SEAT}.log
  unset WLM_SEAT
  echo "Started with the arguments: $ArgumentString" >> $WLM_SESSION_LOG
  eval set -- $ArgumentString >> $WLM_SESSION_LOG
  ArgArray=($ArgumentString)
  unset IFS

  #if the user booted with wlmforceswrender, or configured software rendering globally, or for the seat
  #force software rendering to be enabled
  if [[ $(grep -c "\bwlmforceswrender\b" /proc/cmdline ) == 0 && $(GetSeatConfigKey wlmforceswrender "$XDG_SEAT" 0 ) != 0  ]]
  then
    WLM_USE_SOFTWARE=1
    export LIBGL_ALWAYS_SOFTWARE=1
  else
    WLM_USE_SOFTWARE=0
  fi

  #if the user booted with wlmforcepixman, or configured to use pixman globally, or for the seat
  #force pixman to be enabled
  if [[ $DefaultBackendType == KMS && $(grep -c "\bwlmforcepixmanb" /proc/cmdline ) == 0 && $(GetSeatConfigKey wlmforcepixman "$XDG_SEAT" 0 ) != 0  ]]
  then
    export PIXMANARGS="--use-pixman"
  else
    export PIXMANARGS=""
  fi

  #if the user booted with wlmforcevblankoff, or configured vblank globally, or for the seat
  #force vblank to be disabled
  if [[ $(grep -c "\bwlmforcevblankoff\b" /proc/cmdline ) == 0 && $(GetSeatConfigKey wlmforcevblankoff "$XDG_SEAT" 0 ) != 0  ]]
  then
    export vblank_mode=0
  fi

  if [[ $BackendType == WL ]]
  then
    if [[ $DefaultBackendType == FB ]]
    then
      HostBackendArgument="--backend=fbdev-backend.so"
    else
      HostBackendArgument="--backend=drm-backend.so"
    fi
    weston --no-config $PIXMANARGS --shell=fullscreen-shell.so --socket=$WAYLAND_HOST $HostBackendArgument &>> $WLM_HOST_LOG &
    HostServerPID=$!
    export WAYLAND_DISPLAY=$WAYLAND_HOST
    WaitTimes=0
    if [[ ${WAYLAND_DISPLAY:0:1} == "/" ]]
    then
      WAYLANDDISPLAYPATH=$WAYLAND_DISPLAY
    else
      WAYLANDDISPLAYPATH=$XDG_RUNTIME_DIR/$WAYLAND_DISPLAY
    fi
    #Wait for the server to start up for a maximum of 15 seconds. As soon as the socket is created, the wait loop ends
    while [[ ! -e $WAYLANDDISPLAYPATH && $WaitTimes<15 ]]
    do
      $SLEEPCMD 1
      ((WaitTimes++))
    done
    #If the socket doesn't exist, then the server failed to start, and switch back
    if [[ ! -e $WAYLANDDISPLAYPATH ]]
    then
      echo "The host server failed to start. Will not start the guest server for this session. Please see $WLM_HOST_LOG" &>> $WLM_SESSION_LOG
      if [[ $(loginctl show-session --value -p State $XDG_SESSION_ID 2>/dev/null) == active ]]
      then
        SendSelfCommand Change "$XDG_SEAT"
      fi
      exit
    fi
  else
    export WAYLAND_DISPLAY=$WAYLAND_GUEST
    unset WAYLAND_HOST
    unset WAYLAND_GUEST
  fi

  #Execute first run scripts
  if [[ ! -e "$HOME"/.config/wlmfirstlogin ]]
  then
    dbus-launch --exit-with-session -- /usr/bin/wlruntime_firstrun &>/dev/null
    mkdir -p "$HOME"/.config/
    touch "$HOME"/.config/wlmfirstlogin
  fi

  #Execute the Wayland server, and log it to $HOME/wlsessionlogs/waylandsession_${SEAT}_${DATESTAMP}.log
  dbus-run-session -- ${ArgArray[@]} &>> $WLM_SESSION_LOG &
  GuestServerPID=$!

  #Terminate the host server after the guest terminates
  if [[ $BackendType == WL ]]
  then
    fg 2
    if [[ $(loginctl show-session --value -p State $XDG_SESSION_ID 2>/dev/null) == active ]]
    then
      SendSelfCommand Change "$XDG_SEAT"
    fi
    echo "The guest session has ended. Terminating the host..." &>> $WLM_HOST_LOG
    TerminateJobPID $HostServerPID 15 0
    $SLEEPCMD 3
    TerminateJobPID $HostServerPID 9 0
  else
    fg 1
    if [[ $(loginctl show-session --value -p State $XDG_SESSION_ID 2>/dev/null) == active ]]
    then
      SendSelfCommand Change "$XDG_SEAT"
    fi
  fi
  wait $GuestServerPID
  SessionReturnCode=$?

  #Write the error code and any Journal logs for this session into the logfile
  echo -e "\nSession exited with the error code: $SessionReturnCode\nSession's Journal Logs:" >> $WLM_SESSION_LOG
  journalctl -b _SYSTEMD_SESSION=$XDG_SESSION_ID >> $WLM_SESSION_LOG 2>/dev/null

  exit
}

#Function that reads the waylandloginmanager config, and reports the value of it, if it exists.
#It takes 3 arguments, the first key to get the value of, the second is the seat, and the third is the default value
function GetSeatConfigKey
{
  GlobalKeyValue=""
  ReturnKeyValue=""
  SeatKeyValue=""

  #Only allow /etc/waylandloginmanager.conf to be less that 16kb.
  read -r -n 16000 -d $'\r' LoginManagerConfig </etc/waylandloginmanager.conf
  if [[ ${#LoginManagerConfig} == 16000 ]]
  then
    WriteToLog "/etc/waylandloginmanager.conf is too large"
    return
  fi

  #Convert to an array
  IFS=$'\n'
  LoginManagerConfig=($LoginManagerConfig)
  unset IFS

  for LoginManagerConfigLine in ${LoginManagerConfig[@]}
  do
    IFS="="
    LoginManagerConfigLine=($LoginManagerConfigLine)
    unset IFS

    #Find the config value for all seats
    if [[  ${LoginManagerConfigLine[0]} == "$1" && -z $GlobalKeyValue ]]
    then
      GlobalKeyValue=${LoginManagerConfigLine[1]}
    fi

    #If a seat is specified as an argument and a config value is specifed for a seat, favor it
    if [[ ! -z $2 ]]
    then
      if [[  ${LoginManagerConfigLine[0]} == "$1-$2" && -z $SeatKeyValue ]]
      then
        SeatKeyValue=${LoginManagerConfigLine[1]}
        break
      fi
    fi
  done

  if [[ ! -z $SeatKeyValue ]]
  then
    ReturnKeyValue=$SeatKeyValue
  else
    ReturnKeyValue=$GlobalKeyValue
  fi
  if [[ -z $ReturnKeyValue ]]
  then
    ReturnKeyValue=$3
  fi
  echo $ReturnKeyValue
}

#Function that takes the argument of an environment file, and handles the definitions (for --usersession)
function ReadEnvironmentFile
{
  #parse the session event file if specified, and it exists
  EnvironmentFileData=$(sed '0,/\[EnvironmentFile\]/d;/^\[/Q' "$1" 2>/dev/null | awk -F \# '{print $1}' | sed  -e "s/ *= */=/g" -re "s/(.*)@([A-Z]*)$/\2#\1/g")

  IFS=$'\n'
  EnvironmentFileData=($EnvironmentFileData)
  unset IFS

  for EnvironmentFileLine in ${EnvironmentFileData[@]}
  do
    #environment files are specified as action=var=data
    #Examples
    #set=varname=data sets variable called varname, with the content of data.
    #unset=varname unsets a variable called varname
    #unset=varname@FB unsets a variable called varname ONLY if the current backend is FB. waylandloginmanager tells this script what the current backend is
    IFS="#"
    EnvironmentFileLine=($EnvironmentFileLine)
    if [[ ${#EnvironmentFileLine[@]} -gt 1 ]]
    then
      VARBACKEND=${EnvironmentFileLine[0]}
      EnvironmentFileLine=${EnvironmentFileLine[@]:1}
    else
      unset VARBACKEND
    fi
    unset IFS

    IFS="="
    EnvironmentFileLine=($EnvironmentFileLine)
    unset IFS

    VARACTION=${EnvironmentFileLine[0]}
    VARNAME=${EnvironmentFileLine[1]}

    VARDATAARRAY=(${EnvironmentFileLine[@]:2})
    ADDDELIM=0
    VARDATA=""
    for VARDATASEGMENT in ${VARDATAARRAY[@]}
    do
      if [[ $ADDDELIM != 0 ]]
      then
        VARDATA+="="
      else
        ADDDELIM=1
      fi
      VARDATA+="$VARDATASEGMENT"
    done

    #Only expand some variables
    if [[ $VARDATA == "\$WAYLAND_DISPLAY" ]]
    then
      VARDATA=$WAYLAND_DISPLAY
    fi
    if [[ $VARDATA == "\$XDG_SEAT" ]]
    then
      VARDATA=$XDG_SEAT
    fi

    #if the backend for this line is unspecified, OR if the backend on this line matches the current one running then handle the variable
    if [[ $WLM_USE_SOFTWARE == 1 && $VARBACKEND == SOFTWARE ]]
    then
      ADDSWVAR=1
    else
      ADDSWVAR=0
    fi
    if [[ -z $VARBACKEND || $VARBACKEND == $BackendType || $ADDSWVAR == 1 ]]
    then
      #if it is set, then set the variable
      if [[ $VARACTION == "set" ]]
      then
        export $VARNAME=$VARDATA
      fi
      #if it is unset, then unset the variable
      if [[ $VARACTION == "unset" ]]
      then
        unset $VARNAME
      fi
    fi
  done
}

#All functions below this point are for the main operation of the waylandloginmanager

#This function writes to the logs. It takes 2 argument, the string to log, and the option to log the date or not.
function WriteToLog
{
  if [[ $2 == 1 ]]
  then
    builtin printf "%(%F %T %z)T: %s\n" -1 "$1"   >> /var/log/waylandloginmanager/waylandloginmanager.log 2>&1
  else
    echo "$1" >> /var/log/waylandloginmanager/waylandloginmanager.log 2>&1
  fi
}

#This function makes sure a specified PID belongs to a job, before terminating it.
#This is to ensure that with PID recyling, one that gets reused, and is no longer a subprocess, it does not get terminated
#It takes 3 arguments, 1 is the pid, 2 is the signal, 3 is 0 or 1, where 0 does not terminate the tree, while 1 terminates the tree
function TerminateJobPID
{
  PIDInJob=0
  TerminatePID=$1
  TerminateSignal=$2
  if [[ -z $TerminateSignal ]]
  then
    TerminateSignal=15
  fi
  TerminateTree=$3
  if [[ -z $TerminateTree ]]
  then
    TerminateTree=0
  fi

  for JOBPID in $(jobs -p)
  do
    if [[ $JOBPID == $TerminatePID ]]
    then
      PIDInJob=1
      break
    fi
  done

  if [[ $PIDInJob == 1 && -d /proc/$TerminatePID ]]
  then
    if [[ $TerminateTree == 0 ]]
    then
      \kill -$TerminateSignal -- $TerminatePID &> /dev/null
    else
      \kill -$TerminateSignal -- -$TerminatePID &> /dev/null
    fi
    wait $TerminatePID &> /dev/null
  fi
}

#Function that takes no arguments that does the first steps in setting up the environment, and detecting hardware support, and previous instances for starting up the login manager
function PrepareLoginManager
{

  export XDG_CONFIG_HOME=/etc/loginmanagerdisplay/
  #User that the zenity dialogs and the loginmanagerdisplay (weston instance for the waylandloginmanager runs as
  export LOGINMANAGERDISPLAYUSER=waylandloginmanager
  #User that the su test in AuthenticateUser user runs as
  export PROBETESTUSER=waylandloginmanager
  #User that reads from the loginmanager_control FIFO, and filters the command sent to it to loginmanager_listener
  export FIFOREADERUSER=waylandloginmanager
  #Get the UID of the $LOGINMANAGERDISPLAYUSER
  export LOGINMANAGERDISPLAYUID=$(id $LOGINMANAGERDISPLAYUSER -u)
  export XDG_RUNTIME_DIR=/run/user/$LOGINMANAGERDISPLAYUID

  #Require root privlages
  if [[ $UID != 0 ]]
  then
    echo "Must be run as root."
    exit 1
  fi

  #Create the waylandloginmanager folder in /run for FIFOs and lockfiles
  mkdir -p /run/waylandloginmanager
  touch /run/waylandloginmanager/fifolock
  mkdir -p /var/log/waylandloginmanager/

  #Create and open an empty file, with file descriptor #1023.
  touch /run/waylandloginmanager/pidfile
  exec 1023<> /run/waylandloginmanager/pidfile

  #Detect another instance, testing if the lockfile path to the previous waylandloginmanager's file descriptor 1023 is invalid
  if [[  ! -e "/run/waylandloginmanager/waylandloginmanager.lock"  ]]
  then
    #Link this proccess's file descriptor #1023 to the lock file
    #When this path is valid, this check will not allow the new instance to run, because there already is one
    rm -r "/run/waylandloginmanager/waylandloginmanager.lock" 2>/dev/null
    ln -s /proc/"$$"/fd/1023 "/run/waylandloginmanager/waylandloginmanager.lock"
    Status=$?
    if [[ $Status != 0 ]]
    then
      WriteToLog "Failed to create a lock file." 1
      exit 1
    fi
  else
    WriteToLog "Error: Another instance is already running" 1
    exit 1
  fi
  #second check to make sure this instance 'won' as a second instance could report success, and execute as the first instance is OK to run, but before it creates the lockfile
  #this ensures that the linked /proc/pid/cmdline is this pid
  LOCKPROCPATH=$(readlink "/run/waylandloginmanager/waylandloginmanager.lock" )
  THISPROCPATH=/proc/$$/fd/1023
  if [[ $LOCKPROCPATH != $THISPROCPATH ]]
  then
    WriteToLog "Error: Another instance is already running" 1
    exit 1
  fi

  #Prepare logging for the loginmanagerdisplay

  #Older versions of the waylandloginmanager used to log to /var/log/waylandloginmanager , now /var/log/waylandloginmanager is a folder
  #Handle rare cases where an older version of waylandloginmanager would now prevent proper logging.
  if [[ -f /var/log/waylandloginmanager ]]
  then
    mv /var/log/waylandloginmanager /var/log/waylandloginmanager.log
  fi
  mkdir -p /var/log/waylandloginmanager/loginmanagerdisplays/

  #If /var/log/waylandloginmanager.log exists, or was renamed, move it into the correct, now created folder
  if [[ -f /var/log/waylandloginmanager.log ]]
  then
    mv /var/log/waylandloginmanager.log /var/log/waylandloginmanager/waylandloginmanager.log
  fi

  #Only save the last 250 lines of /var/log/waylandloginmanager/waylandloginmanager.log
  if [[ -f /var/log/waylandloginmanager/waylandloginmanager.log ]]
  then
    mv /var/log/waylandloginmanager/waylandloginmanager.log /var/log/waylandloginmanager/waylandloginmanager.log.bak
    tail -n 250 /var/log/waylandloginmanager/waylandloginmanager.log.bak > /var/log/waylandloginmanager/waylandloginmanager.log
    rm /var/log/waylandloginmanager/waylandloginmanager.log.bak
  fi

  chown $LOGINMANAGERDISPLAYUSER /var/log/waylandloginmanager/loginmanagerdisplays
  WriteToLog "Starting Up..." 1

  #Configure missing things if they are missing. This can be turned on or off
  AutoConfig=0
  if [[ $AutoConfig == 1 ]]
  then
    #Create a user for non-privlaged commands for the waylandloginmanager if it doesn't exist
    if [[ $(id waylandloginmanager &>/dev/null; echo $? ) == 1 ]]
    then
      WriteToLog "Error: The user waylandloginmanager does NOT exist. Creating the user account..." 1
      adduser --no-create-home --home=/etc/loginmanagerdisplay --shell=/bin/bash --disabled-password --system --group waylandloginmanager
    fi

    #Create needed PAM file
    if [[ ! -e /etc/pam.d/waylandloginmanager ]]
    then
        echo "#%PAM-1.0
session [success=ok ignore=ignore module_unknown=ignore default=bad] pam_selinux.so close
auth            optional        pam_group.so
auth            sufficient      pam_rootok.so
session         optional        pam_keyinit.so revoke
session         required        pam_limits.so
session         required        pam_unix.so
session         optional        pam_systemd.so type=wayland
session         optional        pam_ecryptfs.so unwrap
" > /etc/pam.d/waylandloginmanager
    fi
    if [[ ! -e /etc/pam.d/waylandloginmanager-loginmanagerdisplay ]]
    then
      cp /etc/pam.d/waylandloginmanager /etc/pam.d/waylandloginmanager-loginmanagerdisplay
      sed -i 's/type=wayland/type=wayland class=greeter/g' /etc/pam.d/waylandloginmanager-loginmanagerdisplay
    fi

    if [[ ! -e /lib/udev/rules.d/70-uaccess-fbdev.rules ]]
    then
      echo "ACTION=="remove", GOTO="uaccess_fbdev_end"
ENV{MAJOR}=="", GOTO="uaccess_fbdev_end"


# Framebuffer devices
SUBSYSTEM=="graphics", KERNEL=="fb*", TAG+="uaccess"

LABEL="uaccess_fbdev_end"" > /lib/udev/rules.d/70-uaccess-fbdev.rules
    fi
  fi

  #prevent the WaylandLoginManager from being killed with CTRL+C
  trap '' 2

  #Array that contains the time stamps of the creation date of the seats
  SeatCreationDates=()

  #Attempt to import fast user switching data from a crashed WaylandLoginManager
  if [[ -e /run/waylandloginmanager/sessiondata ]]
  then
    . /run/waylandloginmanager/sessiondata
  else
    touch /run/waylandloginmanager/sessiondata
    chmod 700 /run/waylandloginmanager/sessiondata
  fi

  #Set up the needed environment variables
  cd /run/waylandloginmanager

  #Enable job control in this script
  set -m

  #Set Wayland/runtime vars
  export PATH=/opt/bin:$PATH
  export DEB_HOST_MULTIARCH=$(dpkg-architecture -qDEB_HOST_MULTIARCH 2>/dev/null)
  export LD_LIBRARY_PATH=/opt/lib/$DEB_HOST_MULTIARCH:/usr/local/lib/$DEB_HOST_MULTIARCH:/usr/lib/$DEB_HOST_MULTIARCH:/opt/lib:/usr/local/lib:/usr/lib
  export XDG_DATA_DIRS=/opt/share:/usr/share
  export GDK_BACKEND=wayland
  #Set the default path for weston
  export DEFAULTWAYLANDSERVER=$(which weston)
  #Specify where wsession files are found
  export WSESSIONSPATH="/usr/share/wsessions.d"
  export WESTON_PLUGIN_PATH=/opt/lib/$DEB_HOST_MULTIARCH/weston

  ####These settings are dependant on Weston patches####
  export WESTON_FBDEV_SEAT_AWARE=1
  export ONLY_CAN_MULTISESSION_SESSION_SWITCH=0
  ######################################################

  #set MinimumTTY to be 7. this causes the first TTY to try to put the WaylandLoginManager on as tty8.
  MinimumTTY=7
  #default the number of sessions registered to be 0 if unset
  if [[ -z $AllSessions ]]
  then
    export AllSessions=0
  fi

  #Determine if this is running on a live instance, if the root filesystem is overlayfs.
  FSTYPE=$(df / -T | awk '{print $2}' | grep -v Type)
  if [[ $FSTYPE =~ overlay ]]
  then
    ISLIVE=1
  fi

  ZENITYCMD="runuser -u $LOGINMANAGERDISPLAYUSER -m -- zenity"
  TERMINALCMD="runuser -u $LOGINMANAGERDISPLAYUSER -m -- vte"
  WESTONINFOCMD="runuser -u $LOGINMANAGERDISPLAYUSER -m -- weston-info"

  #Detect hardware abilities, first try to see if the system has kernel mode setting, then try framebuffer. if both aren't supported, bring up a text mode dialog
  if [[ $(ls  /dev/dri/card* 2>/dev/null ) && $(grep -c "\bwlmforcefbdev\b" /proc/cmdline) == 0 && $(GetSeatConfigKey wlmforcefbdev "" 0 ) == 0 ]]
  then 
    WriteToLog "Kernel mode setting found." 1
    HardwareSupported=1
  else
    WriteToLog "No kernel mode setting found. Using the framebuffer" 1
  fi
  if [[ $(ls  /dev/fb* 2>/dev/null) && $(grep -c "\bwlmnofbdev\b" /proc/cmdline) == 0 && $(GetSeatConfigKey wlmnofbdev "" 0 ) == 0 ]]
  then
    WriteToLog "Frame buffer support found." 1
    if [[ $(grep -c "\bwlmglobalfbpermissions\b" /proc/cmdline) != 0 ]]
    then
      WriteToLog "WARNING: The 'wlmglobalfbpermissions' option has been passed to the kernel. This causes the waylandloginmanager to give the plugdev group and $LOGINMANAGERDISPLAYUSER access to all framebuffer device files" 1
      setfacl -m "g:plugdev:rwx" /dev/fb*
      setfacl -m "g:$LOGINMANAGERDISPLAYUSER:rwx" /dev/fb*
    fi
    HardwareSupported=1
  else
    WriteToLog "No framebuffer support found" 1
  fi

  if [[ $(grep -c "\bwlmnofbdev\b" /proc/cmdline) != 0 && $(GetSeatConfigKey wlmnofbdev "" 0 ) != 0 ]]
  then
    WriteToLog "Manually override set to disable detection of the framebuffer" 1
  fi

  #if the user booted with a hidden option wlmforcefbdev, set the backend for Weston / Wayland server sessions to be fbdev
  if [[ $(grep -c "\bwlmforcefbdev\b" /proc/cmdline) != 0 && $(GetSeatConfigKey wlmforcefbdev "" 0 ) != 0 ]]
  then
    WriteToLog "Manually override set to use to use the framebuffer" 1
    if [[ $HardwareSupported != 1 ]]
    then
      WriteToLog "ERROR: No framebuffer device found for wlmforcefbdev override!" 1
      openvt -c 63 -s -f -w -- runuser -u $LOGINMANAGERDISPLAYUSER -m -- dialog --msgbox "The wlmforcefbdev overide is set, but no framebuffer device is found!

Will show a menu with a few options for diagnosis." 20 50 --no-cancel
      openvt -c 63 -s -f -w -- rbos-failedboot
      systemctl stop waylandloginmanager.service &> /dev/null
    fi
  fi

  #if there is no Framebuffer or Kernel mode setting, tell the user with a text mode dialog on TTY63, and restart.
  #Depending if this is a live session or not, tell the user how to configure grub if it is installed, or to specify a boot option for the framebuffer from the menu if its live
  if [[ $HardwareSupported != 1 ]]
  then
    if [[ $ISLIVE == 1 ]]
    then
      WriteToLog "ERROR: No supportable hardware found" 1
      openvt -c 63 -s -f -w -- runuser -u $LOGINMANAGERDISPLAYUSER -m -- dialog --msgbox "No Kernel Mode Setting, or Framebuffer device found.

This means your video card does not support KMS, and doesn't create a framebuffer by default. either of which are needed for Weston to work.

You can select a Framebuffer boot option when you start the Live CD, to force a boot with a framebuffer device." 20 50 --no-cancel
    else 
      openvt -c 63 -s -f -w -- runuser -u $LOGINMANAGERDISPLAYUSER -m -- dialog --msgbox "No Kernel Mode Setting, or Framebuffer device found.

This means your video card does not support KMS, and doesn't create a framebuffer by default. either of which are needed for Weston to work.

Will now start a utility to assist you in configuring your system to boot with a framebuffer device." 20 50 --no-cancel
      openvt -c 63 -s -f -w -- rbos-add-framebuffer
    fi
    openvt -c 63 -s -f -w -- runuser -u $LOGINMANAGERDISPLAYUSER -m -- dialog --msgbox "Can not start Weston.

Will now reboot." 20 50 --no-cancel
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Reboot boolean:true
    systemctl stop waylandloginmanager.service &> /dev/null
  fi

  ReadyNotifySent=0
  #Get the TTY that will hold the Wayland server that displays the login screen for seat0
  if ls /run/user/$LOGINMANAGERDISPLAYUID/loginmanagerdisplay_* 1> /dev/null 2>&1
  then
    RUNNINGWLMCOUNT=$(systemctl show wlm-loginmanagerdisplay_*.service -p MainPID --value |& wc -l )
  else
    RUNNINGWLMCOUNT=0
  fi
  OLDSEAT0WLMPID=$(systemctl show wlm-loginmanagerdisplay_seat0.service -p MainPID --value 2>/dev/null)
  if [[ $RUNNINGWLMCOUNT != 0 ]]
  then
    if [[ $OLDSEAT0WLMPID != 0 ]]
    then
      LOGINMANAGERDISPLAYTTY=$(systemctl show wlm-loginmanagerdisplay_seat0.service -p TTYPath --value | sed 's|/dev/tty||g')
    else
      LOGINMANAGERDISPLAYTTY=$(GetNextTTY)
    fi
    systemd-notify --ready &> /dev/null
  else
    LOGINMANAGERDISPLAYTTY=$(GetNextTTY)
  fi

  MinimumTTY=$LOGINMANAGERDISPLAYTTY
  if [[ $LOGINMANAGERDISPLAYTTY -eq -1 ]]
  then
    WriteToLog "ERROR: Not Enough TTYs for login manager display!" 1
    systemctl stop waylandloginmanager.service &> /dev/null
    exit 1
  fi

  #Enable full alt+sysrq, and allow a debug login terminal window when wlmdebug is passed as a kernel argument. This is for testing general issues with the waylandloginmanager
  if [[ $(grep -c "\bwlmdebug\b" /proc/cmdline) != 0 ]]
  then
    echo 1 > /proc/sys/kernel/sysrq
    WriteToLog "WARNING: The diagnostic 'wlmdebug' option has been passed to the kernel, or the system is in Live CD mode. This causes the waylandloginmanager to enable all magic sysrq keys, including the ability to kill processes, and the waylandloginmanager will respond to the Debug command when sent to the main control FIFO, by spawning a graphical login terminal window on the loginmanagerdisplay" 1
    wlmdebug=1
  fi

  #Enable full alt+sysrq, and allow a debug root terminal window when wlmdebuginsecure is passed as a kernel argument, this is for testing commands that need to be run within the same context as the waylandloginmanager
  if [[ $(grep -c "\bwlmdebuginsecure\b" /proc/cmdline) != 0 ]]
  then
    echo 1 > /proc/sys/kernel/sysrq
    WriteToLog "WARNING: The diagnostic and insecure 'wlmdebuginsecure' option has been passed to the kernel. This causes the waylandloginmanager to enable all magic sysrq keys, including the ability to kill processes, and the waylandloginmanager will respond to the Debug command when sent to the main control FIFO, by spawning a graphical ROOT terminal window on the loginmanagerdisplay" 1
    wlmdebug=1
    wlmdebuginsecure=1
  fi
  
  #if /etc/waylandloginmanager.conf exists, use the autologin user specified in that file, if not try the lightdm config file
  if [[ -e /etc/waylandloginmanager.conf ]]
  then
    chmod 755 /etc/waylandloginmanager.conf
  else
    if [[ -e /etc/lightdm/lightdm.conf ]]
    then
      AUTOLOGINUSER=$(awk -F "#" '{print $1}' /etc/lightdm/lightdm.conf | grep ^autologin-user= | awk -F = '{print $2}' | head -1 )
      echo "autologin-user=$AUTOLOGINUSER" >> /etc/waylandloginmanager.conf
    fi
  fi

  HOSTNAME=$(hostname)
  MACHINE_ID=$(cat /var/lib/dbus/machine-id)
}


#This function sends the KDSETMODE ioctl (0x4B3A) with the parameter KD_TEXT (0x00) to the TTY number specified in the first argument, then it sends the VT_SETMODE ioctl (0x5602) with the parameter VT_AUTO (0x00) to the active TTY
#This forces the TTY to be in a state that allows the kernel to switch the TTY (switching to VT_AUTO), instead of a process (VT_PROCESS), when it's in VT_PROCESS, and the process is defunct, the TTY switch fails.
function ResetTTYMode
{
    python3 -c "from array import array; \
from fcntl import ioctl; \
buf = array('h', [0]); \
buf[0] = 0; \
fd = open('/dev/tty$1', 'wb'); \
ioctl(fd, 0x4B3A, 0); \
ioctl(fd, 0x05602, buf); \
fd.close()" &>/dev/null
}

#This function sends the KDSETMODE ioctl (0x4B3A) with the parameter KD_GRAPHICS (0x01) to the TTY number specified in the first argument, to prevent keyboard input from appearing from between the time the switch to the TTY, and before the display server starts.
function SetTTYModeGraphics
{
    python3 -c "from array import array; \
from fcntl import ioctl; \
buf = array('h', [0]); \
buf[0] = 0; \
fd = open('/dev/tty$1', 'wb'); \
ioctl(fd, 0x4B3A, 1); \
fd.close()" &>/dev/null
}

#This function is used by the WaylandLoginManager to find the next availible tty, starting from CalcTTY+1
#it prints the TTY number to stdio. takes no arguments. If it can't find an open tty, it returns -1
function GetNextTTY
{
  SYSTEMDTTYS=()
  #Only seat0 has TTYs
  SESSIONS=($(loginctl show-seat seat0 -p Sessions --value 2>/dev/null ))
  for SESSION in ${SESSIONS[@]}
  do
    SYSTEMDTTYS+=($(loginctl show-session $SESSION -p TTY --value 2>/dev/null))
  done

  TTYNotInLogind=0
  TTYNotInUse=0
  CalcTTY=$MinimumTTY
  #cycle through all ttys, stopping at tty63, as tty63 is 'reserved' by the waylandloginmanager as the tty to switch to in between sessions, as there is issues switching directly between two Weston servers.
  while [[ ($TTYNotInUse -ne 1 && $CalcTTY -lt 62) || $TTYNotInLogind -gt 0 ]]
  do
    ((CalcTTY++))
    fuser -s /dev/tty$CalcTTY &>/dev/null
    TTYNotInUse=$?
    TTYNotInLogind=0
    for SYSTEMDTTY in ${SYSTEMDTTYS[@]}
    do
      if [[ $SYSTEMDTTY == "/dev/tty$CalcTTY" ]]
      then
        ((TTYNotInLogind++))
      fi
    done
  done

  if [[ $TTYNotInUse -ne 1 ]]
  then
    AvailibleTTY=-1
  else
    AvailibleTTY=$CalcTTY
  fi

  echo $AvailibleTTY
}

#Export session data so the waylandloginmanager has user switching data in case of a reload
function ExportSessionData
{
  EXPORTSTRING=$(declare -p AllSessions AllSessionTTYs AllSessionPIDs AllSessionUsers AllSessionIDs AllSeatIDs SeatCreationDates 2>/dev/null)
  echo "${EXPORTSTRING//declare/declare -g}" > /run/waylandloginmanager/sessiondata
}

#This function sends a command to the waylandloginmanager's own loginmanager_control FIFO. It takes 2 arguments, the command to send to the command FIFO, and the relevant seat
function SendSelfCommand
{
  SENDCOMMAND=$1
  SENDSEATARG=$2
  while [[ -e /run/waylandloginmanager/fifolock ]]
  do
    $SLEEPCMD 1
  done
  echo -e "\n$SENDCOMMAND@$SENDSEATARG" > /run/waylandloginmanager/loginmanager_control
}

#This function sends registration data to the waylandloginmanager's own loginmanager_register FIFO. It takes 1 argument, the data string to send to the registration FIFO.
function SendSelfRegisterData
{
  SENDDATA=$1
  while [[ -e /run/waylandloginmanager/fifolock ]]
  do
    $SLEEPCMD 1
  done
  echo "$SENDDATA" > /run/waylandloginmanager/loginmanager_register &
  SendSelfCommand RegisterSession
}

#This function is called when the loginmanager_control FIFO recives the command "RegisterSession". This function will read the contents of loginmanager_register, which only root can write to. 
#Before a process calls RegisterSession to loginmanager_control, the process must also start an attempt to send the data to loginmanager_register, because the timeout period is .01 seconds. If nothing is in loginmanager_register, as if it's not called correctly, or because it's an underprivlaged process that can't write to loginmanager_register, it is ignored.
#it expects the data to be sent in fields seperated by the , character in this order:
# NEWSESSION,TTY_Number,PID_of_Session_Process,User_Name,logind_Session_ID,SEAT,DoLock
function RegisterSession
{
  #get the data from loginmanager_register
  exec 1001<> /run/waylandloginmanager/loginmanager_register
  RegisterDataLines=$(while read -n 100 -t .01 data <&1001; do echo $data; done)
  exec 1001>&-
  IFS=$'\n'
  RegisterDataLines=($RegisterDataLines)
  unset IFS


  for RegisterData in "${RegisterDataLines[@]}"
  do
    #get the register data, and put it into an array so it can be handled
    IFS=','
    ArraySessionData=($RegisterData)
    unset IFS
    RegisterType=${ArraySessionData[0]}
    if [[ ! -z $RegisterData ]]
    then
      WriteToLog "received session data $RegisterData" 0
      if [[ $RegisterType == NEWSESSION ]]
      then
        #Add the session data to the arrays that store info about the sessions.
        SessionTTY=${ArraySessionData[1]}
        SessionPID=${ArraySessionData[2]}
        SessionUser=${ArraySessionData[3]}
        SessionID=${ArraySessionData[4]}
        SessionSeatID=${ArraySessionData[5]}
        SessionDoLock=${ArraySessionData[6]}
        if [[ ! -z $SessionTTY && ! -z $SessionPID && ! -z $SessionUser && ! -z $SessionID ]]
        then
          AllSessionTTYs+=("$SessionTTY")
          AllSessionPIDs+=("$SessionPID")
          AllSessionUsers+=("$SessionUser")
          AllSessionIDs+=("$SessionID")
          AllSeatIDs+=("$SessionSeatID")
          #increment the number of running sessions, now that one is added and running successfuly
          ((AllSessions++))
          #Export the Session data
          ExportSessionData
          if [[ $SessionDoLock == 1 && $ISLIVE != 1 ]]
          then
            loginctl lock-session $SessionID 2> /dev/null
          fi
        else
          WriteToLog "Session failed to start" 1
          SessionStartFailed=1
          if [[ $SessionTTY != 0 ]]
          then
            FailedSessionTTY=$SessionTTY
          fi
          FailedSessionSeat+=("$SessionSeatID")
        fi
      else
        WriteToLog "register session requested, but no data was availible in the FIFO" 1
      fi
    fi
  done
}

#This function takes three arguments. The first is the number of seconds to wait, and the second is the string to show in the dialog. it shows a Zenity dialog with a progress bar to count down the specified time, with the string. The third is the seat to display it on
function DialogWait
{
  GetStartedSeatIndex $3
  SeatFileName=${SeatFileNames[$ReturnSeatIndex]}
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$SeatFileName"
  SetFallbackEnvironmentVariables $3
  waitseconds=$1
  displaystring="$2"
  countseconds=0
  while [[ $countseconds -lt $waitseconds ]]
  do
    percent=$(( $countseconds * 100 / $waitseconds ))
    echo $percent
    ((countseconds++))
    $SLEEPCMD 1
  done | $ZENITYCMD --width=450 --title="Login Manager" --no-cancel --progress --auto-close --text="$displaystring" 2>/dev/null
}

#This function takes 1 argument, the seat that the loginmanagerdisplay belongs to, and waits for the loginmanagerdisplay to startup
function DisplayServerWait
{
  GetStartedSeatIndex $1
  SeatFileName=${SeatFileNames[$ReturnSeatIndex]}
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$SeatFileName"
  command -v weston-info &> /dev/null
  WestonInfoResult=$?
  if [[ $WestonInfoResult == 0 ]]
  then
    while [[ $($WESTONINFOCMD &>/dev/null; echo $?) != 0 ]]
    do
      $SLEEPCMD 1
    done
  else
    while [[ $(fuser -s /run/user/$LOGINMANAGERDISPLAYUID/loginmanagerdisplay_"$SeatFileName" &>/dev/null; echo $?) == 1 ]]
    do
      $SLEEPCMD 1
    done
  fi
}

#This is called by GetUserCredentials and by StartAutoLogin. This allows the user select the session they want to use, similar to how X login managers prompt for the session before the login.
#it exports the WSESSIONDATA variable, which contains arguments and varaibles and the command to run to start a session
#It takes 1 argument, the seat to show the dialogs on
function ChooseSessionType
{
  CurrentHandleSeat="$1"
  GetStartedSeatIndex $CurrentHandleSeat
  SeatFileName=${SeatFileNames[$ReturnSeatIndex]}
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$SeatFileName"
  SetFallbackEnvironmentVariables $CurrentHandleSeat
  #The number of Session IDs start from 0. when a session is added, the number of running sessions is 1 for the next session. The second session gets the ID of 1 etc...
  export SESSIONID=${AllSessions}000
  export WAYLAND_HOST=wlhost-$SESSIONID-$SeatFileName
  export WAYLAND_GUEST=wayland-$SESSIONID-$SeatFileName

  unset WSESSIONLIST
  FirstRunNotRan=0

  #Check the hardware in this seat, to see what backends will be supported
  SeatDefaultBackendType=""
  SeatSupportedBackends=()
  SeatSupportedBackendsString=""
  if [[ $(grep -c "\bwlmforcefbdev\b" /proc/cmdline ) == 0 && $(GetSeatConfigKey wlmforcefbdev "$CurrentHandleSeat" 0 ) == 0 ]]
  then
    SeatSupportsKMS=$(loginctl seat-status "$CurrentHandleSeat" 2>/dev/null |grep -e "/drm/card[0-9]*$" -c)
  else
    SeatSupportsKMS=0
  fi
  if [[ $(grep -c "\bwlmnofbdev\b" /proc/cmdline ) == 0 && $(GetSeatConfigKey wlmnofbdev "$CurrentHandleSeat" 0 ) == 0 ]]
  then
    SeatSupportsFB=$(loginctl seat-status "$CurrentHandleSeat" 2>/dev/null |grep -e "/graphics/fb[0-9]*$" -c)
  else
    SeatSupportsFB=0
  fi
  FB0INSEAT=$(loginctl seat-status "$CurrentHandleSeat" 2>/dev/null |grep -e "/graphics/fb0$" -c)
  #If the kernel mode setting is disabled system wide globally, or just for this seat, do not include kernel mode setting
  #for this seat
  if [[ $SeatSupportsKMS != 0 ]]
  then
    SeatSupportedBackends+=(KMS)
    SeatSupportedBackendsString+="KMS "
    SeatDefaultBackendType=KMS
  fi
  if [[ $SeatSupportsKMS != 0 || ($SeatSupportsFB != 0 && $WESTON_FBDEV_SEAT_AWARE == 1 ) ]]
  then
    SeatSupportedBackends+=(WL)
    SeatSupportedBackendsString+="WL "
  else
    if [[ $FB0INSEAT != 0 ]]
    then
      SeatSupportedBackends+=(WL)
      SeatSupportedBackendsString+="WL "
    fi
  fi
  if [[ $SeatSupportsFB != 0 ]]
  then
    SeatSupportedBackends+=(FB)
    if [[ -z $SeatDefaultBackendType ]]
    then
      SeatDefaultBackendType=FB
      SeatSupportedBackendsString+="FB "
    fi
  fi

  #Find all wsession files, smaller than 16kb
  WSESSIONFILELIST=$(find $WSESSIONSPATH -maxdepth 1 -type f -size -16384c -o -size 16384c -name *.desktop)
  LARGEWSESSIONFILES=$(find $WSESSIONSPATH -maxdepth 1 -type f -size +16384c -name *.desktop -printf "\'%p\' ")
  if [[ ! -z $LARGEWSESSIONFILES ]]
  then
    WriteToLog "The following files: $LARGEWSESSIONFILES have been ignored because they are too large"
  fi

  #Read all the wsession .desktop files
  DesktopFileData=$(gawk 'BEGIN{filenum+=1} {print $0 "#" filenum} \
    ENDFILE {print "[Desktop Entry]#" filenum; print "PhysicalFileName=" FILENAME "#" filenum; \
    print "Enabled=#" filenum; print "Name=#" filenum; print "Comment=#" filenum; print "Type=#" filenum; \
    print "IsFallbackSession=#" filenum; print "CompositorDisplayArgument=#" filenum; \
    print "CompositorSeatArgument=#" filenum; print "SessionArgument=#" filenum; \
    print "AdditionalArguments=#" filenum; print "CompositorExec=#" filenum; \
    print "EnvironmentFile=#" filenum; print "EOF=#" filenum; \
    filenum+=1}' $WSESSIONFILELIST | awk '/\[Desktop Entry]/{flag=1;next}/\[/{flag=0}flag' )

  #Create the arrays for the common attributes for each wsession
  DesktopFileDataArrays=$(echo "$DesktopFileData" | sed -e 's/[0-9][0-9][0-9]#//g' -e 's/^ *Enabled *= */000#/' \
    -e 's/^ *Name *= */001#/' -e 's/^ *Comment *= */002#/' -e 's/^ *Type *= */003#/' -e 's/^ *IsFallbackSession *= */004#/' \
    -e 's/^ *CompositorDisplayArgument *= */005#/' -e 's/^ *CompositorSeatArgument *= */006#/' -e 's/^ *SessionArgument *= */007#/' \
    -e 's/^ *AdditionalArguments *= */008#/' -e 's/^ *CompositorExec *= */009#/' -e 's/^ *EnvironmentFile *= */010#/' \
    -e 's/^ *PhysicalFileName *= */011#/' -e 's/^ *EOF *= */012#/' \
    -e "/^[0-9][0-9][0-9]#/!d" | sort -t "#" -nk 3,3 -k1,1 -u | sed -e 's/#[[:digit:]]\+$//g' -e 's/012#/\r/g' )
  DesktopFileDataArrays=${DesktopFileDataArrays//$'\n'$'\r'$'\n'/$'\r'}
  IFS=$'\r'
  DesktopFileDataArrays=(${DesktopFileDataArrays//$'\n'$'\r'/})
  unset IFS

  #Get the number of files in the array
  DesktopFileCount=${#DesktopFileDataArrays[@]}

  #Build the array containing NeedsFile lines (as there can be more than one, and not fixed in DesktopFileDataArrays
  NeedsFileArrays=$(echo "$DesktopFileData" | sed -e 's/[0-9][0-9][0-9]#//g' \
    -e 's/^ *NeedsFile *= */000#/' -e 's/^ *PhysicalFileName *= */001#/' \
    -e 's/^ *EOF *= */002#/' \
    -e "/[0-9][0-9][0-9]#/!d" | perl -pe 's/\$(\w+)/$ENV{$1}/g' | sort -t "#" -k 3,3 -k 1,1 | sed -e 's/#[[:digit:]]\+$//g' -e 's/002#/\r/g')
  NeedsFileArrays=${NeedsFileArrays//$'\n'$'\r'$'\n'/$'\r'}
  IFS=$'\r'
  NeedsFileArrays=(${NeedsFileArrays//$'\n'$'\r'/})
  unset IFS

  #Create a line of placeholders for the array for the backend hardware support information for the wsessions
  #This will keep the array a fixed size
  SeatBackendArrayPlaceholders=""
  for (( iterator=1 ; iterator <= $DesktopFileCount ; iterator++ ))
  do
    for BACKEND in KMS WL FB
    do
      BackendPlaceHolders=""
      BackendPlaceHolders+=$'\n'"CompositorSupports${BACKEND}=#$iterator"
      BackendPlaceHolders+=$'\n'"Compositor${BACKEND}Arguments=#$iterator"
      BackendPlaceHolders+=$'\n'"Compositor${BACKEND}SeatAware=#$iterator"
      BackendPlaceHolders+=$'\n'"Compositor${BACKEND}SeatArgument=#$iterator"
      SeatBackendArrayPlaceholders+=$'\n'$BackendPlaceHolders$'\n'
    done
  done

  SeatBackendArrays=$(echo "$DesktopFileData"$'\n'"$SeatBackendArrayPlaceholders" | sed  -e 's/[0-9][0-9][0-9]#//g' \
    -re "s/^ *CompositorSupports(KMS|WL|FB) *= */000#000#\1#/" \
    -re  "s/^ *Compositor(KMS|WL|FB)Arguments *= */000#001#\1#/" \
    -re  "s/^ *Compositor(KMS|WL|FB)SeatAware *= */000#002#\1#/" \
    -re  "s/^ *Compositor(KMS|WL|FB)SeatArgument *= */000#003#\1#/" \
    -e 's/^ *EOF *= */001#999#999#/' \
    -e "/^[0-9][0-9][0-9]#/!d" | sed -re 's/^([0-9][0-9][0-9]#[0-9][0-9][0-9])#KMS#/\1#100#/g' \
    -re 's/^([0-9][0-9][0-9]#[0-9][0-9][0-9])#WL#/\1#101#/g' \
    -re 's/^([0-9][0-9][0-9]#[0-9][0-9][0-9])#FB#/\1#102#/g' | sort -t "#"  -k5,5 -k1,1 -u -k3,3 -k2,2 | sed -re 's/^([0-9][0-9][0-9]#[0-9][0-9][0-9])#100#/\1#KMS#/g' \
    -re 's/^([0-9][0-9][0-9]#[0-9][0-9][0-9])#101#/\1#WL#/g' \
    -re 's/^([0-9][0-9][0-9]#[0-9][0-9][0-9])#102#/\1#FB#/g' | sed -e 's/#[[:digit:]]\+$//g' -e 's/001#999#999#/\r/g')
  SeatBackendArrays=${SeatBackendArrays//$'\n'$'\r'$'\n'/$'\r'}
  IFS=$'\r'
  SeatBackendArrays=(${SeatBackendArrays//$'\n'$'\r'/})
  unset IFS

  #Unset the string containing the raw text of the .desktop files
  unset DesktopFileData
  unset SeatBackendArrayPlaceholders

  #Use the arrays created from parsing the wsession files, to determine if each is supported, and to construct the list that will be shown in the dialog
  for (( wsessionnum=0 ; wsessionnum < $DesktopFileCount ; wsessionnum++ ))
  do
    #The array with a fixed layout for the values, for this wsession.
    IFS=$'\n'
    DesktopFileDataArray=(${DesktopFileDataArrays[$wsessionnum]})
    unset IFS

    #The array of arrays (each line has three fields seperated by #, which is then treated as an array) describing the backends supported by the session
    IFS=$'\n'
    SeatBackendArray=(${SeatBackendArrays[$wsessionnum]})
    unset IFS

    #The array of all NeedsFile lines specified
    IFS=$'\n'
    NeedsFileArray=(${NeedsFileArrays[$wsessionnum]})
    unset IFS

    Enabled=${DesktopFileDataArray[0]:4}
    SessionName=${DesktopFileDataArray[1]:4}
    SessionComment=${DesktopFileDataArray[2]:4}
    Type=${DesktopFileDataArray[3]:4}

    #Search for backends supported by the compositor, with the backends the hardware supports. Give presence to the first one found in the array of supported backend types, the best backend types are first in the array
    #Get the hardware support status
    SupportsBackend=0
    for SEATBACKEND in ${SeatSupportedBackends[@]}
    do
      export BackendType=$SEATBACKEND
      SupportsSeat=0
      unset BackendSeatArgument
      unset BackendArguments
      for (( element1 = 0 ; element1 < ${#SeatBackendArray[@]} ; element1=element1+4 ))
      do
        IFS="#"
        #Stores the values from the config file if this session supports a paticular backend in general
        BackendSupportedArray=(${SeatBackendArray[$element1]})
        #Stores the values from the config file on the arguments used to start the session with a paticular backend
        BackendArgumentArray=(${SeatBackendArray[$element1+1]})
        #Stores the values from the config file if each backend is seat aware
        BackendCanSeatArray=(${SeatBackendArray[$element1+2]})
        #Stores the arguments declared in the config file to specify the seat for each availible backend
        BackendSeatArgArray=(${SeatBackendArray[$element1+3]})
        unset IFS
        if [[ ${BackendSupportedArray[2]} == $BackendType ]]
        then
          #If this is seat0, then don't enforce seatawareness, if the first framebuffer device is in seat0
          if [[ $CurrentHandleSeat == seat0 && $BackendType == "FB" ]]
          then
            if [[ $FB0INSEAT == 1 ]]
            then
              SupportsSeat=1
            fi
          #If this is seat0, then this session is implied to be supported on this seat (since ones that don't only run on seat0).
          elif [[ $CurrentHandleSeat == seat0 && $BackendType != "FB" ]]
          then
            SupportsSeat=1
          #If the wayland (fullscreen shell) backend is supported by this session, and the wayland backend is supported on this seat, then seats are supported, since the weston hosts are seat aware
          elif [[ $BackendType == "WL" ]]
          then
            SupportsSeat=1
          fi
          #If none of these seat support overrides declare that this session can run on this seat, get it's config value if it can run on the seat
          if [[ $SupportsSeat == 0 ]]
          then
            SupportsSeat=${BackendCanSeatArray[3]}
          fi
          SupportsBackend=${BackendSupportedArray[3]}
          if [[ $SupportsBackend == 1 && $SupportsSeat == 1 ]]
          then
            BackendArguments=${BackendArgumentArray[3]}
            BackendSeatArgument=${BackendSeatArgArray[3]}
            break
          fi
        fi
      done
      if [[ $SupportsBackend == 1 && $SupportsSeat == 1 ]]
      then
        break
      fi
    done


    IsFallbackSession=${DesktopFileDataArray[4]:4}
    if [[ -z $IsFallbackSession ]]
    then
      IsFallbackSession=0
    fi
    CompositorDisplayArgument=${DesktopFileDataArray[5]:4}
    CompositorSeatArgument=${DesktopFileDataArray[6]:4}
    #The backend argument might be different. If one is set for this backend, override.
    if [[ ! -z $BackendSeatArgument ]]
    then
      CompositorSeatArgument=$BackendSeatArgument
    fi
    SessionArgument=${DesktopFileDataArray[7]:4}
    AdditionalArguments=${DesktopFileDataArray[8]:4}
    CompositorExec=${DesktopFileDataArray[9]:4}
    EnvironmentFile=${DesktopFileDataArray[10]:4}
    WSessionFilePath=${DesktopFileDataArray[11]:4}

    if [[ ! -x $WSessionFilePath ]]
    then
      WriteToLog "Warning: $WSessionFilePath is not executable, the session will not be availible for selection by the user." 0
    fi

    if [[ -z "$EnvironmentFile" ]]
    then
      EnvironmentFile=$WSessionFilePath
    fi

    #Iterate through all NeedsFile values, to make sure that they exist. if one doesn't exist increment NotFoundCount.
    NotFoundCount=0
    for NeedsFile in ${NeedsFileArray[@]}
    do
      NeedsFile=${NeedsFile:4}
      if [[ ! -e $NeedsFile && -n $NeedsFile ]]
      then
        WriteToLog "Warning: Cannot find needed file $NeedsFile for $WSessionFilePath , the session will not be availible for selection by the user." 0
        ((NotFoundCount++))
      fi
    done

    if [[ $Enabled != 1 ]]
    then
      WriteToLog "Warning: $WSessionFilePath is disabled, the session will not be availible for selection by the user." 0
    fi

    if [[ $SupportsBackend != 1 ]]
    then
      WriteToLog "Warning: $WSessionFilePath can't run on any backends supported by this seat: $SeatSupportedBackendsString , the session will not be availible for selection by the user." 0
    fi

    if [[ $SupportsBackend == 1 && $SupportsSeat != 1 ]]
    then
      WriteToLog "Warning: $WSessionFilePath backends $BackendType does not support seats, the session will not be availible for selection by the user." 0
    fi

    if [[ $Type != "WSession" ]]
    then
      WriteToLog "Warning: $WSessionFilePath does not have a Type of 'WSession' , the session will not be availible for selection by the user." 0
    fi

    #if the session supports the CompositorDisplayArgument, for setting the WAYLAND_DISPLAY it should use, then ammend the WAYLAND_GUEST to the end of the command.
    if [[ ! -z $CompositorDisplayArgument ]]
    then
      CompositorDisplayArgument="$CompositorDisplayArgument$WAYLAND_GUEST"
    else 
      CompositorDisplayArgument=""
    fi

    #if the session supports the CompositorSeatArgument, for setting the XDG_SEAT it should use, then ammend the CurrentHandleSeat to the end of the command.
    if [[ ! -z $CompositorSeatArgument && $BackendType != "WL" ]]
    then
      CompositorSeatArgument="$CompositorSeatArgument$CurrentHandleSeat"
    else
      CompositorSeatArgument=""
    fi

    #If the session is enabled, the backend is supported, all the files it needs are there, and its a wsession file, and is executable add the lines describing the session to the string.
    #This is sent through stdio which is added to teh WSESSIONLIST variable
    if [[ $NotFoundCount == 0 && $SupportsBackend == 1 && $SupportsSeat == 1 && $Enabled == 1 && $Type == "WSession" && $IsExecutable != 0 ]]
    then
      if [[ $FirstRunNotRan == 0 ]]
      then
        FirstRunNotRan=1
      else
        WSESSIONLIST+=$'\n'
      fi
      WSESSIONLIST+="$CompositorExec"$'\n'
      WSESSIONLIST+="$BackendArguments"$'\n'
      WSESSIONLIST+="$SessionArgument"$'\n'
      WSESSIONLIST+="$CompositorDisplayArgument"$'\n'
      WSESSIONLIST+="$CompositorSeatArgument"$'\n'
      WSESSIONLIST+="$AdditionalArguments"$'\n'
      WSESSIONLIST+="$EnvironmentFile"$'\n'
      WSESSIONLIST+=""$BackendType"_"$SeatDefaultBackendType"_"$IsFallbackSession"_"$'\n'
      WSESSIONLIST+="$SessionName"$'\n'
      WSESSIONLIST+="$SessionComment"
    fi
  done


  #If wsessions where found above then show a ui dialog. If there where none, use a default session.
  if [[ ! -z $WSESSIONLIST ]]
  then
    WSESSIONARRAY=()
    WSESSIONARRAYELEMENT=0
    while read LINE
    do
      WSESSIONARRAY[$WSESSIONARRAYELEMENT]="$LINE"
      ((WSESSIONARRAYELEMENT++))
    done <<< "$WSESSIONLIST"
    WSESSIONCOUNT=$((${#WSESSIONARRAY[@]}/10))

    WSESSIONPICKLIST=""
    for (( element=0; element<$WSESSIONCOUNT; element++ ))
    do
      if [[ ! -z $WSESSIONPICKLIST ]]
      then
        WSESSIONPICKLIST+=$'\n'
      fi
      WSESSIONPICKLIST+=$element$"#"${WSESSIONARRAY[$((8+element*10))]}"#"${WSESSIONARRAY[$((9+element*10))]}
    done
    WSESSIONPICKLIST=$(echo "$WSESSIONPICKLIST" | sort -t "#" -k 2,2 | sed 's/#/\n/g')
    #select the session. Each line is handled as a column. currently there are 9 collumns. So line 1 is is column 1, line 2 is in collumn 2, and line 10 is in collumn 1 again
    #The zenity dialog then outputs the selected session's lines into the WSESSIONDATA variable. each collumn is a different aspect of the wsessions
    WSESSIONNUMBER=$(echo "$WSESSIONPICKLIST" | $ZENITYCMD --title="Pick a Session..." --height=450 --width=630 --list --text "Select a Wayland Desktop Environment to use" --column sessionnumber --column Name --column Comment --hide-column=1 --print-column=1 2>/dev/null )
    #Abort if the user selected cancel on the zenity dialog
    CancelOrOK=$?
    if [[ $CancelOrOK != 0 ]]
    then
      exit 0
    fi
    WSESSIONDATA=${WSESSIONARRAY[$((0+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((1+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((2+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((3+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((4+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((5+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((6+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((7+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((8+WSESSIONNUMBER*10))]}$'\n'

  else
    unset WSESSIONDATA
    unset WSESSIONNUMBER
    $ZENITYCMD --width=500 --warning --text="No sessions are installed, configured correctly, or supported by the hardware in this seat." 2>/dev/null
    WriteToLog "No sessions are installed in $WSESSIONSPATH, configured correctly, or supported by the hardware in this seat, $CurrentHandleSeat ." 1
    exit 1
  fi
}


#This function displays a diagnostic terminal. depending on if the more secure debug option was passed, wlmdebug it, temporarilly copies a setuid /bin/login so that the host terminal window doesn't have to run as root, and the setuid login binary isn't accessible to the rest of the system, and opens the login terminal window running as a service user. If the more insecure wlmdebuginsecure option was passed, then it starts the terminal as root, with a root terminal.
#It takes 1 argument, the seat to display the terminal on
function DiagnosticTerminal 
{
  GetStartedSeatIndex $1
  SeatFileName=${SeatFileNames[$ReturnSeatIndex]}
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$SeatFileName"
  SetFallbackEnvironmentVariables $1
  if [[ $wlmdebuginsecure == 1 ]]
  then
    vte -g 500x300 &>/dev/null
  else
    mkdir -p /var/tmp/waylandloginmanager/logincmd &> /dev/null
    chown $LOGINMANAGERDISPLAYUSER /var/tmp/waylandloginmanager/logincmd &> /dev/null
    chmod 700 /var/tmp/waylandloginmanager/logincmd &> /dev/null
    cp /bin/login /var/tmp/waylandloginmanager/logincmd &> /dev/null
    chmod +s /var/tmp/waylandloginmanager/logincmd/login &> /dev/null
    $TERMINALCMD -g 500x300 -c "screen -s /var/tmp/waylandloginmanager/logincmd/login" &>/dev/null
    wait -n $TERMINALJOB
    rm /var/tmp/waylandloginmanager/logincmd/login &> /dev/null
  fi
}

#This function is called when the loginmanager_control recives the Info command. It brings up a help dialog for the user, about the waylandloginmanager and the system.
#It takes 1 argument, the seat to display the dialog on
function ShowInfo
{
  GetStartedSeatIndex $1
  SeatFileName=${SeatFileNames[$ReturnSeatIndex]}
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$SeatFileName"
  SetFallbackEnvironmentVariables $1
  if [[ $1 == seat0 ]]
  then
    SEATSTRING="This Login Manager Display for seat seat0 is running on tty: $LOGINMANAGERDISPLAYTTY"
  else
    SEATSTRING="This Login Manager Display is for seat $1"
  fi
  SeatCanMultiSession=$(loginctl show-seat "$1" -p CanMultiSession --value 2>/dev/null)
  if [[ $ONLY_CAN_MULTISESSION_SESSION_SWITCH == 0 || $SeatCanMultiSession == "yes" ]]
  then
    SWITCHSTRING=$'\n'"The arrow icon brings up a prompt to switch between running sessions"
  else
    SWITCHSTRING=""
  fi
  GetStartedSeatIndex $1
  SeatIndexID=$ReturnSeatIndex
  SeatDefaultBackendType=${LoginManagerDisplayBackends[$SeatIndexID]}
  #If the backend type is FB, then add a string to tell the user that in the help dialog
  if [[ $SeatDefaultBackendType == "FB" ]]
  then
    BACKENDSTRING="The framebuffer backend is being used for this seat.

This probably means the current video card drivers do not 
support the native kernel mode setting that is optimal for Weston or other Wayland servers.
or the system was started with the wlmforcefbdev argument."
  else
    BACKENDSTRING="Kernel mode setting is being used for this seat.

This is the optimal way to run Weston or other Wayland servers."
  fi
  $ZENITYCMD --title="Information" --no-wrap --info --text="This is a third party fan made distribution!

$BACKENDSTRING

$SEATSTRING

The key icon brings up a login prompt$SWITCHSTRING
The red X icon brings up a shutdown prompt
The i icon shows this help prompt" &> /dev/null

}

#This function is called when the loginmanager_control FIFO recives the command "Switch". It brings up a dialog containing the list of all running login sessions, to allow the user to pick and switch to start a mew session, by containing the FIFO.
#It takes 1 argument, the seat to display the dialog on, and only the sessions belonging to the seat will be shown
function SwitchUserDialog 
{
  GetStartedSeatIndex $1
  SeatFileName=${SeatFileNames[$ReturnSeatIndex]}
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$SeatFileName"
  SetFallbackEnvironmentVariables $1
  unset SessionList
  #get the number of registered sessions
  NumberOfSessions=${#AllSessionPIDs[@]}
  ((NumberOfSessions--))

  #go thorugh each session, reading the arrays containing information about the sessions. to build the SessionList variable
  #The session list variable is multiline, and used by a zenity dialog.
  #line 1 is the session number
  #line 2 is the TTY for the session
  #line 3 is the PID of the session
  #line 4 is the user name
  #line 5 is the logind session id.
  RunningSeatSessions=($(loginctl show-seat "$1" -p Sessions --value 2>/dev/null))
  while [[ $NumberOfSessions -ge 0 ]]
  do
    #determine if the current session is alive, before adding it to the list
    SessionisRunning=0
    for RunningSeatSession in ${RunningSeatSessions[@]}
    do
      if [[ $RunningSeatSession == ${AllSessionIDs[$NumberOfSessions]} ]]
      then
        SessionisRunning=1
        break
      fi
    done

    if [[ $SessionisRunning == 1 ]]
    then
      if [[ ${AllSeatIDs[$NumberOfSessions]} == "$1" ]]
      then
        if [[ ! -z $SessionList ]]
        then
          SessionList+=$'\n'
        fi
        SessionList+="$NumberOfSessions"$'\n'
        SessionList+="${AllSessionIDs[$NumberOfSessions]}"$'\n'
        SessionList+="${AllSessionPIDs[$NumberOfSessions]}"$'\n'
        SessionList+="${AllSessionUsers[$NumberOfSessions]}"$'\n'
        SessionList+="tty${AllSessionTTYs[$NumberOfSessions]}"
      fi
    fi
    ((NumberOfSessions--))
  done
  #Add a element with a sessionid of -1. When the selected element is -1, it prompts for a user login for a new session, with GetUserCredentials
  if [[ ! -z $SessionList ]]
  then
    SessionList+=$'\n'
  fi
  SessionList+="-1"$'\n'
  SessionList+=$'\n'
  SessionList+=$'\n'
  SessionList+="New Session..."$'\n'
  SessionList+=$'\n'




  unset ChangeSession
  #prompt for the list of running sessions, and return the session ID. (which is used in all of the arrays for Session PID, user name, etc)
  ChangeSession=$(echo "$SessionList"  | sed '$d'| $ZENITYCMD --title="Switch User" --height=450 --list --text "Select a running session to change into" --hide-header --column sessionid --column tty --column pid --column username --column ID --print-column=1 --hide-column=1,3,5 --separator="\n" 2>/dev/null )
  CancelOrOK=$?
  #Abort if the user selected cancel on the zenity dialog
  if [[ $CancelOrOK != 0 ]]
  then
    exit 0
  fi
  #if the chosen session is -1 then contact the FIFO with a login prompt, otherwise switch to the selected session
  if [[ $ChangeSession == "-1" ]]
  then
    SendSelfCommand Login "$1"
  else 
    #if a session is selected, then get the PID, TTY, logind session ID with the selected Session ID as the array element number.
    if [[ $ChangeSession ]]
    then
      ChangeSessionPID=${AllSessionPIDs[$ChangeSession]}
      ChangeSessionTTY=${AllSessionTTYs[$ChangeSession]}
      ChangeSessionID=${AllSessionIDs[$ChangeSession]}

      #before switching into a session double check in case if the session crashed after it was listed ealier in the function.
      ChangeSessionState=$(loginctl show-session "$ChangeSessionID" -p State --value 2>/dev/null)
      if [[ $ChangeSessionState == active || $ChangeSessionState == online ]]
      then
        #Only seat0 supports TTYs
        if [[ "$1" == "seat0" ]]
        then
          chvt $ChangeSessionTTY &>/dev/null &
        fi
        #hand over the logind session ID to allow desktop permissions to work.
        loginctl activate $ChangeSessionID &>/dev/null
      else
        $ZENITYCMD --title="Switch User" --warning --text="The selected session was not found. The session may have quit." 2>/dev/null
      fi
    fi
  fi
}

#Function that starts the user sessions, which is called by AuthenticateUser, if the authentication is successful. It takes 5 arguments, TTY number, the seat, user to start the session for, to lock the screen upon session start, and the multiline string, WSESSIONDATA, which contains specific data about how to start paticular sessions
function StartUserSession 
{ 
  #ensure the loginmanager_control fd doesn't get leaked
  exec 1000>&-


  #unset most varaibles, except PATH and WAYLAND_HOST and WAYLAND_GUEST
  while read var
  do 
    unset "$var" &> /dev/null
  done < <(env | awk -F = '{print $1}' | grep -Ev "^WAYLAND_HOST$|^WAYLAND_GUEST$|^PATH$|^SESSIONID$|^ONLY_CAN_MULTISESSION_SESSION_SWITCH$" )

  #save the arguments passed to StartUserSession, and put the third argument into an array
  WSESSIONDATA=()
  WSESSIONARGUMENTELEMENT=0
  while read LINE
  do
    WSESSIONDATA[$WSESSIONARGUMENTELEMENT]="$LINE"
    ((WSESSIONARGUMENTELEMENT++))
  done <<< "$5"
  USERSESSIONTTY=$1
  USERSEAT=$2
  LOGINUSER=$3
  STARTLOCKED=$4
  GetStartedSeatIndex $USERSEAT
  SeatFileName=${SeatFileNames[$ReturnSeatIndex]}

  #Change to the users homepath so weston starts in the right place, and set some varaibles for the user
  export HOME=$(eval echo ~$LOGINUSER)
  export LOGNAME=$LOGINUSER
  export USER=$LOGINUSER
  export USERNAME=$LOGINUSER
  cd "$HOME"

  #The array makes it easy to get the data out of WSESSIONDATA. any variables in the strings are expanded with perl
  #line 1 is the path to the compositor
  #line 2 is the argument to start with a paticular backend
  #line 3 is the argument with paticular session information
  #line 4 is the argument to start the Wayland server with a specific WAYLAND_DISPLAY
  #line 5 is the argument to start the Wayland server on a paticular XDG_SEAT
  #line 6 is any additional arguments needed
  #line 7 specifies the environment file which is processed by the user session, which is documented at the top of the script.
  #line 8 specifies the backend data, which tells the user session what backend is being used, the default one, and if the session file is calling the session with fallback capabilies. This variable is broken up, and exported as BackendType, DefaultBackendType, and IsFallbackSession
  #line 9 specifies the session name for the user and for helpdialog to know what session is running. this is exported as a varaible.
  CompositorExec="$( echo -n "${WSESSIONDATA[0]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  BackendArguments="$( echo -n "${WSESSIONDATA[1]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  SessionArgument="$( echo -n "${WSESSIONDATA[2]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  CompositorDisplayArgument="$( echo -n "${WSESSIONDATA[3]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  CompositorSeatArgument="$( echo -n "${WSESSIONDATA[4]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  AdditionalArguments="$( echo -n "${WSESSIONDATA[5]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  export EnvironmentFile="$( echo -n "${WSESSIONDATA[6]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  BackendData="$( echo -n "${WSESSIONDATA[7]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  export SessionName="$( echo -n "${WSESSIONDATA[8]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  IFS=_
  BackendData=($BackendData)
  unset IFS
  export BackendType=${BackendData[0]}
  export DefaultBackendType=${BackendData[1]}
  export IsFallbackSession=${BackendData[2]}


  #Call the server with the arguments specified by the selected session
  if [[ "$USERSEAT" == seat0 ]]
  then
    TTYSTRING=" on tty $USERSESSIONTTY"
  else
    TTYSTRING=""
  fi

  systemctl reset-failed "$LOGINUSER-wayland-$SESSIONID-$SeatFileName" &> /dev/null
  #Only seat0 supports TTYs
  if [[ "$USERSEAT" == seat0 ]]
  then
    #Reset the contents of the tty
    echo -n -e '\e[3J' > /dev/tty$USERSESSIONTTY
    #Disable cursor blinking on the TTY the display server will be started on
    echo -n -e '\e[?25l' > /dev/tty$USERSESSIONTTY
    chvt $USERSESSIONTTY &>/dev/null &
    SetTTYModeGraphics $USERSESSIONTTY
    OutputArgs="-p TTYPath=/dev/tty"$USERSESSIONTTY" -p StandardOutput=null -p StandardError=null -p StandardInput=tty"
  else
    OutputArgs=""
  fi

  #If multisession is not supported
  RunSession=1
  if [[ $ONLY_CAN_MULTISESSION_SESSION_SWITCH == 1 && "$USERSEAT" != seat0 ]]
  then
    SeatCanMultiSession=$(loginctl show-seat "$USERSEAT" -p CanMultiSession --value 2>/dev/null)
    SeatSessions=($(loginctl show-seat "$USERSEAT" -p Sessions --value 2>/dev/null))
    SeatSessionsCount=${#SeatSessions[@]}
    SeatSessionType=$(loginctl show-session ${SeatSessions[@]} -p Class --value 2>/dev/null)
    if [[ $SeatCanMultiSession != "yes" ]]
    then
      if [[ $SeatSessionsCount == 0 || ( $SeatSessionsCount == 1 && $SeatSessionType == "greeter") ]]
      then
        loginctl kill-session ${SeatSessions[@]} 2>/dev/null
      else
        RunSession=0
      fi
    fi
  fi
  unset ONLY_CAN_MULTISESSION_SESSION_SWITCH

  if [[ $RunSession == 1 ]]
  then
    WriteToLog "Starting server \"$CompositorExec\" with the arguments of \"$BackendArguments\" \"$SessionArgument\" \"$CompositorSeatArgument\" \"$AdditionalArguments\" \"$CompositorDisplayArgument\" for user $LOGINUSER $TTYSTRING on seat $USERSEAT" 1
    systemd-run --unit="$LOGINUSER-wayland-$SESSIONID-$SeatFileName" -p PrivateTmp=yes -p PAMName=waylandloginmanager -p User="$LOGINUSER" $OutputArgs -p WorkingDirectory=\~ --setenv=SessionName="$SessionName" --setenv=BackendType="$BackendType" --setenv=DefaultBackendType="$DefaultBackendType" --setenv=IsFallbackSession="$IsFallbackSession" --setenv=EnvironmentFile="$EnvironmentFile" --setenv=WAYLAND_GUEST=$WAYLAND_GUEST --setenv=XDG_SEAT="$USERSEAT" --setenv=WLM_SEAT=$SeatFileName --setenv=WAYLAND_HOST="$WAYLAND_HOST" $0 --usersession $CompositorExec $BackendArguments  $SessionArgument $CompositorSeatArgument $AdditionalArguments $CompositorDisplayArgument &>/dev/null

    $SLEEPCMD 5
    #Get the PID that was called, by seing which process is the 'leader pid' of the $USERSESSIONTTY tty that the server was started. This is needed to know what TTY to switch to.
    USERSESSIONPID=$(systemctl show "$LOGINUSER-wayland-$SESSIONID-$SeatFileName" -p ExecMainPID --value 2>/dev/null)
    #Find the logind session id, by trying to find out what session is lead by the $USERSESSIONPID. This is needed to know what logind session needs to be switched to to enable desktop permissions
    SESSIONS=($(loginctl show-seat "$USERSEAT" -p Sessions --value 2>/dev/null ))
    for SESSION in "${SESSIONS[@]}"
    do
      SessionPid=$(loginctl show-session $SESSION -p Leader --value 2>/dev/null)
      if [[ $SessionPid == $USERSESSIONPID ]]
      then
        LOGINDSESSION=$SESSION
        break
      fi
    done < <(echo "$SESSIONS")

    USERREGISTERDISPLAYNAME=$(getent passwd $LOGINUSER | awk -F : '{print $5}' | awk -F , '{print $1}')
    if [[ -z $USERREGISTERDISPLAYNAME ]]
    then
      USERREGISTERDISPLAYNAME=$LOGINUSER
    else
      USERREGISTERDISPLAYNAME="$USERREGISTERDISPLAYNAME   ($LOGINUSER)"
    fi

    #The logind session activation is needed to enable the desktop permissions for the user. (such as udisks, and shutting down the system, and NetworkManager)
    loginctl activate $LOGINDSESSION &>/dev/null

    #Send the tty number, pid, user name, and logind session ID to loginmanager_register in the background, then tell loginmanager_control to read loginmanager_register.
    SendSelfRegisterData "NEWSESSION,$USERSESSIONTTY,$USERSESSIONPID,$USERREGISTERDISPLAYNAME,$LOGINDSESSION,$USERSEAT,$STARTLOCKED"
  else
    WriteToLog "Too many sessions on $USERSEAT that does not support session switching" 1
  fi
}

#Test users credentials, by making sure the user name and password match by trying to test with su and expect.
#Expect has to be run as a non root user, otherwise it always reports success. Run it as the user specified with $PROBETESTUSER
#it returns failure or success
#This is called by GetUserCredentials, after it collects the user name and password for the user. It reads the password from stdin
#It takes 1 argument, the seat to show the dialogs on.
function AuthenticateUser
{
  GetStartedSeatIndex $1
  SeatFileName=${SeatFileNames[$ReturnSeatIndex]}
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$SeatFileName"
  SetFallbackEnvironmentVariables $1
  unset USERPASSWORD
  TryPassword=$(cat -)
  TryPasswordEscaped=$(for ((Iterate=0; Iterate<${#TryPassword}; Iterate++))
  {
    printf "\\\u%x" "'${TryPassword:$Iterate:1}"
  })
  TryPassword=$TryPasswordEscaped
  unset TryPasswordEscaped

  #usernames should start with - anyway. If a username starts with - , don't attempt to use it
  if [[ ${LOGINUSER:0:1} == '-' ]]
  then
    return 1
  fi
  #Test the users login with an embedded expect script running as PROBETESTUSER
  echo "log_user 0
        spawn su \"$LOGINUSER\" -c /bin/true
        expect Password 
        send $TryPassword\r
        catch wait result
        exit [lindex \$result 3]" |runuser -u $PROBETESTUSER -m -- expect 2>/dev/null
  PasswordResult=$?
  unset TryPassword
  if [[ 0 == $PasswordResult ]]
  then
    export USERHOME=$(eval echo ~$LOGINUSER)
    #Prompt for the session type
    ChooseSessionType "$1"

    #if the password and username is correct, start the session
    if [[ $1 == seat0 ]]
    then
      TTYSTRING="on TTY $SessionTTY"
    else
      TTYSTRING=""
    fi
    WriteToLog "Opening a session for $LOGINUSER $TTYSTRING on seat $1" 1
    DialogWait 3 "Attempting to start the selected session..." "$1"
    StartUserSession "$SessionTTY" "$1" "$LOGINUSER" 0 "$WSESSIONDATA" &
    #report success
    return 0
  else
      #report failure
      return 1
  fi
}


#Get the users username and password by allowing the user to select the username in a list, or enter it manually, and then enter thier password
#This function is called when the loginmanager_control FIFO recives the command "Login"
#It takes 1 argument, the seat to display the login prompt on
function GetUserCredentials
{
  GetStartedSeatIndex $1
  SeatFileName=${SeatFileNames[$ReturnSeatIndex]}
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$SeatFileName"
  SetFallbackEnvironmentVariables $1
  #Get the list of nonsystem users, in each line, there is 1 user, with two feilds, the users 'friendly' name, and then the users system login name, seperated by a :
  #this finds the range of UIDs that are user UIDs, and then finds any users with theses UIDS.
  UIDMIN=$(grep -e "^UID_MIN" /etc/login.defs| awk '{print $2}')
  if [[ $ISLIVE == 1 ]]
  then
    UIDMIN=999
  fi
  UIDMAX=$(grep -e "^UID_MAX" /etc/login.defs| awk '{print $2}')
  USERLIST=$(awk -v UIDMIN=$UIDMIN -v UIDMAX=$UIDMAX -F : '{ if ($3>=UIDMIN && $3 <=UIDMAX) print $5":"$1}' /etc/passwd)
  #sort the list
  USERLIST=$(echo "$USERLIST" | sort |uniq)
  #go through each line of users found, to handle the display of the real name (passwd gecos feild)
  while read USER
  do
    IFS=":"
    #handle the line as an array, with two elements
    UserData=($USER)
    #The passwd gecos feild is formated with username,buildingnumber,phonenumber,otherdata. only get the username subfeild.
    UserDisplayName=$(echo ${UserData[0]} | awk -F , '{print $1}')
    UserName=${UserData[1]}
    #If the user has no display name, then set it to be the users login name
    if [[ -z $UserDisplayName ]]
    then
      UserDisplayName=$UserName
    fi
    #The display in the zenity dialog should be "Firstname Lastname    (loginname)"
    UserDisplayName="$UserDisplayName   (${UserData[1]})" 
    unset IFS
    #add the data to the USERLISTSTRING that gets sent into zenity. Line 1 is the display name, line 2 is the user login name, and then line 3 is the display name of the next user...
    USERLISTSTRING+="$UserDisplayName"
    USERLISTSTRING+=$'\n'
    USERLISTSTRING+="$UserName"
    USERLISTSTRING+=$'\n'
  done < <(echo "$USERLIST")
  #Append a default value with the display string to enter the username with -1. When selected, this tells the script to bring up a dialog to allow the user to enter a manual name
  USERLISTSTRING+="Enter User Name..."
  USERLISTSTRING+=$'\n'
  USERLISTSTRING+="-1"


  #present the list of the users to the system
  LOGINUSER=$(echo "$USERLISTSTRING" | $ZENITYCMD --title="Username" --height=450 --list --text "Select a user from the list to log into."  --column users --column usernames --hide-column 2 --print-column 2 --hide-header --separator="\n" 2>/dev/null )
  CancelOrOK=$?
  export LOGINUSER
  #Abort if the user selected cancel on the zenity dialog
  if [[ $CancelOrOK != 0 ]]
  then
    exit 0
  fi
  #if there is no user selected or if the LOGINUSER is -1, as in the user opted to enter a username manually prompt for the username with a text dialog
  if [[ -z $LOGINUSER || $LOGINUSER == -1 ]]
  then
    LOGINUSER=$($ZENITYCMD --title="Username" --entry --text="Enter the User Name:" 2>/dev/null)
    CancelOrOK=$?
    #Abort if the user selected cancel on the zenity dialog
    if [[ $CancelOrOK != 0 ]]
    then
      exit 0
    fi
  fi
  #get the TTY to start the session on, only for seat0
  if [[ "$1" == "seat0" ]]
  then
    export SessionTTY=$(GetNextTTY)
  else
    SessionTTY=0
  fi
  if [[ $SessionTTY -ne -1 ]]
  then
    #Prompt for the users password
    USERPASSWORD=$( $ZENITYCMD --title="Password" --password --text "Type Password for $LOGINUSER" 2>/dev/null )
    CancelOrOK=$?
    #Abort if the user selected cancel on the zenity dialog
    if [[ $CancelOrOK != 0 ]]
    then
      exit 0
    fi
    #send the password to an AuthenticateUser function with stdin
    echo $USERPASSWORD | AuthenticateUser "$1"
    #get the result from AuthenticateUser in the pipe, (and not the echo command)
    passwordresult=${PIPESTATUS[1]}
    unset USERPASSWORD
    if [[ $passwordresult != 0 ]]
    then
      $ZENITYCMD --warning --text="Invalid password for $LOGINUSER, or username invalid" 2>/dev/null
      WriteToLog "Invalid password for $LOGINUSER, or username invalid" 1
    fi
  else
    $ZENITYCMD --warning --text="Not Enough TTYs!" 2>/dev/null
    WriteToLog "Not Enough TTYs for user login!" 1
  fi
}


#This function is called when the loginmanager_control FIFO recives the command "Leave". It brings up a zenity dialog for handling power options for the computer.
#It takes 1 argument, the seat to display the dialogs on
function LeavePrompt
{
  GetStartedSeatIndex $1
  SeatFileName=${SeatFileNames[$ReturnSeatIndex]}
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$SeatFileName"
  SetFallbackEnvironmentVariables $1
  #The first line is sent to the zenity dialog is the actual command it sets the ACTION variable to be. the second line is what it appears as in the Zenity dialog for the user.
  CanPowerOff=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanPowerOff |grep -c yes)
  if [[ $CanPowerOff == 1 ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Shutdown"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Shutdown Computer"
  fi
  CanReboot=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanReboot |grep -c yes)
  if [[ $CanReboot == 1 ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Restart"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Restart Computer"
  fi
  CanSuspend=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanSuspend |grep -c yes)
  if [[ $CanSuspend == 1 ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Standby"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Standby Computer"
  fi
  CanHybridSleep=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanHybridSleep |grep -c yes)
  if [[ $CanHybridSleep == 1 ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Hybrid Sleep"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Hybrid Sleep Computer"
  fi
  CanHibernate=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanHibernate |grep -c yes)
  if [[ $CanHibernate == 1 ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Hibernate"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Hibernate Computer"
  fi
  ACTION=$(echo "$ACTIONSTRING" | $ZENITYCMD --title="Leave..." --height=450 --list  --hide-header --text="What do you want to do?" --separator="\n" --column 'action' --column 'useraction' --hide-column 1 --print-column=1  2>/dev/null )
  CancelOrOK=$?
  #Abort if the user selected cancel on the zenity dialog
  if [[ $CancelOrOK != 0 ]]
  then
    exit 0
  fi

  #Prompt the user if they are sure they want to execute the selected action
  $ZENITYCMD --width=450 --title="Leave..." --question --text="Are you sure you want to $ACTION" 2>/dev/null
  CONFIRM=$?
  if [[ $CONFIRM != 0 ]]
  then
    exit 1
  fi

  #For all actions use the dbus commands to logind
  if [[ $ACTION == "Shutdown" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.PowerOff boolean:true
    RESULT=$?
  elif [[ $ACTION == "Restart" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Reboot boolean:true
    RESULT=$?
  elif [[ $ACTION == "Standby" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Suspend boolean:true
    RESULT=$?
  elif [[ $ACTION == "Hybrid Sleep" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.HybridSleep boolean:true
    RESULT=$?
  elif [[ $ACTION == "Hibernate" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Hibernate boolean:true
    RESULT=$?
  else
    exit
  fi
  #if the selected action failed, tell the user
  if [[ $RESULT != 0 ]]
  then
    $ZENITYCMD --title="Failure" --warning --text="Failed to $ACTION" 2>/dev/null
  fi
}

#This function gets the desired backend information for the specified seat for what backend should be used for the loginmanagerdisplay
#It takes 1 argument, the seat
function GetSeatCapabilityString
{
  #Detect hardware abilities, of the seat
  if [[ $(grep -c "\bwlmforcefbdev\b" /proc/cmdline ) == 0 && $(GetSeatConfigKey wlmforcefbdev "$1" 0 ) == 0  ]]
  then
    SeatSupportsKMS=$(loginctl seat-status "$1" 2>/dev/null |grep -e "/drm/card[0-9]*$" -c)
  else
    SeatSupportsKMS=0
  fi
  if [[ $(grep -c "\bwlmnofbdev\b" /proc/cmdline ) == 0 && $(GetSeatConfigKey wlmnofbdev "$1" 0 ) == 0  ]]
  then
    SeatSupportsFB=$(loginctl seat-status "$1" 2>/dev/null |grep -e "/graphics/fb[0-9]*$" -c)
    FB0INSEAT=$(loginctl seat-status "$1" 2>/dev/null |grep -e "/graphics/fb0$" -c)
  else
    SeatSupportsFB=0
    FB0INSEAT=0
  fi

  #if the user booted with wlmforceswrender, or configured software rendering globally, or for the seat
  #force software rendering to be enabled
  if [[ $(grep -c "\bwlmforceswrender\b" /proc/cmdline ) != 0 || $(GetSeatConfigKey wlmforceswrender "$1" 0 ) != 0  ]]
  then
    FORCESOFTWARE=1
  else
    FORCESOFTWARE=0
  fi

  #if the user booted with wlmforceswrender, or configured vblank globally, or for the seat
  #force vblank to be disabled
  if [[ $(grep -c "\bwlmforcevblankoff\b" /proc/cmdline ) != 0 || $(GetSeatConfigKey wlmforcevblankoff "$1" 0 ) != 0  ]]
  then
    FORCEVBLANK=1
  else
    FORCEVBLANK=0
  fi

  #Determine the backend to use
  WESTONBACKEND=0
  WESTONUSEPIXMAN=0
  if [[ $WESTON_FBDEV_SEAT_AWARE == 1 && $SeatSupportsFB != 0 ]]
  then
    WESTONBACKEND=FB
  else
    if [[ $FB0INSEAT != 0 ]]
    then
      SeatSupportsFB=1
      WESTONBACKEND=FB
    fi
  fi
  #If the kernel mode setting is disabled system wide globally, or just for this seat, do not include kernel mode setting
  #for this seat
  if [[ $SeatSupportsKMS != 0 ]]
  then
    WESTONBACKEND=KMS
  fi

  #if the user booted with wlmforcepixman, or configured to use pixman globally, or for the seat
  #force pixman to be enabled
  if [[ $WESTONBACKEND == KMS && $(grep -c "\bwlmforcepixmanb" /proc/cmdline ) == 0 && $(GetSeatConfigKey wlmforcepixman "$1" 0 ) != 0  ]]
  then
    WESTONUSEPIXMAN=1
  else
    WESTONUSEPIXMAN=0
  fi

  if [[ $SeatSupportsKMS == 0 && $SeatSupportsFB == 0 ]]
  then
    WriteToLog "No usable display hardware found on seat $1 ." 1
  fi
  if [[ $SeatSupportsKMS != 0 && $WESTONBACKEND == KMS ]]
  then
    WriteToLog "Kernel mode setting found for seat $1 ." 0
  fi
  if [[ $SeatSupportsFB != 0 ]]
  then
    WriteToLog "Framebuffer found for seat $1 ." 0
  fi


  #Return the seat compatibility info
  echo "$WESTONBACKEND $WESTONUSEPIXMAN $FORCESOFTWARE $FORCEVBLANK"
}

#This calls the loginmanagerdisplay_(seat) weston sessions. It takes 1 argument, the seat
function StartLoginManagerDisplay
{
  #Information about the seat
  CurrentSeat=$1
  SeatStartCount=${LoginManagerDisplayFailCounts[$SeatIndexID]}
  SeatWestonBackend=${LoginManagerDisplayBackends[$SeatIndexID]}
  SeatUsePixman=${LoginManagerDisplayPixmanFlags[$SeatIndexID]}
  SeatFileName=${SeatFileNames[$SeatIndexID]}
  DoStartLoginManagerDisplay=1
  LOGINMANAGERDISPLAYSTATUS=0
  SeatUseMultiSessionConfig=1

  #If the seat can't multisession, and the loginmanagerdisplay for this seat is stopped, don't try to start it. This only would concern seats that are not seat0
  if [[ $ONLY_CAN_MULTISESSION_SESSION_SWITCH == 1 && $CurrentSeat != "seat0" ]]
  then
    SeatCanMultiSession=$(loginctl show-seat "$CurrentSeat" -p CanMultiSession --value 2>/dev/null)
    SeatSessions=$(loginctl show-seat "$CurrentSeat" -p Sessions --value 2>/dev/null)
    if [[ $SeatCanMultiSession != "yes" ]]
    then
      SeatUseMultiSessionConfig=0
      #The Autologin prompt starts before the loginmanagerdisplay
      if [[ ! -z "$SeatSessions" && ( ! -z ${LastLoginPIDs[$SeatIndexID]} && -e /proc/${LastLoginPIDs[$SeatIndexID]}) ]]
      then
        SeatStartCount=0
        DoStartLoginManagerDisplay=0
      else
        if [[ ! -z "$SeatSessions" ]]
        then
          SeatStartCount=0
          DoStartLoginManagerDisplay=0
        fi
      fi
    fi
  fi

  #Detect if the socket for the loginmanagerdisplay exists, and if the service is running
  if [[ -e /run/user/$LOGINMANAGERDISPLAYUID/loginmanagerdisplay_$SeatFileName && -e /proc/${LoginManagerDisplayPIDs[$SeatIndexID]} ]]
  then
    DoStartLoginManagerDisplay=0
    return
  fi

  #Handle the seat hardware information
  if [[ $SeatWestonBackend == KMS ]]
  then
    WESTONBACKENDSTRING="drm-backend.so"
  elif [[ $SeatWestonBackend == FB ]]
  then
    WESTONBACKENDSTRING="fbdev-backend.so"
  elif [[ $SeatWestonBackend == "" ]]
  then
    WriteToLog "No backend found for $CurrentSeat ." 1
    SeatStartCount=5
    LOGINMANAGERDISPLAYSTATUS=1
  fi

  if [[ $LOGINMANAGERDISPLAYSTATUS == 0 && $SeatStartCount < 5 && $DoStartLoginManagerDisplay == 1 ]]
  then

    if [[ $SeatUsePixman == 1 ]]
    then
      PIXMANARGS="--use-pixman"
    else
      unset PIXMANARGS
    fi

    (( SeatStartCount++ ))
    if [[ "$CurrentSeat" == seat0 ]]
    then
      WriteToLog "Starting the loginmanagerdisplay on tty $LOGINMANAGERDISPLAYTTY for seat $CurrentSeat (Attempt $SeatStartCount)" 1
      #Reset the contents of the tty
      echo -n -e '\e[3J' > /dev/tty$LOGINMANAGERDISPLAYTTY
      #Disable cursor blinking on the TTY the display server will be started on
      echo -n -e '\e[?25l' > /dev/tty$LOGINMANAGERDISPLAYTTY
      ResetTTYMode $LOGINMANAGERDISPLAYTTY
      SetTTYModeGraphics $LOGINMANAGERDISPLAYTTY
    else
      WriteToLog "Starting the loginmanagerdisplay for seat $CurrentSeat (Attempt $SeatStartCount)" 1
    fi
    if [[ -x "$DEFAULTWAYLANDSERVER" ]]
    then
      systemctl reset-failed wlm-loginmanagerdisplay_$SeatFileName &> /dev/null
      if [[ $CurrentSeat == seat0 ]]
      then
        chvt $LOGINMANAGERDISPLAYTTY &>/dev/null &
        OutputArgs="-p TTYPath=/dev/tty"$LOGINMANAGERDISPLAYTTY" -p StandardOutput=null -p StandardError=null -p StandardInput=tty"
      else
        OutputArgs=""
      fi
      if [[ $SeatUseMultiSessionConfig == 1 ]]
      then
        WESTONCONFIG="$XDG_CONFIG_HOME/loginmanagerdisplay-switch.ini"
      else
        WESTONCONFIG="$XDG_CONFIG_HOME/loginmanagerdisplay-noswitch.ini"
      fi
      SetFallbackEnvironmentVariables $CurrentSeat
      LOGINMANAGERDISPLAYENVSTRING=""
      if [[ ! -z $LIBGL_ALWAYS_SOFTWARE ]]
      then
        LOGINMANAGERDISPLAYENVSTRING+=" --setenv=LIBGL_ALWAYS_SOFTWARE=$LIBGL_ALWAYS_SOFTWARE "
      fi
      if [[ ! -z $vblank_mode ]]
      then
        LOGINMANAGERDISPLAYENVSTRING+=" --setenv=vblank_mode=$vblank_mode "
      fi
      systemd-run --unit=wlm-loginmanagerdisplay_$SeatFileName -p PrivateTmp=yes -p PAMName=waylandloginmanager-loginmanagerdisplay -p User="$LOGINMANAGERDISPLAYUSER" $OutputArgs -p WorkingDirectory=\~ $LOGINMANAGERDISPLAYENVSTRING --setenv=LD_LIBRARY_PATH="$LD_LIBRARY_PATH" --setenv=PATH="$PATH" --setenv=XDG_CONFIG_HOME="$XDG_CONFIG_HOME" --setenv=XDG_SEAT=$CurrentSeat --setenv=HOME="$HOME" $DEFAULTWAYLANDSERVER --backend=$WESTONBACKENDSTRING $PIXMANARGS --socket=loginmanagerdisplay_$SeatFileName --log=/var/log/waylandloginmanager/loginmanagerdisplays/loginmanagerdisplay_$SeatFileName.log --config="$WESTONCONFIG" &>/dev/null

      LOGINMANAGERDISPLAYREADY=1
      TRYCOUNT=0
      while [[ $LOGINMANAGERDISPLAYREADY != 0 && $TRYCOUNT -le 5 ]]
      do
        LOGINMANAGERDISPLAYREADY=$(systemctl is-active wlm-loginmanagerdisplay_$SeatFileName.service &> /dev/null; echo $?)
        $SLEEPCMD 1
        ((TRYCOUNT++))
      done
      #Get the logind session of the weston instance running loginmanagerdisplay, and have it register to the main 'thread'
      NewLoginManagerDisplayInfo=$(GetLoginManagerDisplayInfo $CurrentSeat)
      IFS=@
      NewLoginManagerDisplayInfo=($NewLoginManagerDisplayInfo)
      unset IFS

      NewLoginManagerDisplayPID=${NewLoginManagerDisplayInfo[0]}
      NewLoginManagerDisplaySession=${NewLoginManagerDisplayInfo[1]}
      LoginManagerDisplayPIDs[$SeatIndexID]=$NewLoginManagerDisplayPID
      LoginManagerDisplaySessions[$SeatIndexID]=$NewLoginManagerDisplaySession

      if [[ ! -z $NewLoginManagerDisplaySession ]]
      then
        loginctl activate $NewLoginManagerDisplaySession &>/dev/null
        if [[ $ReadyNotifySent == 0 ]]
        then
          ReadyNotifySent=1
          TRYCOUNT=0
          while [[ ! -e /run/user/$LOGINMANAGERDISPLAYUID/loginmanagerdisplay_$SeatFileName && $TRYCOUNT -le 5 ]]
          do
            $SLEEPCMD 1
            ((TRYCOUNT++))
          done
          systemd-notify --ready &> /dev/null
        fi
      else
        #If the first loginmanagerdisplay fails to start on the first attempt
        #That should not happen, declare the service start as complete, and don't worry about the seamless startup
        if [[ $ReadyNotifySent == 0 ]]
        then
          ReadyNotifySent=1
          systemd-notify --ready &> /dev/null
        fi
      fi
    else
      if [[ $SeatStartCount == 1 ]]
      then
        WriteToLog "$DEFAULTWAYLANDSERVER is not executable, or does not exist, or not supported on seat $CurrentSeat" 1
      fi
    fi
  fi
  if [[ $SeatStartCount == 5 ]]
  then
    (( SeatStartCount++ ))
    WriteToLog "Maximum attempts to start the loginmanagerdisplay for $CurrentSeat has been reached" 1
  fi
  LoginManagerDisplayFailCounts[$SeatIndexID]=$SeatStartCount
}

#This function determines the PID, and the systemd session of the loginmanagerdisplay, it takes 1 argument, the seat.
function GetLoginManagerDisplayInfo
{
  GetStartedSeatIndex $1
  SeatFileName=${SeatFileNames[$ReturnSeatIndex]}
  #Get the pid of loginmanagerdisplay
  unset REGISTERDISPLAYSESSION
  LOGINMANAGERDISPLAYPID=$(systemctl show wlm-loginmanagerdisplay_"$SeatFileName".service -p MainPID --value 2>/dev/null)
  IFS=" "
  #Get all logind sessions
  WLMLOGINDSESSIONS=($(loginctl show-seat "$1" -p Sessions --value 2>/dev/null ))
  unset IFS
  #Go thorugh each logind session, see the one where the main pid matches the pid of the loginmanagerdisplay
  for WLMLOGINDSESSION in "${WLMLOGINDSESSIONS[@]}"
  do
    WLMLOGINDSESSIONPID=$(loginctl show-session "$WLMLOGINDSESSION" -p Leader --value 2>/dev/null )
    if [[ $LOGINMANAGERDISPLAYPID == $WLMLOGINDSESSIONPID ]]
    then
      REGISTERDISPLAYSESSION=$WLMLOGINDSESSION
      break
    fi
  done
  echo "$LOGINMANAGERDISPLAYPID@$REGISTERDISPLAYSESSION"
}

#This function sets fallback environment variables such as LIBGL_ALWAYS_SOFTWARE if it is specified for the seat
#It takes 1 argument, the seat
function SetFallbackEnvironmentVariables
{
  GetStartedSeatIndex $1
  SeatIndexIDFallback=$ReturnSeatIndex
  SetFallbackSoftware=${SeatForceSWRenderFlags[$SeatIndexIDFallback]}
  SetFallbackVblank=${SeatForceVblankFlags[$SeatIndexIDFallback]}
  if [[ $SetFallbackSoftware == 1 ]]
  then
    export LIBGL_ALWAYS_SOFTWARE=1
  else
    unset LIBGL_ALWAYS_SOFTWARE
  fi

  if [[ $SetFallbackVblank == 1 ]]
  then
    export vblank_mode=0
  else
    unset vblank_mode
  fi
}

#This fuction starts an autologin session, and takes 2 arguments, the first is the seat to start the autologin session on, the second is the autologin user
function StartAutoLogin
{
  AUTOLOGINUSER=$2
  echo "$1" >> /run/waylandloginmanager/autologinran
  #Wait until the loginmanagerdisplay becomes availible
  DisplayServerWait "$1"
  ChooseSessionType "$1"
  #Abort if the user selected cancel on the zenity dialog
  CancelOrOK=$?
  if [[ $CancelOrOK != 0 ]]
  then
    exit 0
  fi
  #get the TTY to start the autologin session on, only for seat0
  if [[ "$1" == seat0 ]]
  then
    export AutoSessionTTY=$(GetNextTTY)
   else
    export AutoSessionTTY=0
  fi
  DialogWait 3 "Attempting to start the selected session..." "$1"
  #if there is a tty for the autologin session, the autologin is configured, start the autologin session
  if [[ $AutoSessionTTY -ne -1 ]]
  then
    if [[ "$1" == seat0 ]]
    then
      WriteToLog "Starting Autologin session for $AUTOLOGINUSER on TTY $AutoSessionTTY on seat $1" 1
    else
      WriteToLog "Starting Autologin session for $AUTOLOGINUSER on seat $1" 1
    fi
    StartUserSession "$AutoSessionTTY" "$1" "$AUTOLOGINUSER" 1 "$WSESSIONDATA" &
  else
    $ZENITYCMD --warning --text="Not Enough TTYs for autologin!" 2>/dev/null
    WriteToLog "Not Enough TTYs for autologin!" 1
  fi
}

#This function is part of the startup for the waylandloginmanager. it creates the FIFO files, giving ONLY write access to loginmanager_control for ALL users, and only write access to loginmanager_register is given to root. Any other permissions, including read is denied.
function SetupIPCFiles
{
  #Create communication fifo.
  rm -r /run/waylandloginmanager/loginmanager_control &> /dev/null
  rm -r /run/waylandloginmanager/loginmanager_listener &> /dev/null
  rm -r /run/waylandloginmanager/loginmanager_register &> /dev/null
  mkfifo -m 622 /run/waylandloginmanager/loginmanager_control
  mkfifo -m 200 /run/waylandloginmanager/loginmanager_listener
  mkfifo -m 200 /run/waylandloginmanager/loginmanager_register
  chown $FIFOREADERUSER /run/waylandloginmanager/loginmanager_control
  #open the main FIFO that recives commands.
  exec 1000<> /run/waylandloginmanager/loginmanager_listener

  touch /run/waylandloginmanager/autologinran
  chmod 700 /run/waylandloginmanager/autologinran
  rm /run/waylandloginmanager/fifolock 2>/dev/null
}

#This function displays a dialog containing actions for the Wayland Login Manager for the user, Shutdown, Switch User, login, and show a help dialog. It's optional, for in the case Weston isn't configured
#It takes 1 argument, the seat.
function UserActionDialog
{
  GetStartedSeatIndex $1
  SeatFileName=${SeatFileNames[$ReturnSeatIndex]}
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$SeatFileName"
  SetFallbackEnvironmentVariables $1
  #wait for the loginmanagerdisplay
  DisplayServerWait "$1"
  ActionMenu="Login\nLogin...\n"
  SeatCanMultiSession=$(loginctl show-seat "$1" -p CanMultiSession --value 2>/dev/null)
  if [[ $ONLY_CAN_MULTISESSION_SESSION_SWITCH == 0 || $SeatCanMultiSession == "yes" ]]
  then
    ActionMenu+="Switch\nSwitch User...\n"
  fi
  ActionMenu+="Leave\nShutdown...\nInfo\nHelp..."
  if [[ $wlmdebuginsecure == 1 ]]
  then
    ActionMenu+="\nDebug\nRoot Terminal..."
  elif [[ $wlmdebug == 1 ]]
  then
    ActionMenu+="\nDebug\nTerminal Login..."
  fi
  USERACTION=$(echo -e "$ActionMenu"|$ZENITYCMD  --title="Login Manager" --height=300 --hide-column 1 --separator="\n" --list --column action --column display --hide-header --text "Select an Action"  2>> /var/log/waylandloginmanager/loginmanagerdisplays/loginmanagerdisplay_"$SeatFileName".log; exit ${PIPESTATUS[1]})
ZENITYSTATUS=$?
  #If the useraction exists (the user did not click cancel), then send the command to the loginmanager_control
  if [[ ! -z $USERACTION ]]
  then
    SendSelfCommand $USERACTION "$1"
  else
    $SLEEPCMD .1
  fi
  #if zenity segfaults, then something is wrong. wait longer
  if [[ $ZENITYSTATUS == 139 ]]
  then
    $SLEEPCMD 5
  fi
  exit $ZENITYSTATUS
}

#This part of the script is constantly running. It reads what the user send to loginmanager_control running as a service account, and filters out only valid commands to loginmanager_listener, and only sends a limited number of lines.
function UnprivilegedFIFOFilter
{
  while [ 1 ]
  do
    runuser -u $FIFOREADERUSER -m -- bash -c "grep -Eom 3 \"^Switch@[a-Z0-9_\-]*$|^Change@[a-Z0-9_\-]*$|^Login@[a-Z0-9_\-]*$|^Leave@[a-Z0-9_\-]*$|^RegisterSession@[a-Z0-9_\-]*$|^DetectSeats@[a-Z0-9_\-]*$|^Info@[a-Z0-9_\-]*$|^Debug@[a-Z0-9_\-]*$|^$\" /run/waylandloginmanager/loginmanager_control" > /run/waylandloginmanager/loginmanager_listener 2>/dev/null
    $SLEEPCMD .1
  done
}

#Function to get the index number of the specified seat of the array "StartedSeats" for the specified seat. It takes 1 argument, the seat
#This is so per-seat information can be stored in arrays using the same index to refer to the data per-seat
function GetStartedSeatIndex
{
  ReturnSeatIndex="-1"
  SeatCount=${#StartedSeats[@]}
  #Go through the StartedSeats array, untill the index matches the specified seat
  for (( StartIndex=0; StartIndex<$StartedSeatCount;  StartIndex=StartIndex+2 ))
  do
    if [[ ${StartedSeats[$StartIndex]} == $1 ]]
    then
      ReturnSeatIndex=$StartIndex
      break
    fi
  done
  if [[ $ReturnSeatIndex != "-1" ]]
  then
    ReturnSeatIndex=$(($ReturnSeatIndex/2))
  fi
}

#This part of the script is constantly running, once it finishes setting up. This reads the loginmanager_listener FIFO constantly, waiting for it to recive a command from a program called by the loginmanagerdisplay's weston desktop shell that sends approriate commands to it, or the user session, shutdowndialog, or even some functions within this script.
#it also checks to see if the active sesssion is active, and if not, switches back to the tty of the loginmanagerdisplay.
function WaylandLoginManagerMain
{
  LoginManagerFirstLoop=1
  SessionStartFailed=0
  MainLoopMinutes=0
  DoDetectSeats=1
  StartedSeats=()

  #Arrays about running helper processes
  LastUserActionPIDs=()
  LastSwitchPIDs=()
  LastLoginPIDs=()
  LastLeavePIDs=()
  LastInfoPIDs=()
  LastDebugPIDs=()
  LoginManagerDisplaySessions=()
  LoginManagerDisplayPIDs=()

  #Arrays about the seats, what hardware is supported
  #and how many times something related to the seat failed
  UserActionFailCounts=()
  UserActionFailSkips=()
  LoginManagerDisplayFailCounts=()
  LoginManagerDisplayBackends=()
  LoginManagerDisplayPixmanFlags=()
  SeatForceSWRenderFlags=()
  SeatForceVblankFlags=()
  SeatFileNames=()


  #loop 'forever'
  while [ 1 ]
  do
    #Detect all seats, and add them to the array.
    if [[ $SECONDS -gt 60 ]]
    then
      ((MainLoopMinutes++))
      SECONDS=0
    fi
    if [[ $DoDetectSeats == 1 || $MainLoopMinutes -ge 120 ]]
    then
      DoDetectSeats=0
      MainLoopMinutes=0
      #Find what seats are new
      AllRunningSeats=()
      NewAllRunningSeats=($(loginctl --no-legend list-seats 2>/dev/null | sort))
      for NewRunningSeat in ${NewAllRunningSeats[@]}
      do
        AllRunningSeats+=($NewRunningSeat)
      done

      #Find new seats by going the list of running ones, going through all stored ones
      #Then finding ones that have no matches
      for RunningSeat in ${AllRunningSeats[@]}
      do
        IncludeSeat=1
        StartedSeatCount=${#StartedSeats[@]}
        for (( StartIndex=0; StartIndex<$StartedSeatCount;  StartIndex=StartIndex+2 ))
        do
          if [[ $RunningSeat == ${StartedSeats[$StartIndex]} ]]
          then
            IncludeSeat=0
            break
          fi
        done
        #Detect the age of the seat, by the date stamp of the last entry logged for the seat
        #As of now, this is the best way to get the creation time of a seat, since the attribute is not presented
        SeatCreationDate=$(journalctl  -b _HOSTNAME=$HOSTNAME _MACHINE_ID=$MACHINE_ID SEAT_ID=$RunningSeat _SYSTEMD_UNIT=systemd-logind.service -o short-unix 2>/dev/null | tail -1 | awk  '{print $1}')
        OldSeatCreationDate=${SeatCreationDates[$(($StartIndex/2))]}
        #If the seat is new, detected to have been removed in the past, or if the seat date is different, (removed and readded before the detection interval)
        if [[ $IncludeSeat == 1 || ${StartedSeats[$(($StartIndex+1))]} == -1 || $SeatCreationDate != $OldSeatCreationDate ]]
        then
          #Determine and store if this seat is multisession compatible
          HasMultiSession=$(loginctl show-seat $RunningSeat -p CanMultiSession --value 2>/dev/null)
          if [[ $ONLY_CAN_MULTISESSION_SESSION_SWITCH == 0 || $HasMultiSession == "yes" ]]
          then
            CanMultiSession=1
          else
            CanMultiSession=0
          fi
          WriteToLog "New seat $RunningSeat , multisession support is $CanMultiSession" 1
          #Each seat is worth two array elements, the first is the seat name, the second is if it supports multisession
          if [[ ${StartedSeats[$(($StartIndex+1))]} == -1 ]]
          then
            TerminateJobPID ${LastUserActionPIDs[$StartIndex/2]} 15 1
            StartedSeats[$(($StartIndex+1))]=$CanMultiSession
          else
            StartedSeats+=($RunningSeat)
            StartedSeats+=($CanMultiSession)
          fi
          #Seats can be 255 characters long, file names can only be 255 characters long
          #If a seat is 64 characters or greater, use the hash. sha256 (hashes are 64 characters long)
          if [[ ${#RunningSeat} -gt 63 ]]
          then
            SeatFileName=$(echo -n $RunningSeat | sha256sum | awk '{print $1}')
          else
            SeatFileName=$RunningSeat
          fi
          SeatFileNames[$StartIndex/2]=$SeatFileName
          if [[ $SeatCreationDate != $OldSeatCreationDate && ! -z $OldSeatCreationDate ]]
          then
            systemctl stop "wlm-loginmanagerdisplay_$SeatFileName" &> /dev/null
            rm /run/user/$LOGINMANAGERDISPLAYUID/loginmanagerdisplay_$SeatFileName &> /dev/null
          fi
          SeatCapabilityArr=($(GetSeatCapabilityString $RunningSeat))
          UserActionFailCounts[$StartIndex/2]=0
          UserActionFailSkips[$StartIndex/2]=0
          SeatCreationDates[$StartIndex/2]=$SeatCreationDate
          LoginManagerDisplayBackends[$StartIndex/2]=${SeatCapabilityArr[0]}
          LoginManagerDisplayPixmanFlags[$StartIndex/2]=${SeatCapabilityArr[1]}
          SeatForceSWRenderFlags[$StartIndex/2]=${SeatCapabilityArr[2]}
          SeatForceVblankFlags[$StartIndex/2]=${SeatCapabilityArr[3]}
          LoginManagerDisplayFailCounts[$StartIndex/2]=0
          SEATAUTOLOGINCOUNT=$(cat /run/waylandloginmanager/autologinran 2>/dev/null |grep -c "^$RunningSeat$")
          SEATAUTOLOGINUSER=$(GetSeatConfigKey autologin-user "$RunningSeat" ":" )
          #if autologin is specified
          if [[ ! -z $SEATAUTOLOGINUSER && $SEATAUTOLOGINCOUNT == 0 && $SEATAUTOLOGINUSER != ':' ]]
          then
            StartAutoLogin $RunningSeat $SEATAUTOLOGINUSER &
            LastLoginPIDs[$StartIndex/2]=$!
          fi
        fi
      done

      #Find out what seats went away, and reset their fail counts
      #Go through the list of registred seats, the list of running seats
      #If there are no matches for the registered seat, then it is gone
      StartedSeatCount=${#StartedSeats[@]}
      for (( StartIndex=0; StartIndex<$StartedSeatCount;  StartIndex=StartIndex+2 ))
      do
        SeatRemoved=1
        for RunningSeat in ${AllRunningSeats[@]}
        do
          if [[ $RunningSeat == ${StartedSeats[$StartIndex]} ]]
          then
            SeatRemoved=0
          fi
        done
        #Reset the fail count info for this seat in the arrays, it's possible the seat could be recreated
        if [[ $SeatRemoved == 1 && ${StartedSeats[$(($StartIndex+1))]} != -1 ]]
        then
          ChangeIndex=$((StartIndex/2))
          SeatFileName=${SeatFileNames[$ChangeIndex]}
          UserActionFailCounts[$ChangeIndex]=0
          UserActionFailSkips[$ChangeIndex]=0
          LoginManagerDisplayFailCounts[$ChangeIndex]=0
          WriteToLog "The seat ${StartedSeats[$StartIndex]} has been detected to have been removed" 1
          systemctl stop "wlm-loginmanagerdisplay_$SeatFileName" &> /dev/null
          StartedSeats[$(($StartIndex+1))]=-1
          TerminateJobPID ${LastUserActionPIDs[$StartIndex/2]} 15 1
          unset LastUserActionPIDs[$StartIndex/2]
        fi
      done

      #Export the Session Data
      ExportSessionData
    fi

    LoginManagerDisplayAttemptsMaxedOut=1
    UIPromptAttemptsMaxedOut=1
    #Handle the loginmanagerdisplay, and the main dialog for each seat
    for RunningSeat in ${AllRunningSeats[@]}
    do
      UIJobCount=0
      GetStartedSeatIndex $RunningSeat
      SeatIndexID=$ReturnSeatIndex

      #Determine if there are any running UI jobs for the paticular seat
      if [[
      ( ! -z ${LastUserActionPIDs[$SeatIndexID]} && -d /proc/${LastUserActionPIDs[$SeatIndexID]}) ||
      ( ! -z ${LastSwitchPIDs[$SeatIndexID]} && -d /proc/${LastSwitchPIDs[$SeatIndexID]}) ||
      ( ! -z ${LastLoginPIDs[$SeatIndexID]} && -d /proc/${LastLoginPIDs[$SeatIndexID]}) ||
      ( ! -z ${LastLeavePIDs[$SeatIndexID]} && -d /proc/${LastLeavePIDs[$SeatIndexID]}) ||
      ( ! -z ${LastInfoPIDs[$SeatIndexID]} && -d /proc/${LastInfoPIDs[$SeatIndexID]}) ]]
      then
        ((UIJobCount++))
      fi

      #Start the loginmanagerdisplay
      if [[ $LoginManagerFirstLoop == 1 ]]
      then
        LoginManagerDisplayInfo=$(GetLoginManagerDisplayInfo $RunningSeat)
        IFS=@
        LoginManagerDisplayInfo=($LoginManagerDisplayInfo)
        unset IFS
        LoginManagerDisplayPIDs[$SeatIndexID]=${LoginManagerDisplayInfo[0]}
        LoginManagerDisplaySessions[$SeatIndexID]=${LoginManagerDisplayInfo[0]}
      fi
      StartLoginManagerDisplay $RunningSeat

      #Set default values for the element for this seat in the fail info arrays if they are not set
      if [[ -z ${UserActionFailCounts[$SeatIndexID]} ]]
      then
        UserActionFailCounts[$SeatIndexID]=0
      fi
      if [[ -z ${UserActionFailSkips[$SeatIndexID]} ]]
      then
        UserActionFailSkips[$SeatIndexID]=0
      fi

      #If the PID for the seats UserActionDialog is not running, get the return status
      if [[ ! -z ${LastUserActionPIDs[$SeatIndexID]} && ! -e /proc/${LastUserActionPIDs[$SeatIndexID]} ]]
      then
        wait ${LastUserActionPIDs[$SeatIndexID]} 2> /dev/null
        UserActionResult=$?
        #If the return status is not 0 or 1 (1 is a valid press of cancel, and not a crash)
        #increase the fail count
        if [[ ($UserActionResult != 0 && $UserActionResult != 1) ]]
        then
          UserActionResult=0
          unset LastUserActionPIDs[$SeatIndexID]
          if [[ ${UserActionFailSkips[$SeatIndexID]} == 0 ]]
          then
            ((UserActionFailCounts[$SeatIndexID]++))
            WriteToLog "The prompt for the user action for seat $RunningSeat terminated incorrectly. Please see the loginmanagerdisplay log." 1
          else
            UserActionFailCounts[$SeatIndexID]=0
            UserActionFailSkips[$SeatIndexID]=0
          fi
        fi
        if [[ ${UserActionFailCounts[$SeatIndexID]} == 5 ]]
        then
          WriteToLog "The prompt for the user action for seat $RunningSeat has terminated incorrectly too many times in a row." 1
        fi
      fi

      #If the seat had the loginmanagerdisplay fail 5 times, declare it
      if [[ ${LoginManagerDisplayFailCounts[$SeatIndexID]} < 5 ]]
      then
        LoginManagerDisplayAttemptsMaxedOut=0
      fi
      #If the seat had the UserActionDialog fail 5 times, declare it
      if [[ ${UserActionFailCounts[$SeatIndexID]} < 5 ]]
      then
        UIPromptAttemptsMaxedOut=0
        if [[ $UIJobCount == 0 ]]
        then
          UserActionDialog $RunningSeat &
          LastUserActionPIDs[$SeatIndexID]=$!
        fi
      fi
    done

    #If it is declared the loginmanagerdisplay service failed for all seats, then show a text mode dialog
    if [[ $LoginManagerDisplayAttemptsMaxedOut == 1 ]]
    then
      systemd-notify --ready &> /dev/null
      WriteToLog "ERROR: Maximum restarts of the loginmanagerdisplay has been reached for every seat" 1
      openvt -c 63 -s -f -w -- runuser -u $LOGINMANAGERDISPLAYUSER -m -- dialog --msgbox "The maximum number of restart attempts for the loginmanagerdisplay for each seat has been reached.

Will show a menu with a few options for diagnosis." 20 50 --no-cancel

      openvt -c 63 -s -f -w -- rbos-failedboot
      systemctl stop waylandloginmanager.service &> /dev/null
    fi

    #If it is declared that the UserActionDialog process failed for all seats, then show a text mode dialog
    if [[ $UIPromptAttemptsMaxedOut == 1 ]]
    then
      WriteToLog "The prompt for the user action terminated incorrectly too many times in a row for every seat." 1
      openvt -c 63 -s -f -w -- runuser -u $LOGINMANAGERDISPLAYUSER -m -- dialog --msgbox "The prompt for the user action terminated incorrectly too many times in a row for every seat.

Will show a menu with a few options for diagnosis." 20 50 --no-cancel
      openvt -c 63 -s -f -w -- rbos-failedboot
      systemctl stop waylandloginmanager.service &> /dev/null
    fi

    #Quickly find if any sessions are not running
    NotRunningSessions=0
    for SessionPid in ${AllSessionPIDs[@]}
    do
      if [[ ! -e /proc/$SessionPid/environ ]]
      then
         ((NotRunningSessions++))
      fi
    done

    #If a session failed to start (it terminates before it can register the PID, and session ID), switch back to the loginmanagerdisplay
    if [[ $SessionStartFailed == 1 ]]
    then
      SessionStartFailed=0
      for FailSeat in ${FailedSessionSeat[@]}
      do
        if [[ $FailSeat == seat0 ]]
        then
          read -t 4 -n5 ActiveSystemTTY < /sys/class/tty/tty0/active
          ActiveSystemTTY=${ActiveSystemTTY:3}
          if [[ $FailedSessionTTY == $ActiveSystemTTY ]]
          then
            if [[ ! -z $FailedSessionTTY ]]
            then
              ResetTTYMode $FailedSessionTTY
            fi
          fi
        fi
        GetStartedSeatIndex $FailSeat
        SeatIndexID=$ReturnSeatIndex
        SeatCanMultiSession=${StartedSeats[$SeatIndexID*2+1]}
        if [[ $SeatCanMultiSession == 1 ]]
        then
          WriteToLog "Switching back to the loginmanagerdisplay for seat $FailSeat as a session failed to start" 1
          loginctl activate ${LoginManagerDisplaySessions[$SeatIndexID]} &>/dev/null
        fi
      done
    fi
    unset FailedSessionTTY
    FailedSessionSeat=()

    #Handle for when a session is detected to not be running
    #And also attempt to unlock the TTY, if applicable
    if [[ $NotRunningSessions != 0 ]]
    then
      read -t 4 -n5 ActiveSystemTTY < /sys/class/tty/tty0/active
      ActiveSystemTTY=${ActiveSystemTTY:3}

      #Create temporary arrays
      NewAllSessionTTYs=()
      NewAllSessionPIDs=()
      NewAllSessionUsers=()
      NewAllSessionIDs=()
      NewAllSeatIDs=()

      #Go through all sessions, and then rebuild the array to only store running sessions
      for (( element = 0 ; element < ${#AllSessionPIDs[@]} ; element++ ))
      do
        RunningSessionTTY=${AllSessionTTYs[$element]}
        RunningSessionPID=${AllSessionPIDs[$element]}
        RunningSessionUser=${AllSessionUsers[$element]}
        RunningSessionID=${AllSessionIDs[$element]}
        RunningSeatID=${AllSeatIDs[$element]}
        #If the session is alive, add its data to the new arrays
        if [[ -e /proc/$RunningSessionPID/environ ]]
        then
          NewAllSessionTTYs+=("$RunningSessionTTY")
          NewAllSessionPIDs+=("$RunningSessionPID")
          NewAllSessionUsers+=("$RunningSessionUser")
          NewAllSessionIDs+=("$RunningSessionID")
          NewAllSeatIDs+=("$RunningSeatID")
        else
          GetStartedSeatIndex $RunningSeatID
          SeatIndexID=$ReturnSeatIndex
          SeatCanMultiSession=${StartedSeats[$SeatIndexID*2+1]}
          #If the session terminated, and then current system TTY is the same as the terminated sessions, go back to the loginmanagerdisplay
          if [[ $RunningSeatID != "seat0" && $SeatCanMultiSession == 1 ]]
          then
            WriteToLog "Switching back to the loginmanagerdisplay for seat $RunningSeatID after $RunningSessionID terminated" 1
            loginctl activate ${LoginManagerDisplaySessions[$SeatIndexID]} &>/dev/null
          elif [[ $RunningSessionTTY == $ActiveSystemTTY ]]
          then
            if [[ ! -z $RunningSessionTTY ]]
            then
              ResetTTYMode $RunningSessionTTY
            fi
            WriteToLog "Switching back to the loginmanagerdisplay for seat $RunningSeatID after $RunningSessionID terminated" 1
            loginctl activate ${LoginManagerDisplaySessions[$SeatIndexID]} &>/dev/null
          fi
        fi
      done

      #Set the actual arrays to be the value of the temporary arrays
      AllSessionTTYs=("${NewAllSessionTTYs[@]}")
      AllSessionPIDs=("${NewAllSessionPIDs[@]}")
      AllSessionUsers=("${NewAllSessionUsers[@]}")
      AllSessionIDs=("${NewAllSessionIDs[@]}")
      AllSeatIDs=("${NewAllSeatIDs[@]}")

      #Export the Session Data
      ExportSessionData

      #Remove the temporary arrays
      unset NewAllSessionTTYs
      unset NewAllSessionPIDs
      unset NewAllSessionUsers
      unset NewAllSessionIDs
      unset NewAllSeatIDs
    fi


    #Read the next line that was sent to the FIFO. Allow a 1 second delay before it times out, and lets the loop run again. It only reads 288 bytes at a time.
    #32 for the command, 1 for the delimiter, and 255 for the max logind seat name size
    read -n 288 -t 1 COMMANDDATA <&1000
    IFS=@
    COMMANDDATA=($COMMANDDATA)
    unset IFS
    COMMAND=${COMMANDDATA[0]}
    SEATARG=${COMMANDDATA[1]}

    if [[ $COMMAND != "" && $COMMAND != "DetectSeats" && $COMMAND != "RegisterSession" ]]
    then
      WriteToLog "received command $COMMAND for seat $SEATARG" 1
    else
      if [[ $COMMAND == "RegisterSession" || $COMMAND == "DetectSeats" ]]
      then
        WriteToLog "received command $COMMAND" 1
      fi
    fi
    #If a seat is specified, and it is not running, ignore the command
    if [[ ! -z $SEATARG ]]
    then
      GetStartedSeatIndex $SEATARG
      SeatIndexID=$ReturnSeatIndex
      SeatIsRunning=0
      #Go through the list of running seats, check if one of them matches the specified one
      for RunningSeat in ${AllRunningSeats[@]}
      do
        if [[ $SEATARG == $RunningSeat ]]
        then
          SeatIsRunning=1
          SeatCanMultiSession=${StartedSeats[$SeatIndexID*2+1]}
          break
        fi
      done
      if [[ $SeatIsRunning == 0 ]]
      then
        WriteToLog "Ignoring $COMMAND command as specified seat $SEATARG not running or invalid" 1
        COMMAND=""
      fi
    fi
    #If it recives a Switch command, then go back to the loginmanagerdisplay's TTY and bring up a switch user dialog and start a switch user job, only if there isn't another switchuserdialog job running
    if [[ $COMMAND == "Switch" ]]
    then
      if [[ $SeatCanMultiSession == 1 ]]
      then
        LOGINMANAGERDISPLAYSESSION=${LoginManagerDisplaySessions[$SeatIndexID]}
        ACTIVESESSION=$(loginctl show-seat "$SEATARG" -p ActiveSession --value 2>/dev/null)
        if [[ $ACTIVESESSION != $LOGINMANAGERDISPLAYSESSION ]]
        then
          loginctl lock-session $(loginctl show-seat "$SEATARG" -p ActiveSession --value 2>/dev/null) &>/dev/null
          loginctl activate $LOGINMANAGERDISPLAYSESSION &>/dev/null
        fi
        if [[ $(jobs -p -r | grep -c ^${LastSwitchPIDs[$SeatIndexID]}$) == 0 ]]
        then
          if [[ ! -z ${LastUserActionPIDs[$SeatIndexID]} ]]
          then
            TerminateJobPID ${LastUserActionPIDs[$SeatIndexID]} 15 1
            UserActionFailSkips[$SeatIndexID]=1
          fi
          SwitchUserDialog "$SEATARG" &
          LastSwitchPIDs[$SeatIndexID]=$!
        else
          WriteToLog "A handler for the Switch command is already open" 0
        fi
      else
        WriteToLog "$SEATARG does not support switching the session" 1
      fi
    #If the command is change, go back to the loginmanagerdisplay TTY, and don't do anything else. It only switches to the TTY if the TTY isn't active already.
    elif [[ $COMMAND == "Change" ]]
    then
      if [[ $SeatCanMultiSession == 1 ]]
      then
        LOGINMANAGERDISPLAYSESSION=${LoginManagerDisplaySessions[$SeatIndexID]}
        ACTIVESESSION=$(loginctl show-seat "$SEATARG" -p ActiveSession --value 2>/dev/null)
        if [[ $ACTIVESESSION != $LOGINMANAGERDISPLAYSESSION ]]
        then
          loginctl lock-session $(loginctl show-seat "$SEATARG" -p ActiveSession --value 2>/dev/null) &>/dev/null
          loginctl activate $LOGINMANAGERDISPLAYSESSION &>/dev/null
        fi
      else
        WriteToLog "$SEATARG does not support switching the session" 0
      fi
    #If it recives a Login command, then bring up a login dialog and start a login job, only if there isn't another login job running
    elif [[ $COMMAND == "Login" ]]
    then
      if [[ $(jobs -p -r | grep -c ^${LastLoginPIDs[$SeatIndexID]}$) == 0  ]]
      then
        if [[ ! -z ${LastUserActionPIDs[$SeatIndexID]} ]]
        then
          TerminateJobPID ${LastUserActionPIDs[$SeatIndexID]} 15 1
          UserActionFailSkips[$SeatIndexID]=1
        fi
        GetUserCredentials "$SEATARG" &
        LastLoginPIDs[$SeatIndexID]=$!
      else
        WriteToLog "A handler for the Login command is already open" 0
      fi
    #If it recives a Leave command, then bring up a shutdown dialog and start a shutdown job, only if there isn't another shutdown job running
    elif [[ $COMMAND == "Leave" ]] 
    then
      if [[ $(jobs -p -r | grep -c ^${LastLeavePIDs[$SeatIndexID]}$) == 0  ]]
      then
        if [[ ! -z ${LastUserActionPIDs[$SeatIndexID]} ]]
        then
          TerminateJobPID ${LastUserActionPIDs[$SeatIndexID]} 15 1
          UserActionFailSkips[$SeatIndexID]=1
        fi
        LeavePrompt $SEATARG &
        LastLeavePIDs[$SeatIndexID]=$!
      else
        WriteToLog "A handler for the Leave command is already open" 0
      fi
    #if the command is RegisterSession, then attempt to read the loginmanager_register FIFO, and register any data sent to that FIFO.
    elif [[ $COMMAND == "RegisterSession" ]]
    then
      RegisterSession
    #If the command id DetectSeats, then inventory seats on the next loop
    elif [[ $COMMAND == "DetectSeats" ]]
    then
      DoDetectSeats=1
    #If it recives a Info command, then bring up a info dialog and start a info job, only if there isn't another info job running
    elif [[ $COMMAND == "Info" ]]
    then
      if [[ $(jobs -p -r | grep -c ^${LastInfoPIDs[$SeatIndexID]}$) == 0  ]]
      then
        if [[ ! -z ${LastUserActionPIDs[$SeatIndexID]} ]]
        then
          TerminateJobPID ${LastUserActionPIDs[$SeatIndexID]} 15 1
          UserActionFailSkips[$SeatIndexID]=1
        fi
        ShowInfo "$SEATARG" &
        LastInfoPIDs[$SeatIndexID]=$!
      else
        WriteToLog "A handler for the Info command is already open" 0
      fi
    #If the command is Debug, and wlmdebug was passed to the kernel, then show a login terminal window, only if there isn't another debug terminal window job running
    elif [[ $COMMAND == "Debug" ]]
    then
      if [[ $wlmdebug == 1 ]]
      then
        if [[ $(jobs -p -r | grep -c ^${LastDebugPIDs[$SeatIndexID]}$) == 0 || $wlmdebuginsecure == 1  ]]
        then
          DiagnosticTerminal "$SEATARG" &
          LastDebugPIDs[$SeatIndexID]=$!
          WriteToLog "Spawned a login terminal window on the loginmanagerdisplay for $SEATARG" 1
        else
          WriteToLog "A handler for the Debug command is already open" 0
        fi
      else
        WriteToLog "Invalid command: $COMMAND for $SEATARG received, but wlmdebug not passed to the kernel, or not in Live CD mode." 1
      fi
    #if the command is empty, then execute bash's built in null command
    elif [[ $COMMAND == "" ]]
      then
      :
    #if the command is unknown, then log that.
    else
      WriteToLog "Invalid command: $COMMAND received for seat $SEATARG" 0
    fi
    LoginManagerFirstLoop=0
    $SLEEPCMD .5
  done
}


#Use bash builtin sleep if availible
if [[ -f /usr/lib/bash/sleep ]]
then
  enable -f /usr/lib/bash/sleep sleep
  SLEEPCMD=\sleep
else
  SLEEPCMD=/bin/sleep
fi

#If the waylandloginmanager is started with no arguments assume default operation. 
#If it is started with --usersession, then perform operations to start the user session, running as the user
if [[ $1 == "" ]]
then
  #Prepare the loginmanager
  PrepareLoginManager

  #Create files used for ipc
  SetupIPCFiles

  #Start the filter that will only send valid data to the main command FIFO
  UnprivilegedFIFOFilter &

  #Start the loginmanager
  WaylandLoginManagerMain
elif [[ $1 == "--usersession" ]]
then
  shift
  UserSessionWorker "$@" &> /dev/null
elif [[ $1 == "--sendcommand" ]]
then
  if [[ -z $3 ]]
  then
    SEAT=$XDG_SEAT
  else
    SEAT=$3
  fi
  SendSelfCommand $2 "$SEAT"
else
  echo "waylandloginmanager: Please start with no arguments."
  exit 1
fi
