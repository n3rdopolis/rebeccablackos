#! /bin/bash
#    Copyright (c) 2012, 2013, 2014, 2015, 2016, 2017 nerdopolis (or n3rdopolis) <bluescreen_avenger@verzion.net>
#
#    This file is part of RebeccaBlackOS.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

#This script is the WaylandLoginManager it handles a graphical login for the user, and allows the user to start multiple types of Wayland sessions, specified in wesession files, and it supports autologin, mounting of ecryptfs home directories, and user switching. It supports watching the active session until it fails, so that it swiches back to the needed TTY for the user.

#The main server it displays on is refered to as the loginmanagerdisplay. it runs as non root, as well as the zenity dialogs

#It depends on zenity kbd, weston, and expect
#It also requires logger to log to syslog, but won't fail without it

#It depends on the line
#SUBSYSTEM=="graphics", KERNEL=="fb*", TAG+="uaccess"
#in a udev rules file.
#or pass wlmglobalfbpermissions to the kernel

#It also requires /etc/pam.d/waylandloginmanager

#It needs a user account called waylandloginmanager

#as well as:
#At least systemd v227 as it has all the ability to launch Wayland sessions with systemd-run

#/etc/waylandloginmanager.conf
  #Otherwise it uses /etc/lightdm/lightdm.conf . the only supported key is 'autologin-user=$AUTOLOGINUSER', and it usually takes it from /etc/lightdm/lightdm.conf at first run. It only uses /etc/waylandloginmanager.conf, as another init script can cause the lightdm config to drop the configured autologin user on an unsafe shutdown
#/usr/libexec/wayland_login_helpers/*
  #These scripts are small utilities that send the approriate commands to the waylandloginmanager's FIFO. They need to be configured in the launchers of /etc/loginmanagerdisplay/weston.ini. It's how the user interacts with the waylandloginmanager on the loginmanagerdisplay (other then the zenity dialogs)
  #These are optional as the waylandloginmanager displays a selection list with the same commands as well
#/etc/loginmanagerdisplay/weston.ini
  #Configuration for the loginmanagerdisplay. This should add the launchers in /usr/lib/wayland_login_helpers to the launcher bar, which send commands to the FIFO for weston, or at least prevent the default terminal icon from appearing in the toolbar for security reasons.
  #The mainform makes this reqirement optional
#/usr/share/wsessions.d/*
  #These are .desktop files, (and .environment files as well) which describe how to start different Wayland servers or sessions
  #These files are documented in /usr/share/wsession/aboutwsessions.txt

#Log Files:
  #/var/log/waylandloginmanager : this is the main log for the waylandloginmanager
  #/var/log/loginmanagerdisplay.log : This is the log file for the Weston server that is the loginmanagerdisplay
  #~/wlsessionlogs/waylandsession_($DATESTAMP).log : This is where all wayland servers get logged as the run as the user.
  #~/wlsessionlogs/waylandhost.log : This log is for the host Wayland server that gets started for Wayland sessions that run on other Wayland servers

#Runtime Files:
  #/run/waylandloginmanager/autologinran: Denotes that the autologin process has run already, after startup (since /run is a tmpfs). This prevents autologin when the service is restarted
  #/run/waylandloginmanager/sessiondata: Stores data for user switching so that the session list can be reloaded if waylandloginmanager restarts. As it's stored in /run which is a tmpfs, there should be no risk of one from a previous boot giving it false data
  #/run/waylandloginmanager/usrbinwaylandloginmanager.lock: (the file name is generated by the path that this script is in, removing the slashes). this prevents two instances of the waylandloginmanager from starting. 
    #It is a symlink to /proc/$$/cmdline (where $$ is the pid of the waylandloginmanager). It is checked in two different ways to protect against a race condition
  #/run/waylandloginmanager/loginmanager_register : Only root can write to this FIFO to register sessions, and no one can read it (except root). Functions registering sessions must first write to this FIFO, and then send the RegisterSession command to the loginmanager_control FIFO
  #/run/waylandloginmanager/loginmanager_control : All users have write access, but and no one can read it, except the FIFOREADERUSER service account. A process running as PROBETESTUSER reads the data getting send to it, and filters out only valid commands to get sent to loginmanager_listener
  #/run/waylandloginmanager/loginmanager_listener : Only root has write access to it, and no one has read access to it (except root). Supported commands:
      #Switch : calls up a switch user dialog on the loginmanagerdisplay, switching to the tty (see documentation for function SwitchUserDialog)
      #Change : switches to the tty the loginmanagerdisplay is on 
      #Info : calls up a help dialog for the user on the loginmanagerdisplay (see documentation for function ShowInfo)
      #Leave : calls up a dialog with shutdown/restart/supend options on the loginmanagerdisplay (see documentation for function LeavePrompt)
      #Login : Starts the login process (see documentation for function GetUserCredentials)
      #RegisterSession : Tells the waylandloginmanager to read from the loginmanager_register FIFO. When this is called the process must be attempting to write to the loginmanager_register already. If there is nothing being written in the short .01 second timeout, it is ignored. (see documentation for function RegisterSession)
      #DetectSeats: Tells the waylandloginmanager to detect all running seats
  #Each command is then ended by a @ followed by the argument for the specified seat

#These functions are for the user session part of the waylandloginmanager

#Function that is run to start user sessions while running as the user (when started with the --usersession argument)
function UserSessionWorker
{
  #Enable job control
  set -m

  #set up the environment for the user. Determine the user name, set Wayland variables, and if the current session has an environment file then handle it.
  USER=$(id -u)
  export XDG_SESSION_TYPE=wayland
  . /usr/bin/wlruntime_vars &> /dev/null

  if [[ -e /usr/share/wsessions.d/default.environment ]]
  then
    ReadEnvironmentFile /usr/share/wsessions.d/default.environment
  fi

  if [[ -e $EnvironmentFile ]]
  then
    ReadEnvironmentFile "$EnvironmentFile"
  fi

  #Create a folder for the logs
  if [[ ! -e ~/wlsessionlogs ]]
  then
    mkdir ~/wlsessionlogs
  fi

  #Create a /tmp/.X11-unix/ folder, don't assume it exists
  mkdir /tmp/.X11-unix/

  #Cleanup old log files
  LOGFILECOUNT=0
  ls -t ~/wlsessionlogs/waylandsession* 2>/dev/null | while read LOGFILE
  do
    ((LOGFILECOUNT++))
    if [[ $LOGFILECOUNT > 4 ]]
    then
      rm "$LOGFILE"
    fi
  done

  #set all arguments into an array
  ArgumentString=$(echo -en "$@")
  DATESTAMP=$(date +%s)
  export WLM_SESSION_LOG="$HOME"/wlsessionlogs/waylandsession_$DATESTAMP.log
  echo "Started with the arguments: $ArgumentString" >> "$HOME"/wlsessionlogs/waylandsession_$DATESTAMP.log
  eval set -- $ArgumentString >> "$HOME"/wlsessionlogs/waylandsession_$DATESTAMP.log
  ArgArray=($ArgumentString)
  unset IFS

  #if the user booted with wlmforceswrender, force software rendering to be enabled
  if [[ $(grep -c "\bwlmforceswrender\b" /proc/cmdline ) != 0 ]]
  then
    if [[ $DefaultBackendType == KMS ]]
    then
      export PIXMANARGS="--use-pixman"
    fi
    export LIBGL_ALWAYS_SOFTWARE=1
  else
    export PIXMANARGS=""
  fi

  #if the user booted with wlmforcevblankoff, force vblank to be disabled
  if [[ $(grep -c "\bwlmforcevblankoff\b" /proc/cmdline) != 0 ]]
  then
    export vblank_mode=0
  fi

  if [[ $BackendType == WL ]]
  then
    if [[ $DefaultBackendType == FB ]]
    then
      HostBackendArgument="--backend=fbdev-backend.so"
    else
      HostBackendArgument="--backend=drm-backend.so"
    fi
    weston --no-config $PIXMANARGS --seat=$XDG_SEAT --shell=fullscreen-shell.so --socket=$WAYLAND_HOST $HostBackendArgument &>> "$HOME"/wlsessionlogs/waylandhost.log &
    HostServerPID=$!
    export WAYLAND_DISPLAY=$WAYLAND_HOST
    WaitTimes=0
    #Wait for the server to start up for a maximum of 15 seconds. As soon as the socket is created, the wait loop ends
    while [[ ! -e $XDG_RUNTIME_DIR/$WAYLAND_DISPLAY && $WaitTimes<15 ]]
    do
      $SLEEPCMD 1
      ((WaitTimes++))
    done
    #If the socket doesn't exist, then the server failed to start, and switch back
    if [[ ! -e $XDG_RUNTIME_DIR/$WAYLAND_DISPLAY ]]
    then
      echo "The host server failed to start. Will not start the guest server for this session. Please see $HOME/wlsessionlogs/waylandhost.log" &>> "$HOME"/wlsessionlogs/waylandsession_$DATESTAMP.log
      SendSelfCommand Change "$XDG_SEAT"
      exit
    fi
  else
    export WAYLAND_DISPLAY=$WAYLAND_GUEST
    unset WAYLAND_HOST
    unset WAYLAND_GUEST
  fi

  #Execute first run scripts
  if [[ ! -e "$HOME"/.config/wlmfirstlogin ]]
  then
    dbus-launch --exit-with-session -- /usr/bin/wlruntime_firstrun
    mkdir -p "$HOME"/.config/
    touch "$HOME"/.config/wlmfirstlogin
  fi

  #Execute the Wayland server, and log it to $HOME/wlsessionlogs/waylandsession_$DATESTAMP.log
  dbus-run-session -- ${ArgArray[@]} &>> "$HOME"/wlsessionlogs/waylandsession_$DATESTAMP.log &
  GuestServerPID=$!

  #Terminate the host server after the guest terminates
  if [[ $BackendType == WL ]]
  then
    fg 2
    echo "The guest session has ended. Terminating the host..." &>> "$HOME"/wlsessionlogs/waylandhost.log
    kill -15 $HostServerPID &> /dev/null
    $SLEEPCMD 3
    kill -9 $HostServerPID &> /dev/null
  else
    fg 1
  fi

  #Write any Journal logs for this session into the logfile
  echo -e "\nSession's Journal Logs:" >> "$HOME"/wlsessionlogs/waylandsession_$DATESTAMP.log
  journalctl -b _SYSTEMD_SESSION=$XDG_SESSION_ID >> "$HOME"/wlsessionlogs/waylandsession_$DATESTAMP.log

  exit
}

function UIHost 
{
  "$@"
  exit
}

#Function that takes the argument of an environment file, and handles the definitions (for --usersession)
function ReadEnvironmentFile
{
  #parse the session event file if specified, and it exists
  EnvironmentFileData=$(sed '0,/\[EnvironmentFile\]/d;/^\[/Q' "$1" | awk -F \# '{print $1}' | sed  -e "s/ *= */\#/g" -re "s/ *@([A-Z]*)$/\#\1/g")

  IFS=$'\n'
  EnvironmentFileData=($EnvironmentFileData)
  unset IFS

  for EnvironmentFileLine in ${EnvironmentFileData[@]}
  do
    #environment files are specified as action=var=data
    #Examples
    #set=varname=data sets variable called varname, with the content of data.
    #unset=varname unsets a variable called varname
    #unset=varname@FB unsets a variable called varname ONLY if the current backend is FB. waylandloginmanager tells this script what the current backend is
    IFS="#"
    EnvironmentFileLine=($EnvironmentFileLine)
    unset IFS

    VARACTION=${EnvironmentFileLine[0]}
    VARNAME=${EnvironmentFileLine[1]}
    VARDATA=${EnvironmentFileLine[2]}
    VARBACKEND=${EnvironmentFileLine[3]}

    #Only expand some variables
    if [[ $VARDATA == "\$WAYLAND_DISPLAY" ]]
    then
      VARDATA=$WAYLAND_DISPLAY
    fi
    if [[ $VARDATA == "\$XDG_SEAT" ]]
    then
      VARDATA=$XDG_SEAT
    fi

    #if the backend for this line is unspecified, OR if the backend on this line matches the current one running then handle the variable
    if [[ -z $VARBACKEND || $VARBACKEND == $BackendType ]]
    then
      #if it is set, then set the variable
      if [[ $VARACTION == "set" ]]
      then
        export $VARNAME=$VARDATA
      fi
      #if it is unset, then unset the variable
      if [[ $VARACTION == "unset" ]]
      then
        unset $VARNAME
      fi

    fi
  done
}

#All functions below this point are for the main operation of the waylandloginmanager

#This function writes to the logs. It takes 1 argument, the string to log.
function WriteToLog
{
  logger -t waylandloginmanager "$1" -s  >>/var/log/waylandloginmanager 2>&1
}

#Function that takes no arguments that does the first steps in setting up the environment, and detecting hardware support, and previous instances for starting up the login manager
function PrepareLoginManager
{
  #Create the waylandloginmanager folder in /run for FIFOs and lockfiles
  mkdir -p /run/waylandloginmanager
  touch /run/waylandloginmanager/fifolock

  #Detect another instance, by creating a testing a lockfile, which is a symlink to /proc/pid/cmdline, and making sure the second line of /proc/pid/cmdline matches (as it's the path to the script).
  SCRIPTPATH=$(readlink -f "$0")
  SCRIPTNAME=$(echo "$SCRIPTPATH" | sed 's\/\\g')
  LOCKSCRIPT=$(readlink -f "$(strings -a "/run/waylandloginmanager/$SCRIPTNAME.lock" 2>/dev/null | sed -n 2p)" )
  if [[ "$SCRIPTPATH" != "$LOCKSCRIPT" ]]
  then
    rm -r "/run/waylandloginmanager/$SCRIPTNAME.lock" 2>/dev/null
    ln -s /proc/"$$"/cmdline "/run/waylandloginmanager/$SCRIPTNAME.lock"
  else
    WriteToLog "Error: Another instance is already running"
    exit 1
  fi
  #second check to make sure this instance 'won' as a second instance could report success, and execute as the first instance is OK to run, but before it creates the lockfile
  #this ensures that the linked /proc/pid/cmdline is this pid
  LOCKPROCPATH=$(dirname $(readlink "/run/waylandloginmanager/$SCRIPTNAME.lock" ))
  THISPROCPATH=/proc/$$
  if [[ $LOCKPROCPATH != $THISPROCPATH ]]
  then
    WriteToLog "Error: Another instance is already running"
    exit 1
  fi

  #Require root privlages
  if [[ $UID != 0 ]]
  then
    echo "Must be run as root."
    exit 1
  fi
  
  #Configure missing things if they are missing. This can be turned on or off
  AutoConfig=0
  if [[ $AutoConfig == 1 ]]
  then

    #Create a user for non-privlaged commands for the waylandloginmanager if it doesn't exist
    if [[ $(id waylandloginmanager &>/dev/null; echo $? ) == 1 ]]
    then
      WriteToLog "Error: The user waylandloginmanager does NOT exist. Creating the user account..."
      adduser --no-create-home --home=/etc/loginmanagerdisplay --shell=/bin/bash --disabled-password --system --group waylandloginmanager
    fi

    #Create needed PAM file
    if [[ ! -e /etc/pam.d/waylandloginmanager ]]
    then
        echo "#%PAM-1.0
session [success=ok ignore=ignore module_unknown=ignore default=bad] pam_selinux.so close
auth            optional        pam_group.so
auth            sufficient      pam_rootok.so
session         optional        pam_keyinit.so revoke
session         required        pam_limits.so
session         required        pam_unix.so
session         optional        pam_systemd.so type=wayland
session         optional        pam_ecryptfs.so unwrap
" > /etc/pam.d/waylandloginmanager
    fi
    
    if [[ ! -e /lib/udev/rules.d/70-uaccess-fbdev.rules ]]
    then
      echo "ACTION=="remove", GOTO="uaccess_fbdev_end"
ENV{MAJOR}=="", GOTO="uaccess_fbdev_end"


# Framebuffer devices
SUBSYSTEM=="graphics", KERNEL=="fb*", TAG+="uaccess"

LABEL="uaccess_fbdev_end"" > /lib/udev/rules.d/70-uaccess-fbdev.rules
    fi
  fi

  #prevent the WaylandLoginManager from being killed with CTRL+C
  trap '' 2

  #Attempt to import fast user switching data from a crashed WaylandLoginManager
  if [[ -e /run/waylandloginmanager/sessiondata ]]
  then
    . /run/waylandloginmanager/sessiondata
  else
    touch /run/waylandloginmanager/sessiondata
    chmod 700 /run/waylandloginmanager/sessiondata
  fi

  #Set up the needed environment variables
  cd /run/waylandloginmanager

  #Enable job control in this script
  set -m

  export XDG_CONFIG_HOME=/etc/loginmanagerdisplay/
  #User that the zenity dialogs and the loginmanagerdisplay (weston instance for the waylandloginmanager runs as
  export LOGINMANAGERDISPLAYUSER=waylandloginmanager
  #User that the su test in AuthenticateUser user runs as
  export PROBETESTUSER=waylandloginmanager
  #User that reads from the loginmanager_control FIFO, and filters the command sent to it to loginmanager_listener
  export FIFOREADERUSER=waylandloginmanager
  #Get the UID of the $LOGINMANAGERDISPLAYUSER
  export LOGINMANAGERDISPLAYUID=$(id $LOGINMANAGERDISPLAYUSER -u)
  #Set Wayland/runtime vars
  export PATH=/opt/bin:$PATH
  export DEB_HOST_MULTIARCH=$(dpkg-architecture -qDEB_HOST_MULTIARCH 2>/dev/null)
  export LD_LIBRARY_PATH=/opt/lib/$DEB_HOST_MULTIARCH:/usr/local/lib/$DEB_HOST_MULTIARCH:/usr/lib/$DEB_HOST_MULTIARCH:/opt/lib:/usr/local/lib:/usr/lib
  export XDG_DATA_DIRS=/opt/share:/usr/share
  export GDK_BACKEND=wayland
  export XDG_RUNTIME_DIR=/run/user/$LOGINMANAGERDISPLAYUID
  #Set the default path for weston
  export DEFAULTWAYLANDSERVER=$(which weston)
  #Specify where wsession files are found
  export WSESSIONSPATH="/usr/share/wsessions.d"
  export WESTON_PLUGIN_PATH=/opt/lib/$DEB_HOST_MULTIARCH/weston
  #WLM_LD_LIBRARY_PATH is exported so that it can set it as LD_LIBRARY_PATH, as the sudo command that starts it as the LOGINMANAGERDISPLAYUSER drops LD_LIBRARY_PATH, and do the same for PATH
  export WLM_LD_LIBRARY_PATH=$LD_LIBRARY_PATH
  export WLM_PATH=$PATH
  # TODO if Weston fbdev becomes seat aware, change to 1
  export WESTON_FBDEV_SEAT_AWARE=0
  # TODO Determine if this is needed, how weston handles multisession on non seat0
  export ONLY_SEAT0_SESSION_SWITCH=1
  #if the user booted with a hidden option wlmforceswrender, force software rendering to be enabled
  if [[ $(grep -c "\bwlmforceswrender\b" /proc/cmdline) != 0 ]]
  then
    export WLM_FORCE_SOFTWARE=1
    export LIBGL_ALWAYS_SOFTWARE=1
  else
    export PIXMANARGS=""
  fi
  #if the user booted with wlmforcevblankoff, force vblank to be disabled
  if [[ $(grep -c "\bwlmforcevblankoff\b" /proc/cmdline) != 0 ]]
  then
    export vblank_mode=0
  fi
  #set MinimumTTY to be 7. this causes the first TTY to try to put the WaylandLoginManager on as tty8.
  MinimumTTY=7
  #default the number of sessions registered to be 0 if unset
  if [[ -z $AllSessions ]]
  then
    export AllSessions=0
  fi

  #Determine if this is running on a live instance, if the root filesystem is overlayfs.
  FSTYPE=$(df / -T | awk '{print $2}' | grep -v Type)
  if [[ $FSTYPE =~ overlay ]]
  then
    ISLIVE=1
  fi

  ZENITYCMD="sudo -E -u $LOGINMANAGERDISPLAYUSER $0 --uihost zenity"
  TERMINALCMD="sudo -E -u $LOGINMANAGERDISPLAYUSER $0 --uihost vte"

  #Detect hardware abilities, first try to see if the system has kernel mode setting, then try framebuffer. if both aren't supported, bring up a text mode dialog
  if [[ $(ls  /dev/dri/card* 2>/dev/null ) && $(grep -c "\bwlmforcefbdev\b" /proc/cmdline) == 0 ]]
  then 
    WriteToLog "Kernel mode setting found."
    HardwareSupported=1
  else
    WriteToLog "No kernel mode setting found. Using the framebuffer"
  fi
  if [[ $(ls  /dev/fb* 2>/dev/null) ]]
  then
    if [[ $(grep -c "\bwlmglobalfbpermissions\b" /proc/cmdline) != 0 ]]
    then
      WriteToLog "WARNING: The 'wlmglobalfbpermissions' option has been passed to the kernel. This causes the waylandloginmanager to give the plugdev group and $LOGINMANAGERDISPLAYUSER access to all framebuffer device files"
      setfacl -m "g:plugdev:rwx" /dev/fb*
      setfacl -m "g:$LOGINMANAGERDISPLAYUSER:rwx" /dev/fb*
    fi
    HardwareSupported=1
  else
    WriteToLog "No framebuffer support found"
  fi


  #if the user booted with a hidden option wlmforcefbdev, set the backend for Weston / Wayland server sessions to be fbdev
  if [[ $(grep -c "\bwlmforcefbdev\b" /proc/cmdline) != 0 ]]
  then
    WriteToLog "Manually override set to use to use the framebuffer"
    if [[ $HardwareSupported != 1 ]]
    then
      WriteToLog "ERROR: No framebuffer device found for wlmforcefbdev override!"
      openvt -c 63 -s -f -w -- sudo -E -u $LOGINMANAGERDISPLAYUSER dialog --msgbox "The wlmforcefbdev overide is set, but no framebuffer device is found!

Will show a menu with a few options for diagnosis." 20 50 --no-cancel
      openvt -c 63 -s -f -w -- rbos-failedboot
      systemctl stop waylandloginmanager.service
      exit 1
    fi
  fi

  #if there is no Framebuffer or Kernel mode setting, tell the user with a text mode dialog on TTY63, and restart.
  #Depending if this is a live session or not, tell the user how to configure grub if it is installed, or to specify a boot option for the framebuffer from the menu if its live
  if [[ $HardwareSupported != 1 ]]
  then
    if [[ $ISLIVE == 1 ]]
    then
      WriteToLog "ERROR: No supportable hardware found"
      openvt -c 63 -s -f -w -- sudo -E -u $LOGINMANAGERDISPLAYUSER dialog --msgbox "No Kernel Mode Setting, or Framebuffer device found.

This means your video card does not support KMS, and doesn't create a framebuffer by default. either of which are needed for Weston to work.

You can select a Framebuffer boot option when you start the Live CD, to force a boot with a framebuffer device." 20 50 --no-cancel
    else 
      openvt -c 63 -s -f -w -- sudo -E -u $LOGINMANAGERDISPLAYUSER dialog --msgbox "No Kernel Mode Setting, or Framebuffer device found.

This means your video card does not support KMS, and doesn't create a framebuffer by default. either of which are needed for Weston to work.

Will now start a utility to assist you in configuring your system to boot with a framebuffer device." 20 50 --no-cancel
      openvt -c 63 -s -f -w -- rbos-add-framebuffer
    fi
    openvt -c 63 -s -f -w -- sudo -E -u $LOGINMANAGERDISPLAYUSER dialog --msgbox "Can not start Weston.

Will now reboot." 20 50 --no-cancel
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Reboot boolean:true
    systemctl stop waylandloginmanager.service
    exit 1
  fi

  ReadyNotifySent=0
  #Get the TTY that will hold the Wayland server that displays the login screen for seat0
  RUNNINGWLMCOUNT=$(fuser /run/user/$LOGINMANAGERDISPLAYUID/loginmanagerdisplay_* |& wc -l )
  OLDSEAT0PID=$(fuser /run/user/$LOGINMANAGERDISPLAYUID/loginmanagerdisplay_seat0 2>/dev/null)
  if [[ $RUNNINGWLMCOUNT != 0 ]]
  then
    if [[ ! -z $OLDSEAT0PID ]]
    then
      LOGINMANAGERDISPLAYTTY=$(ps --no-headers $OLDSEAT0PID | awk '{print $2}' | sed 's/tty//g')
    fi
    #Get the logind session of the weston instance running loginmanagerdisplay for each seat
    AllRunningSeats=($(loginctl --no-legend list-seats))
    for RunningSeat in ${AllRunningSeats[@]}
    do
      GetLoginManagerDisplaySession 0 $RunningSeat
    done
    systemd-notify --ready
  else
    LOGINMANAGERDISPLAYTTY=$(GetNextTTY)
  fi

  MinimumTTY=$LOGINMANAGERDISPLAYTTY
  if [[ $LOGINMANAGERDISPLAYTTY -eq -1 ]]
  then
    WriteToLog "ERROR: Not Enough TTYs for login manager display!"
    systemctl stop waylandloginmanager.service
    exit 1
  fi

  #Enable full alt+sysrq, and allow a debug login terminal window when wlmdebug is passed as a kernel argument. This is for testing general issues with the waylandloginmanager
  if [[ $(grep -c "\bwlmdebug\b" /proc/cmdline) != 0 ]]
  then
    echo 1 > /proc/sys/kernel/sysrq
    WriteToLog "WARNING: The diagnostic 'wlmdebug' option has been passed to the kernel, or the system is in Live CD mode. This causes the waylandloginmanager to enable all magic sysrq keys, including the ability to kill processes, and the waylandloginmanager will respond to the Debug command when sent to the main control FIFO, by spawning a graphical login terminal window on the loginmanagerdisplay"
    wlmdebug=1
  fi

  #Enable full alt+sysrq, and allow a debug root terminal window when wlmdebuginsecure is passed as a kernel argument, this is for testing commands that need to be run within the same context as the waylandloginmanager
  if [[ $(grep -c "\bwlmdebuginsecure\b" /proc/cmdline) != 0 ]]
  then
    echo 1 > /proc/sys/kernel/sysrq
    WriteToLog "WARNING: The diagnostic and insecure 'wlmdebuginsecure' option has been passed to the kernel. This causes the waylandloginmanager to enable all magic sysrq keys, including the ability to kill processes, and the waylandloginmanager will respond to the Debug command when sent to the main control FIFO, by spawning a graphical ROOT terminal window on the loginmanagerdisplay"
    wlmdebug=1
    wlmdebuginsecure=1
  fi
  
  #if /etc/waylandloginmanager.conf exists, use the autologin user specified in that file, if not try the lightdm config file
  if [[ -e /etc/waylandloginmanager.conf ]]
  then
    AUTOLOGINUSER=$(awk -F "#" '{print $1}' /etc/waylandloginmanager.conf | grep autologin-user= | awk -F = '{print $2}' | head -1 )
  else
    AUTOLOGINUSER=$(awk -F "#" '{print $1}' /etc/lightdm/lightdm.conf | grep autologin-user= | awk -F = '{print $2}' | head -1 )
    echo "autologin-user=$AUTOLOGINUSER" >> /etc/waylandloginmanager.conf
  fi
}


#This function sends the KDSETMODE ioctl (0x4B3A) with the parameter KD_TEXT (0x00) to the active TTY, then it sends the VT_SETMODE ioctl (0x5602) with the parameter VT_AUTO (0x00) to the active TTY
#This forces the TTY to be in a state that allows the kernel to switch the TTY (switching to VT_AUTO), instead of a process (VT_PROCESS), when it's in VT_PROCESS, and the process is defunct, the TTY switch fails.
function ResetTTYMode
{
    python3 -c "from array import array; \
from fcntl import ioctl; \
buf = array('h', [0]); \
buf[0] = 0; \
fd = open('/dev/tty$1', 'wb'); \
ioctl(fd, 0x4B3A, 0); \
ioctl(fd, 0x05602, buf); \
fd.close()"
}

#This function is used by the WaylandLoginManager to find the next availible tty, starting from CalcTTY+1
#it prints the TTY number to stdio. takes no arguments. If it can't find an open tty, it returns -1
function GetNextTTY
{
  SYSTEMDTTYS=()
  #Only seat0 has TTYs
  SESSIONS=($(loginctl show-seat seat0 -p Sessions --value 2>/dev/null ))
  for SESSION in ${SESSIONS[@]}
  do
    SYSTEMDTTYS+=($(loginctl show-session $SESSION -p TTY --value))
  done

  TTYNotInLogind=0
  TTYNotInUse=0
  CalcTTY=$MinimumTTY
  #cycle through all ttys, stopping at tty63, as tty63 is 'reserved' by the waylandloginmanager as the tty to switch to in between sessions, as there is issues switching directly between two Weston servers.
  while [[ ($TTYNotInUse -ne 1 && $CalcTTY -lt 62) || $TTYNotInLogind -gt 0 ]]
  do
    ((CalcTTY++))
    fuser -s /dev/tty$CalcTTY
    TTYNotInUse=$?
    TTYNotInLogind=0
    for SYSTEMDTTY in ${SYSTEMDTTYS[@]}
    do
      if [[ $SYSTEMDTTY == "/dev/tty$CalcTTY" ]]
      then
        ((TTYNotInLogind++))
      fi
    done
  done

  if [[ $TTYNotInUse -ne 1 ]]
  then
    AvailibleTTY=-1
  else
    AvailibleTTY=$CalcTTY
  fi

  echo $AvailibleTTY
}

#Export session data so the waylandloginmanager has user switching data in case of a reload
function ExportSessionData
{
  EXPORTSTRING=$(declare -p AllSessions AllSessionTTYs AllSessionPIDs AllSessionUsers AllSessionIDs AllSeatIDs)
  echo "${EXPORTSTRING//declare/declare -g}" > /run/waylandloginmanager/sessiondata
}

#This function sends a command to the waylandloginmanager's own loginmanager_control FIFO. It takes 2 arguments, the command to send to the command FIFO, and the relevant seat
function SendSelfCommand
{
  SENDCOMMAND=$1
  SENDSEATARG=$2
  while [[ -e /run/waylandloginmanager/fifolock ]]
  do
    $SLEEPCMD 1
  done
  echo -e "\n$SENDCOMMAND@$SENDSEATARG" > /run/waylandloginmanager/loginmanager_control
}

#This function sends registration data to the waylandloginmanager's own loginmanager_register FIFO. It takes 1 argument, the data string to send to the registration FIFO.
function SendSelfRegisterData
{
  SENDDATA=$1
  while [[ -e /run/waylandloginmanager/fifolock ]]
  do
    $SLEEPCMD 1
  done
  echo "$SENDDATA" > /run/waylandloginmanager/loginmanager_register &
  SendSelfCommand RegisterSession
}

#This function is called when the loginmanager_control FIFO recives the command "RegisterSession". This function will read the contents of loginmanager_register, which only root can write to. 
#Before a process calls RegisterSession to loginmanager_control, the process must also start an attempt to send the data to loginmanager_register, because the timeout period is .01 seconds. If nothing is in loginmanager_register, as if it's not called correctly, or because it's an underprivlaged process that can't write to loginmanager_register, it is ignored.
#it expects the data to be sent in fields seperated by the @ charachter in this order:
# NEWSESSION@TTY_Number@PID_of_Session_Process@User_Name@logind_Session_ID@SEAT@DoLock
# or
# NEWWLMDISPLAY@logind_Session_ID@SEAT
function RegisterSession
{
  #get the data from loginmanager_register
  exec 1001<> /run/waylandloginmanager/loginmanager_register
  RegisterData=$(while read -n 100 -t .01 data <&1001; do echo $data; done| head -1)
  exec 1001>&-
  #get the register data, and put it into an array so it can be handled
  IFS='@'
  ArraySessionData=($RegisterData)
  unset IFS
  RegisterType=${ArraySessionData[0]}
  if [[ ! -z $RegisterData ]]
  then
    WriteToLog "received session data $RegisterData"
    if [[ $RegisterType == NEWSESSION ]]
    then
      #Add the session data to the arrays that store info about the sessions.
      SessionTTY=${ArraySessionData[1]}
      SessionPID=${ArraySessionData[2]}
      SessionUser=${ArraySessionData[3]}
      SessionID=${ArraySessionData[4]}
      SessionSeatID=${ArraySessionData[5]}
      SessionDoLock=${ArraySessionData[6]}
      if [[ ! -z $SessionTTY && ! -z $SessionPID && ! -z $SessionUser && ! -z $SessionID ]]
      then
        AllSessionTTYs+=($SessionTTY)
        AllSessionPIDs+=($SessionPID)
        AllSessionUsers+=($SessionUser)
        AllSessionIDs+=($SessionID)
        AllSeatIDs+=($SessionSeatID)
        #increment the number of running sessions, now that one is added and running successfuly
        ((AllSessions++))
        #Export the Session data
        ExportSessionData
        if [[ $SessionDoLock == 1 && $ISLIVE != 1 ]]
        then
          loginctl lock-session $SessionID 2> /dev/null
        fi
      else
        WriteToLog "Session failed to start"
        SessionStartFailed=1
        FailedSessionTTY=$SessionTTY
        FailedSessionSeat=$SessionSeatID
      fi


    elif [[ $RegisterType == NEWWLMDISPLAY ]]
    then
      RegisterSeat=${ArraySessionData[2]}
      if [[ $ReadyNotifySent == 0 ]]
      then
        systemd-notify --ready
        ReadyNotifySent=1
      fi
      #Remove sessions that are not running from the array
      RUNNINGSESSIONS=($(loginctl --no-legend list-sessions | while read SESSION OTHERCOLS; do echo $SESSION; done))
      REGISTEREDSESSIONS=(${LOGINMANAGERDISPLAYSESSIONS[@]})
      LOGINMANAGERDISPLAYSESSIONS=()

      for REGISTEREDSESSION in ${REGISTEREDSESSIONS[@]}
      do
        AddSession=0
        IFS=@
        REGISTEREDSESSIONDATA=($REGISTEREDSESSION)
        unset IFS
        for RUNNINGSESSION in ${RUNNINGSESSIONS[@]}
        do
          if [[ ${REGISTEREDSESSIONDATA[0]} == $RUNNINGSESSION ]]
          then
            AddSession=1
            break
          fi
        done
        if [[ $AddSession == 1 ]]
        then
          LOGINMANAGERDISPLAYSESSIONS+=($REGISTEREDSESSION)
        fi
      done
      REGISTEREDSESSIONS=()

      LOGINMANAGERDISPLAYSESSIONS+=($RegisterSeat@${ArraySessionData[1]})
    fi
  else
    WriteToLog "register session requested, but no data was availible in the FIFO"
  fi
}

#This function takes three arguments. The first is the number of seconds to wait, and the second is the string to show in the dialog. it shows a Zenity dialog with a progress bar to count down the specified time, with the string. The third is the seat to display it on
function DialogWait
{
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$3"
  waitseconds=$1
  displaystring="$2"
  countseconds=0
  while [[ $countseconds -lt $waitseconds ]]
  do
    percent=$(( $countseconds * 100 / $waitseconds ))
    echo $percent
    ((countseconds++))
    $SLEEPCMD 1
  done | $ZENITYCMD --width=450 --title="Login Manager" --no-cancel --progress --auto-close --text="$displaystring" 2>/dev/null
}

#This function takes 1 argument, the seat that the loginmanagerdisplay belongs to, and waits for the loginmanagerdisplay to startup
function DisplayServerWait
{
  while [[ $(fuser -s /run/user/$LOGINMANAGERDISPLAYUID/loginmanagerdisplay_"$1" &>/dev/null; echo $?) == 1 ]]
  do
    $SLEEPCMD 1
  done
}

#This is called by GetUserCredentials and by StartAutoLogin. This allows the user select the session they want to use, similar to how X login managers prompt for the session before the login.
#it exports the WSESSIONDATA variable, which contains arguments and varaibles and the command to run to start a session
#It takes 1 argument, the seat to show the dialogs on
function ChooseSessionType
{
  CurrentHandleSeat="$1"
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$CurrentHandleSeat"
  #The number of Session IDs start from 0. when a session is added, the number of running sessions is 1 for the next session. The second session gets the ID of 1 etc...
  export SESSIONID=${AllSessions}000
  export WAYLAND_HOST=wlhost-$SESSIONID
  export WAYLAND_GUEST=wayland-$SESSIONID

  unset WSESSIONLIST
  FirstRunNotRan=0

  SeatDefaultBackendType=""
  SeatSupportsKMS=$(loginctl seat-status "$CurrentHandleSeat" |grep -e "/drm/card[0-9]*$" -c)
  SeatSupportsFB=$(loginctl seat-status "$CurrentHandleSeat" |grep -e "/graphics/fb[0-9]*$" -c)
  FB0INSEAT0=$(loginctl seat-status seat0 |grep -e "/graphics/fb0$" -c)
  if [[ $SeatSupportsKMS != 0 && $(grep -c "\bwlmforcefbdev\b" /proc/cmdline) == 0  ]]
  then
    SeatSupportedBackends+=(KMS)
    SeatDefaultBackendType=KMS
  fi
  if [[ $SeatSupportsKMS != 0 || ($SeatSupportsFB != 0 && $WESTON_FBDEV_SEAT_AWARE == 1 ) ]]
  then
    SeatSupportedBackends+=(WL)
  else
    if [[ "$CurrentHandleSeat" == "seat0" && $FB0INSEAT0 != 0 ]]
    then
      SeatSupportedBackends+=(WL)
    fi
  fi
  if [[ $SeatSupportsFB != 0 ]]
  then
    SeatSupportedBackends+=(FB)
    SeatDefaultBackendType=FB
  fi
  #Parse the list of sessions specified, so that zenity can use it as a list of sessions
  #Find all executable files, in the wsessions path (and not in any of its subdirectories) 
  #The subshell outputs a multiline string with all session data. every session is a fixed number of lines.
  #ONLY the session lines should be set through stdio in the while loop. This string is sent to a zenity dialog.
  while read SESSIONFILE
  do
    IsExecutable=$(find $SESSIONFILE |wc -l)
    if [[ $IsExecutable == 0 ]]
    then
      WriteToLog "Warning: $SESSIONFILE is not executable, the session will not be availible for selection by the user."
    fi
    #split away all the data from this file, starting at [Desktop Entry]
    DesktopFileData=$(sed '0,/\[Desktop Entry\]/d;/^\[/Q' "$SESSIONFILE" | awk -F \# '{print $1}')
    #Read all the supported values that are specified in the wsession file

    #Append empty values to the bottom of the DesktopFileData, This is so that when parsed for an array, the array elements line up. The FIRST result will be matched by sed,
    #Only single occuring, non dynamic values (as in NOT the backend type) will be handled by the array, which is most values
    DesktopFileDataWithPlaceholders=$DesktopFileData$'\n'"Enabled="$'\n'"Name="$'\n'"Comment="$'\n'"Type="$'\n'"IsFallbackSession="$'\n'"CompositorDisplayArgument="$'\n'"CompositorSeatArgument="$'\n'"SessionArgument="$'\n'"AdditionalArguments="$'\n'"CompositorExec="$'\n'"EnvironmentFile="$'\n'

    #Create an array with a fixed layout for the values.
    IFS=$'\n'
    DesktopFileMainArray=($(echo "$DesktopFileDataWithPlaceholders" | sed -e 's/[0-9][0-9][0-9]#//g' -e 's/^ *Enabled *= */000#/' -e 's/^ *Name *= */001#/' -e 's/^ *Comment *= */002#/' -e 's/^ *Type *= */003#/' -e 's/^ *IsFallbackSession *= */004#/' -e 's/^ *CompositorDisplayArgument *= */005#/' -e 's/^ *CompositorSeatArgument *= */006#/' -e 's/^ *SessionArgument *= */007#/' -e 's/^ *AdditionalArguments *= */008#/' -e 's/^ *CompositorExec *= */009#/' -e 's/^ *EnvironmentFile *= */010#/' -e "/^[0-9][0-9][0-9]#/!d" | sort -t "#" -k1,1 -u))
    unset IFS

    #Create an array of arrays (each line has three fields seperated by |, which is then treated as an array) describing the backends supported by the session
    IFS=$'\n'
    DesktopFileBackendArray=($(echo "$DesktopFileData" | sed  -e 's/[0-9][0-9][0-9]#//g' -re "s/^ *CompositorSupports([A-Z]*) *= */000#\1#/" -re  "s/^ *Compositor([A-Z]*)Arguments *= */001#\1#/"  -re  "s/^ *Compositor([A-Z]*)SeatAware *= */002#\1#/" -e "/^[0-9][0-9][0-9]#/!d" | sort -t "#" -u -k2,2 -k1,1))
    unset IFS

    Enabled=${DesktopFileMainArray[0]:4}
    SessionName=${DesktopFileMainArray[1]:4}
    SessionComment=${DesktopFileMainArray[2]:4}
    Type=${DesktopFileMainArray[3]:4}

    #Search for backends supported by the compositor, with the backends the hardware supports. Give presence to the first one found in the array of supported backend types, the best backend types are first in the array
    SupportsBackend=0
    for (( element1 = 0 ; element1 < ${#SeatSupportedBackends[@]} ; element1++ ))
    do
      export BackendType=${SeatSupportedBackends[$element1]}
      for (( element2 = 0 ; element2 < ${#DesktopFileBackendArray[@]} ; element2++ ))
      do
        IFS="#"
        ThisBackendArray=(${DesktopFileBackendArray[$element2]})
        unset IFS
        if [[ ${ThisBackendArray[1]} == $BackendType ]]
        then
          if [[ ${ThisBackendArray[2]} == 1 && ${ThisBackendArray[0]} == 000 ]]
          then
            SupportsBackend=1
            break
          else
            SupportsBackend=0
          fi
        fi
      done
      if [[ $SupportsBackend == 1 ]]
      then
        break
      fi
    done

    #See if the current sessions backend is multiseat aware
    SupportsSeat=0
    if [[ ! -z $BackendType ]]
    then
      for (( element = 0 ; element < ${#DesktopFileBackendArray[@]} ; element++ ))
      do
        IFS="#"
        ThisBackendArray=(${DesktopFileBackendArray[$element]})
        unset IFS
        if [[ ${ThisBackendArray[1]} == $BackendType && ${ThisBackendArray[0]} == 002 ]]
        then
          SupportsSeat=${ThisBackendArray[2]}
          break
        fi
      done
    fi
    #If this is seat0, then don't enforce seatawareness
    if [[ $CurrentHandleSeat == seat0 && $BackendType="FB" ]]
    then
      if [[ $FB0INSEAT0 == 1 ]]
      then
        SupportsSeat=1
      fi
    elif [[ $CurrentHandleSeat == seat0 && $BackendType != "FB" ]]
    then
      SupportsSeat=1
    fi

    IsFallbackSession=${DesktopFileMainArray[4]:4}
    if [[ -z $IsFallbackSession ]]
    then
      IsFallbackSession=0
    fi
    CompositorDisplayArgument=${DesktopFileMainArray[5]:4}
    CompositorSeatArgument=${DesktopFileMainArray[6]:4}
    SessionArgument=${DesktopFileMainArray[7]:4}
    AdditionalArguments=${DesktopFileMainArray[8]:4}
    CompositorExec=${DesktopFileMainArray[9]:4}
    EnvironmentFile=${DesktopFileMainArray[10]:4}
    if [[ -z "$EnvironmentFile" ]]
    then
      EnvironmentFile=$SESSIONFILE
    fi
    unset BackendArguments
    if [[ ! -z $BackendType ]]
    then
      for (( element = 0 ; element < ${#DesktopFileBackendArray[@]} ; element++ ))
      do
        IFS="#"
        ThisBackendArray=(${DesktopFileBackendArray[$element]})
        unset IFS
        if [[ ${ThisBackendArray[1]} == $BackendType && ${ThisBackendArray[0]} == 001 ]]
        then
          BackendArguments=${ThisBackendArray[2]}
          break
        fi
      done
    fi
    #The strings in NeedsFile are expanded here, so that the script can later determine if the full expanded path exists.
    NeedsFile=$(echo "$DesktopFileData" | sed -e 's/[0-9][0-9][0-9]#//g' -e 's/^ *NeedsFile *= */000#/' -e "/[0-9][0-9][0-9]#/!d" -e 's/[0-9][0-9][0-9]#//g' | perl -pe 's/\$(\w+)/$ENV{$1}/g')
    if [[ ! -z $NeedsFile ]]
    then
      NeedsFile+=$'\n'
    fi
    NeedsFile+=$CompositorExec

    #Iterate through all NeedsFile values, to make sure that they exist. if one doesn't exist increment NotFoundCount.
    NotFoundCount=0
    while read FILE
    do
      if [[ ! -e $FILE && -n $FILE ]]
      then
        WriteToLog "Warning: Cannot find needed file $FILE for $SESSIONFILE , the session will not be availible for selection by the user."
        ((NotFoundCount++))
      fi
    done < <(echo "$NeedsFile")

    if [[ $Enabled != 1 ]]
    then
      WriteToLog "Warning: $SESSIONFILE is disabled, the session will not be availible for selection by the user."
    fi

    if [[ $SupportsBackend != 1 ]]
    then
      WriteToLog "Warning: $SESSIONFILE can't run on any backends supported by this seat: "${SeatSupportedBackends[*]}" , the session will not be availible for selection by the user."
    fi

    if [[ $SupportsSeat != 1 ]]
    then
      WriteToLog "Warning: $SESSIONFILE backends $BackendType does not support seats, the session will not be availible for selection by the user."
    fi

    if [[ $Type != "WSession" ]]
    then
      WriteToLog "Warning: $SESSIONFILE does not have a Type of 'WSession' , the session will not be availible for selection by the user."
    fi

    #if the session supports the CompositorDisplayArgument, for setting the WAYLAND_DISPLAY it should use, then ammend the WAYLAND_GUEST to the end of the command.
    if [[ ! -z $CompositorDisplayArgument ]]
    then
      CompositorDisplayArgument="$CompositorDisplayArgument$WAYLAND_GUEST"
    else 
      CompositorDisplayArgument=""
    fi

    #if the session supports the CompositorSeatArgument, for setting the XDG_SEAT it should use, then ammend the CurrentHandleSeat to the end of the command.
    if [[ ! -z $CompositorSeatArgument ]]
    then
      CompositorSeatArgument="$CompositorSeatArgument$CurrentHandleSeat"
    else
      CompositorSeatArgument=""
    fi

    #If the session is enabled, the backend is supported, all the files it needs are there, and its a wsession file, and is executable add the lines describing the session to the string.
    #This is sent through stdio which is added to teh WSESSIONLIST variable
    if [[ $NotFoundCount == 0 && $SupportsBackend == 1 && $SupportsSeat == 1 && $Enabled == 1 && $Type == "WSession" && $IsExecutable != 0 ]]
    then
      if [[ $FirstRunNotRan == 0 ]]
      then
        FirstRunNotRan=1
      else
        WSESSIONLIST+=$'\n'
      fi
      WSESSIONLIST+="$CompositorExec"$'\n'
      WSESSIONLIST+="$BackendArguments"$'\n'
      WSESSIONLIST+="$SessionArgument"$'\n'
      WSESSIONLIST+="$CompositorDisplayArgument"$'\n'
      WSESSIONLIST+="$CompositorSeatArgument"$'\n'
      WSESSIONLIST+="$AdditionalArguments"$'\n'
      WSESSIONLIST+="$EnvironmentFile"$'\n'
      WSESSIONLIST+=""$BackendType"_"$SeatDefaultBackendType"_"$IsFallbackSession"_"$'\n'
      WSESSIONLIST+="$SessionName"$'\n'
      WSESSIONLIST+="$SessionComment"
    fi
  done < <(find $WSESSIONSPATH -maxdepth 1 -name "*\.desktop" -type f | sort )


  #If wesessions where found above then show a zenity dialog. If there where none, use a default session.
  if [[ ! -z $WSESSIONLIST ]]
  then
    PROMPTED=1
    WSESSIONARRAY=()
    WSESSIONARRAYELEMENT=0
    while read LINE
    do
      WSESSIONARRAY[$WSESSIONARRAYELEMENT]="$LINE"
      ((WSESSIONARRAYELEMENT++))
    done <<< "$WSESSIONLIST"
    WSESSIONCOUNT=$((${#WSESSIONARRAY[@]}/10))

    WSESSIONPICKLIST=""
    for (( element=0; element<$WSESSIONCOUNT; element++ ))
    do
      if [[ ! -z $WSESSIONPICKLIST ]]
      then
        WSESSIONPICKLIST+=$'\n'
      fi
      WSESSIONPICKLIST+=$element$"#"${WSESSIONARRAY[$((8+element*10))]}"#"${WSESSIONARRAY[$((9+element*10))]}
    done
    WSESSIONPICKLIST=$(echo "$WSESSIONPICKLIST" | sort -t "#" -k 2,2 | sed 's/#/\n/g')
    #select the session. Each line is handled as a column. currently there are 9 collumns. So line 1 is is column 1, line 2 is in collumn 2, and line 10 is in collumn 1 again
    #The zenity dialog then outputs the selected session's lines into the WSESSIONDATA variable. each collumn is a different aspect of the wsessions
    WSESSIONNUMBER=$(echo "$WSESSIONPICKLIST" | $ZENITYCMD --title="Pick a Session..." --height=450 --width=630 --list --text "Select a Wayland Desktop Environment to use" --column sessionnumber --column Name --column Comment --hide-column=1 --print-column=1 2>/dev/null )
    #Abort if the user selected cancel on the zenity dialog
    CancelOrOK=$?
    if [[ $CancelOrOK != 0 ]]
    then
      exit 1
    fi
    WSESSIONDATA=${WSESSIONARRAY[$((0+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((1+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((2+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((3+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((4+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((5+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((6+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((7+WSESSIONNUMBER*10))]}$'\n'${WSESSIONARRAY[$((8+WSESSIONNUMBER*10))]}$'\n'

  else 
    unset WSESSIONDATA
    unset WSESSIONNUMBER
  fi

  #If there are wsessions, it does prompt the user, if the user doesn't select one, it tells the user that its falling back to the default. If there are no wsessions, it silently falls back to the default, by adding hardcoded values to the wsessiondata variable.
  if [[ -z $WSESSIONDATA ]]
  then 
    if [[ $PROMPTED == 1 ]]
    then
      $ZENITYCMD --width=500 --warning --text="No session selected. Defaulting to the Default Weston Desktop Shell." 2>/dev/null
    else
      WriteToLog "No sessions installed in $WSESSIONSPATH or no sessions are enabled, or are missing files specified by NeedsFile values. Defaulting to the Default Weston Desktop Shell"
    fi
    #There are different commands needed to support different backends
    if [[ $SeatDefaultBackendType == KMS ]]
    then
      WSESSIONDATA="$DEFAULTWAYLANDSERVER"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--backend=drm-backend.so"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+=""
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--socket=$WAYLAND_GUEST"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--seat=$USERSEAT"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--xwayland"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+=""
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="KMS_KMS_0_"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="Default Weston Desktop Shell"

    elif [[ $SeatDefaultBackendType == FB ]]
    then 
      WSESSIONDATA="$DEFAULTWAYLANDSERVER"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--backend=fbdev-backend.so"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+=""
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--socket=$WAYLAND_GUEST"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--seat=$USERSEAT"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="--xwayland"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+=""
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="FB_FB_0_"
      WSESSIONDATA+=$'\n'
      WSESSIONDATA+="Default Weston Desktop Shell"
    fi
    #export the WSESSIONDATA varaible
    export WSESSIONDATA
  fi
}


#This function displays a diagnostic terminal. depending on if the more secure debug option was passed, wlmdebug it, temporarilly copies a setuid /bin/login so that the host terminal window doesn't have to run as root, and the setuid login binary isn't accessible to the rest of the system, and opens the login terminal window running as a service user. If the more insecure wlmdebuginsecure option was passed, then it starts the terminal as root, with a root terminal.
#It takes 1 argument, the seat to display the terminal on
function DiagnosticTerminal 
{
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$1"
  if [[ $wlmdebuginsecure == 1 ]]
  then
    vte -g 500x300 &>/dev/null
  else
    mkdir -p /var/tmp/waylandloginmanager/logincmd
    chown $LOGINMANAGERDISPLAYUSER /var/tmp/waylandloginmanager/logincmd
    chmod 700 /var/tmp/waylandloginmanager/logincmd
    cp /bin/login /var/tmp/waylandloginmanager/logincmd
    chmod +s /var/tmp/waylandloginmanager/logincmd/login
    $TERMINALCMD -g 500x300 -c "screen -s /var/tmp/waylandloginmanager/logincmd/login" &>/dev/null
    wait -n $TERMINALJOB
    rm /var/tmp/waylandloginmanager/logincmd/login
  fi
}

#This function is called when the loginmanager_control recives the Info command. It brings up a help dialog for the user, about the waylandloginmanager and the system.
#It takes 1 argument, the seat to display the dialog on
function ShowInfo
{
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$1"
  #If the backend type is FB, then add a string to tell the user that in the help dialog
  if [[ $DefaultBackendType == "FB" ]]
  then
    BACKENDSTRING="The framebuffer backend is being used.

This probably means the current video card drivers do not 
support the native kernel mode setting that is optimal for Weston or other Wayland servers.
or the system was started with the wlmforcefbdev argument."
  else
    BACKENDSTRING="Kernel mode setting is being used.

This is the optimal way to run Weston or other Wayland servers."
  fi
  $ZENITYCMD --title="Information" --no-wrap --info --text="This is a third party fan made distribution!

$BACKENDSTRING

The Login Manager Display for seat0 is running on tty: $LOGINMANAGERDISPLAYTTY

The key icon brings up a login prompt
The arrow icon brings up a prompt to switch between running sessions
The red X icon brings up a shutdown prompt
The i icon shows this help prompt"

}

#This function is called when the loginmanager_control FIFO recives the command "Switch". It brings up a dialog containing the list of all running login sessions, to allow the user to pick and switch to start a mew session, by containing the FIFO.
#It takes 1 argument, the seat to display the dialog on, and only the sessions belonging to the seat will be shown
function SwitchUserDialog 
{
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$1"
  unset SessionList
  #get the number of registered sessions
  NumberOfSessions=${#AllSessionPIDs[@]}
  ((NumberOfSessions--))

  #go thorugh each session, reading the arrays containing information about the sessions. to build the SessionList variable
  #The session list variable is multiline, and used by a zenity dialog.
  #line 1 is the session number
  #line 2 is the TTY for the session
  #line 3 is the PID of the session
  #line 4 is the user name
  #line 5 is the logind session id.
  while [[ $NumberOfSessions -ge 0 ]]
  do
    #determine if the current session is alive, before adding it to the list
    if [[ -e /proc/${AllSessionPIDs[$NumberOfSessions]}/environ ]]
    then
    if [[ ! -z $SessionList ]]
      then
        SessionList+=$'\n'
      fi
      if [[ ${AllSeatIDs[$NumberOfSessions]} == "$1" ]]
      then
        SessionList+="$NumberOfSessions"$'\n'
        SessionList+="${AllSessionIDs[$NumberOfSessions]}"$'\n'
        SessionList+="${AllSessionPIDs[$NumberOfSessions]}"$'\n'
        SessionList+="${AllSessionUsers[$NumberOfSessions]}"$'\n'
        SessionList+="tty${AllSessionTTYs[$NumberOfSessions]}"
      fi
    fi
    ((NumberOfSessions--))
  done
  #Add a element with a sessionid of -1. When the selected element is -1, it prompts for a user login for a new session, with GetUserCredentials
  if [[ ! -z $SessionList ]]
  then
    SessionList+=$'\n'
  fi
  SessionList+="-1"$'\n'
  SessionList+=$'\n'
  SessionList+=$'\n'
  SessionList+="New Session..."$'\n'
  SessionList+=$'\n'




  unset ChangeSession
  #prompt for the list of running sessions, and return the session ID. (which is used in all of the arrays for Session PID, user name, etc)
  ChangeSession=$(echo "$SessionList"  | sed '$d'| $ZENITYCMD --title="Switch User" --height=450 --list --text "Select a running session to change into" --hide-header --column sessionid --column tty --column pid --column username --column ID --print-column=1 --hide-column=1,3,5 --separator="\n" 2>/dev/null )
  CancelOrOK=$?
  #Abort if the user selected cancel on the zenity dialog
  if [[ $CancelOrOK != 0 ]]
  then
    exit 1
  fi
  #if the chosen session is -1 then contact the FIFO with a login prompt, otherwise switch to the selected session
  if [[ $ChangeSession == "-1" ]]
  then
    SendSelfCommand Login "$1"
  else 
    #if a session is selected, then get the PID, TTY, logind session ID with the selected Session ID as the array element number.
    if [[ $ChangeSession ]]
    then
      ChangeSessionPID=${AllSessionPIDs[$ChangeSession]}
      ChangeSessionTTY=${AllSessionTTYs[$ChangeSession]}
      ChangeSessionID=${AllSessionIDs[$ChangeSession]}

      #before switching into a session double check in case if the session crashed after it was listed ealier in the function.
      if [[ -e /proc/$ChangeSessionPID/environ ]]
      then
        #Only seat0 supports TTYs
        if [[ "$1" == "seat0" ]]
        then
          chvt $ChangeSessionTTY &>/dev/null &
        fi
        #hand over the logind session ID to allow desktop permissions to work.
        loginctl activate $ChangeSessionID &>/dev/null
      else
        $ZENITYCMD --title="Switch User" --warning --text="The selected session was not found. The session may have quit." 2>/dev/null
      fi
    fi
  fi
}

#Function that starts the user sessions, which is called by AuthenticateUser, if the authentication is successful. It takes 5 arguments, TTY number, the seat, user to start the session for, to lock the screen upon session start, and the multiline string, WSESSIONDATA, which contains specific data about how to start paticular sessions
function StartUserSession 
{ 
  #ensure the loginmanager_control fd doesn't get leaked
  exec 1000>&-


  #unset most varaibles, except PATH and WAYLAND_HOST and WAYLAND_GUEST
  while read var
  do 
    unset "$var" &> /dev/null
  done < <(env | awk -F = '{print $1}' | grep -Ev "^WAYLAND_HOST$|^WAYLAND_GUEST$|^PATH$|^SESSIONID$" ) 

  #save the arguments passed to StartUserSession, and put the third argument into an array
  WSESSIONDATA=()
  WSESSIONARGUMENTELEMENT=0
  while read LINE
  do
    WSESSIONDATA[$WSESSIONARGUMENTELEMENT]="$LINE"
    ((WSESSIONARGUMENTELEMENT++))
  done <<< "$5"
  USERSESSIONTTY=$1
  USERSEAT=$2
  LOGINUSER=$3
  STARTLOCKED=$4

  #Change to the users homepath so weston starts in the right place, and set some varaibles for the user
  export HOME=$(eval echo ~$LOGINUSER)
  export LOGNAME=$LOGINUSER
  export USER=$LOGINUSER
  export USERNAME=$LOGINUSER
  cd "$HOME"

  #The array makes it easy to get the data out of WSESSIONDATA. any variables in the strings are expanded with perl
  #line 1 is the path to the compositor
  #line 2 is the argument to start with a paticular backend
  #line 3 is the argument with paticular session information
  #line 4 is the argument to start the Wayland server with a specific WAYLAND_DISPLAY
  #line 5 is the argument to start the Wayland server on a paticular XDG_SEAT
  #line 6 is any additional arguments needed
  #line 7 specifies the environment file which is processed by the user session, which is documented at the top of the script.
  #line 8 specifies the backend data, which tells the user session what backend is being used, the default one, and if the session file is calling the session with fallback capabilies. This variable is broken up, and exported as BackendType, DefaultBackendType, and IsFallbackSession
  #line 9 specifies the session name for the user and for helpdialog to know what session is running. this is exported as a varaible.
  CompositorExec="$( echo -n "${WSESSIONDATA[0]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  BackendArguments="$( echo -n "${WSESSIONDATA[1]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  SessionArgument="$( echo -n "${WSESSIONDATA[2]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  CompositorDisplayArgument="$( echo -n "${WSESSIONDATA[3]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  CompositorSeatArgument="$( echo -n "${WSESSIONDATA[4]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  AdditionalArguments="$( echo -n "${WSESSIONDATA[5]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  export EnvironmentFile="$( echo -n "${WSESSIONDATA[6]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  BackendData="$( echo -n "${WSESSIONDATA[7]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  export SessionName="$( echo -n "${WSESSIONDATA[8]}" | perl -pe 's/\$(\w+)/$ENV{$1}/g' )"
  IFS=_
  BackendData=($BackendData)
  unset IFS
  export BackendType=${BackendData[0]}
  export DefaultBackendType=${BackendData[1]}
  export IsFallbackSession=${BackendData[2]}


  #Call the server with the arguments specified by the selected session
  WriteToLog "Starting server \"$CompositorExec\" with the arguments of \"$BackendArguments\" \"$SessionArgument\" \"$CompositorSeatArgument\" \"$AdditionalArguments\" \"$CompositorDisplayArgument\" for user $LOGINUSER on tty $USERSESSIONTTY on seat $USERSEAT"
  systemctl reset-failed "$LOGINUSER-wayland-$SESSIONID" &> /dev/null
  #Only seat0 supports TTYs
  if [[ "$USERSEAT" == seat0 ]]
  then
    #Reset the contents of the tty
    echo -n -e '\e[3J' > /dev/tty$USERSESSIONTTY
    #Disable cursor blinking on the TTY the display server will be started on
    echo -n -e '\e[?25l' > /dev/tty$USERSESSIONTTY
    chvt $USERSESSIONTTY &>/dev/null &
    OutputArgs="-p TTYPath=/dev/tty"$USERSESSIONTTY" -p StandardOutput=tty -p StandardError=tty -p StandardInput=tty -p"
  else
    OutputArgs=""
  fi

  #If multisession is not supported
  RunSession=1
  if [[ $ONLY_SEAT0_SESSION_SWITCH == 1 && "$USERSEAT" != seat0 ]]
  then
    SeatCanMultiSession=$(loginctl show-seat "$USERSEAT" -p CanMultiSession --value)
    SeatSessions=($(loginctl show-seat "$USERSEAT" -p Sessions --value))
    SeatSessionsCount=${#SeatSessions[@]}
    SeatSessionType=$(loginctl show-session ${SeatSessions[@]} -p Class --value)
    if [[ $SeatCanMultiSession != "yes" ]]
    then
      if [[ $SeatSessionsCount == 0 || ( $SeatSessionsCount == 1 && $SeatSessionType == "greeter") ]]
      then
        loginctl terminate-session ${SeatSessions[@]}
        touch /run/waylandloginmanager/inhibit
      else
        RunSession=0
      fi
    fi
  fi

  if [[ $RunSession == 1 ]]
  then
    systemd-run --unit="$LOGINUSER-wayland-$SESSIONID" -p PrivateTmp=yes -p PAMName=waylandloginmanager -p User="$LOGINUSER" $OutputArgs WorkingDirectory=\~ --setenv=SessionName="$SessionName" --setenv=BackendType="$BackendType" --setenv=DefaultBackendType="$DefaultBackendType" --setenv=IsFallbackSession="$IsFallbackSession" --setenv=EnvironmentFile="$EnvironmentFile" --setenv=WAYLAND_GUEST=$WAYLAND_GUEST --setenv=XDG_SEAT="$USERSEAT" --setenv=WAYLAND_HOST="$WAYLAND_HOST" $0 --usersession $CompositorExec $BackendArguments  $SessionArgument $CompositorSeatArgument $AdditionalArguments $CompositorDisplayArgument &>/dev/null
  else
    WriteToLog "Too many sessions on $USERSEAT that does not support session switching"
  fi
  rm /run/waylandloginmanager/inhibit
  $SLEEPCMD 5
  #Get the PID that was called, by seing which process is the 'leader pid' of the $USERSESSIONTTY tty that the server was started. This is needed to know what TTY to switch to.
  USERSESSIONPID=$(ps --tty /dev/tty$USERSESSIONTTY | sed -n 2p | awk '{print $1}')
  #Find the logind session id, by trying to find out what session is lead by the $USERSESSIONPID. This is needed to know what logind session needs to be switched to to enable desktop permissions
  SESSIONS=($(loginctl show-seat "$USERSEAT" -p Sessions --value 2>/dev/null ))
  for SESSION in "${SESSIONS[@]}"
  do
    SessionPid=$(loginctl show-session $SESSION -p Leader --value 2>/dev/null)
    if [[ $SessionPid == $USERSESSIONPID ]]
    then
      LOGINDSESSION=$SESSION
      break
    fi
  done < <(echo "$SESSIONS")

  #The logind session activation is needed to enable the desktop permissions for the user. (such as udisks, and shutting down the system, and NetworkManager)
  loginctl activate $LOGINDSESSION &>/dev/null

  #Send the tty number, pid, user name, and logind session ID to loginmanager_register in the background, then tell loginmanager_control to read loginmanager_register.
  SendSelfRegisterData "NEWSESSION@$USERSESSIONTTY@$USERSESSIONPID@$LOGNAME@$LOGINDSESSION@$USERSEAT@$STARTLOCKED"
}

#Test users credentials, by making sure the user name and password match by trying to test with su and expect.
#Expect has to be run as a non root user, otherwise it always reports success. Run it as the user specified with $PROBETESTUSER
#it returns failure or success
#This is called by GetUserCredentials, after it collects the user name and password for the user. It reads the password from stdin
#It takes 1 argument, the seat to show the dialogs on.
function AuthenticateUser
{
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$1"
  unset USERPASSWORD
  TryPassword=$(cat -)
  #Test the users login with an embedded expect script running as PROBETESTUSER
  echo "log_user 0
        spawn su $LOGINUSER -c /bin/true
        expect Password 
        send $TryPassword\r
        catch wait result
        exit [lindex \$result 3]" |sudo -u $PROBETESTUSER expect
  PasswordResult=$?
  unset TryPassword
  if [[ 0 == $PasswordResult ]]
  then
    export USERHOME=$(eval echo ~$LOGINUSER)
    #Prompt for the session type
    ChooseSessionType "$1"

    #if the password and username is correct, start the session
    WriteToLog "Opening a session for $LOGINUSER on TTY $SessionTTY on seat $1"
    DialogWait 3 "Attempting to start the selected session..." "$1"
    StartUserSession "$SessionTTY" "$1" "$LOGINUSER" 0 "$WSESSIONDATA" &
    #report success
    return 0
  else
      #report failure
      return 1
  fi
}


#Get the users username and password by allowing the user to select the username in a list, or enter it manually, and then enter thier password
#This function is called when the loginmanager_control FIFO recives the command "Login"
#It takes 1 argument, the seat to display the login prompt on
function GetUserCredentials
{
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$1"
  #Get the list of nonsystem users, in each line, there is 1 user, with two feilds, the users 'friendly' name, and then the users system login name, seperated by a :
  #this finds the range of UIDs that are user UIDs, and then finds any users with theses UIDS.
  UIDMIN=$(grep -e "^UID_MIN" /etc/login.defs| awk '{print $2}')
  if [[ $ISLIVE == 1 ]]
  then
    UIDMIN=999
  fi
  UIDMAX=$(grep -e "^UID_MAX" /etc/login.defs| awk '{print $2}')
  USERLIST=$(awk -v UIDMIN=$UIDMIN -v UIDMAX=$UIDMAX -F : '{ if ($3>=UIDMIN && $3 <=UIDMAX) print $5":"$1}' /etc/passwd)
  #sort the list
  USERLIST=$(echo "$USERLIST" | sort |uniq)
  #go through each line of users found, to handle the display of the real name (passwd gecos feild)
  while read USER
  do
    IFS=":"
    #handle the line as an array, with two elements
    UserData=($USER)
    #The passwd gecos feild is formated with username,buildingnumber,phonenumber,otherdata. only get the username subfeild.
    UserDisplayName=$(echo ${UserData[0]} | awk -F , '{print $1}')
    UserName=${UserData[1]}
    #If the user has no display name, then set it to be the users login name
    if [[ -z $UserDisplayName ]]
    then
      UserDisplayName=$UserName
    fi
    #The display in the zenity dialog should be "Firstname Lastname    (loginname)"
    UserDisplayName="$UserDisplayName   (${UserData[1]})" 
    unset IFS
    #add the data to the USERLISTSTRING that gets sent into zenity. Line 1 is the display name, line 2 is the user login name, and then line 3 is the display name of the next user...
    USERLISTSTRING+="$UserDisplayName"
    USERLISTSTRING+=$'\n'
    USERLISTSTRING+="$UserName"
    USERLISTSTRING+=$'\n'
  done < <(echo "$USERLIST")
  #Append a default value with the display string to enter the username with -1. When selected, this tells the script to bring up a dialog to allow the user to enter a manual name
  USERLISTSTRING+="Enter User Name..."
  USERLISTSTRING+=$'\n'
  USERLISTSTRING+="-1"


  #present the list of the users to the system
  LOGINUSER=$(echo "$USERLISTSTRING" | $ZENITYCMD --title="Username" --height=450 --list --text "Select a user from the list to log into."  --column users --column usernames --hide-column 2 --print-column 2 --hide-header --separator="\n" 2>/dev/null )
  CancelOrOK=$?
  export LOGINUSER
  #Abort if the user selected cancel on the zenity dialog
  if [[ $CancelOrOK != 0 ]]
  then
    exit 1
  fi
  #if there is no user selected or if the LOGINUSER is -1, as in the user opted to enter a username manually prompt for the username with a text dialog
  if [[ -z $LOGINUSER || $LOGINUSER == -1 ]]
  then
    LOGINUSER=$($ZENITYCMD --title="Username" --entry --text="Enter the User Name:" 2>/dev/null)
    CancelOrOK=$?
    #Abort if the user selected cancel on the zenity dialog
    if [[ $CancelOrOK != 0 ]]
    then
      exit 1
    fi
  fi
  #get the TTY to start the session on, only for seat0
  if [[ "$1" == "seat0" ]]
  then
    export SessionTTY=$(GetNextTTY)
  else
    SessionTTY=0
  fi
  if [[ $SessionTTY -ne -1 ]]
  then
    #Prompt for the users password
    USERPASSWORD=$( $ZENITYCMD --title="Password" --password --text "Type Password for $LOGINUSER" 2>/dev/null )
    CancelOrOK=$?
    #Abort if the user selected cancel on the zenity dialog
    if [[ $CancelOrOK != 0 ]]
    then
      exit 1
    fi
    #send the password to an AuthenticateUser function with stdin
    echo $USERPASSWORD | AuthenticateUser "$1"
    #get the result from AuthenticateUser in the pipe, (and not the echo command)
    passwordresult=${PIPESTATUS[1]}
    unset USERPASSWORD
    if [[ $passwordresult != 0 ]]
    then
      $ZENITYCMD --warning --text="Invalid password for $LOGINUSER, or username invalid" 2>/dev/null
      WriteToLog "Invalid password for $LOGINUSER, or username invalid"
    fi
  else
    $ZENITYCMD --warning --text="Not Enough TTYs!" 2>/dev/null
    WriteToLog "Not Enough TTYs for user login!"
  fi
}


#This function is called when the loginmanager_control FIFO recives the command "Leave". It brings up a zenity dialog for handling power options for the computer.
#It takes 1 argument, the seat to display the dialogs on
function LeavePrompt
{
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$1"
  #The first line is sent to the zenity dialog is the actual command it sets the ACTION variable to be. the second line is what it appears as in the Zenity dialog for the user.
  CanPowerOff=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanPowerOff |grep -c yes)
  if [[ $CanPowerOff == 1 ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Shutdown"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Shutdown Computer"
  fi
  CanReboot=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanReboot |grep -c yes)
  if [[ $CanReboot == 1 ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Restart"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Restart Computer"
  fi
  CanSuspend=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanSuspend |grep -c yes)
  if [[ $CanSuspend == 1 ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Standby"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Standby Computer"
  fi
  CanHybridSleep=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanHybridSleep |grep -c yes)
  if [[ $CanHybridSleep == 1 ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Hybrid Sleep"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Hybrid Sleep Computer"
  fi
  CanHibernate=$(dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.CanHibernate |grep -c yes)
  if [[ $CanHibernate == 1 ]]
  then
    if [[ ! -z $ACTIONSTRING ]]
    then
      ACTIONSTRING+=$'\n'
    fi
    ACTIONSTRING+="Hibernate"
    ACTIONSTRING+=$'\n'
    ACTIONSTRING+="Hibernate Computer"
  fi
  ACTION=$(echo "$ACTIONSTRING" | $ZENITYCMD --title="Leave..." --height=450 --list  --hide-header --text="What do you want to do?" --separator="\n" --column 'action' --column 'useraction' --hide-column 1 --print-column=1  2>/dev/null )
  CancelOrOK=$?
  #Abort if the user selected cancel on the zenity dialog
  if [[ $CancelOrOK != 0 ]]
  then
    exit 1
  fi

  #Prompt the user if they are sure they want to execute the selected action
  $ZENITYCMD --width=450 --title="Leave..." --question --text="Are you sure you want to $ACTION" 2>/dev/null
  CONFIRM=$?
  if [[ $CONFIRM != 0 ]]
  then
    exit 1
  fi

  #For all actions use the dbus commands to logind
  if [[ $ACTION == "Shutdown" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.PowerOff boolean:true
    RESULT=$?
  elif [[ $ACTION == "Restart" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Reboot boolean:true
    RESULT=$?
  elif [[ $ACTION == "Standby" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Suspend boolean:true
    RESULT=$?
  elif [[ $ACTION == "Hybrid Sleep" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.HybridSleep boolean:true
    RESULT=$?
  elif [[ $ACTION == "Hibernate" ]]
  then
    dbus-send --print-reply --system --dest=org.freedesktop.login1 /org/freedesktop/login1 org.freedesktop.login1.Manager.Hibernate boolean:true
    RESULT=$?
  else
    exit
  fi
  #if the selected action failed, tell the user
  if [[ $RESULT != 0 ]]
  then
    $ZENITYCMD --title="Failure" --warning --text="Failed to $ACTION" 2>/dev/null
  fi
}


#This calls the loginmanagerdisplay_(seat) weston sessions.  Everytime a weston session dies, wait 5 seconds, then try to call it back up. Only 5 times each.
function StartLoginManagerDisplays
{
  #Reset the contents of the tty
  echo -n -e '\e[3J' > /dev/tty$LOGINMANAGERDISPLAYTTY
  #Disable cursor blinking on the TTY the display server will be started on
  echo -n -e '\e[?25l' > /dev/tty$LOGINMANAGERDISPLAYTTY
  SEATCHECKLOOPS=0
  FIRSTSEATCHECK=1

  SeatFailArray=()

  while [ 1 ]
  do
    ((SEATCHECKLOOPS++))

    #Wait 1 minute before checking for seats (for the second time and beyond). 5 second pause. 60 seconds in 1 minute
    if [[ $SEATCHECKLOOPS == 12 || $FIRSTSEATCHECK == 1 ]]
    then
      FIRSTSEATCHECK=0
      SEATCHECKLOOPS=0
      #Get a list of seats that are running, and seats that are handled
      IFS=$'\n'
      AllRunningSeats=($(loginctl --no-legend list-seats))
      unset IFS

      #Find what seats are new
      NewSeatFailArray=()
      for RunningSeat in ${AllRunningSeats[@]}
      do
        IncludeSeat=1
        for SeatFailData in ${SeatFailArray[@]}
        do
          IFS=@
          SeatFailDataArray=($SeatFailData[@])
          unset IFS
          if [[ $RunningSeat == ${SeatFailDataArray[0]} ]]
          then
            NewSeatFailArray+=($SeatFailData)
            break
          fi
        done
        if [[ $IncludeSeat == 1 ]]
        then
          #Detect hardware abilities, of the seat
          SeatSupportsKMS=$(loginctl seat-status "$RunningSeat" |grep -e "/drm/card[0-9]*$" -c)
          SeatSupportsFB=$(loginctl seat-status "$RunningSeat" |grep -e "/graphics/fb[0-9]*$" -c)
          FB0INSEAT0=$(loginctl seat-status seat0 |grep -e "/graphics/fb0$" -c)

          #Determine the backend to use
          WESTONBACKEND=0
          WESTONUSEPIXMAN=0
          if [[ $WESTON_FBDEV_SEAT_AWARE == 1 && $SeatSupportsFB != 0 ]]
          then
            WESTONBACKEND=FB
          else
            if [[ "$RunningSeat" == "seat0" && $FB0INSEAT0 != 0 ]]
            then
              WESTONBACKEND=FB
            fi
          fi
          if [[ $SeatSupportsKMS != 0 && $(grep -c "\bwlmforcefbdev\b" /proc/cmdline) == 0 ]]
          then
            WESTONBACKEND=KMS
            if [[ $WLM_FORCE_SOFTWARE == 1 ]]
            then
              WESTONUSEPIXMAN=1
            fi
          fi

          #Add info about the seat, the default fail count as 0, and the backend and pixman info
          NewSeatFailArray+=($RunningSeat@0@$WESTONBACKEND@$WESTONUSEPIXMAN)
          if [[ ! -z $AUTOLOGINUSER ]]
          then
            echo $RunningSeat >> /run/waylandloginmanager/newseats
          fi
        fi
      done
      SeatFailArray=${NewSeatFailArray}
      unset NewSeatFailArray
      SendSelfCommand DetectSeats
    fi

    #Go through each running seat, and start the loginmanagerdisplay for each seat, for a limited number of times
    RunningSeatCount=${#SeatFailArray[@]}
    for ((SeatIndex=0; SeatIndex<$RunningSeatCount; SeatIndex++ ))
    do
      SeatData=${SeatFailArray[$SeatIndex]}
      IFS=@
      SeatData=($SeatData)
      unset IFS

      #Information about the seat
      CurrentSeat=${SeatData[0]}
      SeatStartCount=${SeatData[1]}
      SeatWestonBackend=${SeatData[2]}
      SeatUsePixman=${SeatData[3]}
      StartLoginManagerDisplay=1
      LOGINMANAGERDISPLAYSTATUS=0

      #If the seat can't multisession, and the loginmanagerdisplay for this seat is stopped, don't try to start it
      if [[ $ONLY_SEAT0_SESSION_SWITCH == 1 && $CurrentSeat != "seat0" ]]
      then
        SeatCanMultiSession=$(loginctl show-seat "$CurrentSeat" -p CanMultiSession --value)
        SeatSessions=$(loginctl show-seat "$CurrentSeat" -p Sessions --value)
        if [[ $SeatCanMultiSession != "yes" && ! -z "$SeatSessions" ]]
        then
          SeatStartCount=0
          StartLoginManagerDisplay=0
        fi
      fi

      #Handle the seat hardware information
      if [[ $SeatWestonBackend == KMS ]]
      then
        WESTONBACKEND="drm-backend.so"
      elif [[ $SeatWestonBackend == FB ]]
      then
        WESTONBACKEND="fbdev-backend.so"
      elif [[ $SeatWestonBackend == 0 ]]
      then
        #If the seat does not support the hardware, then abort
        if [[ $SeatStartCount == 0 ]]
        then
          WriteToLog "$CurrentSeat does not have any supported hardware to start a loginmanagerdisplay"
        fi
        SeatStartCount=5
        LOGINMANAGERDISPLAYSTATUS=1
      fi
      if [[ $SeatUsePixman == 1 ]]
      then
        PIXMANARGS="--use-pixman"
      fi

      #Detect if the socket for the loginmanagerdisplay exists
      if [[ -e /run/user/$LOGINMANAGERDISPLAYUID/loginmanagerdisplay_$CurrentSeat ]]
      then
        StartLoginManagerDisplay=0
      fi

      if [[ $LOGINMANAGERDISPLAYSTATUS == 0 && $SeatStartCount < 5 && $StartLoginManagerDisplay == 1 ]]
      then
        (( SeatStartCount++ ))
        WriteToLog "Starting the loginmanagerdisplay on tty $LOGINMANAGERDISPLAYTTY for seat $CurrentSeat"
        if [[ -x "$DEFAULTWAYLANDSERVER" ]]
        then
          systemctl reset-failed wlm-loginmanagerdisplay_$1 &> /dev/null
          if [[ $CurrentSeat == seat0 ]]
          then
            chvt $LOGINMANAGERDISPLAYTTY &>/dev/null &
            OutputArgs="-p TTYPath=/dev/tty"$LOGINMANAGERDISPLAYTTY" -p StandardOutput=tty -p StandardError=tty -p StandardInput=tty"
          else
            OutputArgs=""
          fi
          if [[ ! -e /run/waylandloginmanager/inhibit ]]
          then
            systemd-run --unit=wlm-loginmanagerdisplay_$CurrentSeat -p PrivateTmp=yes -p PAMName=waylandloginmanager-loginmanagerdisplay -p User="$LOGINMANAGERDISPLAYUSER" $OutputArgs -p WorkingDirectory=\~ --setenv=LD_LIBRARY_PATH="$LD_LIBRARY_PATH" --setenv=PATH="$PATH" --setenv=XDG_CONFIG_HOME="$XDG_CONFIG_HOME" --setenv=XDG_SEAT=$CurrentSeat --setenv=HOME="$HOME" $DEFAULTWAYLANDSERVER --backend=$WESTONBACKEND $PIXMANARGS --socket=loginmanagerdisplay_$CurrentSeat --seat=$CurrentSeat --log=/var/log/loginmanagerdisplay_$CurrentSeat.log &>/dev/null
          fi
          LOGINMANAGERDISPLAYREADY=1
          while [[ $LOGINMANAGERDISPLAYREADY != 0 ]]
          do
            LOGINMANAGERDISPLAYREADY=$(systemctl is-active wlm-loginmanagerdisplay_$CurrentSeat.service &> /dev/null; echo $?)
            $SLEEPCMD 1
          done
          #Get the logind session of the weston instance running loginmanagerdisplay, and have it register to the main 'thread'
          GetLoginManagerDisplaySession 1 $CurrentSeat
          loginctl activate $LOGINMANAGERDISPLAYSESSION &>/dev/null
        else
          if [[ $SeatStartCount == 1 ]]
          then
            WriteToLog "$DEFAULTWAYLANDSERVER is not executable, or does not exist, or not supported on seat $CurrentSeat"
          fi
          if [[ $SeatStartCount == 5 ]]
          then
            WriteToLog "Maximum attempts to start the loginmanagerdisplay for $CurrentSeat has been reached"
          fi
        fi
      fi

      SeatFailArray[$SeatIndex]="$CurrentSeat@$SeatStartCount"
    done

    #Determine if all seats failed, if so, then abort the loop
    for SeatData in ${SeatFailArray[@]}
    {
      AttemptsMaxedOut=1
      IFS=@
      SeatData=($SeatData)
      unset IFS

      SeatAttemptCount=${SeatData[1]}
      if [[ $SeatAttemptCount < 5 ]]
      then
        AttemptsMaxedOut=0
        break
      fi
    }
    if [[ $AttemptsMaxedOut == 1 ]]
    then
      break
    fi
    $SLEEPCMD 5
  done
  WriteToLog "ERROR: Maximum restarts of the loginmanagerdisplay has been reached"
  openvt -c 63 -s -f -w -- sudo -E -u $LOGINMANAGERDISPLAYUSER dialog --msgbox "The maximum number of restart attempts for the loginmanagerdisplay for each seat has been reached.

Will show a menu with a few options for diagnosis." 20 50 --no-cancel

  systemd-notify --ready
  openvt -c 63 -s -f -w -- rbos-failedboot
  systemctl stop waylandloginmanager.service
  exit 1
}

#This function determines the systemd session of the loginmanagerdisplay, it takes 2 arguments, the first is if it should send the registration or not.
#The second, is the seat.
function GetLoginManagerDisplaySession
{
  RegisterLoginManagerDisplay=$1
  #Get the pid of loginmanagerdisplay
  LOGINMANAGERDISPLAYPID=$(systemctl show wlm-loginmanagerdisplay_"$2".service -p MainPID --value 2>/dev/null)
  IFS=" "
  #Get all logind sessions
  WLMLOGINDSESSIONS=($(loginctl show-seat "$2" -p Sessions --value 2>/dev/null ))
  unset IFS
  #Go thorugh each logind session, see the one where the main pid matches the pid of the loginmanagerdisplay
  for WLMLOGINDSESSION in "${WLMLOGINDSESSIONS[@]}"
  do
    WLMLOGINDSESSIONPID=$(loginctl show-session "$WLMLOGINDSESSION" -p Leader --value 2>/dev/null )
    if [[ $LOGINMANAGERDISPLAYPID == $WLMLOGINDSESSIONPID ]]
    then
      REGISTERDISPLAYSESSION=$WLMLOGINDSESSION
      break
    fi
  done
  if [[ $RegisterLoginManagerDisplay == 1 ]]
  then
    SendSelfRegisterData "NEWWLMDISPLAY@$REGISTERDISPLAYSESSION@$2"
  fi
}


#This determines if the autologin user was specified, and then configures that value to /etc/waylandloginmanager.conf, as in an unsafe shutdown, the lightdm config file has sometimes dropped the autologin user.
#It starts an autologin session on each seat for the specified user
function HandleAutoLogins
{
  AutoLoginFirstLoop=1
  #if autologin is specified
  if [[ ! -z $AUTOLOGINUSER ]]
  then
    while [ 1 ]
    do
      #Get a list of seats that are running, and seats that are handled
      if [[ -e /run/waylandloginmanager/newseats ]]
      then
        IFS=$'\n'
        AllRunningSeats=($(cat /run/waylandloginmanager/newseats))
        AllStartedSeats=($(cat /run/waylandloginmanager/autologinran))
        unset IFS
        NewSeats=()
        rm /run/waylandloginmanager/newseats

        #Find what seats are new
        for RunningSeat in ${AllRunningSeats[@]}
        do
          IncludeSeat=1
          for StartedSeat in ${AllStartedSeats[@]}
          do
            if [[ $RunningSeat == $StartedSeat ]]
            then
              IncludeSeat=0
              break
            fi
          done
          if [[ $IncludeSeat == 1 ]]
          then
            NewSeats+=($RunningSeat)
          fi
        done

        #Start a autologin session on each new seat
        for NewSeat in ${NewSeats[@]}
        do
          StartAutoLogin $NewSeat &
        done
      fi
      $SLEEPCMD 5
    done
  fi 
}

#This fuction starts an autologin session, and takes 1 argument, the seat to start the autologin session on
function StartAutoLogin
{
  echo "$1" >> /run/waylandloginmanager/autologinran
  #Wait until the loginmanagerdisplay becomes availible
  DisplayServerWait "$1"
  ChooseSessionType "$1"
  #Abort if the user selected cancel on the zenity dialog
  CancelOrOK=$?
  if [[ $CancelOrOK != 0 ]]
  then
    exit 1
  fi
  #get the TTY to start the autologin session on, only for seat0
  if [[ "$1" == seat0 ]]
  then
    export AutoSessionTTY=$(GetNextTTY)
   else
    export AutoSessionTTY=0
  fi
  DialogWait 3 "Attempting to start the selected session..." "$1"
  #if there is a tty for the autologin session, the autologin is configured, start the autologin session
  if [[ $AutoSessionTTY -ne -1 ]]
  then
    WriteToLog "Starting Autologin session for $AUTOLOGINUSER on TTY $AutoSessionTTY"
    StartUserSession "$AutoSessionTTY" "$1" "$AUTOLOGINUSER" 1 "$WSESSIONDATA" &
  else
    $ZENITYCMD --warning --text="Not Enough TTYs for autologin!" 2>/dev/null
    WriteToLog "Not Enough TTYs for autologin!"
  fi
}

#This function is part of the startup for the waylandloginmanager. it creates the FIFO files, giving ONLY write access to loginmanager_control for ALL users, and only write access to loginmanager_register is given to root. Any other permissions, including read is denied.
function SetupLoggingAndFIFO
{
  #Create communication fifo.
  rm -r /run/waylandloginmanager/loginmanager_control &> /dev/null
  rm -r /run/waylandloginmanager/loginmanager_listener &> /dev/null
  rm -r /run/waylandloginmanager/loginmanager_register &> /dev/null
  mkfifo -m 622 /run/waylandloginmanager/loginmanager_control
  mkfifo -m 200 /run/waylandloginmanager/loginmanager_listener
  mkfifo -m 200 /run/waylandloginmanager/loginmanager_register
  chown $FIFOREADERUSER /run/waylandloginmanager/loginmanager_control
  #open the main FIFO that recives commands.
  exec 1000<> /run/waylandloginmanager/loginmanager_listener
  #Prepare logging for the loginmanagerdisplay
  touch /var/log/loginmanagerdisplay.log
  chown $LOGINMANAGERDISPLAYUSER /var/log/loginmanagerdisplay.log
  touch /run/waylandloginmanager/autologinran
  chmod 700 /run/waylandloginmanager/autologinran
  rm /run/waylandloginmanager/fifolock
}

#This function displays a dialog containing actions for the Wayland Login Manager for the user, Shutdown, Switch User, login, and show a help dialog. It's optional, for in the case Weston isn't configured
#It takes 1 argument, the seat.
function UserActionDialog
{
  export WAYLAND_DISPLAY=loginmanagerdisplay_"$1"
  #wait for the loginmanagerdisplay
  DisplayServerWait "$1"
  ActionMenu="Login\nLogin...\n"
  SeatCanMultiSession=$(loginctl show-seat "$1" -p CanMultiSession --value)
  if [[ $ONLY_SEAT0_SESSION_SWITCH == 0 || $SeatCanMultiSession == "yes" ]]
  then
    ActionMenu+="Switch\nSwitch User...\n"
  fi
  ActionMenu+="Leave\nShutdown...\nInfo\nHelp..."
  if [[ $wlmdebuginsecure == 1 ]]
  then
    ActionMenu+="\nDebug\nRoot Terminal..."
  elif [[ $wlmdebug == 1 ]]
  then
    ActionMenu+="\nDebug\nTerminal Login..."
  fi
  USERACTION=$(echo -e "$ActionMenu"|$ZENITYCMD  --title="Login Manager" --height=300 --hide-column 1 --separator="\n" --list --column action --column display --hide-header --text "Select an Action"  2>> /var/log/loginmanagerdisplay.log; exit ${PIPESTATUS[1]})
ZENITYSTATUS=$?
  #If the useraction exists (the user did not click cancel), then send the command to the loginmanager_control
  if [[ ! -z $USERACTION ]]
  then
    SendSelfCommand $USERACTION "$1"
  else
    $SLEEPCMD .1
  fi
  #if zenity segfaults, then something is wrong. wait longer
  if [[ $ZENITYSTATUS == 139 ]]
  then
    $SLEEPCMD 5
  fi
  exit $ZENITYSTATUS
}

#This part of the script is constantly running. It reads what the user send to loginmanager_control running as a service account, and filters out only valid commands to loginmanager_listener, and only sends a limited number of lines.
function CommandFIFOProxy
{
  while [ 1 ]
  do
    sudo -u $FIFOREADERUSER bash -c "grep -Eom 3 \"^Switch@[a-Z0-9_\-]*$|^Change@[a-Z0-9_\-]*$|^Login@[a-Z0-9_\-]*$|^Leave@[a-Z0-9_\-]*$|^RegisterSession@[a-Z0-9_\-]*$|^DetectSeats@[a-Z0-9_\-]*$|^Info@[a-Z0-9_\-]*$|^Debug@[a-Z0-9_\-]*$|^$\" /run/waylandloginmanager/loginmanager_control" > /run/waylandloginmanager/loginmanager_listener
    $SLEEPCMD .1
  done
}

#Function to get the index number of the specified seat of the array "StartedSeats" for the specified seat. It takes 1 argument, the seat
function GetStartedSeatIndex
{
  ReturnSeatIndex="-1"
  SeatCount=${#StartedSeats[@]}
  for (( StartIndex=0; StartIndex<$StartedSeatCount;  StartIndex=StartIndex+2 ))
  do
    if [[ ${StartedSeats[$StartIndex]} == $1 ]]
    then
      ReturnSeatIndex=$StartIndex
      break
    fi
  done
  if [[ $ReturnSeatIndex != "-1" ]]
  then
    ReturnSeatIndex=$(($ReturnSeatIndex/2))
  fi
  echo $ReturnSeatIndex
}

#Function to get the ID of the registered loginmanagerdisplay for this seat. It takes 1 argument, the seat
function GetSeatLoginManagerDisplay
{
  #Get the loginmanagerdisplay for the seat
  RETURNSESSION=""
  for SESSION in ${LOGINMANAGERDISPLAYSESSIONS[@]}
  do
    IFS="@"
    SESSION=($SESSION)
    unset IFS

    if [[ ${SESSION[0]} == "$1" ]]
    then
      RETURNSESSION=${SESSION[1]}
      break
    fi
  done
  echo $RETURNSESSION
}

#This part of the script is constantly running, once it finishes setting up. This reads the loginmanager_listener FIFO constantly, waiting for it to recive a command from a program called by the loginmanagerdisplay's weston desktop shell that sends approriate commands to it, or the user session, shutdowndialog, or even some functions within this script.
#it also checks to see if the active sesssion is active, and if not, switches back to the tty of the loginmanagerdisplay.
function ReadCommandFIFO
{
  SessionStartFailed=0
  DoDetectSeats=1
  StartedSeats=()

  LastUserActionPIDs=()
  LastSwitchPIDs=()
  LastLogonPIDs=()
  LastLeavePIDs=()
  LastInfoPIDs=()
  LastDebugPIDs=()

  UserActionFailCounts=()
  UserActionFailSkips=()

  #loop 'forever'
  while [ 1 ]
  do

    #Detect all seats, and add them to the array
    if [[ $DoDetectSeats == 1 ]]
    then
      DoDetectSeats=0
      #Find what seats are new
      AllRunningSeats=($(loginctl --no-legend list-seats))
      for RunningSeat in ${AllRunningSeats[@]}
      do
        IncludeSeat=1
        StartedSeatCount=${#StartedSeats[@]}
        for (( StartIndex=0; StartIndex<$StartedSeatCount;  StartIndex=StartIndex+2 ))
        do
          if [[ $RunningSeat == ${StartedSeats[$StartIndex]} ]]
          then
            IncludeSeat=0
            break
          fi
        done
        if [[ $IncludeSeat == 1 ]]
        then
          HasMultiSession=$(loginctl show-seat $RunningSeat -p CanMultiSession --value)
          if [[ $ONLY_SEAT0_SESSION_SWITCH == 0 || $HasMultiSession == "yes" ]]
          then
            CanMultiSession=1
          else
            CanMultiSession=0
          fi
          WriteToLog "New seat $RunningSeat detected, multisession support is $CanMultiSession"
          StartedSeats+=($RunningSeat)
          StartedSeats+=($CanMultiSession)
        fi
      done

      #Find out what seats went away, and reset their fail counts
      StartedSeatCount=${#StartedSeats[@]}
      for (( StartIndex=0; StartIndex<$StartedSeatCount;  StartIndex=StartIndex+2 ))
      do
        SeatRemoved=1
        for RunningSeat in ${AllRunningSeats[@]}
        do
          if [[ $RunningSeat == ${StartedSeats[$StartIndex]} ]]
          then
            SeatRemoved=0
          fi
        done
        if [[ $SeatRemoved == 1 ]]
        then
          ChangeIndex=$((StartIndex/2))
          UserActionFailCounts[$ChangeIndex]=0
          UserActionFailSkips[$ChangeIndex]=0
        fi
      done
    fi

    #Handle the main dialog for each seat
    for RunningSeat in ${AllRunningSeats[@]}
    do
      UIPromptAttemptsMaxedOut=1
      UIJobCount=0
      SeatIndexID=$(GetStartedSeatIndex $RunningSeat)

      while read JOB
      do
        if [[ $JOB == ${LastUserActionPIDs[$SeatIndexID]} || $JOB == ${LastSwitchPIDs[$SeatIndexID]} || $JOB == ${LastLogonPIDs[$SeatIndexID]} || $JOB == ${LastLeavePIDs[$SeatIndexID]} || $JOB == ${LastInfoPIDs[$SeatIndexID]} ]]
        then
          ((UIJobCount++))
        fi
      done < <(jobs -p -r)

      if [[ -z ${UserActionFailCounts[$SeatID]} ]]
      then
        UserActionFailCounts[$SeatID]=0
      fi
      if [[ -z ${UserActionFailSkips[$SeatID]} ]]
      then
        UserActionFailSkips[$SeatID]=0
      fi
      if [[ ! -z ${LastUserActionPIDs[$SeatIndexID]} && ! -e /proc/${LastUserActionPIDs[$SeatIndexID]} ]]
      then
        wait ${LastUserActionPIDs[$SeatIndexID]}
        UserActionResult=$?
        if [[ ($UserActionResult != 0 && $UserActionResult != 1) ]]
        then
          UserActionResult=0
          if [[ ${UserActionFailSkips[$SeatIndexID]} == 0 ]]
          then
            ((UserActionFailCounts[$SeatIndexID]++))
            WriteToLog "The prompt for the user action for seat $RunningSeat terminated incorrectly. Please see the loginmanagerdisplay log."
          else
            UserActionFailCounts[$SeatIndexID]=0
            UserActionFailSkips[$SeatIndexID]=0
          fi
        fi
      fi

      if [[ ${UserActionFailCounts[$SeatIndexID]} < 5 ]]
      then
        UIPromptAttemptsMaxedOut=0
        if [[ $UIJobCount == 0 ]]
        then
          UserActionDialog $RunningSeat &
          LastUserActionPIDs[$SeatIndexID]=$!
        fi
      fi
    done

    if [[ $UIPromptAttemptsMaxedOut == 1 ]]
    then
      WriteToLog "The prompt for the user action terminated incorrectly too many times in a row for every seat."
      openvt -c 63 -s -f -w -- sudo -E -u $LOGINMANAGERDISPLAYUSER dialog --msgbox "The prompt for the user action terminated incorrectly too many times in a row.

Will show a menu with a few options for diagnosis." 20 50 --no-cancel
      openvt -c 63 -s -f -w -- rbos-failedboot
      systemctl stop waylandloginmanager.service
      exit 1
    fi

    #Quickly find if any sessions are not running
    NotRunningSessions=0
    for SessionPid in ${AllSessionPIDs[@]}
    do
      if [[ ! -e /proc/$SessionPid/environ ]]
      then
         ((NotRunningSessions++))
      fi
    done

    #If a session failed to start (it terminates before it can register the PID, and session ID), switch back to the loginmanagerdisplay
    if [[ $SessionStartFailed == 1 ]]
    then
      read -t 4 -n5 ActiveSystemTTY < /sys/class/tty/tty0/active
      ActiveSystemTTY=${ActiveSystemTTY:3}
      SessionStartFailed=0
      if [[ $FailedSessionTTY == $ActiveSystemTTY ]]
      then
        if [[ ! -z $FailedSessionTTY ]]
        then
          ResetTTYMode $FailedSessionTTY
        fi
      fi
      SeatIndexID=$(GetStartedSeatIndex $FailedSessionSeat)
      SeatCanMultiSession=${StartedSeats[SeatIndexID+1]}
      if [[ $SeatCanMultiSession == 1 ]]
      then
        loginctl activate $(GetSeatLoginManagerDisplay $FailedSessionSeat) &>/dev/null
      fi
      unset FailedSessionTTY
      unset FailedSessionSeat
    fi

    #Handle for when a session is detected to not be running
    #And also attempt to unlock the TTY, if applicable
    if [[ $NotRunningSessions != 0 ]]
    then
      read -t 4 -n5 ActiveSystemTTY < /sys/class/tty/tty0/active
      ActiveSystemTTY=${ActiveSystemTTY:3}

      #Create temporary arrays
      NewAllSessionTTYs=()
      NewAllSessionPIDs=()
      NewAllSessionUsers=()
      NewAllSessionIDs=()
      NewAllSeatIDs=()

      #Go through all sessions, and then rebuild the array to only store running sessions
      for (( element = 0 ; element < ${#AllSessionPIDs[@]} ; element++ ))
      do
        RunningSessionTTY=${AllSessionTTYs[$element]}
        RunningSessionPID=${AllSessionPIDs[$element]}
        RunningSessionUser=${AllSessionUsers[$element]}
        RunningSessionID=${AllSessionIDs[$element]}
        RunningSeatID=${AllSeatIDs[$element]}
        #If the session is alive, add its data to the new arrays
        if [[ -e /proc/$RunningSessionPID/environ ]]
        then
          NewAllSessionTTYs+=($RunningSessionTTY)
          NewAllSessionPIDs+=($RunningSessionPID)
          NewAllSessionUsers+=($RunningSessionUser)
          NewAllSessionIDs+=($RunningSessionID)
          NewAllSeatIDs+=($RunningSeatID)
        else
          SeatIndexID=$(GetStartedSeatIndex $RunningSeatID)
          SeatCanMultiSession=${StartedSeats[SeatIndexID+1]}
          #If the session terminated, and then current system TTY is the same as the terminated sessions, go back to the loginmanagerdisplay
          if [[ $RunningSeat != "seat0" && $SeatCanMultiSession == 1 ]]
          then
            loginctl activate $(GetSeatLoginManagerDisplay $RunningSeatID) &>/dev/null
          elif [[ $RunningSessionTTY == $ActiveSystemTTY ]]
          then
            if [[ ! -z $RunningSessionTTY ]]
            then
              ResetTTYMode $RunningSessionTTY
            fi
            loginctl activate $(GetSeatLoginManagerDisplay $RunningSeatID) &>/dev/null
          fi
        fi
      done

      #Set the actual arrays to be the value of the temporary arrays
      AllSessionTTYs=(${NewAllSessionTTYs[@]})
      AllSessionPIDs=(${NewAllSessionPIDs[@]})
      AllSessionUsers=(${NewAllSessionUsers[@]})
      AllSessionIDs=(${NewAllSessionIDs[@]})
      AllSeatIDs=(${NewAllSeatIDs[@]})

      #Export the Session Data
      ExportSessionData

      #Remove the temporary arrays
      unset NewAllSessionTTYs
      unset NewAllSessionPIDs
      unset NewAllSessionUsers
      unset NewAllSessionIDs
      unset NewAllSeatIDs
    fi


    #Read the next line that was sent to the FIFO. Allow a 1 second delay before it times out, and lets the loop run again. It only reads 288 bytes at a time.
    #32 for the command, 1 for the delimiter, and 255 for the max logind seat name size
    read -n 288 -t 1 COMMANDDATA <&1000
    IFS=@
    COMMANDDATA=($COMMANDDATA)
    unset IFS
    COMMAND=${COMMANDDATA[0]}
    SEATARG=${COMMANDDATA[1]}

    if [[ $COMMAND != "" && $COMMAND != "DetectSeats" && $COMMAND != "RegisterSession" ]]
    then
      WriteToLog "received command $COMMAND for seat $SEATARG"
    else
      if [[ $COMMAND == "RegisterSession" ]]
      then
        WriteToLog "received command $COMMAND"
      fi
    fi
    if [[ ! -z $SEATARG ]]
    then
      SeatIndexID=$(GetStartedSeatIndex $SEATARG)
    fi
    SeatCanMultiSession=${StartedSeats[SeatIndexID+1]}

    #If it recives a Switch command, then go back to the loginmanagerdisplay's TTY and bring up a switch user dialog and start a switch user job, only if there isn't another switchuserdialog job running
    if [[ $COMMAND == "Switch" ]]
    then
      if [[ $SeatCanMultiSession == 1 ]]
      then
        LOGINMANAGERDISPLAYSESSION=$(GetSeatLoginManagerDisplay "$SEATARG")
        ACTIVESESSION=$(loginctl show-seat "$SEATARG" -p ActiveSession --value)
        if [[ $ACTIVESESSION != $LOGINMANAGERDISPLAYSESSION ]]
        then
          loginctl lock-session $(loginctl show-seat "$SEATARG" -p ActiveSession --value) &>/dev/null
          loginctl activate $LOGINMANAGERDISPLAYSESSION &>/dev/null
        fi
        if [[ $(jobs -p -r | grep -c ^${LastSwitchPIDs[$SeatIndexID]}$) == 0 ]]
        then
          if [[ ! -z ${LastUserActionPIDs[$SeatIndexID]} ]]
          then
            kill -15 -${LastUserActionPIDs[$SeatIndexID]} &> /dev/null
            ${UserActionFailSkips[$SeatID]}=1
            wait ${LastUserActionPIDs[$SeatIndexID]} 2>/dev/null
          fi
          SwitchUserDialog "$SEATARG" &
          LastSwitchPIDs[$SeatIndexID]=$!
        else
          WriteToLog "A handler for the Switch command is already open"
        fi
      fi
    #If the command is change, go back to the loginmanagerdisplay TTY, and don't do anything else. It only switches to the TTY if the TTY isn't active already.
    elif [[ $COMMAND == "Change" ]]
    then
      if [[ $SeatCanMultiSession == 1 ]]
      then
        LOGINMANAGERDISPLAYSESSION=$(GetSeatLoginManagerDisplay "$SEATARG")
        ACTIVESESSION=$(loginctl show-seat "$SEATARG" -p ActiveSession --value)
        if [[ $ACTIVESESSION != $LOGINMANAGERDISPLAYSESSION ]]
        then
          loginctl lock-session $(loginctl show-seat "$SEATARG" -p ActiveSession --value) &>/dev/null
          loginctl activate $LOGINMANAGERDISPLAYSESSION &>/dev/null
        fi
      fi
    #If it recives a Login command, then bring up a login dialog and start a login job, only if there isn't another login job running
    elif [[ $COMMAND == "Login" ]]
    then
      if [[ $(jobs -p -r | grep -c ^${LastLogonPIDs[$SeatIndexID]}$) == 0  ]]
      then
        if [[ ! -z ${LastUserActionPIDs[$SeatIndexID]} ]]
        then
          kill -15 -${LastUserActionPIDs[$SeatIndexID]} &> /dev/null
          ${UserActionFailSkips[$SeatID]}=1
          wait ${LastUserActionPIDs[$SeatIndexID]} 2>/dev/null
        fi
        GetUserCredentials "$SEATARG" &
        LastLogonPIDs[$SeatIndexID]=$!
      else
        WriteToLog "A handler for the Login command is already open"
      fi
    #If it recives a Leave command, then bring up a shutdown dialog and start a shutdown job, only if there isn't another shutdown job running
    elif [[ $COMMAND == "Leave" ]] 
    then
      if [[ $(jobs -p -r | grep -c ^${LastLeavePIDs[$SeatIndexID]}$) == 0  ]]
      then
        if [[ ! -z ${LastUserActionPIDs[$SeatIndexID]} ]]
        then
          kill -15 -${LastUserActionPIDs[$SeatIndexID]} &> /dev/null
          ${UserActionFailSkips[$SeatID]}=1
          wait ${LastUserActionPIDs[$SeatIndexID]} 2>/dev/null
        fi
        LeavePrompt $SEATARG &
        LastLeavePIDs[$SeatIndexID]=$!
      else
        WriteToLog "A handler for the Leave command is already open"
      fi
    #if the command is RegisterSession, then attempt to read the loginmanager_register FIFO, and register any data sent to that FIFO.
    elif [[ $COMMAND == "RegisterSession" ]]
    then
      RegisterSession
    #If the command id DetectSeats, then inventory seats on the next loop
    elif [[ $COMMAND == "DetectSeats" ]]
    then
      DoDetectSeats=1
    #If it recives a Info command, then bring up a info dialog and start a info job, only if there isn't another info job running
    elif [[ $COMMAND == "Info" ]]
    then
      if [[ $(jobs -p -r | grep -c ^${LastInfoPIDs[$SeatIndexID]}$) == 0  ]]
      then
        if [[ ! -z ${LastUserActionPIDs[$SeatIndexID]} ]]
        then
          kill -15 -${LastUserActionPIDs[$SeatIndexID]} &> /dev/null
          ${UserActionFailSkips[$SeatID]}=1
          wait ${LastUserActionPIDs[$SeatIndexID]} 2>/dev/null
        fi
        ShowInfo "$SEATARG" &
        LastInfoPIDs[$SeatIndexID]=$!
      else
        WriteToLog "A handler for the Info command is already open"
      fi
    #If the command is Debug, and wlmdebug was passed to the kernel, then show a login terminal window, only if there isn't another debug terminal window job running
    elif [[ $COMMAND == "Debug" ]]
    then
      if [[ $wlmdebug == 1 ]]
      then
        if [[ $(jobs -p -r | grep -c ^${LastDebugPIDs[$SeatIndexID]}$) == 0 || $wlmdebuginsecure == 1  ]]
        then
          DiagnosticTerminal "$SEATARG" &
          LastDebugPIDs[$SeatIndexID]=$!
          WriteToLog "Spawned a login terminal window on the loginmanagerdisplay for $SEATARG"
        else
          WriteToLog "A handler for the Debug command is already open"
        fi
      else
        WriteToLog "Invalid command: $COMMAND for $SEATARG received, but wlmdebug not passed to the kernel, or not in Live CD mode."
      fi
    #if the command is empty, then execute bash's built in null command
    elif [[ $COMMAND == "" ]]
      then
      :
    #if the command is unknown, then log that.
    else
      WriteToLog "Invalid command: $COMMAND received for seat $SEATARG"
    fi
    $SLEEPCMD .5
  done
}


#Use bash builtin sleep if availible
if [[ -f /usr/lib/bash/sleep ]]
then
  enable -f /usr/lib/bash/sleep sleep
  SLEEPCMD=\sleep
else
  SLEEPCMD=/bin/sleep
fi

#If the waylandloginmanager is started with no arguments assume default operation. 
#If it is started with --uihost, then all arguments after that are treated as a command, but to set LD_LIBRARY_PATH.
#If it is started with --usersession, then perform operations to start the user session, running as the user
if [[ $1 == "" ]]
then
  #Prepare the loginmanager
  PrepareLoginManager

  #Start the main loginmanagerdisplay Weston servers for each seat
  StartLoginManagerDisplays &

  #Start the autologin launcher, which will determine if there is an autologin user. Treat it as a login prompt, to not allow any other login prompts to start, until the job ends.
  HandleAutoLogins &

  #Setup the FIFO before anything starts using the fifo, and logging for the loginmanagerdisplay
  SetupLoggingAndFIFO

  #Start the filter proxy that will only send valid data to the main command FIFO
  CommandFIFOProxy &

  #Start the login managers FIFO reader, and function that monitors the running sessions
  ReadCommandFIFO
elif [[ $1 == "--uihost" ]]
then
  shift 
  export LD_LIBRARY_PATH=$WLM_LD_LIBRARY_PATH
  export PATH=$WLM_PATH
  UIHost "$@"
elif [[ $1 == "--usersession" ]]
then
  shift
  UserSessionWorker "$@" &> /dev/null
elif [[ $1 == "--sendcommand" ]]
then
  if [[ -z $3 ]]
  then
    SEAT=$XDG_SEAT
  else
    SEAT=$3
  fi
  SendSelfCommand $2 "$SEAT"
else
  echo "waylandloginmanager: Please start with no arguments."
  exit 1
fi
