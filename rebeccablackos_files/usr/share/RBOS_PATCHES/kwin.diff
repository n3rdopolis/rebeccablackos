diff --git a/libinput/connection.cpp b/libinput/connection.cpp
index 4a3122136..40b5931fe 100644
--- a/libinput/connection.cpp
+++ b/libinput/connection.cpp
@@ -134,8 +134,8 @@ Connection *Connection::create(QObject *parent)
             return nullptr;
         }
         // TODO: don't hardcode seat name
-        if (!s_context->assignSeat("seat0")) {
-            qCWarning(KWIN_LIBINPUT) << "Failed to assign seat seat0";
+        if (!s_context->assignSeat(getenv("XDG_SEAT"))) {
+            qCWarning(KWIN_LIBINPUT) << "Failed to assign seat";
             delete s_context;
             s_context = nullptr;
             return nullptr;
diff --git a/main_wayland.cpp b/main_wayland.cpp
index 9d7f49d05..d4ac7ba6a 100644
--- a/main_wayland.cpp
+++ b/main_wayland.cpp
@@ -585,7 +585,6 @@ int main(int argc, char * argv[])
     QCommandLineOption framebufferDeviceOption(QStringLiteral("fb-device"),
                                                i18n("The framebuffer device to render to."),
                                                QStringLiteral("fbdev"));
-    framebufferDeviceOption.setDefaultValue(QStringLiteral("/dev/fb0"));
     QCommandLineOption x11DisplayOption(QStringLiteral("x11-display"),
                                         i18n("The X11 Display to use in windowed mode on platform X11."),
                                         QStringLiteral("display"));
diff --git a/plugins/platforms/fbdev/fb_backend.cpp b/plugins/platforms/fbdev/fb_backend.cpp
index e2899f0dd..51af0350a 100644
--- a/plugins/platforms/fbdev/fb_backend.cpp
+++ b/plugins/platforms/fbdev/fb_backend.cpp
@@ -24,6 +24,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "scene_qpainter_fb_backend.h"
 #include "screens.h"
 #include "virtual_terminal.h"
+#include "udev.h"
 // system
 #include <fcntl.h>
 #include <unistd.h>
@@ -37,6 +38,7 @@ namespace KWin
 
 FramebufferBackend::FramebufferBackend(QObject *parent)
     : Platform(parent)
+    , m_udev(new Udev)
 {
 }
 
@@ -75,17 +77,27 @@ void FramebufferBackend::init()
     } else {
         connect(logind, &LogindIntegration::connectedChanged, this, takeControl);
     }
-    VirtualTerminal::create(this);
+    if (strcmp(getenv("XDG_SEAT"), "seat0") == 0)
+    {
+        VirtualTerminal::create(this);
+    }
 }
 
 void FramebufferBackend::openFrameBuffer()
 {
-    VirtualTerminal::self()->init();
-    int fd = LogindIntegration::self()->takeDevice(deviceIdentifier().constData());
+    if (strcmp(getenv("XDG_SEAT"), "seat0") == 0)
+    {
+        VirtualTerminal::self()->init();
+    }
+    char *framebufferDevice = strdup(deviceIdentifier().constData());
+    UdevDevice::Ptr device = m_udev->primaryFramebuffer();
+    if (!framebufferDevice)
+	framebufferDevice = strdup(device->devNode());
+    int fd = LogindIntegration::self()->takeDevice(framebufferDevice);
     if (fd < 0) {
         qCWarning(KWIN_FB) << "Failed to open frame buffer device through logind, trying without";
     }
-    fd = open(deviceIdentifier().constData(), O_RDWR | O_CLOEXEC);
+    fd = open(framebufferDevice, O_RDWR | O_CLOEXEC);
     if (fd < 0) {
         qCWarning(KWIN_FB) << "failed to open frame buffer device";
         emit initFailed();
diff --git a/plugins/platforms/fbdev/fb_backend.h b/plugins/platforms/fbdev/fb_backend.h
index 2ffca0eb9..2fa51f6ab 100644
--- a/plugins/platforms/fbdev/fb_backend.h
+++ b/plugins/platforms/fbdev/fb_backend.h
@@ -27,6 +27,8 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 namespace KWin
 {
 
+class Udev;
+
 class KWIN_EXPORT FramebufferBackend : public Platform
 {
     Q_OBJECT
@@ -89,6 +91,7 @@ private:
     QSize m_resolution;
     QSize m_physicalSize;
     QByteArray m_id;
+    QScopedPointer<Udev> m_udev;
     struct Color {
         quint32 offset;
         quint32 length;
diff --git a/udev.cpp b/udev.cpp
index f65724a9d..4c730586d 100644
--- a/udev.cpp
+++ b/udev.cpp
@@ -51,6 +51,7 @@ public:
         SysName
     };
     void addMatch(Match match, const char *name);
+    void addMatchProperty(const char *name, const char *value);
     void scan();
     UdevDevice::Ptr find(std::function<bool(const UdevDevice::Ptr &)> test);
 
@@ -93,6 +94,14 @@ void UdevEnumerate::addMatch(UdevEnumerate::Match match, const char *name)
     }
 }
 
+void UdevEnumerate::addMatchProperty(const char *name, const char *value)
+{
+    if (m_enumerate.isNull()) {
+        return;
+    }
+    udev_enumerate_add_match_property(m_enumerate.data(), name, value);
+}
+
 void UdevEnumerate::scan()
 {
     if (m_enumerate.isNull()) {
@@ -133,9 +142,10 @@ UdevDevice::Ptr Udev::primaryGpu()
     UdevEnumerate enumerate(this);
     enumerate.addMatch(UdevEnumerate::Match::SubSystem, "drm");
     enumerate.addMatch(UdevEnumerate::Match::SysName, "card[0-9]*");
+    enumerate.addMatchProperty("ID_SEAT", getenv("XDG_SEAT"));
     enumerate.scan();
-    return enumerate.find([](const UdevDevice::Ptr &device) {
-        // TODO: check seat
+    UdevDevice::Ptr fallbackDevice, returnDevice;
+    returnDevice = enumerate.find([](const UdevDevice::Ptr &device) {
         auto pci = device->getParentWithSubsystemDevType("pci");
         if (!pci) {
             return false;
@@ -146,6 +156,14 @@ UdevDevice::Ptr Udev::primaryGpu()
         }
         return false;
     });
+    if (!returnDevice)
+    {
+        returnDevice = enumerate.find([](const UdevDevice::Ptr &device) {
+            return true;
+	});
+    }
+
+    return returnDevice;
 }
 
 UdevDevice::Ptr Udev::virtualGpu()
@@ -178,6 +196,38 @@ UdevDevice::Ptr Udev::renderNode()
     });
 }
 
+UdevDevice::Ptr Udev::primaryFramebuffer()
+{
+    if (!m_udev) {
+        return UdevDevice::Ptr();
+    }
+    UdevEnumerate enumerate(this);
+    enumerate.addMatch(UdevEnumerate::Match::SubSystem, "graphics");
+    enumerate.addMatch(UdevEnumerate::Match::SysName, "fb[0-9]*");
+    enumerate.addMatchProperty("ID_SEAT", getenv("XDG_SEAT"));
+    enumerate.scan();
+    UdevDevice::Ptr fallbackDevice, returnDevice;
+    returnDevice = enumerate.find([](const UdevDevice::Ptr &device) {
+        auto pci = device->getParentWithSubsystemDevType("pci");
+        if (!pci) {
+            return false;
+        }
+        const char *systAttrValue = udev_device_get_sysattr_value(pci, "boot_vga");
+        if (systAttrValue && qstrcmp(systAttrValue, "1") == 0) {
+            return true;
+        }
+        return false;
+    });
+    if (!returnDevice)
+    {
+        returnDevice = enumerate.find([](const UdevDevice::Ptr &device) {
+            return true;
+	});
+    }
+
+    return returnDevice;
+}
+
 UdevDevice::Ptr Udev::deviceFromSyspath(const char *syspath)
 {
     return UdevDevice::Ptr(new UdevDevice(udev_device_new_from_syspath(m_udev, syspath)));
diff --git a/udev.h b/udev.h
index 5dad01e56..88a87e869 100644
--- a/udev.h
+++ b/udev.h
@@ -82,6 +82,7 @@ public:
         return m_udev != nullptr;
     }
     UdevDevice::Ptr primaryGpu();
+    UdevDevice::Ptr primaryFramebuffer();
     UdevDevice::Ptr virtualGpu();
     UdevDevice::Ptr renderNode();
     UdevDevice::Ptr deviceFromSyspath(const char *syspath);
