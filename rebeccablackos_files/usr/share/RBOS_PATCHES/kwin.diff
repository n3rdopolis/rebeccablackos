diff --git a/libinput/connection.cpp b/libinput/connection.cpp
index 46eee7a21..664a8953e 100644
--- a/libinput/connection.cpp
+++ b/libinput/connection.cpp
@@ -137,9 +137,8 @@ Connection *Connection::create(QObject *parent)
             s_context = nullptr;
             return nullptr;
         }
-        // TODO: don't hardcode seat name
-        if (!s_context->assignSeat("seat0")) {
-            qCWarning(KWIN_LIBINPUT) << "Failed to assign seat seat0";
+        if (!s_context->assignSeat(LogindIntegration::self()->seat().toUtf8().constData())) {
+            qCWarning(KWIN_LIBINPUT) << "Failed to assign seat";
             delete s_context;
             s_context = nullptr;
             return nullptr;
diff --git a/logind.cpp b/logind.cpp
index c300cac67..53d5666dd 100644
--- a/logind.cpp
+++ b/logind.cpp
@@ -438,6 +438,9 @@ void LogindIntegration::getSeat()
             if (m_seatPath != seatPath) {
                 m_seatPath = seatPath;
             }
+            if (m_seatName != seat.name) {
+                m_seatName = seat.name;
+            }
         }
     );
 }
diff --git a/logind.h b/logind.h
index d0af39fe1..40e3c4f70 100644
--- a/logind.h
+++ b/logind.h
@@ -56,6 +56,10 @@ public:
     int takeDevice(const char *path);
     void releaseDevice(int fd);
 
+    const QString seat() const {
+        return m_seatName;
+    }
+
 Q_SIGNALS:
     void connectedChanged();
     void hasSessionControlChanged(bool);
@@ -91,6 +95,7 @@ private:
     bool m_sessionControl;
     bool m_sessionActive;
     int m_vt = -1;
+    QString m_seatName = QStringLiteral("seat0");
     QString m_seatPath;
     QString m_sessionControllerName;
     QString m_sessionControllerService;
diff --git a/main_wayland.cpp b/main_wayland.cpp
index 9d7f49d05..d4ac7ba6a 100644
--- a/main_wayland.cpp
+++ b/main_wayland.cpp
@@ -585,7 +585,6 @@ int main(int argc, char * argv[])
     QCommandLineOption framebufferDeviceOption(QStringLiteral("fb-device"),
                                                i18n("The framebuffer device to render to."),
                                                QStringLiteral("fbdev"));
-    framebufferDeviceOption.setDefaultValue(QStringLiteral("/dev/fb0"));
     QCommandLineOption x11DisplayOption(QStringLiteral("x11-display"),
                                         i18n("The X11 Display to use in windowed mode on platform X11."),
                                         QStringLiteral("display"));
diff --git a/plugins/platforms/fbdev/fb_backend.cpp b/plugins/platforms/fbdev/fb_backend.cpp
index e2899f0dd..bd1d5ea02 100644
--- a/plugins/platforms/fbdev/fb_backend.cpp
+++ b/plugins/platforms/fbdev/fb_backend.cpp
@@ -24,6 +24,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "scene_qpainter_fb_backend.h"
 #include "screens.h"
 #include "virtual_terminal.h"
+#include "udev.h"
 // system
 #include <fcntl.h>
 #include <unistd.h>
@@ -81,13 +82,18 @@ void FramebufferBackend::init()
 void FramebufferBackend::openFrameBuffer()
 {
     VirtualTerminal::self()->init();
-    int fd = LogindIntegration::self()->takeDevice(deviceIdentifier().constData());
+    QString framebufferDevice = deviceIdentifier().constData();
+    if (framebufferDevice.isEmpty()) {
+        framebufferDevice = QString(Udev().primaryFramebuffer()->devNode());
+    }
+    int fd = LogindIntegration::self()->takeDevice(framebufferDevice.toUtf8().constData());
+    qCDebug(KWIN_FB) << "Using frame buffer device:" << framebufferDevice;
     if (fd < 0) {
-        qCWarning(KWIN_FB) << "Failed to open frame buffer device through logind, trying without";
+        qCWarning(KWIN_FB) << "Failed to open frame buffer device:" << framebufferDevice << "through logind, trying without";
     }
-    fd = open(deviceIdentifier().constData(), O_RDWR | O_CLOEXEC);
+    fd = open(framebufferDevice.toUtf8().constData(), O_RDWR | O_CLOEXEC);
     if (fd < 0) {
-        qCWarning(KWIN_FB) << "failed to open frame buffer device";
+        qCWarning(KWIN_FB) << "failed to open frame buffer device:" << framebufferDevice;
         emit initFailed();
         return;
     }
@@ -119,6 +125,28 @@ bool FramebufferBackend::queryScreenInfo()
     if (ioctl(m_fd, FBIOGET_FSCREENINFO, &fixinfo) < 0 || ioctl(m_fd, FBIOGET_VSCREENINFO, &varinfo) < 0) {
         return false;
     }
+
+    // correct the color info, and try to turn on screens, assuming this is a non-primary framebuffer device
+    varinfo.grayscale = 0;
+    varinfo.transp.offset = 24;
+    varinfo.transp.length = 8;
+    varinfo.transp.msb_right = 0;
+    varinfo.red.offset = 16;
+    varinfo.red.length = 8;
+    varinfo.red.msb_right = 0;
+    varinfo.green.offset = 8;
+    varinfo.green.length = 8;
+    varinfo.green.msb_right = 0;
+    varinfo.blue.offset = 0;
+    varinfo.blue.length = 8;
+    varinfo.blue.msb_right = 0;
+    ioctl(m_fd, FBIOPUT_VSCREENINFO, &varinfo);
+
+    // Probe the device for new screen information.
+    if (ioctl(m_fd, FBIOGET_FSCREENINFO, &fixinfo) < 0 || ioctl(m_fd, FBIOGET_VSCREENINFO, &varinfo) < 0) {
+        return false;
+    }
+
     m_resolution = QSize(varinfo.xres, varinfo.yres);
     m_physicalSize = QSize(varinfo.width, varinfo.height);
     m_id = QByteArray(fixinfo.id);
diff --git a/plugins/platforms/fbdev/scene_qpainter_fb_backend.cpp b/plugins/platforms/fbdev/scene_qpainter_fb_backend.cpp
index ec311586c..50e365b4e 100644
--- a/plugins/platforms/fbdev/scene_qpainter_fb_backend.cpp
+++ b/plugins/platforms/fbdev/scene_qpainter_fb_backend.cpp
@@ -20,6 +20,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "scene_qpainter_fb_backend.h"
 #include "fb_backend.h"
 #include "composite.h"
+#include "logind.h"
 #include "cursor.h"
 #include "virtual_terminal.h"
 // Qt
@@ -75,7 +76,7 @@ void FramebufferQPainterBackend::present(int mask, const QRegion &damage)
 {
     Q_UNUSED(mask)
     Q_UNUSED(damage)
-    if (!VirtualTerminal::self()->isActive()) {
+    if (!LogindIntegration::self()->isActiveSession()) {
         return;
     }
     QPainter p(&m_backBuffer);
diff --git a/udev.cpp b/udev.cpp
index f65724a9d..f064b089b 100644
--- a/udev.cpp
+++ b/udev.cpp
@@ -18,6 +18,7 @@ You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "udev.h"
+#include "logind.h"
 // Qt
 #include <QByteArray>
 #include <QScopedPointer>
@@ -106,6 +107,7 @@ UdevDevice::Ptr UdevEnumerate::find(std::function<bool(const UdevDevice::Ptr &de
     if (m_enumerate.isNull()) {
         return UdevDevice::Ptr();
     }
+    QString defaultSeat = QStringLiteral("seat0");
     udev_list_entry *it = udev_enumerate_get_list_entry(m_enumerate.data());
     UdevDevice::Ptr firstFound;
     while (it) {
@@ -115,6 +117,13 @@ UdevDevice::Ptr UdevEnumerate::find(std::function<bool(const UdevDevice::Ptr &de
         if (!device) {
             continue;
         }
+        QString deviceSeat = device->property("ID_SEAT");
+        if (deviceSeat.isEmpty()) {
+            deviceSeat = defaultSeat;
+        }
+        if (deviceSeat != LogindIntegration::self()->seat()) {
+            continue;
+        }
         if (test(device)) {
             return device;
         }
@@ -135,7 +144,6 @@ UdevDevice::Ptr Udev::primaryGpu()
     enumerate.addMatch(UdevEnumerate::Match::SysName, "card[0-9]*");
     enumerate.scan();
     return enumerate.find([](const UdevDevice::Ptr &device) {
-        // TODO: check seat
         auto pci = device->getParentWithSubsystemDevType("pci");
         if (!pci) {
             return false;
@@ -178,6 +186,28 @@ UdevDevice::Ptr Udev::renderNode()
     });
 }
 
+UdevDevice::Ptr Udev::primaryFramebuffer()
+{
+    if (!m_udev) {
+        return UdevDevice::Ptr();
+    }
+    UdevEnumerate enumerate(this);
+    enumerate.addMatch(UdevEnumerate::Match::SubSystem, "graphics");
+    enumerate.addMatch(UdevEnumerate::Match::SysName, "fb[0-9]*");
+    enumerate.scan();
+    return enumerate.find([](const UdevDevice::Ptr &device) {
+        auto pci = device->getParentWithSubsystemDevType("pci");
+        if (!pci) {
+            return false;
+        }
+        const char *systAttrValue = udev_device_get_sysattr_value(pci, "boot_vga");
+        if (systAttrValue && qstrcmp(systAttrValue, "1") == 0) {
+            return true;
+        }
+        return false;
+    });
+}
+
 UdevDevice::Ptr Udev::deviceFromSyspath(const char *syspath)
 {
     return UdevDevice::Ptr(new UdevDevice(udev_device_new_from_syspath(m_udev, syspath)));
diff --git a/udev.h b/udev.h
index 5dad01e56..88a87e869 100644
--- a/udev.h
+++ b/udev.h
@@ -82,6 +82,7 @@ public:
         return m_udev != nullptr;
     }
     UdevDevice::Ptr primaryGpu();
+    UdevDevice::Ptr primaryFramebuffer();
     UdevDevice::Ptr virtualGpu();
     UdevDevice::Ptr renderNode();
     UdevDevice::Ptr deviceFromSyspath(const char *syspath);
