diff --git a/libinput/connection.cpp b/libinput/connection.cpp
index 4a3122136..6e0a67c1a 100644
--- a/libinput/connection.cpp
+++ b/libinput/connection.cpp
@@ -133,9 +133,8 @@ Connection *Connection::create(QObject *parent)
             s_context = nullptr;
             return nullptr;
         }
-        // TODO: don't hardcode seat name
-        if (!s_context->assignSeat("seat0")) {
-            qCWarning(KWIN_LIBINPUT) << "Failed to assign seat seat0";
+        if (!s_context->assignSeat(LogindIntegration::self()->seat())) {
+            qCWarning(KWIN_LIBINPUT) << "Failed to assign seat";
             delete s_context;
             s_context = nullptr;
             return nullptr;
diff --git a/logind.cpp b/logind.cpp
index c300cac67..4ec5bb557 100644
--- a/logind.cpp
+++ b/logind.cpp
@@ -438,6 +438,9 @@ void LogindIntegration::getSeat()
             if (m_seatPath != seatPath) {
                 m_seatPath = seatPath;
             }
+            if (m_seatName != seat.name.toStdString().c_str()) {
+                m_seatName = strdup(seat.name.toStdString().c_str());
+            }
         }
     );
 }
diff --git a/logind.h b/logind.h
index d0af39fe1..f5835bb24 100644
--- a/logind.h
+++ b/logind.h
@@ -56,6 +56,10 @@ public:
     int takeDevice(const char *path);
     void releaseDevice(int fd);
 
+    const char *seat() const {
+        return m_seatName;
+    }
+
 Q_SIGNALS:
     void connectedChanged();
     void hasSessionControlChanged(bool);
@@ -91,6 +95,7 @@ private:
     bool m_sessionControl;
     bool m_sessionActive;
     int m_vt = -1;
+    char *m_seatName;
     QString m_seatPath;
     QString m_sessionControllerName;
     QString m_sessionControllerService;
diff --git a/main_wayland.cpp b/main_wayland.cpp
index 9d7f49d05..d4ac7ba6a 100644
--- a/main_wayland.cpp
+++ b/main_wayland.cpp
@@ -585,7 +585,6 @@ int main(int argc, char * argv[])
     QCommandLineOption framebufferDeviceOption(QStringLiteral("fb-device"),
                                                i18n("The framebuffer device to render to."),
                                                QStringLiteral("fbdev"));
-    framebufferDeviceOption.setDefaultValue(QStringLiteral("/dev/fb0"));
     QCommandLineOption x11DisplayOption(QStringLiteral("x11-display"),
                                         i18n("The X11 Display to use in windowed mode on platform X11."),
                                         QStringLiteral("display"));
diff --git a/plugins/platforms/fbdev/fb_backend.cpp b/plugins/platforms/fbdev/fb_backend.cpp
index e2899f0dd..3d285039b 100644
--- a/plugins/platforms/fbdev/fb_backend.cpp
+++ b/plugins/platforms/fbdev/fb_backend.cpp
@@ -24,6 +24,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 #include "scene_qpainter_fb_backend.h"
 #include "screens.h"
 #include "virtual_terminal.h"
+#include "udev.h"
 // system
 #include <fcntl.h>
 #include <unistd.h>
@@ -37,6 +38,7 @@ namespace KWin
 
 FramebufferBackend::FramebufferBackend(QObject *parent)
     : Platform(parent)
+    , m_udev(new Udev)
 {
 }
 
@@ -80,12 +82,20 @@ void FramebufferBackend::init()
 
 void FramebufferBackend::openFrameBuffer()
 {
-    VirtualTerminal::self()->init();
-    int fd = LogindIntegration::self()->takeDevice(deviceIdentifier().constData());
+    if (strcmp(LogindIntegration::self()->seat(), "seat0") == 0)
+    {
+        VirtualTerminal::self()->init();
+    }
+    char *framebufferDevice = strdup(deviceIdentifier().constData());
+    UdevDevice::Ptr device = m_udev->primaryFramebuffer();
+    if (strcmp(framebufferDevice,"\0") == 0)
+	framebufferDevice = strdup(device->devNode());
+    int fd = LogindIntegration::self()->takeDevice(framebufferDevice);
+    qCDebug(KWIN_FB) << "Using frame buffer device:" << framebufferDevice;
     if (fd < 0) {
         qCWarning(KWIN_FB) << "Failed to open frame buffer device through logind, trying without";
     }
-    fd = open(deviceIdentifier().constData(), O_RDWR | O_CLOEXEC);
+    fd = open(framebufferDevice, O_RDWR | O_CLOEXEC);
     if (fd < 0) {
         qCWarning(KWIN_FB) << "failed to open frame buffer device";
         emit initFailed();
diff --git a/plugins/platforms/fbdev/fb_backend.h b/plugins/platforms/fbdev/fb_backend.h
index 2ffca0eb9..2fa51f6ab 100644
--- a/plugins/platforms/fbdev/fb_backend.h
+++ b/plugins/platforms/fbdev/fb_backend.h
@@ -27,6 +27,8 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.
 namespace KWin
 {
 
+class Udev;
+
 class KWIN_EXPORT FramebufferBackend : public Platform
 {
     Q_OBJECT
@@ -89,6 +91,7 @@ private:
     QSize m_resolution;
     QSize m_physicalSize;
     QByteArray m_id;
+    QScopedPointer<Udev> m_udev;
     struct Color {
         quint32 offset;
         quint32 length;
diff --git a/udev.cpp b/udev.cpp
index f65724a9d..f28357de5 100644
--- a/udev.cpp
+++ b/udev.cpp
@@ -18,6 +18,7 @@ You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *********************************************************************/
 #include "udev.h"
+#include "logind.h"
 // Qt
 #include <QByteArray>
 #include <QScopedPointer>
@@ -106,6 +107,7 @@ UdevDevice::Ptr UdevEnumerate::find(std::function<bool(const UdevDevice::Ptr &de
     if (m_enumerate.isNull()) {
         return UdevDevice::Ptr();
     }
+    const char defaultSeat[] = "seat0";
     udev_list_entry *it = udev_enumerate_get_list_entry(m_enumerate.data());
     UdevDevice::Ptr firstFound;
     while (it) {
@@ -115,6 +117,13 @@ UdevDevice::Ptr UdevEnumerate::find(std::function<bool(const UdevDevice::Ptr &de
         if (!device) {
             continue;
         }
+        const char *deviceSeat = device->property("ID_SEAT");
+        if (!deviceSeat) {
+            deviceSeat = defaultSeat;
+        }
+        if (qstrcmp(deviceSeat, LogindIntegration::self()->seat())) {
+            continue;
+        }
         if (test(device)) {
             return device;
         }
@@ -135,7 +144,6 @@ UdevDevice::Ptr Udev::primaryGpu()
     enumerate.addMatch(UdevEnumerate::Match::SysName, "card[0-9]*");
     enumerate.scan();
     return enumerate.find([](const UdevDevice::Ptr &device) {
-        // TODO: check seat
         auto pci = device->getParentWithSubsystemDevType("pci");
         if (!pci) {
             return false;
@@ -178,6 +186,28 @@ UdevDevice::Ptr Udev::renderNode()
     });
 }
 
+UdevDevice::Ptr Udev::primaryFramebuffer()
+{
+    if (!m_udev) {
+        return UdevDevice::Ptr();
+    }
+    UdevEnumerate enumerate(this);
+    enumerate.addMatch(UdevEnumerate::Match::SubSystem, "graphics");
+    enumerate.addMatch(UdevEnumerate::Match::SysName, "fb[0-9]*");
+    enumerate.scan();
+    return enumerate.find([](const UdevDevice::Ptr &device) {
+        auto pci = device->getParentWithSubsystemDevType("pci");
+        if (!pci) {
+            return false;
+        }
+        const char *systAttrValue = udev_device_get_sysattr_value(pci, "boot_vga");
+        if (systAttrValue && qstrcmp(systAttrValue, "1") == 0) {
+            return true;
+        }
+        return false;
+    });
+}
+
 UdevDevice::Ptr Udev::deviceFromSyspath(const char *syspath)
 {
     return UdevDevice::Ptr(new UdevDevice(udev_device_new_from_syspath(m_udev, syspath)));
diff --git a/udev.h b/udev.h
index 5dad01e56..88a87e869 100644
--- a/udev.h
+++ b/udev.h
@@ -82,6 +82,7 @@ public:
         return m_udev != nullptr;
     }
     UdevDevice::Ptr primaryGpu();
+    UdevDevice::Ptr primaryFramebuffer();
     UdevDevice::Ptr virtualGpu();
     UdevDevice::Ptr renderNode();
     UdevDevice::Ptr deviceFromSyspath(const char *syspath);
