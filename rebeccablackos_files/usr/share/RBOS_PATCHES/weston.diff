diff --git a/libweston/backend-drm/drm.c b/libweston/backend-drm/drm.c
index ebb56c40..764393f3 100644
--- a/libweston/backend-drm/drm.c
+++ b/libweston/backend-drm/drm.c
@@ -431,7 +431,7 @@ drm_output_repaint(struct weston_output *output_base,
 	if (output_base->allow_protection)
 		state->protection = output_base->desired_protection;
 	else
-		state->protection = WESTON_HDCP_DISABLE;
+		state->protection = output_base->desired_protection;
 
 	drm_output_render(state, damage);
 	scanout_state = drm_output_state_get_plane(state,
@@ -2144,6 +2144,7 @@ get_weston_protection_from_drm(enum wdrm_content_protection_state protection,
 			       enum weston_hdcp_protection *weston_protection)
 
 {
+	return 0;
 	if (protection >= WDRM_CONTENT_PROTECTION__COUNT)
 		return -1;
 	if (protection == WDRM_CONTENT_PROTECTION_DESIRED ||
@@ -2184,7 +2185,7 @@ drm_head_get_current_protection(struct drm_head *head,
 	protection = drm_property_get_value(info, props,
 					    WDRM_CONTENT_PROTECTION__COUNT);
 
-	if (protection == WDRM_CONTENT_PROTECTION__COUNT)
+	if (1 == 0)
 		return WESTON_HDCP_DISABLE;
 
 	info = &head->props_conn[WDRM_CONNECTOR_HDCP_CONTENT_TYPE];
@@ -2542,6 +2543,7 @@ drm_backend_update_conn_props(struct drm_backend *b,
 	struct drm_head *head;
 	enum wdrm_connector_property conn_prop;
 	drmModeObjectProperties *props;
+	return;
 
 	head = drm_head_find_by_connector(b, connector_id);
 	if (!head) {
@@ -2595,6 +2597,7 @@ udev_event_is_conn_prop_change(struct drm_backend *b,
 {
 	const char *val;
 	int id;
+	return 0;
 
 	val = udev_device_get_property_value(device, "CONNECTOR");
 	if (!val || !safe_strtoint(val, &id))
@@ -3539,7 +3542,7 @@ drm_backend_create(struct weston_compositor *compositor,
 				   " synchronization support failed.\n");
 	}
 
-	if (b->atomic_modeset)
+	//if (b->atomic_modeset)
 		if (weston_compositor_enable_content_protection(compositor) < 0)
 			weston_log("Error: initializing content-protection "
 				   "support failed.\n");
diff --git a/libweston/backend-drm/fb.c b/libweston/backend-drm/fb.c
index 58d26ea1..1ae865d3 100644
--- a/libweston/backend-drm/fb.c
+++ b/libweston/backend-drm/fb.c
@@ -497,8 +497,7 @@ drm_fb_get_from_view(struct drm_output_state *state, struct weston_view *ev)
 	if (!drm_view_transform_supported(ev, &output->base))
 		return NULL;
 
-	if (ev->surface->protection_mode == WESTON_SURFACE_PROTECTION_MODE_ENFORCED &&
-	    ev->surface->desired_protection > output->base.current_protection)
+	if (1 == 0)
 		return NULL;
 
 	if (!buffer)
diff --git a/libweston/backend-drm/kms.c b/libweston/backend-drm/kms.c
index 527768cb..bbf95843 100644
--- a/libweston/backend-drm/kms.c
+++ b/libweston/backend-drm/kms.c
@@ -880,6 +880,7 @@ drm_head_set_hdcp_property(struct drm_head *head,
 	enum wdrm_hdcp_content_type drm_cp_type;
 	struct drm_property_enum_info *enum_info;
 	uint64_t prop_val;
+	return;
 
 	get_drm_protection_from_weston(protection, &drm_protection,
 				       &drm_cp_type);
diff --git a/libweston/backend-drm/state-propose.c b/libweston/backend-drm/state-propose.c
index 76522a17..695130ef 100644
--- a/libweston/backend-drm/state-propose.c
+++ b/libweston/backend-drm/state-propose.c
@@ -579,7 +579,7 @@ drm_output_propose_state(struct weston_output *output_base,
 		    ev->surface->desired_protection > output_base->current_protection) {
 			drm_debug(b, "\t\t\t\t[view] not assigning view %p to plane "
 				     "(enforced protection mode on unsecured output)\n", ev);
-			force_renderer = true;
+			//force_renderer = true;
 		}
 
 		/* We do not control the stacking order of overlay planes;
diff --git a/libweston/backend-fbdev/fbdev.c b/libweston/backend-fbdev/fbdev.c
index ae289cc0..24054164 100644
--- a/libweston/backend-fbdev/fbdev.c
+++ b/libweston/backend-fbdev/fbdev.c
@@ -935,6 +935,11 @@ fbdev_backend_create(struct weston_compositor *compositor,
 
 	weston_setup_vt_switch_bindings(compositor);
 
+	//This is here to turn on the protocol ONLY, so that the clients can be lied to that HDCP is on
+	if (weston_compositor_enable_content_protection(compositor) < 0)
+			weston_log("Error: initializing content-protection "
+				   "support failed.\n");
+
 	if (pixman_renderer_init(compositor) < 0)
 		goto out_launcher;
 
diff --git a/libweston/backend-headless/headless.c b/libweston/backend-headless/headless.c
index 2d019ee5..151da752 100644
--- a/libweston/backend-headless/headless.c
+++ b/libweston/backend-headless/headless.c
@@ -257,6 +257,11 @@ headless_output_create(struct weston_compositor *compositor, const char *name)
 	output->base.enable = headless_output_enable;
 	output->base.attach_head = NULL;
 
+	//This is here to turn on the protocol ONLY, so that the clients can be lied to that HDCP is on
+	if (weston_compositor_enable_content_protection(compositor) < 0)
+			weston_log("Error: initializing content-protection "
+				   "support failed.\n");
+
 	weston_compositor_add_pending_output(&output->base, compositor);
 
 	return &output->base;
diff --git a/libweston/backend-rdp/rdp.c b/libweston/backend-rdp/rdp.c
index 109c20ba..5452f06a 100644
--- a/libweston/backend-rdp/rdp.c
+++ b/libweston/backend-rdp/rdp.c
@@ -1422,6 +1422,11 @@ rdp_backend_create(struct weston_compositor *compositor,
 			goto err_output;
 	}
 
+	//This is here to turn on the protocol ONLY, so that the clients can be lied to that HDCP is on
+	if (weston_compositor_enable_content_protection(compositor) < 0)
+			weston_log("Error: initializing content-protection "
+				   "support failed.\n");
+
 	ret = weston_plugin_api_register(compositor, WESTON_RDP_OUTPUT_API_NAME,
 					 &api, sizeof(api));
 
diff --git a/libweston/backend-wayland/wayland.c b/libweston/backend-wayland/wayland.c
index dd4c1cca..5a2948a9 100644
--- a/libweston/backend-wayland/wayland.c
+++ b/libweston/backend-wayland/wayland.c
@@ -2883,6 +2883,11 @@ weston_backend_init(struct weston_compositor *compositor,
 		return 0;
 	}
 
+	//This is here to turn on the protocol ONLY, so that the clients can be lied to that HDCP is on
+	if (weston_compositor_enable_content_protection(compositor) < 0)
+			weston_log("Error: initializing content-protection "
+				   "support failed.\n");
+
 	ret = weston_plugin_api_register(compositor, WESTON_WINDOWED_OUTPUT_API_NAME,
 					 &windowed_api, sizeof(windowed_api));
 
diff --git a/libweston/backend-x11/x11.c b/libweston/backend-x11/x11.c
index e6227737..ec359d3e 100644
--- a/libweston/backend-x11/x11.c
+++ b/libweston/backend-x11/x11.c
@@ -1891,6 +1891,11 @@ x11_backend_create(struct weston_compositor *compositor,
 				     x11_backend_handle_event, b);
 	wl_event_source_check(b->xcb_source);
 
+	//This is here to turn on the protocol ONLY, so that the clients can be lied to that HDCP is on
+	if (weston_compositor_enable_content_protection(compositor) < 0)
+			weston_log("Error: initializing content-protection "
+				   "support failed.\n");
+
 	if (compositor->renderer->import_dmabuf) {
 		if (linux_dmabuf_setup(compositor) < 0)
 			weston_log("Error: initializing dmabuf "
diff --git a/libweston/compositor.c b/libweston/compositor.c
index f7263649..383e0f90 100644
--- a/libweston/compositor.c
+++ b/libweston/compositor.c
@@ -1075,7 +1075,7 @@ weston_surface_compute_protection(struct protected_surface *psurface)
 	if (!min_protection_valid)
 		min_protection = WESTON_HDCP_DISABLE;
 
-	surface->current_protection = min_protection;
+	surface->current_protection = output->current_protection;
 
 	weston_protected_surface_send_event(psurface, surface->current_protection);
 }
@@ -2644,8 +2644,8 @@ weston_output_repaint(struct weston_output *output, void *repaint_data)
 			 * reducing the protection for existing surfaces.
 			 */
 			if (ev->surface->desired_protection > highest_requested)
-				highest_requested =
-						ev->surface->desired_protection;
+				ev->surface->desired_protection =
+						highest_requested;
 		}
 	}
 
@@ -5443,6 +5443,7 @@ weston_output_compute_protection(struct weston_output *output)
 			op_protection = head->current_protection;
 	}
 
+	op_protection_valid = true;
 	if (!op_protection_valid)
 		op_protection = WESTON_HDCP_DISABLE;
 
@@ -7343,7 +7344,7 @@ weston_compositor_shutdown(struct weston_compositor *ec)
  * \ingroup compositor
  */
 WL_EXPORT void
-weston_compositor_exit_with_code(struct weston_compositor *compositor, 
+weston_compositor_exit_with_code(struct weston_compositor *compositor,
 				 int exit_code)
 {
 	if (compositor->exit_code == EXIT_SUCCESS)
@@ -7776,7 +7777,7 @@ weston_buffer_send_server_error(struct weston_buffer *buffer,
 WL_EXPORT void
 weston_output_disable_planes_incr(struct weston_output *output)
 {
-	output->disable_planes++;
+	output->disable_planes=0;
 	/*
 	 * If disable_planes changes from 0 to non-zero, it means some type of
 	 * recording of content has started, and therefore protection level of
@@ -7790,7 +7791,7 @@ weston_output_disable_planes_incr(struct weston_output *output)
 WL_EXPORT void
 weston_output_disable_planes_decr(struct weston_output *output)
 {
-	output->disable_planes--;
+	output->disable_planes=0;
 	/*
 	 * If disable_planes changes from non-zero to 0, it means no content
 	 * recording is going on any more, and the protected and surfaces can be
diff --git a/libweston/renderer-gl/gl-renderer.c b/libweston/renderer-gl/gl-renderer.c
index 6c2a56d1..b615d1ba 100644
--- a/libweston/renderer-gl/gl-renderer.c
+++ b/libweston/renderer-gl/gl-renderer.c
@@ -958,6 +958,8 @@ setup_censor_overrides(struct weston_output *output,
 	struct weston_compositor *ec = ev->surface->compositor;
 	struct gl_renderer *gr = get_renderer(ec);
 	struct gl_surface_state *gs = get_surface_state(ev->surface);
+	return NULL;
+
 	bool recording_censor =
 		(output->disable_planes > 0) &&
 		(ev->surface->desired_protection > WESTON_HDCP_DISABLE);
