diff --git a/man/logind.conf.xml b/man/logind.conf.xml
index 9682add08c..8164a79af4 100644
--- a/man/logind.conf.xml
+++ b/man/logind.conf.xml
@@ -192,6 +192,14 @@
         and continues to run until system shutdown. Defaults to 10s.</para></listitem>
       </varlistentry>
 
+      <varlistentry>
+        <term><varname>HandleSecureAttentionKey=</varname></term>
+
+        <listitem><para>Specifies if the Secure Attention Sequence (Ctrl+Alt+Shift+Esc) should be handled or not</para>
+
+        <xi:include href="version-info.xml" xpointer="v256"/></listitem>
+      </varlistentry>
+
       <varlistentry>
         <term><varname>HandlePowerKey=</varname></term>
         <term><varname>HandlePowerKeyLongPress=</varname></term>
diff --git a/man/org.freedesktop.login1.xml b/man/org.freedesktop.login1.xml
index 639b09ad8c..6ec4fb6168 100644
--- a/man/org.freedesktop.login1.xml
+++ b/man/org.freedesktop.login1.xml
@@ -143,6 +143,8 @@ node /org/freedesktop/login1 {
       SetWallMessage(in  s wall_message,
                      in  b enable);
     signals:
+      SecureAttentionKey(s seat_id,
+                         o object_path);
       SessionNew(s session_id,
                  o object_path);
       SessionRemoved(s session_id,
@@ -214,6 +216,8 @@ node /org/freedesktop/login1 {
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s HandleLidSwitchDocked = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
+      readonly s HandleSecureAttentionKey = '...';
+      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t HoldoffTimeoutUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s IdleAction = '...';
@@ -264,6 +268,8 @@ node /org/freedesktop/login1 {
 
     <!--property HandleHibernateKeyLongPress is not documented!-->
 
+    <!--property HandleSecureAttentionKey is not documented!-->
+
     <!--property StopIdleSessionUSec is not documented!-->
 
     <!--Autogenerated cross-references for systemd.directives, do not edit-->
@@ -388,6 +394,8 @@ node /org/freedesktop/login1 {
 
     <variablelist class="dbus-method" generated="True" extra-ref="SetWallMessage()"/>
 
+    <variablelist class="dbus-signal" generated="True" extra-ref="SecureAttentionKey"/>
+
     <variablelist class="dbus-signal" generated="True" extra-ref="SessionNew"/>
 
     <variablelist class="dbus-signal" generated="True" extra-ref="SessionRemoved"/>
@@ -462,6 +470,8 @@ node /org/freedesktop/login1 {
 
     <variablelist class="dbus-property" generated="True" extra-ref="HandleLidSwitchDocked"/>
 
+    <variablelist class="dbus-property" generated="True" extra-ref="HandleSecureAttentionKey"/>
+
     <variablelist class="dbus-property" generated="True" extra-ref="HoldoffTimeoutUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IdleAction"/>
@@ -667,6 +677,10 @@ node /org/freedesktop/login1 {
       <para>Whenever the inhibition state or idle hint changes, <function>PropertyChanged</function>
       signals are sent out to which clients can subscribe.</para>
 
+      <para>The <function>SecureAttentionKey</function> signal is sent when the user presses Ctrl+Alt+Shift+Esc to
+      request the login manager to display the greeter, for instance in the case of a deadlocked compositor
+      </para>
+
       <para>The <function>SessionNew</function>, <function>SessionRemoved</function>,
       <function>UserNew</function>, <function>UserRemoved</function>, <function>SeatNew</function>, and
       <function>SeatRemoved</function> signals are sent each time a session is created or removed, a user
diff --git a/src/basic/macro.h b/src/basic/macro.h
index 2671c6ceaa..dc3f4ececf 100644
--- a/src/basic/macro.h
+++ b/src/basic/macro.h
@@ -313,6 +313,15 @@ static inline int __coverity_check_and_return__(int condition) {
 /* Pointers range from NULL to POINTER_MAX */
 #define POINTER_MAX ((void*) UINTPTR_MAX)
 
+#define _FOREACH_ARRAY(i, array, num, m, end)                           \
+        for (typeof(array[0]) *i = (array), *end = ({                   \
+                                typeof(num) m = (num);                  \
+                                (i && m > 0) ? i + m : NULL;            \
+                        }); end && i < end; i++)
+
+#define FOREACH_ARRAY(i, array, num)                                    \
+        _FOREACH_ARRAY(i, array, num, UNIQ_T(m, UNIQ), UNIQ_T(end, UNIQ))
+
 /* Iterates through a specified list of pointers. Accepts NULL pointers, but uses POINTER_MAX as internal marker for EOL. */
 #define FOREACH_POINTER(p, x, ...)                                                       \
         for (typeof(p) *_l = (typeof(p)[]) { ({ p = x; }), ##__VA_ARGS__, POINTER_MAX }; \
diff --git a/src/login/logind-action.c b/src/login/logind-action.c
index c6a36a1556..8424d752d1 100644
--- a/src/login/logind-action.c
+++ b/src/login/logind-action.c
@@ -11,6 +11,7 @@
 #include "format-util.h"
 #include "logind-action.h"
 #include "logind-dbus.h"
+#include "logind-seat-dbus.h"
 #include "logind-session-dbus.h"
 #include "process-util.h"
 #include "special.h"
@@ -121,12 +122,41 @@ const HandleActionData* handle_action_lookup(HandleAction action) {
         return &handle_action_data_table[action];
 }
 
+static int manager_handle_action_secure_attention_key(
+                Manager *m,
+                bool is_edge,
+                char *seat) {
+        int r;
+        Seat *o;
+        char *p;
+
+        if (!is_edge)
+                return 0;
+
+        o = hashmap_get(m->seats, seat);
+        p = seat_bus_path(o);
+
+        log_struct(LOG_INFO,
+                   LOG_MESSAGE("Secure Attention Key sequence pressed on seat %s", seat),
+                   "MESSAGE_ID=" SD_MESSAGE_SECURE_ATTENTION_KEY_PRESS_STR);
+
+        r = sd_bus_emit_signal(m->bus,
+                                  "/org/freedesktop/login1",
+                                  "org.freedesktop.login1.Manager",
+                                  "SecureAttentionKey",
+                                  "so", seat, p);
+
+        free(p);
+        return r;
+}
+
 int manager_handle_action(
                 Manager *m,
                 InhibitWhat inhibit_key,
                 HandleAction handle,
                 bool ignore_inhibited,
-                bool is_edge) {
+                bool is_edge,
+                char *action_seat) {
 
         static const char * const message_table[_HANDLE_ACTION_MAX] = {
                 [HANDLE_POWEROFF]               = "Powering off...",
@@ -177,7 +207,7 @@ int manager_handle_action(
                 }
         }
 
-        /* Locking is handled differently from the rest. */
+        /* Locking and greeter activation is handled differently from the rest. */
         if (handle == HANDLE_LOCK) {
                 if (!is_edge)
                         return 0;
@@ -187,6 +217,17 @@ int manager_handle_action(
                 return 1;
         }
 
+        if (handle == HANDLE_SECURE_ATTENTION_KEY) {
+                if (!is_edge)
+                        return 0;
+
+                if (!action_seat)
+                        return 0;
+
+                log_info("Requesting greeter on seat %s...", action_seat);
+                return manager_handle_action_secure_attention_key (m, is_edge, action_seat);
+        }
+
         if (handle == HANDLE_SUSPEND)
                 supported = can_sleep(SLEEP_SUSPEND) > 0;
         else if (handle == HANDLE_HIBERNATE)
@@ -263,6 +304,7 @@ static const char* const handle_action_verb_table[_HANDLE_ACTION_MAX] = {
         [HANDLE_SUSPEND_THEN_HIBERNATE] = "suspend and later hibernate",
         [HANDLE_FACTORY_RESET]          = "perform a factory reset",
         [HANDLE_LOCK]                   = "be locked",
+        [HANDLE_SECURE_ATTENTION_KEY]   = "secure attention key pressed",
 };
 
 DEFINE_STRING_TABLE_LOOKUP_TO_STRING(handle_action_verb, HandleAction);
@@ -279,6 +321,7 @@ static const char* const handle_action_table[_HANDLE_ACTION_MAX] = {
         [HANDLE_SUSPEND_THEN_HIBERNATE] = "suspend-then-hibernate",
         [HANDLE_FACTORY_RESET]          = "factory-reset",
         [HANDLE_LOCK]                   = "lock",
+        [HANDLE_SECURE_ATTENTION_KEY]   = "secure attention key",
 };
 
 DEFINE_STRING_TABLE_LOOKUP(handle_action, HandleAction);
diff --git a/src/login/logind-action.h b/src/login/logind-action.h
index 9a01af1690..90151b76cc 100644
--- a/src/login/logind-action.h
+++ b/src/login/logind-action.h
@@ -13,6 +13,7 @@ typedef enum HandleAction {
         HANDLE_HIBERNATE,
         HANDLE_HYBRID_SLEEP,
         HANDLE_SUSPEND_THEN_HIBERNATE,
+        HANDLE_SECURE_ATTENTION_KEY,
         HANDLE_LOCK,
         HANDLE_FACTORY_RESET,
         _HANDLE_ACTION_MAX,
@@ -47,7 +48,8 @@ int manager_handle_action(
                 InhibitWhat inhibit_key,
                 HandleAction handle,
                 bool ignore_inhibited,
-                bool is_edge);
+                bool is_edge,
+                char *action_seat);
 
 const char* handle_action_verb_to_string(HandleAction h) _const_;
 
diff --git a/src/login/logind-button.c b/src/login/logind-button.c
index 0314ae1774..c73c1d284b 100644
--- a/src/login/logind-button.c
+++ b/src/login/logind-button.c
@@ -15,7 +15,26 @@
 #include "string-util.h"
 #include "util.h"
 
-#define CONST_MAX5(a, b, c, d, e) CONST_MAX(CONST_MAX(a, b), CONST_MAX(CONST_MAX(c, d), e))
+/* KEY_RESTART is the highest value key in keys_interested */
+#define _KEY_MAX_INTERESTED KEY_RESTART
+
+/* Adding more values here may require _KEY_MAX_INTERESTED to be updated */
+static const int keys_interested[] = {
+        KEY_ESC,
+        KEY_LEFTCTRL,
+        KEY_LEFTSHIFT,
+        KEY_RIGHTSHIFT,
+        KEY_LEFTALT,
+        KEY_RIGHTCTRL,
+        KEY_RIGHTALT,
+        KEY_POWER,
+        KEY_LEFTMETA,
+        KEY_RIGHTMETA,
+        KEY_SLEEP,
+        KEY_SUSPEND,
+        KEY_POWER2,
+        KEY_RESTART,
+};
 
 #define ULONG_BITS (sizeof(unsigned long)*8)
 
@@ -48,6 +67,8 @@ Button* button_new(Manager *m, const char *name) {
                 return mfree(b);
         }
 
+        b->button_modifier_mask = BUTTON_MODIFIER_NONE;
+
         b->manager = m;
         b->fd = -1;
 
@@ -75,7 +96,7 @@ int button_set_seat(Button *b, const char *sn) {
         return free_and_strdup(&b->seat, sn);
 }
 
-static void button_lid_switch_handle_action(Manager *manager, bool is_edge) {
+static void button_lid_switch_handle_action(Manager *manager, bool is_edge, char *seat) {
         HandleAction handle_action;
 
         assert(manager);
@@ -89,7 +110,7 @@ static void button_lid_switch_handle_action(Manager *manager, bool is_edge) {
         else
                 handle_action = manager->handle_lid_switch;
 
-        manager_handle_action(manager, INHIBIT_HANDLE_LID_SWITCH, handle_action, manager->lid_switch_ignore_inhibited, is_edge);
+        manager_handle_action(manager, INHIBIT_HANDLE_LID_SWITCH, handle_action, manager->lid_switch_ignore_inhibited, is_edge, seat);
 }
 
 static int button_recheck(sd_event_source *e, void *userdata) {
@@ -97,7 +118,7 @@ static int button_recheck(sd_event_source *e, void *userdata) {
 
         assert(b->lid_closed);
 
-        button_lid_switch_handle_action(b->manager, false);
+        button_lid_switch_handle_action(b->manager, false, b->seat);
         return 1;
 }
 
@@ -118,71 +139,91 @@ static int button_install_check_event_source(Button *b) {
 }
 
 static int long_press_of_power_key_handler(sd_event_source *e, uint64_t usec, void *userdata) {
-        Manager *m = ASSERT_PTR(userdata);
+        Button *b = ASSERT_PTR(userdata);
+        Manager *m = b->manager;
 
         assert(e);
 
+        if (!m)
+                return 0;
+
         m->power_key_long_press_event_source = sd_event_source_unref(m->power_key_long_press_event_source);
 
         log_struct(LOG_INFO,
                    LOG_MESSAGE("Power key pressed long."),
                    "MESSAGE_ID=" SD_MESSAGE_POWER_KEY_LONG_PRESS_STR);
 
-        manager_handle_action(m, INHIBIT_HANDLE_POWER_KEY, m->handle_power_key_long_press, m->power_key_ignore_inhibited, true);
+        manager_handle_action(m, INHIBIT_HANDLE_POWER_KEY, m->handle_power_key_long_press, m->power_key_ignore_inhibited, true, b->seat);
         return 0;
 }
 
 static int long_press_of_reboot_key_handler(sd_event_source *e, uint64_t usec, void *userdata) {
-        Manager *m = ASSERT_PTR(userdata);
+        Button *b = ASSERT_PTR(userdata);
+        Manager *m = b->manager;
 
         assert(e);
 
+        if (!m)
+                return 0;
+
         m->reboot_key_long_press_event_source = sd_event_source_unref(m->reboot_key_long_press_event_source);
 
         log_struct(LOG_INFO,
                    LOG_MESSAGE("Reboot key pressed long."),
                    "MESSAGE_ID=" SD_MESSAGE_REBOOT_KEY_LONG_PRESS_STR);
 
-        manager_handle_action(m, INHIBIT_HANDLE_REBOOT_KEY, m->handle_reboot_key_long_press, m->reboot_key_ignore_inhibited, true);
+        manager_handle_action(m, INHIBIT_HANDLE_REBOOT_KEY, m->handle_reboot_key_long_press, m->reboot_key_ignore_inhibited, true, b->seat);
         return 0;
 }
 
 static int long_press_of_suspend_key_handler(sd_event_source *e, uint64_t usec, void *userdata) {
-        Manager *m = ASSERT_PTR(userdata);
+        Button *b = ASSERT_PTR(userdata);
+        Manager *m = b->manager;
 
         assert(e);
 
+        if (!m)
+                return 0;
+
         m->suspend_key_long_press_event_source = sd_event_source_unref(m->suspend_key_long_press_event_source);
 
         log_struct(LOG_INFO,
                    LOG_MESSAGE("Suspend key pressed long."),
                    "MESSAGE_ID=" SD_MESSAGE_SUSPEND_KEY_LONG_PRESS_STR);
 
-        manager_handle_action(m, INHIBIT_HANDLE_SUSPEND_KEY, m->handle_suspend_key_long_press, m->suspend_key_ignore_inhibited, true);
+        manager_handle_action(m, INHIBIT_HANDLE_SUSPEND_KEY, m->handle_suspend_key_long_press, m->suspend_key_ignore_inhibited, true, b->seat);
         return 0;
 }
 
 static int long_press_of_hibernate_key_handler(sd_event_source *e, uint64_t usec, void *userdata) {
-        Manager *m = ASSERT_PTR(userdata);
+        Button *b = ASSERT_PTR(userdata);
+        Manager *m = b->manager;
 
         assert(e);
 
+        if (!m)
+                return 0;
+
         m->hibernate_key_long_press_event_source = sd_event_source_unref(m->hibernate_key_long_press_event_source);
 
         log_struct(LOG_INFO,
                    LOG_MESSAGE("Hibernate key pressed long."),
                    "MESSAGE_ID=" SD_MESSAGE_HIBERNATE_KEY_LONG_PRESS_STR);
 
-        manager_handle_action(m, INHIBIT_HANDLE_HIBERNATE_KEY, m->handle_hibernate_key_long_press, m->hibernate_key_ignore_inhibited, true);
+        manager_handle_action(m, INHIBIT_HANDLE_HIBERNATE_KEY, m->handle_hibernate_key_long_press, m->hibernate_key_ignore_inhibited, true, b->seat);
         return 0;
 }
 
-static void start_long_press(Manager *m, sd_event_source **e, sd_event_time_handler_t callback) {
+static void start_long_press(Button *b, sd_event_source **e, sd_event_time_handler_t callback) {
         int r;
 
-        assert(m);
+        assert(b);
         assert(e);
 
+        Manager *m = b->manager;
+        if (!m)
+                return;
+
         if (*e)
                 return;
 
@@ -191,7 +232,7 @@ static void start_long_press(Manager *m, sd_event_source **e, sd_event_time_hand
                         e,
                         CLOCK_MONOTONIC,
                         LONG_PRESS_DURATION, 0,
-                        callback, m);
+                        callback, b);
         if (r < 0)
                 log_warning_errno(r, "Failed to add long press timer event, ignoring: %m");
 }
@@ -218,12 +259,12 @@ static int button_dispatch(sd_event_source *s, int fd, uint32_t revents, void *u
                 case KEY_POWER2:
                         if (b->manager->handle_power_key_long_press != HANDLE_IGNORE && b->manager->handle_power_key_long_press != b->manager->handle_power_key) {
                                 log_debug("Power key pressed. Further action depends on the key press duration.");
-                                start_long_press(b->manager, &b->manager->power_key_long_press_event_source, long_press_of_power_key_handler);
+                                start_long_press(b, &b->manager->power_key_long_press_event_source, long_press_of_power_key_handler);
                         } else {
                                 log_struct(LOG_INFO,
                                            LOG_MESSAGE("Power key pressed short."),
                                            "MESSAGE_ID=" SD_MESSAGE_POWER_KEY_STR);
-                                manager_handle_action(b->manager, INHIBIT_HANDLE_POWER_KEY, b->manager->handle_power_key, b->manager->power_key_ignore_inhibited, true);
+                                manager_handle_action(b->manager, INHIBIT_HANDLE_POWER_KEY, b->manager->handle_power_key, b->manager->power_key_ignore_inhibited, true, b->seat);
                         }
                         break;
 
@@ -235,12 +276,12 @@ static int button_dispatch(sd_event_source *s, int fd, uint32_t revents, void *u
                 case KEY_RESTART:
                         if (b->manager->handle_reboot_key_long_press != HANDLE_IGNORE && b->manager->handle_reboot_key_long_press != b->manager->handle_reboot_key) {
                                 log_debug("Reboot key pressed. Further action depends on the key press duration.");
-                                start_long_press(b->manager, &b->manager->reboot_key_long_press_event_source, long_press_of_reboot_key_handler);
+                                start_long_press(b, &b->manager->reboot_key_long_press_event_source, long_press_of_reboot_key_handler);
                         } else {
                                 log_struct(LOG_INFO,
                                            LOG_MESSAGE("Reboot key pressed short."),
                                            "MESSAGE_ID=" SD_MESSAGE_REBOOT_KEY_STR);
-                                manager_handle_action(b->manager, INHIBIT_HANDLE_REBOOT_KEY, b->manager->handle_reboot_key, b->manager->reboot_key_ignore_inhibited, true);
+                                manager_handle_action(b->manager, INHIBIT_HANDLE_REBOOT_KEY, b->manager->handle_reboot_key, b->manager->reboot_key_ignore_inhibited, true, b->seat);
                         }
                         break;
 
@@ -253,26 +294,65 @@ static int button_dispatch(sd_event_source *s, int fd, uint32_t revents, void *u
                 case KEY_SLEEP:
                         if (b->manager->handle_suspend_key_long_press != HANDLE_IGNORE && b->manager->handle_suspend_key_long_press != b->manager->handle_suspend_key) {
                                 log_debug("Suspend key pressed. Further action depends on the key press duration.");
-                                start_long_press(b->manager, &b->manager->suspend_key_long_press_event_source, long_press_of_suspend_key_handler);
+                                start_long_press(b, &b->manager->suspend_key_long_press_event_source, long_press_of_suspend_key_handler);
                         } else {
                                 log_struct(LOG_INFO,
                                            LOG_MESSAGE("Suspend key pressed short."),
                                            "MESSAGE_ID=" SD_MESSAGE_SUSPEND_KEY_STR);
-                                manager_handle_action(b->manager, INHIBIT_HANDLE_SUSPEND_KEY, b->manager->handle_suspend_key, b->manager->suspend_key_ignore_inhibited, true);
+                                manager_handle_action(b->manager, INHIBIT_HANDLE_SUSPEND_KEY, b->manager->handle_suspend_key, b->manager->suspend_key_ignore_inhibited, true, b->seat);
                         }
                         break;
 
                 case KEY_SUSPEND:
                         if (b->manager->handle_hibernate_key_long_press != HANDLE_IGNORE && b->manager->handle_hibernate_key_long_press != b->manager->handle_hibernate_key) {
                                 log_debug("Hibernate key pressed. Further action depends on the key press duration.");
-                                start_long_press(b->manager, &b->manager->hibernate_key_long_press_event_source, long_press_of_hibernate_key_handler);
+                                start_long_press(b, &b->manager->hibernate_key_long_press_event_source, long_press_of_hibernate_key_handler);
                         } else {
                                 log_struct(LOG_INFO,
                                            LOG_MESSAGE("Hibernate key pressed short."),
                                            "MESSAGE_ID=" SD_MESSAGE_HIBERNATE_KEY_STR);
-                                manager_handle_action(b->manager, INHIBIT_HANDLE_HIBERNATE_KEY, b->manager->handle_hibernate_key, b->manager->hibernate_key_ignore_inhibited, true);
+                                manager_handle_action(b->manager, INHIBIT_HANDLE_HIBERNATE_KEY, b->manager->handle_hibernate_key, b->manager->hibernate_key_ignore_inhibited, true, b->seat);
                         }
                         break;
+
+                case KEY_ESC:
+                        if (b->manager->handle_secure_attention_key != HANDLE_IGNORE) {
+                                if ((b->button_modifier_mask & (BUTTON_MODIFIER_LEFT_CTRL | BUTTON_MODIFIER_RIGHT_CTRL)) != 0 &&
+                                    (b->button_modifier_mask & (BUTTON_MODIFIER_LEFT_ALT | BUTTON_MODIFIER_RIGHT_ALT)) != 0 &&
+                                    (b->button_modifier_mask & (BUTTON_MODIFIER_LEFT_SHIFT | BUTTON_MODIFIER_RIGHT_SHIFT)) != 0) {
+                                        log_debug("Secure Attention Key sequence pressed short.");
+                                        manager_handle_action(b->manager, INHIBIT_SECURE_ATTENTION_KEY, b->manager->handle_secure_attention_key, b->manager->secure_attention_key_inhibited, true, b->seat);
+                                }
+                        }
+                        break;
+
+                case KEY_LEFTSHIFT:
+                        b->button_modifier_mask |= BUTTON_MODIFIER_LEFT_SHIFT;
+                        break;
+                case KEY_RIGHTSHIFT:
+                        b->button_modifier_mask |= BUTTON_MODIFIER_RIGHT_SHIFT;
+                        break;
+
+                case KEY_LEFTCTRL:
+                        b->button_modifier_mask |= BUTTON_MODIFIER_LEFT_CTRL;
+                        break;
+                case KEY_RIGHTCTRL:
+                        b->button_modifier_mask |= BUTTON_MODIFIER_RIGHT_CTRL;
+                        break;
+
+                case KEY_LEFTMETA:
+                        b->button_modifier_mask |= BUTTON_MODIFIER_LEFT_META;
+                        break;
+                case KEY_RIGHTMETA:
+                        b->button_modifier_mask |= BUTTON_MODIFIER_RIGHT_META;
+                        break;
+
+                case KEY_LEFTALT:
+                        b->button_modifier_mask |= BUTTON_MODIFIER_LEFT_ALT;
+                        break;
+                case KEY_RIGHTALT:
+                        b->button_modifier_mask |= BUTTON_MODIFIER_RIGHT_ALT;
+                        break;
                 }
 
         } else if (ev.type == EV_KEY && ev.value == 0) {
@@ -292,7 +372,7 @@ static int button_dispatch(sd_event_source *s, int fd, uint32_t revents, void *u
 
                                 b->manager->power_key_long_press_event_source = sd_event_source_unref(b->manager->power_key_long_press_event_source);
 
-                                manager_handle_action(b->manager, INHIBIT_HANDLE_POWER_KEY, b->manager->handle_power_key, b->manager->power_key_ignore_inhibited, true);
+                                manager_handle_action(b->manager, INHIBIT_HANDLE_POWER_KEY, b->manager->handle_power_key, b->manager->power_key_ignore_inhibited, true, b->seat);
                         }
                         break;
 
@@ -304,7 +384,7 @@ static int button_dispatch(sd_event_source *s, int fd, uint32_t revents, void *u
 
                                 b->manager->reboot_key_long_press_event_source = sd_event_source_unref(b->manager->reboot_key_long_press_event_source);
 
-                                manager_handle_action(b->manager, INHIBIT_HANDLE_REBOOT_KEY, b->manager->handle_reboot_key, b->manager->reboot_key_ignore_inhibited, true);
+                                manager_handle_action(b->manager, INHIBIT_HANDLE_REBOOT_KEY, b->manager->handle_reboot_key, b->manager->reboot_key_ignore_inhibited, true, b->seat);
                         }
                         break;
 
@@ -316,7 +396,7 @@ static int button_dispatch(sd_event_source *s, int fd, uint32_t revents, void *u
 
                                 b->manager->suspend_key_long_press_event_source = sd_event_source_unref(b->manager->suspend_key_long_press_event_source);
 
-                                manager_handle_action(b->manager, INHIBIT_HANDLE_SUSPEND_KEY, b->manager->handle_suspend_key, b->manager->suspend_key_ignore_inhibited, true);
+                                manager_handle_action(b->manager, INHIBIT_HANDLE_SUSPEND_KEY, b->manager->handle_suspend_key, b->manager->suspend_key_ignore_inhibited, true, b->seat);
                         }
                         break;
                 case KEY_SUSPEND:
@@ -327,9 +407,40 @@ static int button_dispatch(sd_event_source *s, int fd, uint32_t revents, void *u
 
                                 b->manager->hibernate_key_long_press_event_source = sd_event_source_unref(b->manager->hibernate_key_long_press_event_source);
 
-                                manager_handle_action(b->manager, INHIBIT_HANDLE_HIBERNATE_KEY, b->manager->handle_hibernate_key, b->manager->hibernate_key_ignore_inhibited, true);
+                                manager_handle_action(b->manager, INHIBIT_HANDLE_HIBERNATE_KEY, b->manager->handle_hibernate_key, b->manager->hibernate_key_ignore_inhibited, true, b->seat);
                         }
                         break;
+
+                case KEY_ESC:
+                        break;
+
+                case KEY_LEFTSHIFT:
+                        b->button_modifier_mask &= ~BUTTON_MODIFIER_LEFT_SHIFT;
+                        break;
+                case KEY_RIGHTSHIFT:
+                        b->button_modifier_mask &= ~BUTTON_MODIFIER_RIGHT_SHIFT;
+                        break;
+
+                case KEY_LEFTCTRL:
+                        b->button_modifier_mask &= ~BUTTON_MODIFIER_LEFT_CTRL;
+                        break;
+                case KEY_RIGHTCTRL:
+                        b->button_modifier_mask &= ~BUTTON_MODIFIER_RIGHT_CTRL;
+                        break;
+
+                case KEY_LEFTMETA:
+                        b->button_modifier_mask &= ~BUTTON_MODIFIER_LEFT_META;
+                        break;
+                case KEY_RIGHTMETA:
+                        b->button_modifier_mask &= ~BUTTON_MODIFIER_RIGHT_META;
+                        break;
+
+                case KEY_LEFTALT:
+                        b->button_modifier_mask &= ~BUTTON_MODIFIER_LEFT_ALT;
+                        break;
+                case KEY_RIGHTALT:
+                        b->button_modifier_mask &= ~BUTTON_MODIFIER_RIGHT_ALT;
+                        break;
                 }
 
         } else if (ev.type == EV_SW && ev.value > 0) {
@@ -340,7 +451,7 @@ static int button_dispatch(sd_event_source *s, int fd, uint32_t revents, void *u
                                    "MESSAGE_ID=" SD_MESSAGE_LID_CLOSED_STR);
 
                         b->lid_closed = true;
-                        button_lid_switch_handle_action(b->manager, true);
+                        button_lid_switch_handle_action(b->manager, true, b->seat);
                         button_install_check_event_source(b);
 
                 } else if (ev.code == SW_DOCK) {
@@ -382,17 +493,25 @@ static int button_suitable(int fd) {
                 return -errno;
 
         if (bitset_get(types, EV_KEY)) {
-                unsigned long keys[CONST_MAX5(KEY_POWER, KEY_POWER2, KEY_SLEEP, KEY_SUSPEND, KEY_RESTART)/ULONG_BITS+1];
+                unsigned long keys[_KEY_MAX_INTERESTED/ULONG_BITS+1];
 
                 if (ioctl(fd, EVIOCGBIT(EV_KEY, sizeof keys), keys) < 0)
                         return -errno;
 
+                /* If the device has power related keys, then accept */
                 if (bitset_get(keys, KEY_POWER) ||
                     bitset_get(keys, KEY_POWER2) ||
                     bitset_get(keys, KEY_SLEEP) ||
                     bitset_get(keys, KEY_SUSPEND) ||
                     bitset_get(keys, KEY_RESTART))
                         return true;
+
+                /* If the device has keys that can accept the SAK  */
+                if ((bitset_get (keys, KEY_LEFTCTRL) || bitset_get (keys, KEY_LEFTCTRL)) &&
+                    (bitset_get (keys, KEY_LEFTCTRL) || bitset_get (keys, KEY_LEFTCTRL)) &&
+                    (bitset_get (keys, KEY_LEFTCTRL) || bitset_get (keys, KEY_LEFTCTRL)) &&
+                    bitset_get (keys, KEY_ESC))
+                        return true;
         }
 
         if (bitset_get(types, EV_SW)) {
@@ -409,10 +528,36 @@ static int button_suitable(int fd) {
         return false;
 }
 
+static void button_get_modifier_mask(Button *b) {
+        unsigned long keys[KEY_MAX/ULONG_BITS+1];
+
+        if (ioctl(b->fd, EVIOCGKEY(sizeof(keys)), keys) >= 0) {
+                if (bitset_get (keys, KEY_LEFTSHIFT))
+                        b->button_modifier_mask &= ~BUTTON_MODIFIER_LEFT_SHIFT;
+                if (bitset_get (keys, KEY_RIGHTSHIFT))
+                        b->button_modifier_mask &= ~BUTTON_MODIFIER_RIGHT_SHIFT;
+
+                if (bitset_get (keys, KEY_LEFTCTRL))
+                        b->button_modifier_mask &= ~BUTTON_MODIFIER_LEFT_CTRL;
+                if (bitset_get (keys, KEY_RIGHTCTRL))
+                        b->button_modifier_mask &= ~BUTTON_MODIFIER_RIGHT_CTRL;
+
+                if (bitset_get (keys, KEY_LEFTMETA))
+                        b->button_modifier_mask &= ~BUTTON_MODIFIER_LEFT_META;
+                if (bitset_get (keys, KEY_RIGHTCTRL))
+                        b->button_modifier_mask &= ~BUTTON_MODIFIER_RIGHT_META;
+
+                if (bitset_get (keys, KEY_LEFTALT))
+                        b->button_modifier_mask &= ~BUTTON_MODIFIER_LEFT_ALT;
+                if (bitset_get (keys, KEY_RIGHTALT))
+                        b->button_modifier_mask &= ~BUTTON_MODIFIER_RIGHT_ALT;
+        }
+}
+
 static int button_set_mask(const char *name, int fd) {
         unsigned long
                 types[CONST_MAX(EV_KEY, EV_SW)/ULONG_BITS+1] = {},
-                keys[CONST_MAX5(KEY_POWER, KEY_POWER2, KEY_SLEEP, KEY_SUSPEND, KEY_RESTART)/ULONG_BITS+1] = {},
+                keys[_KEY_MAX_INTERESTED/ULONG_BITS+1] = {},
                 switches[CONST_MAX(SW_LID, SW_DOCK)/ULONG_BITS+1] = {};
         struct input_mask mask;
 
@@ -433,11 +578,11 @@ static int button_set_mask(const char *name, int fd) {
                 return log_full_errno(IN_SET(errno, ENOTTY, EOPNOTSUPP, EINVAL) ? LOG_DEBUG : LOG_WARNING,
                                       errno, "Failed to set EV_SYN event mask on /dev/input/%s: %m", name);
 
-        bitset_put(keys, KEY_POWER);
-        bitset_put(keys, KEY_POWER2);
-        bitset_put(keys, KEY_SLEEP);
-        bitset_put(keys, KEY_SUSPEND);
-        bitset_put(keys, KEY_RESTART);
+        FOREACH_ARRAY(key, keys_interested, ELEMENTSOF(keys_interested)) {
+                assert(*key <= _KEY_MAX_INTERESTED);
+
+                bitset_put(keys, *key);
+        }
 
         mask = (struct input_mask) {
                 .type = EV_KEY,
@@ -491,6 +636,8 @@ int button_open(Button *b) {
 
         (void) button_set_mask(b->name, fd);
 
+        button_get_modifier_mask(b);
+
         b->io_event_source = sd_event_source_unref(b->io_event_source);
         r = sd_event_add_io(b->manager->event, &b->io_event_source, fd, EPOLLIN, button_dispatch, b);
         if (r < 0)
diff --git a/src/login/logind-button.h b/src/login/logind-button.h
index 041d66521c..dd87221347 100644
--- a/src/login/logind-button.h
+++ b/src/login/logind-button.h
@@ -5,6 +5,18 @@ typedef struct Button Button;
 
 #include "logind.h"
 
+typedef enum {
+        BUTTON_MODIFIER_NONE        = 0,
+        BUTTON_MODIFIER_LEFT_SHIFT  = 1 << 0,
+        BUTTON_MODIFIER_RIGHT_SHIFT = 1 << 1,
+        BUTTON_MODIFIER_LEFT_CTRL   = 1 << 2,
+        BUTTON_MODIFIER_RIGHT_CTRL  = 1 << 3,
+        BUTTON_MODIFIER_LEFT_ALT    = 1 << 4,
+        BUTTON_MODIFIER_RIGHT_ALT   = 1 << 5,
+        BUTTON_MODIFIER_LEFT_META   = 1 << 6,
+        BUTTON_MODIFIER_RIGHT_META  = 1 << 7,
+} ButtonModifierMask;
+
 struct Button {
         Manager *manager;
 
@@ -15,6 +27,8 @@ struct Button {
         char *seat;
         int fd;
 
+        ButtonModifierMask button_modifier_mask;
+
         bool lid_closed;
         bool docked;
 };
diff --git a/src/login/logind-core.c b/src/login/logind-core.c
index 02adc81909..f924fd53fa 100644
--- a/src/login/logind-core.c
+++ b/src/login/logind-core.c
@@ -46,6 +46,7 @@ void manager_reset_config(Manager *m) {
         m->handle_suspend_key_long_press = HANDLE_HIBERNATE;
         m->handle_hibernate_key = HANDLE_HIBERNATE;
         m->handle_hibernate_key_long_press = HANDLE_IGNORE;
+        m->handle_secure_attention_key = HANDLE_SECURE_ATTENTION_KEY;
 
         m->handle_lid_switch = HANDLE_SUSPEND;
         m->handle_lid_switch_ep = _HANDLE_ACTION_INVALID;
@@ -697,6 +698,8 @@ bool manager_all_buttons_ignored(Manager *m) {
                 return false;
         if (m->handle_lid_switch_docked != HANDLE_IGNORE)
                 return false;
+        if (m->handle_secure_attention_key != HANDLE_IGNORE)
+                return false;
 
         return true;
 }
diff --git a/src/login/logind-dbus.c b/src/login/logind-dbus.c
index 56aba3b073..9b67da062a 100644
--- a/src/login/logind-dbus.c
+++ b/src/login/logind-dbus.c
@@ -3338,6 +3338,7 @@ static const sd_bus_vtable manager_vtable[] = {
         SD_BUS_PROPERTY("HandleLidSwitch", "s", property_get_handle_action, offsetof(Manager, handle_lid_switch), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("HandleLidSwitchExternalPower", "s", property_get_handle_action, offsetof(Manager, handle_lid_switch_ep), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("HandleLidSwitchDocked", "s", property_get_handle_action, offsetof(Manager, handle_lid_switch_docked), SD_BUS_VTABLE_PROPERTY_CONST),
+        SD_BUS_PROPERTY("HandleSecureAttentionKey", "s", property_get_handle_action, offsetof(Manager, handle_secure_attention_key), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("HoldoffTimeoutUSec", "t", NULL, offsetof(Manager, holdoff_timeout_usec), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("IdleAction", "s", property_get_handle_action, offsetof(Manager, idle_action), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("IdleActionUSec", "t", NULL, offsetof(Manager, idle_action_usec), SD_BUS_VTABLE_PROPERTY_CONST),
@@ -3668,6 +3669,9 @@ static const sd_bus_vtable manager_vtable[] = {
                                 method_set_wall_message,
                                 SD_BUS_VTABLE_UNPRIVILEGED),
 
+        SD_BUS_SIGNAL_WITH_ARGS("SecureAttentionKey",
+                                SD_BUS_ARGS("s", seat_id, "o", object_path),
+                                0),
         SD_BUS_SIGNAL_WITH_ARGS("SessionNew",
                                 SD_BUS_ARGS("s", session_id, "o", object_path),
                                 0),
diff --git a/src/login/logind-gperf.gperf b/src/login/logind-gperf.gperf
index c95a3b2dc3..ba6d5f3dc6 100644
--- a/src/login/logind-gperf.gperf
+++ b/src/login/logind-gperf.gperf
@@ -36,6 +36,7 @@ Login.HandleHibernateKeyLongPress,  config_parse_handle_action,         0, offse
 Login.HandleLidSwitch,              config_parse_handle_action,         0, offsetof(Manager, handle_lid_switch)
 Login.HandleLidSwitchExternalPower, config_parse_handle_action,         0, offsetof(Manager, handle_lid_switch_ep)
 Login.HandleLidSwitchDocked,        config_parse_handle_action,         0, offsetof(Manager, handle_lid_switch_docked)
+Login.HandleSecureAttentionKey,     config_parse_handle_action,         0, offsetof(Manager, handle_secure_attention_key)
 Login.PowerKeyIgnoreInhibited,      config_parse_bool,                  0, offsetof(Manager, power_key_ignore_inhibited)
 Login.SuspendKeyIgnoreInhibited,    config_parse_bool,                  0, offsetof(Manager, suspend_key_ignore_inhibited)
 Login.HibernateKeyIgnoreInhibited,  config_parse_bool,                  0, offsetof(Manager, hibernate_key_ignore_inhibited)
diff --git a/src/login/logind-inhibit.h b/src/login/logind-inhibit.h
index 871e69a03a..276bd3f01f 100644
--- a/src/login/logind-inhibit.h
+++ b/src/login/logind-inhibit.h
@@ -12,7 +12,8 @@ typedef enum InhibitWhat {
         INHIBIT_HANDLE_HIBERNATE_KEY = 1 << 5,
         INHIBIT_HANDLE_LID_SWITCH    = 1 << 6,
         INHIBIT_HANDLE_REBOOT_KEY    = 1 << 7,
-        _INHIBIT_WHAT_MAX            = 1 << 8,
+        INHIBIT_SECURE_ATTENTION_KEY = 1 << 8,
+        _INHIBIT_WHAT_MAX            = 1 << 9,
         _INHIBIT_WHAT_INVALID        = -EINVAL,
 } InhibitWhat;
 
diff --git a/src/login/logind.c b/src/login/logind.c
index 788ddfccc5..149ed4faf4 100644
--- a/src/login/logind.c
+++ b/src/login/logind.c
@@ -982,7 +982,7 @@ static int manager_dispatch_idle_action(sd_event_source *s, uint64_t t, void *us
                         else
                                 log_info("System idle. Will %s now.", handle_action_verb_to_string(m->idle_action));
 
-                        manager_handle_action(m, 0, m->idle_action, false, is_edge);
+                        manager_handle_action(m, 0, m->idle_action, false, is_edge, NULL);
                         m->idle_action_not_before_usec = n;
                 }
 
diff --git a/src/login/logind.h b/src/login/logind.h
index d0b1f9671e..d07bc5a359 100644
--- a/src/login/logind.h
+++ b/src/login/logind.h
@@ -106,6 +106,7 @@ struct Manager {
         HandleAction handle_suspend_key_long_press;
         HandleAction handle_hibernate_key;
         HandleAction handle_hibernate_key_long_press;
+        HandleAction handle_secure_attention_key;
 
         HandleAction handle_lid_switch;
         HandleAction handle_lid_switch_ep;
@@ -116,6 +117,7 @@ struct Manager {
         bool hibernate_key_ignore_inhibited;
         bool lid_switch_ignore_inhibited;
         bool reboot_key_ignore_inhibited;
+        bool secure_attention_key_inhibited;
 
         bool remove_ipc;
 
diff --git a/src/systemd/sd-messages.h b/src/systemd/sd-messages.h
index 51241c9426..648041cd4b 100644
--- a/src/systemd/sd-messages.h
+++ b/src/systemd/sd-messages.h
@@ -143,6 +143,8 @@ _SD_BEGIN_DECLARATIONS;
 #define SD_MESSAGE_POWER_KEY_STR                      SD_ID128_MAKE_STR(b7,2e,a4,a2,88,15,45,a0,b5,0e,20,0e,55,b9,b0,71)
 #define SD_MESSAGE_POWER_KEY_LONG_PRESS               SD_ID128_MAKE(3e,01,17,10,1e,b2,43,c1,b9,a5,0d,b3,49,4a,b1,0b)
 #define SD_MESSAGE_POWER_KEY_LONG_PRESS_STR           SD_ID128_MAKE_STR(3e,01,17,10,1e,b2,43,c1,b9,a5,0d,b3,49,4a,b1,0b)
+#define SD_MESSAGE_SECURE_ATTENTION_KEY_PRESS         SD_ID128_MAKE(b2,bc,ba,f5,ed,f9,48,e0,93,ce,50,bb,ea,0e,81,ec)
+#define SD_MESSAGE_SECURE_ATTENTION_KEY_PRESS_STR     SD_ID128_MAKE_STR(b2,bc,ba,f5,ed,f9,48,e0,93,ce,50,bb,ea,0e,81,ec)
 #define SD_MESSAGE_REBOOT_KEY                         SD_ID128_MAKE(9f,a9,d2,c0,12,13,4e,c3,85,45,1f,fe,31,6f,97,d0)
 #define SD_MESSAGE_REBOOT_KEY_STR                     SD_ID128_MAKE_STR(9f,a9,d2,c0,12,13,4e,c3,85,45,1f,fe,31,6f,97,d0)
 #define SD_MESSAGE_REBOOT_KEY_LONG_PRESS              SD_ID128_MAKE(f1,c5,9a,58,c9,d9,43,66,89,65,c3,37,ca,ec,59,75)
