diff --git a/src/core/show-status.c b/src/core/show-status.c
index ed5d6f0cfa..ee05f1e0be 100644
--- a/src/core/show-status.c
+++ b/src/core/show-status.c
@@ -58,7 +58,7 @@ int status_vprintf(const char *status, ShowStatusFlags flags, const char *format
          * but minimizes the time window the kernel might end up killing PID 1 due to SAK). It also makes things easier
          * for us so that we don't have to recover from hangups and suchlike triggered on the console. */
 
-        fd = open_terminal("/dev/console", O_WRONLY|O_NOCTTY|O_CLOEXEC);
+        fd = open("/dev/console", O_WRONLY|O_NOCTTY|O_CLOEXEC);
         if (fd < 0)
                 return fd;
 
diff --git a/catalog/systemd.catalog.in b/catalog/systemd.catalog.in
index 4c29128f71..e840e427ff 100644
--- a/catalog/systemd.catalog.in
+++ b/catalog/systemd.catalog.in
@@ -119,6 +119,16 @@ Documentation: sd-login(3)
 
 A seat @SEAT_ID@ has been removed and is no longer available.
 
+-- b2bcbaf5edf948e093ce50bbea0e81ec
+Subject: The Secure Attention Key (SAK) was pressed on @SEAT_ID@
+Defined-By: systemd
+Support: %SUPPORT_URL%
+Documentation: man:systemd-logind.service(8)
+
+The Secure Attention Key (SAK), Ctrl+Alt+Shift+Esc, was pressed on @SEAT_ID@.
+
+Pressing the SAK indicates an explicit request by the user for the system to display a secure login dialog or greeter.
+
 -- c7a787079b354eaaa9e77b371893cd27
 Subject: Time change
 Defined-By: systemd
diff --git a/man/logind.conf.xml b/man/logind.conf.xml
index 9682add08c..c029c1e86b 100644
--- a/man/logind.conf.xml
+++ b/man/logind.conf.xml
@@ -204,6 +204,7 @@
         <term><varname>HandleLidSwitch=</varname></term>
         <term><varname>HandleLidSwitchExternalPower=</varname></term>
         <term><varname>HandleLidSwitchDocked=</varname></term>
+        <term><varname>HandleSecureAttentionKey=</varname></term>
 
         <listitem><para>Controls how logind shall handle the system power, reboot and sleep keys and the lid
         switch to trigger actions such as system power-off, reboot or suspend. Can be one of
@@ -211,7 +212,7 @@
         <literal>halt</literal>, <literal>kexec</literal>, <literal>suspend</literal>,
         <literal>hibernate</literal>, <literal>hybrid-sleep</literal>,
         <literal>suspend-then-hibernate</literal>, <literal>lock</literal>, and
-        <literal>factory-reset</literal>.  If <literal>ignore</literal>, <command>systemd-logind</command>
+        <literal>factory-reset</literal>, <literal>secure-attention-key</literal>.  If <literal>ignore</literal>, <command>systemd-logind</command>
         will never handle these keys. If <literal>lock</literal>, all running sessions will be screen-locked;
         otherwise, the specified action will be taken in the respective event. Only input devices with the
         <literal>power-switch</literal> udev tag will be watched for key/lid switch
@@ -232,7 +233,8 @@
         system is inserted in a docking station, or if more than one display is connected, the action
         specified by <varname>HandleLidSwitchDocked=</varname> occurs; if the system is on external power the
         action (if any) specified by <varname>HandleLidSwitchExternalPower=</varname> occurs; otherwise the
-        <varname>HandleLidSwitch=</varname> action occurs.</para>
+        <varname>HandleLidSwitch=</varname> action occurs.
+        <varname>HandleSecureAttentionKey=</varname> defaults to <literal>secure-attention-key</literal></para>
 
         <para>A different application may disable logind's handling of system power and
         sleep keys and the lid switch by taking a low-level inhibitor lock
@@ -243,7 +245,7 @@
         to take over suspend and hibernation handling, and to use their own configuration
         mechanisms. If a low-level inhibitor lock is taken, logind will not take any
         action when that key or switch is triggered and the <varname>Handle*=</varname>
-        settings are irrelevant.</para></listitem>
+        settings are irrelevant, except for <varname>HandleSecureAttentionKey=</varname>, which is always handled since its addition in v257.</para>
       </varlistentry>
 
       <varlistentry>
diff --git a/man/org.freedesktop.login1.xml b/man/org.freedesktop.login1.xml
index 639b09ad8c..17ed335d05 100644
--- a/man/org.freedesktop.login1.xml
+++ b/man/org.freedesktop.login1.xml
@@ -143,6 +143,8 @@ node /org/freedesktop/login1 {
       SetWallMessage(in  s wall_message,
                      in  b enable);
     signals:
+      SecureAttentionKey(s seat_id,
+                         o object_path);
       SessionNew(s session_id,
                  o object_path);
       SessionRemoved(s session_id,
@@ -214,6 +216,8 @@ node /org/freedesktop/login1 {
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s HandleLidSwitchDocked = '...';
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
+      readonly s HandleSecureAttentionKey = '...';
+      @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly t HoldoffTimeoutUSec = ...;
       @org.freedesktop.DBus.Property.EmitsChangedSignal("const")
       readonly s IdleAction = '...';
@@ -264,6 +268,8 @@ node /org/freedesktop/login1 {
 
     <!--property HandleHibernateKeyLongPress is not documented!-->
 
+    <!--property HandleSecureAttentionKey is not documented!-->
+
     <!--property StopIdleSessionUSec is not documented!-->
 
     <!--Autogenerated cross-references for systemd.directives, do not edit-->
@@ -388,6 +394,8 @@ node /org/freedesktop/login1 {
 
     <variablelist class="dbus-method" generated="True" extra-ref="SetWallMessage()"/>
 
+    <variablelist class="dbus-signal" generated="True" extra-ref="SecureAttentionKey"/>
+
     <variablelist class="dbus-signal" generated="True" extra-ref="SessionNew"/>
 
     <variablelist class="dbus-signal" generated="True" extra-ref="SessionRemoved"/>
@@ -462,6 +470,8 @@ node /org/freedesktop/login1 {
 
     <variablelist class="dbus-property" generated="True" extra-ref="HandleLidSwitchDocked"/>
 
+    <variablelist class="dbus-property" generated="True" extra-ref="HandleSecureAttentionKey"/>
+
     <variablelist class="dbus-property" generated="True" extra-ref="HoldoffTimeoutUSec"/>
 
     <variablelist class="dbus-property" generated="True" extra-ref="IdleAction"/>
@@ -667,6 +677,10 @@ node /org/freedesktop/login1 {
       <para>Whenever the inhibition state or idle hint changes, <function>PropertyChanged</function>
       signals are sent out to which clients can subscribe.</para>
 
+      <para>The <function>SecureAttentionKey()</function> signal is sent when the user presses Ctrl+Alt+Shift+Esc to
+      request the login manager to display the greeter, for instance in the case of a deadlocked compositor.
+      </para>
+
       <para>The <function>SessionNew</function>, <function>SessionRemoved</function>,
       <function>UserNew</function>, <function>UserRemoved</function>, <function>SeatNew</function>, and
       <function>SeatRemoved</function> signals are sent each time a session is created or removed, a user
diff --git a/src/basic/macro.h b/src/basic/macro.h
index 2671c6ceaa..f20cf1dc2c 100644
--- a/src/basic/macro.h
+++ b/src/basic/macro.h
@@ -313,6 +313,18 @@ static inline int __coverity_check_and_return__(int condition) {
 /* Pointers range from NULL to POINTER_MAX */
 #define POINTER_MAX ((void*) UINTPTR_MAX)
 
+#define _FOREACH_ARRAY(i, array, num, m, end)                           \
+        for (typeof(array[0]) *i = (array), *end = ({                   \
+                                typeof(num) m = (num);                  \
+                                (i && m > 0) ? i + m : NULL;            \
+                        }); end && i < end; i++)
+
+#define FOREACH_ARRAY(i, array, num)                                    \
+        _FOREACH_ARRAY(i, array, num, UNIQ_T(m, UNIQ), UNIQ_T(end, UNIQ))
+
+#define FOREACH_ELEMENT(i, array)                                 \
+        FOREACH_ARRAY(i, array, ELEMENTSOF(array))
+
 /* Iterates through a specified list of pointers. Accepts NULL pointers, but uses POINTER_MAX as internal marker for EOL. */
 #define FOREACH_POINTER(p, x, ...)                                                       \
         for (typeof(p) *_l = (typeof(p)[]) { ({ p = x; }), ##__VA_ARGS__, POINTER_MAX }; \
diff --git a/src/login/logind-action.c b/src/login/logind-action.c
index c6a36a1556..255d8a8fda 100644
--- a/src/login/logind-action.c
+++ b/src/login/logind-action.c
@@ -11,6 +11,7 @@
 #include "format-util.h"
 #include "logind-action.h"
 #include "logind-dbus.h"
+#include "logind-seat-dbus.h"
 #include "logind-session-dbus.h"
 #include "process-util.h"
 #include "special.h"
@@ -121,12 +122,55 @@ const HandleActionData* handle_action_lookup(HandleAction action) {
         return &handle_action_data_table[action];
 }
 
+static int manager_handle_action_secure_attention_key(
+                Manager *m,
+                bool is_edge,
+                const char *seat) {
+
+        int r;
+        Seat *o;
+        _cleanup_free_ char *p = NULL;
+
+        assert(m);
+
+        if (!is_edge)
+                return 0;
+
+        if (!seat)
+                return 0;
+
+        o = hashmap_get(m->seats, seat);
+        if (!o)
+                return 0;
+
+        p = seat_bus_path(o);
+        if (!p)
+                return log_oom();
+
+        log_struct(LOG_INFO,
+                   LOG_MESSAGE("Secure Attention Key sequence pressed on seat %s", seat),
+                   "MESSAGE_ID=" SD_MESSAGE_SECURE_ATTENTION_KEY_PRESS_STR,
+                   "SEAT_ID=%s", seat);
+
+        r = sd_bus_emit_signal(
+                        m->bus,
+                        "/org/freedesktop/login1",
+                        "org.freedesktop.login1.Manager",
+                        "SecureAttentionKey",
+                        "so", seat, p);
+        if (r < 0)
+                log_warning_errno(r, "Failed to emit SecureAttentionKey signal, ignoring: %m");
+
+        return 0;
+}
+
 int manager_handle_action(
                 Manager *m,
                 InhibitWhat inhibit_key,
                 HandleAction handle,
                 bool ignore_inhibited,
-                bool is_edge) {
+                bool is_edge,
+                const char *action_seat) {
 
         static const char * const message_table[_HANDLE_ACTION_MAX] = {
                 [HANDLE_POWEROFF]               = "Powering off...",
@@ -177,7 +221,7 @@ int manager_handle_action(
                 }
         }
 
-        /* Locking is handled differently from the rest. */
+        /* Locking and greeter activation is handled differently from the rest. */
         if (handle == HANDLE_LOCK) {
                 if (!is_edge)
                         return 0;
@@ -187,6 +231,10 @@ int manager_handle_action(
                 return 1;
         }
 
+        if (handle == HANDLE_SECURE_ATTENTION_KEY)
+                return manager_handle_action_secure_attention_key(m, is_edge, action_seat);
+
+
         if (handle == HANDLE_SUSPEND)
                 supported = can_sleep(SLEEP_SUSPEND) > 0;
         else if (handle == HANDLE_HIBERNATE)
@@ -263,6 +311,7 @@ static const char* const handle_action_verb_table[_HANDLE_ACTION_MAX] = {
         [HANDLE_SUSPEND_THEN_HIBERNATE] = "suspend and later hibernate",
         [HANDLE_FACTORY_RESET]          = "perform a factory reset",
         [HANDLE_LOCK]                   = "be locked",
+        [HANDLE_SECURE_ATTENTION_KEY]   = "handle the secure attention key",
 };
 
 DEFINE_STRING_TABLE_LOOKUP_TO_STRING(handle_action_verb, HandleAction);
@@ -279,6 +328,7 @@ static const char* const handle_action_table[_HANDLE_ACTION_MAX] = {
         [HANDLE_SUSPEND_THEN_HIBERNATE] = "suspend-then-hibernate",
         [HANDLE_FACTORY_RESET]          = "factory-reset",
         [HANDLE_LOCK]                   = "lock",
+        [HANDLE_SECURE_ATTENTION_KEY]   = "secure-attention-key",
 };
 
 DEFINE_STRING_TABLE_LOOKUP(handle_action, HandleAction);
diff --git a/src/login/logind-action.h b/src/login/logind-action.h
index 9a01af1690..c2eed83247 100644
--- a/src/login/logind-action.h
+++ b/src/login/logind-action.h
@@ -13,6 +13,7 @@ typedef enum HandleAction {
         HANDLE_HIBERNATE,
         HANDLE_HYBRID_SLEEP,
         HANDLE_SUSPEND_THEN_HIBERNATE,
+        HANDLE_SECURE_ATTENTION_KEY,
         HANDLE_LOCK,
         HANDLE_FACTORY_RESET,
         _HANDLE_ACTION_MAX,
@@ -47,7 +48,8 @@ int manager_handle_action(
                 InhibitWhat inhibit_key,
                 HandleAction handle,
                 bool ignore_inhibited,
-                bool is_edge);
+                bool is_edge,
+                const char *action_seat);
 
 const char* handle_action_verb_to_string(HandleAction h) _const_;
 
diff --git a/src/login/logind-button.c b/src/login/logind-button.c
index 0314ae1774..76f9d28f45 100644
--- a/src/login/logind-button.c
+++ b/src/login/logind-button.c
@@ -15,7 +15,36 @@
 #include "string-util.h"
 #include "util.h"
 
-#define CONST_MAX5(a, b, c, d, e) CONST_MAX(CONST_MAX(a, b), CONST_MAX(CONST_MAX(c, d), e))
+/* KEY_RESTART is the highest value key in keys_interested. */
+#define _KEY_MAX_INTERESTED KEY_RESTART
+
+/* Adding more values here may require _KEY_MAX_INTERESTED to be updated, this array must be sorted by key value. */
+static const int keys_interested[] = {
+        KEY_ESC,
+        KEY_LEFTCTRL,
+        KEY_LEFTSHIFT,
+        KEY_RIGHTSHIFT,
+        KEY_LEFTALT,
+        KEY_RIGHTCTRL,
+        KEY_RIGHTALT,
+        KEY_POWER,
+        KEY_SLEEP,
+        KEY_SUSPEND,
+        KEY_POWER2,
+        KEY_RESTART,
+};
+
+static const struct {
+        int keycode;
+        ButtonModifierMask modifier_mask;
+} keycode_modifier_table[] = {
+        { KEY_LEFTSHIFT,  BUTTON_MODIFIER_LEFT_SHIFT  },
+        { KEY_RIGHTSHIFT, BUTTON_MODIFIER_RIGHT_SHIFT },
+        { KEY_LEFTCTRL,   BUTTON_MODIFIER_LEFT_CTRL   },
+        { KEY_RIGHTCTRL,  BUTTON_MODIFIER_RIGHT_CTRL  },
+        { KEY_LEFTALT,    BUTTON_MODIFIER_LEFT_ALT    },
+        { KEY_RIGHTALT,   BUTTON_MODIFIER_RIGHT_ALT   },
+};
 
 #define ULONG_BITS (sizeof(unsigned long)*8)
 
@@ -48,6 +77,8 @@ Button* button_new(Manager *m, const char *name) {
                 return mfree(b);
         }
 
+        b->button_modifier_mask = BUTTON_MODIFIER_NONE;
+
         b->manager = m;
         b->fd = -1;
 
@@ -75,7 +106,18 @@ int button_set_seat(Button *b, const char *sn) {
         return free_and_strdup(&b->seat, sn);
 }
 
-static void button_lid_switch_handle_action(Manager *manager, bool is_edge) {
+static ButtonModifierMask button_get_keycode_modifier_mask(int keycode) {
+
+        assert(keycode > 0);
+
+        FOREACH_ELEMENT(i, keycode_modifier_table)
+                if (i->keycode == keycode)
+                        return i->modifier_mask;
+
+        return BUTTON_MODIFIER_NONE;
+}
+
+static void button_lid_switch_handle_action(Manager *manager, bool is_edge, const char* seat) {
         HandleAction handle_action;
 
         assert(manager);
@@ -89,7 +131,7 @@ static void button_lid_switch_handle_action(Manager *manager, bool is_edge) {
         else
                 handle_action = manager->handle_lid_switch;
 
-        manager_handle_action(manager, INHIBIT_HANDLE_LID_SWITCH, handle_action, manager->lid_switch_ignore_inhibited, is_edge);
+        manager_handle_action(manager, INHIBIT_HANDLE_LID_SWITCH, handle_action, manager->lid_switch_ignore_inhibited, is_edge, seat);
 }
 
 static int button_recheck(sd_event_source *e, void *userdata) {
@@ -97,7 +139,7 @@ static int button_recheck(sd_event_source *e, void *userdata) {
 
         assert(b->lid_closed);
 
-        button_lid_switch_handle_action(b->manager, false);
+        button_lid_switch_handle_action(b->manager, /* is_edge= */ false, b->seat);
         return 1;
 }
 
@@ -118,7 +160,8 @@ static int button_install_check_event_source(Button *b) {
 }
 
 static int long_press_of_power_key_handler(sd_event_source *e, uint64_t usec, void *userdata) {
-        Manager *m = ASSERT_PTR(userdata);
+        Button *b = ASSERT_PTR(userdata);
+        Manager *m = ASSERT_PTR(b->manager);
 
         assert(e);
 
@@ -128,12 +171,13 @@ static int long_press_of_power_key_handler(sd_event_source *e, uint64_t usec, vo
                    LOG_MESSAGE("Power key pressed long."),
                    "MESSAGE_ID=" SD_MESSAGE_POWER_KEY_LONG_PRESS_STR);
 
-        manager_handle_action(m, INHIBIT_HANDLE_POWER_KEY, m->handle_power_key_long_press, m->power_key_ignore_inhibited, true);
+        manager_handle_action(m, INHIBIT_HANDLE_POWER_KEY, m->handle_power_key_long_press, m->power_key_ignore_inhibited, /* is_edge= */ true, b->seat);
         return 0;
 }
 
 static int long_press_of_reboot_key_handler(sd_event_source *e, uint64_t usec, void *userdata) {
-        Manager *m = ASSERT_PTR(userdata);
+        Button *b = ASSERT_PTR(userdata);
+        Manager *m = ASSERT_PTR(b->manager);
 
         assert(e);
 
@@ -143,12 +187,13 @@ static int long_press_of_reboot_key_handler(sd_event_source *e, uint64_t usec, v
                    LOG_MESSAGE("Reboot key pressed long."),
                    "MESSAGE_ID=" SD_MESSAGE_REBOOT_KEY_LONG_PRESS_STR);
 
-        manager_handle_action(m, INHIBIT_HANDLE_REBOOT_KEY, m->handle_reboot_key_long_press, m->reboot_key_ignore_inhibited, true);
+        manager_handle_action(m, INHIBIT_HANDLE_REBOOT_KEY, m->handle_reboot_key_long_press, m->reboot_key_ignore_inhibited, /* is_edge= */ true, b->seat);
         return 0;
 }
 
 static int long_press_of_suspend_key_handler(sd_event_source *e, uint64_t usec, void *userdata) {
-        Manager *m = ASSERT_PTR(userdata);
+        Button *b = ASSERT_PTR(userdata);
+        Manager *m = ASSERT_PTR(b->manager);
 
         assert(e);
 
@@ -158,12 +203,13 @@ static int long_press_of_suspend_key_handler(sd_event_source *e, uint64_t usec,
                    LOG_MESSAGE("Suspend key pressed long."),
                    "MESSAGE_ID=" SD_MESSAGE_SUSPEND_KEY_LONG_PRESS_STR);
 
-        manager_handle_action(m, INHIBIT_HANDLE_SUSPEND_KEY, m->handle_suspend_key_long_press, m->suspend_key_ignore_inhibited, true);
+        manager_handle_action(m, INHIBIT_HANDLE_SUSPEND_KEY, m->handle_suspend_key_long_press, m->suspend_key_ignore_inhibited, /* is_edge= */ true, b->seat);
         return 0;
 }
 
 static int long_press_of_hibernate_key_handler(sd_event_source *e, uint64_t usec, void *userdata) {
-        Manager *m = ASSERT_PTR(userdata);
+        Button *b = ASSERT_PTR(userdata);
+        Manager *m = ASSERT_PTR(b->manager);
 
         assert(e);
 
@@ -173,15 +219,17 @@ static int long_press_of_hibernate_key_handler(sd_event_source *e, uint64_t usec
                    LOG_MESSAGE("Hibernate key pressed long."),
                    "MESSAGE_ID=" SD_MESSAGE_HIBERNATE_KEY_LONG_PRESS_STR);
 
-        manager_handle_action(m, INHIBIT_HANDLE_HIBERNATE_KEY, m->handle_hibernate_key_long_press, m->hibernate_key_ignore_inhibited, true);
+        manager_handle_action(m, INHIBIT_HANDLE_HIBERNATE_KEY, m->handle_hibernate_key_long_press, m->hibernate_key_ignore_inhibited, /* is_edge= */ true, b->seat);
         return 0;
 }
 
-static void start_long_press(Manager *m, sd_event_source **e, sd_event_time_handler_t callback) {
+static void start_long_press(Button *b, sd_event_source **e, sd_event_time_handler_t callback) {
+        Manager *m;
         int r;
 
-        assert(m);
+        assert(b);
         assert(e);
+        m = ASSERT_PTR(b->manager);
 
         if (*e)
                 return;
@@ -191,7 +239,7 @@ static void start_long_press(Manager *m, sd_event_source **e, sd_event_time_hand
                         e,
                         CLOCK_MONOTONIC,
                         LONG_PRESS_DURATION, 0,
-                        callback, m);
+                        callback, b);
         if (r < 0)
                 log_warning_errno(r, "Failed to add long press timer event, ignoring: %m");
 }
@@ -218,12 +266,12 @@ static int button_dispatch(sd_event_source *s, int fd, uint32_t revents, void *u
                 case KEY_POWER2:
                         if (b->manager->handle_power_key_long_press != HANDLE_IGNORE && b->manager->handle_power_key_long_press != b->manager->handle_power_key) {
                                 log_debug("Power key pressed. Further action depends on the key press duration.");
-                                start_long_press(b->manager, &b->manager->power_key_long_press_event_source, long_press_of_power_key_handler);
+                                start_long_press(b, &b->manager->power_key_long_press_event_source, long_press_of_power_key_handler);
                         } else {
                                 log_struct(LOG_INFO,
                                            LOG_MESSAGE("Power key pressed short."),
                                            "MESSAGE_ID=" SD_MESSAGE_POWER_KEY_STR);
-                                manager_handle_action(b->manager, INHIBIT_HANDLE_POWER_KEY, b->manager->handle_power_key, b->manager->power_key_ignore_inhibited, true);
+                                manager_handle_action(b->manager, INHIBIT_HANDLE_POWER_KEY, b->manager->handle_power_key, b->manager->power_key_ignore_inhibited, /* is_edge= */ true, b->seat);
                         }
                         break;
 
@@ -235,12 +283,12 @@ static int button_dispatch(sd_event_source *s, int fd, uint32_t revents, void *u
                 case KEY_RESTART:
                         if (b->manager->handle_reboot_key_long_press != HANDLE_IGNORE && b->manager->handle_reboot_key_long_press != b->manager->handle_reboot_key) {
                                 log_debug("Reboot key pressed. Further action depends on the key press duration.");
-                                start_long_press(b->manager, &b->manager->reboot_key_long_press_event_source, long_press_of_reboot_key_handler);
+                                start_long_press(b, &b->manager->reboot_key_long_press_event_source, long_press_of_reboot_key_handler);
                         } else {
                                 log_struct(LOG_INFO,
                                            LOG_MESSAGE("Reboot key pressed short."),
                                            "MESSAGE_ID=" SD_MESSAGE_REBOOT_KEY_STR);
-                                manager_handle_action(b->manager, INHIBIT_HANDLE_REBOOT_KEY, b->manager->handle_reboot_key, b->manager->reboot_key_ignore_inhibited, true);
+                                manager_handle_action(b->manager, INHIBIT_HANDLE_REBOOT_KEY, b->manager->handle_reboot_key, b->manager->reboot_key_ignore_inhibited, /* is_edge= */ true, b->seat);
                         }
                         break;
 
@@ -253,26 +301,42 @@ static int button_dispatch(sd_event_source *s, int fd, uint32_t revents, void *u
                 case KEY_SLEEP:
                         if (b->manager->handle_suspend_key_long_press != HANDLE_IGNORE && b->manager->handle_suspend_key_long_press != b->manager->handle_suspend_key) {
                                 log_debug("Suspend key pressed. Further action depends on the key press duration.");
-                                start_long_press(b->manager, &b->manager->suspend_key_long_press_event_source, long_press_of_suspend_key_handler);
+                                start_long_press(b, &b->manager->suspend_key_long_press_event_source, long_press_of_suspend_key_handler);
                         } else {
                                 log_struct(LOG_INFO,
                                            LOG_MESSAGE("Suspend key pressed short."),
                                            "MESSAGE_ID=" SD_MESSAGE_SUSPEND_KEY_STR);
-                                manager_handle_action(b->manager, INHIBIT_HANDLE_SUSPEND_KEY, b->manager->handle_suspend_key, b->manager->suspend_key_ignore_inhibited, true);
+                                manager_handle_action(b->manager, INHIBIT_HANDLE_SUSPEND_KEY, b->manager->handle_suspend_key, b->manager->suspend_key_ignore_inhibited, /* is_edge= */ true, b->seat);
                         }
                         break;
 
                 case KEY_SUSPEND:
                         if (b->manager->handle_hibernate_key_long_press != HANDLE_IGNORE && b->manager->handle_hibernate_key_long_press != b->manager->handle_hibernate_key) {
                                 log_debug("Hibernate key pressed. Further action depends on the key press duration.");
-                                start_long_press(b->manager, &b->manager->hibernate_key_long_press_event_source, long_press_of_hibernate_key_handler);
+                                start_long_press(b, &b->manager->hibernate_key_long_press_event_source, long_press_of_hibernate_key_handler);
                         } else {
                                 log_struct(LOG_INFO,
                                            LOG_MESSAGE("Hibernate key pressed short."),
                                            "MESSAGE_ID=" SD_MESSAGE_HIBERNATE_KEY_STR);
-                                manager_handle_action(b->manager, INHIBIT_HANDLE_HIBERNATE_KEY, b->manager->handle_hibernate_key, b->manager->hibernate_key_ignore_inhibited, true);
+                                manager_handle_action(b->manager, INHIBIT_HANDLE_HIBERNATE_KEY, b->manager->handle_hibernate_key, b->manager->hibernate_key_ignore_inhibited, /* is_edge= */ true, b->seat);
                         }
                         break;
+
+                case KEY_ESC:
+                        if (b->manager->handle_secure_attention_key == HANDLE_IGNORE)
+                                break;
+                        if (!BUTTON_MODIFIER_HAS_SHIFT(b->button_modifier_mask) ||
+                            !BUTTON_MODIFIER_HAS_CTRL(b->button_modifier_mask) ||
+                            !BUTTON_MODIFIER_HAS_ALT(b->button_modifier_mask))
+                                break;
+
+                        log_debug("Secure Attention Key sequence pressed.");
+                        manager_handle_action(b->manager, /* inhibit_key= */ 0, b->manager->handle_secure_attention_key, /* ignore_inhibited= */ true, /* is_edge= */ true, b->seat);
+                        break;
+
+                default:
+                        b->button_modifier_mask |= button_get_keycode_modifier_mask(ev.code);
+                        break;
                 }
 
         } else if (ev.type == EV_KEY && ev.value == 0) {
@@ -292,7 +356,7 @@ static int button_dispatch(sd_event_source *s, int fd, uint32_t revents, void *u
 
                                 b->manager->power_key_long_press_event_source = sd_event_source_unref(b->manager->power_key_long_press_event_source);
 
-                                manager_handle_action(b->manager, INHIBIT_HANDLE_POWER_KEY, b->manager->handle_power_key, b->manager->power_key_ignore_inhibited, true);
+                                manager_handle_action(b->manager, INHIBIT_HANDLE_POWER_KEY, b->manager->handle_power_key, b->manager->power_key_ignore_inhibited, /* is_edge= */ true, b->seat);
                         }
                         break;
 
@@ -304,7 +368,7 @@ static int button_dispatch(sd_event_source *s, int fd, uint32_t revents, void *u
 
                                 b->manager->reboot_key_long_press_event_source = sd_event_source_unref(b->manager->reboot_key_long_press_event_source);
 
-                                manager_handle_action(b->manager, INHIBIT_HANDLE_REBOOT_KEY, b->manager->handle_reboot_key, b->manager->reboot_key_ignore_inhibited, true);
+                                manager_handle_action(b->manager, INHIBIT_HANDLE_REBOOT_KEY, b->manager->handle_reboot_key, b->manager->reboot_key_ignore_inhibited, /* is_edge= */ true, b->seat);
                         }
                         break;
 
@@ -316,7 +380,7 @@ static int button_dispatch(sd_event_source *s, int fd, uint32_t revents, void *u
 
                                 b->manager->suspend_key_long_press_event_source = sd_event_source_unref(b->manager->suspend_key_long_press_event_source);
 
-                                manager_handle_action(b->manager, INHIBIT_HANDLE_SUSPEND_KEY, b->manager->handle_suspend_key, b->manager->suspend_key_ignore_inhibited, true);
+                                manager_handle_action(b->manager, INHIBIT_HANDLE_SUSPEND_KEY, b->manager->handle_suspend_key, b->manager->suspend_key_ignore_inhibited, /* is_edge= */ true, b->seat);
                         }
                         break;
                 case KEY_SUSPEND:
@@ -327,9 +391,16 @@ static int button_dispatch(sd_event_source *s, int fd, uint32_t revents, void *u
 
                                 b->manager->hibernate_key_long_press_event_source = sd_event_source_unref(b->manager->hibernate_key_long_press_event_source);
 
-                                manager_handle_action(b->manager, INHIBIT_HANDLE_HIBERNATE_KEY, b->manager->handle_hibernate_key, b->manager->hibernate_key_ignore_inhibited, true);
+                                manager_handle_action(b->manager, INHIBIT_HANDLE_HIBERNATE_KEY, b->manager->handle_hibernate_key, b->manager->hibernate_key_ignore_inhibited, /* is_edge= */ true, b->seat);
                         }
                         break;
+
+                case KEY_ESC:
+                        break;
+
+                default:
+                        b->button_modifier_mask &= ~button_get_keycode_modifier_mask(ev.code);
+                        break;
                 }
 
         } else if (ev.type == EV_SW && ev.value > 0) {
@@ -340,7 +411,7 @@ static int button_dispatch(sd_event_source *s, int fd, uint32_t revents, void *u
                                    "MESSAGE_ID=" SD_MESSAGE_LID_CLOSED_STR);
 
                         b->lid_closed = true;
-                        button_lid_switch_handle_action(b->manager, true);
+                        button_lid_switch_handle_action(b->manager, /* is_edge= */ true, b->seat);
                         button_install_check_event_source(b);
 
                 } else if (ev.code == SW_DOCK) {
@@ -382,17 +453,25 @@ static int button_suitable(int fd) {
                 return -errno;
 
         if (bitset_get(types, EV_KEY)) {
-                unsigned long keys[CONST_MAX5(KEY_POWER, KEY_POWER2, KEY_SLEEP, KEY_SUSPEND, KEY_RESTART)/ULONG_BITS+1];
+                unsigned long keys[_KEY_MAX_INTERESTED/ULONG_BITS+1];
 
                 if (ioctl(fd, EVIOCGBIT(EV_KEY, sizeof keys), keys) < 0)
                         return -errno;
 
+                /* If the device has power related keys, then accept the device. */
                 if (bitset_get(keys, KEY_POWER) ||
                     bitset_get(keys, KEY_POWER2) ||
                     bitset_get(keys, KEY_SLEEP) ||
                     bitset_get(keys, KEY_SUSPEND) ||
                     bitset_get(keys, KEY_RESTART))
                         return true;
+
+                /* If the device has keys for the Secure Attention Key sequence, then accept the device. */
+                if ((bitset_get(keys, KEY_LEFTSHIFT) || bitset_get(keys, KEY_RIGHTSHIFT)) &&
+                    (bitset_get(keys, KEY_LEFTCTRL) || bitset_get(keys, KEY_RIGHTCTRL)) &&
+                    (bitset_get(keys, KEY_LEFTALT) || bitset_get(keys, KEY_RIGHTALT)) &&
+                    bitset_get(keys, KEY_ESC))
+                        return true;
         }
 
         if (bitset_get(types, EV_SW)) {
@@ -409,10 +488,27 @@ static int button_suitable(int fd) {
         return false;
 }
 
+static int button_initialize_modifier_mask(Button *b) {
+        unsigned long keys[KEY_MAX/ULONG_BITS+1];
+
+        assert(b);
+
+        if (ioctl(b->fd, EVIOCGKEY(sizeof(keys)), keys) < 0)
+                return log_error_errno(errno, "Failed to initialize modifier mask on /dev/input/%s: %m", b->name);
+
+        b->button_modifier_mask = BUTTON_MODIFIER_NONE;
+
+        FOREACH_ELEMENT(i, keycode_modifier_table)
+                if (bitset_get(keys, i->keycode))
+                        b->button_modifier_mask |= i->modifier_mask;
+
+        return 0;
+}
+
 static int button_set_mask(const char *name, int fd) {
         unsigned long
                 types[CONST_MAX(EV_KEY, EV_SW)/ULONG_BITS+1] = {},
-                keys[CONST_MAX5(KEY_POWER, KEY_POWER2, KEY_SLEEP, KEY_SUSPEND, KEY_RESTART)/ULONG_BITS+1] = {},
+                keys[_KEY_MAX_INTERESTED/ULONG_BITS+1] = {},
                 switches[CONST_MAX(SW_LID, SW_DOCK)/ULONG_BITS+1] = {};
         struct input_mask mask;
 
@@ -433,11 +529,11 @@ static int button_set_mask(const char *name, int fd) {
                 return log_full_errno(IN_SET(errno, ENOTTY, EOPNOTSUPP, EINVAL) ? LOG_DEBUG : LOG_WARNING,
                                       errno, "Failed to set EV_SYN event mask on /dev/input/%s: %m", name);
 
-        bitset_put(keys, KEY_POWER);
-        bitset_put(keys, KEY_POWER2);
-        bitset_put(keys, KEY_SLEEP);
-        bitset_put(keys, KEY_SUSPEND);
-        bitset_put(keys, KEY_RESTART);
+        FOREACH_ELEMENT(key, keys_interested) {
+                assert(*key <= _KEY_MAX_INTERESTED);
+
+                bitset_put(keys, *key);
+        }
 
         mask = (struct input_mask) {
                 .type = EV_KEY,
@@ -498,6 +594,11 @@ int button_open(Button *b) {
 
         b->fd = TAKE_FD(fd);
         log_info("Watching system buttons on %s (%s)", p, name);
+
+        r = button_initialize_modifier_mask(b);
+        if (r < 0)
+                return r;
+
         return 0;
 }
 
diff --git a/src/login/logind-button.h b/src/login/logind-button.h
index 041d66521c..564fa71dec 100644
--- a/src/login/logind-button.h
+++ b/src/login/logind-button.h
@@ -5,6 +5,20 @@ typedef struct Button Button;
 
 #include "logind.h"
 
+typedef enum ButtonModifierMask {
+        BUTTON_MODIFIER_NONE        = 0,
+        BUTTON_MODIFIER_LEFT_SHIFT  = 1 << 0,
+        BUTTON_MODIFIER_RIGHT_SHIFT = 1 << 1,
+        BUTTON_MODIFIER_LEFT_CTRL   = 1 << 2,
+        BUTTON_MODIFIER_RIGHT_CTRL  = 1 << 3,
+        BUTTON_MODIFIER_LEFT_ALT    = 1 << 4,
+        BUTTON_MODIFIER_RIGHT_ALT   = 1 << 5,
+} ButtonModifierMask;
+
+#define BUTTON_MODIFIER_HAS_SHIFT(modifier) (((modifier) & (BUTTON_MODIFIER_LEFT_SHIFT|BUTTON_MODIFIER_RIGHT_SHIFT)) != 0)
+#define BUTTON_MODIFIER_HAS_CTRL(modifier) (((modifier) & (BUTTON_MODIFIER_LEFT_CTRL|BUTTON_MODIFIER_RIGHT_CTRL)) != 0)
+#define BUTTON_MODIFIER_HAS_ALT(modifier) (((modifier) & (BUTTON_MODIFIER_LEFT_ALT|BUTTON_MODIFIER_RIGHT_ALT)) != 0)
+
 struct Button {
         Manager *manager;
 
@@ -15,6 +29,8 @@ struct Button {
         char *seat;
         int fd;
 
+        ButtonModifierMask button_modifier_mask;
+
         bool lid_closed;
         bool docked;
 };
diff --git a/src/login/logind-core.c b/src/login/logind-core.c
index 02adc81909..f924fd53fa 100644
--- a/src/login/logind-core.c
+++ b/src/login/logind-core.c
@@ -46,6 +46,7 @@ void manager_reset_config(Manager *m) {
         m->handle_suspend_key_long_press = HANDLE_HIBERNATE;
         m->handle_hibernate_key = HANDLE_HIBERNATE;
         m->handle_hibernate_key_long_press = HANDLE_IGNORE;
+        m->handle_secure_attention_key = HANDLE_SECURE_ATTENTION_KEY;
 
         m->handle_lid_switch = HANDLE_SUSPEND;
         m->handle_lid_switch_ep = _HANDLE_ACTION_INVALID;
@@ -697,6 +698,8 @@ bool manager_all_buttons_ignored(Manager *m) {
                 return false;
         if (m->handle_lid_switch_docked != HANDLE_IGNORE)
                 return false;
+        if (m->handle_secure_attention_key != HANDLE_IGNORE)
+                return false;
 
         return true;
 }
diff --git a/src/login/logind-dbus.c b/src/login/logind-dbus.c
index 8972a53348..633b3d628a 100644
--- a/src/login/logind-dbus.c
+++ b/src/login/logind-dbus.c
@@ -3341,6 +3341,7 @@ static const sd_bus_vtable manager_vtable[] = {
         SD_BUS_PROPERTY("HandleLidSwitch", "s", property_get_handle_action, offsetof(Manager, handle_lid_switch), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("HandleLidSwitchExternalPower", "s", property_get_handle_action, offsetof(Manager, handle_lid_switch_ep), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("HandleLidSwitchDocked", "s", property_get_handle_action, offsetof(Manager, handle_lid_switch_docked), SD_BUS_VTABLE_PROPERTY_CONST),
+        SD_BUS_PROPERTY("HandleSecureAttentionKey", "s", property_get_handle_action, offsetof(Manager, handle_secure_attention_key), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("HoldoffTimeoutUSec", "t", NULL, offsetof(Manager, holdoff_timeout_usec), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("IdleAction", "s", property_get_handle_action, offsetof(Manager, idle_action), SD_BUS_VTABLE_PROPERTY_CONST),
         SD_BUS_PROPERTY("IdleActionUSec", "t", NULL, offsetof(Manager, idle_action_usec), SD_BUS_VTABLE_PROPERTY_CONST),
@@ -3671,6 +3672,9 @@ static const sd_bus_vtable manager_vtable[] = {
                                 method_set_wall_message,
                                 SD_BUS_VTABLE_UNPRIVILEGED),
 
+        SD_BUS_SIGNAL_WITH_ARGS("SecureAttentionKey",
+                                SD_BUS_ARGS("s", seat_id, "o", object_path),
+                                0),
         SD_BUS_SIGNAL_WITH_ARGS("SessionNew",
                                 SD_BUS_ARGS("s", session_id, "o", object_path),
                                 0),
diff --git a/src/login/logind-gperf.gperf b/src/login/logind-gperf.gperf
index c95a3b2dc3..ba6d5f3dc6 100644
--- a/src/login/logind-gperf.gperf
+++ b/src/login/logind-gperf.gperf
@@ -36,6 +36,7 @@ Login.HandleHibernateKeyLongPress,  config_parse_handle_action,         0, offse
 Login.HandleLidSwitch,              config_parse_handle_action,         0, offsetof(Manager, handle_lid_switch)
 Login.HandleLidSwitchExternalPower, config_parse_handle_action,         0, offsetof(Manager, handle_lid_switch_ep)
 Login.HandleLidSwitchDocked,        config_parse_handle_action,         0, offsetof(Manager, handle_lid_switch_docked)
+Login.HandleSecureAttentionKey,     config_parse_handle_action,         0, offsetof(Manager, handle_secure_attention_key)
 Login.PowerKeyIgnoreInhibited,      config_parse_bool,                  0, offsetof(Manager, power_key_ignore_inhibited)
 Login.SuspendKeyIgnoreInhibited,    config_parse_bool,                  0, offsetof(Manager, suspend_key_ignore_inhibited)
 Login.HibernateKeyIgnoreInhibited,  config_parse_bool,                  0, offsetof(Manager, hibernate_key_ignore_inhibited)
diff --git a/src/login/logind.c b/src/login/logind.c
index 788ddfccc5..f59a7633c8 100644
--- a/src/login/logind.c
+++ b/src/login/logind.c
@@ -982,7 +982,7 @@ static int manager_dispatch_idle_action(sd_event_source *s, uint64_t t, void *us
                         else
                                 log_info("System idle. Will %s now.", handle_action_verb_to_string(m->idle_action));
 
-                        manager_handle_action(m, 0, m->idle_action, false, is_edge);
+                        manager_handle_action(m, /* inhibit_key= */ 0, m->idle_action, /* ignore_inhibited= */ false, is_edge, /* action_seat= */ NULL);
                         m->idle_action_not_before_usec = n;
                 }
 
diff --git a/src/login/logind.conf.in b/src/login/logind.conf.in
index 0b10df6839..ae69d4c2d6 100644
--- a/src/login/logind.conf.in
+++ b/src/login/logind.conf.in
@@ -33,6 +33,7 @@
 #HandleLidSwitch=suspend
 #HandleLidSwitchExternalPower=suspend
 #HandleLidSwitchDocked=ignore
+#HandleSecureAttentionKey=secure-attention-key
 #PowerKeyIgnoreInhibited=no
 #SuspendKeyIgnoreInhibited=no
 #HibernateKeyIgnoreInhibited=no
diff --git a/src/login/logind.h b/src/login/logind.h
index d0b1f9671e..9478773249 100644
--- a/src/login/logind.h
+++ b/src/login/logind.h
@@ -106,6 +106,7 @@ struct Manager {
         HandleAction handle_suspend_key_long_press;
         HandleAction handle_hibernate_key;
         HandleAction handle_hibernate_key_long_press;
+        HandleAction handle_secure_attention_key;
 
         HandleAction handle_lid_switch;
         HandleAction handle_lid_switch_ep;
diff --git a/src/systemd/sd-messages.h b/src/systemd/sd-messages.h
index 51241c9426..648041cd4b 100644
--- a/src/systemd/sd-messages.h
+++ b/src/systemd/sd-messages.h
@@ -143,6 +143,8 @@ _SD_BEGIN_DECLARATIONS;
 #define SD_MESSAGE_POWER_KEY_STR                      SD_ID128_MAKE_STR(b7,2e,a4,a2,88,15,45,a0,b5,0e,20,0e,55,b9,b0,71)
 #define SD_MESSAGE_POWER_KEY_LONG_PRESS               SD_ID128_MAKE(3e,01,17,10,1e,b2,43,c1,b9,a5,0d,b3,49,4a,b1,0b)
 #define SD_MESSAGE_POWER_KEY_LONG_PRESS_STR           SD_ID128_MAKE_STR(3e,01,17,10,1e,b2,43,c1,b9,a5,0d,b3,49,4a,b1,0b)
+#define SD_MESSAGE_SECURE_ATTENTION_KEY_PRESS         SD_ID128_MAKE(b2,bc,ba,f5,ed,f9,48,e0,93,ce,50,bb,ea,0e,81,ec)
+#define SD_MESSAGE_SECURE_ATTENTION_KEY_PRESS_STR     SD_ID128_MAKE_STR(b2,bc,ba,f5,ed,f9,48,e0,93,ce,50,bb,ea,0e,81,ec)
 #define SD_MESSAGE_REBOOT_KEY                         SD_ID128_MAKE(9f,a9,d2,c0,12,13,4e,c3,85,45,1f,fe,31,6f,97,d0)
 #define SD_MESSAGE_REBOOT_KEY_STR                     SD_ID128_MAKE_STR(9f,a9,d2,c0,12,13,4e,c3,85,45,1f,fe,31,6f,97,d0)
 #define SD_MESSAGE_REBOOT_KEY_LONG_PRESS              SD_ID128_MAKE(f1,c5,9a,58,c9,d9,43,66,89,65,c3,37,ca,ec,59,75)
