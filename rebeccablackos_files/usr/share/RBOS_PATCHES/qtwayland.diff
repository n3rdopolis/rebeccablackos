From 1e32e71403a6a9cb117343464fbc34564598e831 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Martin=20Gr=C3=A4=C3=9Flin?= <mgraesslin@kde.org>
Date: Mon, 16 Feb 2015 15:50:11 +0100
Subject: [PATCH] Run eventDispatcher in QWaylandDisplay::forceRoundTrip

If the application uses QCoreApplication::setEventDispatcher before
the QGuiApplication is created the blocking roundtrip might block the
application indefinitely. This can happen if the application starts a
Wayland server in the same process before the QGuiApplication is
created. And the QtWayland plugin connects to this server. In this case
a roundtrip blocks as the Wayland server cannot process the events
the QWaylandDisplay is waiting for.

By running the event dispatcher manually and using the pending
variant for dispatching the Wayland event queue, the application can
be kept alive.

Change-Id: I9c36fccbae8921e1ae9a0a8b7f460520b1b65d5c
Reviewed-by: Giulio Camuffo <giulio.camuffo@jollamobile.com>
---
 src/client/qwaylanddisplay.cpp |   11 +++++++++--
 1 files changed, 9 insertions(+), 2 deletions(-)

diff --git a/src/client/qwaylanddisplay.cpp b/src/client/qwaylanddisplay.cpp
index 9dedabd..11904ae 100644
--- a/src/client/qwaylanddisplay.cpp
+++ b/src/client/qwaylanddisplay.cpp
@@ -338,8 +338,15 @@ void QWaylandDisplay::forceRoundTrip()
     wl_proxy_set_queue((struct wl_proxy *)callback, mEventQueue);
     wl_callback_add_listener(callback, &sync_listener, &done);
     flushRequests();
-    while (!done && ret >= 0)
-        ret = wl_display_dispatch_queue(mDisplay, mEventQueue);
+    if (QThread::currentThread()->eventDispatcher()) {
+        while (!done && ret >= 0) {
+            QThread::currentThread()->eventDispatcher()->processEvents(QEventLoop::WaitForMoreEvents);
+            ret = wl_display_dispatch_queue_pending(mDisplay, mEventQueue);
+        }
+    } else {
+        while (!done && ret >= 0)
+            ret = wl_display_dispatch_queue(mDisplay, mEventQueue);
+    }
 
     if (ret == -1 && !done)
         wl_callback_destroy(callback);
-- 
1.7.1

