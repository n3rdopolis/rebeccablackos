#! /usr/bin/perl
#    Copyright (c) 2012 - 2026 nerdopolis (or n3rdopolis) <bluescreen_avenger@verzion.net>
#
#    This file is part of RebeccaBlackOS.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

use strict;
use warnings;
use Env;
use Net::DBus;
use Net::DBus::Reactor;

#Global vars
my %SeatManager;

#Sessions logged in on PTYs use logind's TTY attribute
#Takes no arguments, returns an array of paths
sub GetSessionTTYs
{
  my @SessionTTYs=();

  #Enumerate through all logind sessions, collect all the TTY/PTYs that contain a running session
  my @Sessions=@{$SeatManager{Login1ManagerCallObject}->ListSessions()};
  foreach my $Session ( @Sessions )
  {
    my $SessionName=$Session->[0];
    my $SessionUID=$Session->[1];
    my $SessionUsername=$Session->[2];
    my $SessionSeat=$Session->[3];
    my $SessionPath=$Session->[4];

    my $SessionPropertiesObject=$SeatManager{Login1Service}->get_object($SessionPath, "org.freedesktop.DBus.Properties");
    my $SessionTTY=$SessionPropertiesObject->Get("org.freedesktop.login1.Session", "TTY");
    if ($SessionTTY ne "")
    {
      push(@SessionTTYs, $SessionTTY);
    }
  }

  return @SessionTTYs;
}

#Get the list of vtty-frontend@{THE_SEAT}@vtty*.service
#Takes the seat as the argument, returns an array, they should be numbers
sub GetSeatVttyBackends
{
  my $SeatName=$_[0];

  my @VttyBackends=();

  my @Units=@{$SeatManager{Systemd1ManagerCallObject}->ListUnits()};
  foreach my $Unit ( @Units )
  {
    my $UnitName=$Unit->[0];
    my $UnitDescription=$Unit->[1];
    my $UnitLoadState=$Unit->[2];
    my $UnitState=$Unit->[3];
    my $UnitSubState=$Unit->[4];
    my $UnitFollowedState=$Unit->[5];
    my $UnitObjectPath=$Unit->[6];
    my $UnitIsJobQueued=$Unit->[7];
    my $UnitJobType=$Unit->[8];
    my $UnitJobPath=$Unit->[9];

    if ($UnitName =~ /^vtty-frontend\@${SeatName}\@vtty/ && $UnitName =~ /\.service$/)
    {
      #Remove the vtty-frontend@vtty@   and the .service   leaving just the number
      $UnitName = $UnitName =~ s/^vtty-frontend\@${SeatName}\@vtty//r;
      $UnitName = $UnitName =~ s/\.service$//r;

      push(@VttyBackends, $UnitName);
    }
  }

  return @VttyBackends;
}

#Check from 1 - NAutoVTs for PTYs with no sessions in logind, return the first one to have no logged in session on the seat
#Unless it finds vtty backends running with a missing frontend
sub GetSeatFreeVttyInstance
{
  my $SeatName=$_[0];

  my $SkipSelectedSession=0;
  my $SelectedSession=-1;

  my @SessionTTYs=GetSessionTTYs();
  my @VttyBackends=GetSeatVttyBackends($SeatName);

  for (my $SessionIterator = 1; $SessionIterator <= $SeatManager{MaxSessionCount}; $SessionIterator++)
  {
    my $VttyInstanceName="${SeatName}\@vtty${SessionIterator}";
    my $VttyBackendUsed=0;

    if (GetUnitMainPID("vtty-backend\@${VttyInstanceName}.service") > 0)
    {
      #If the backend is running, but the frontend is not
      if (GetUnitMainPID("vtty-frontend\@${VttyInstanceName}.service") == 0)
      {
        #Skip starting the frontend if vtty-launch is inhibiting it
        if (-e "/run/vtty/${VttyInstanceName}/vttylaunchinhibit")
        {
          next;
        }

        eval{$SeatManager{Systemd1ManagerCallObject}->StartUnit("vtty-frontend\@${VttyInstanceName}.service", "replace")};
        $SkipSelectedSession=1;
      }

      #A session was already found. Skip finding free sessions, but still loop to start any failed frontends
      if ($SelectedSession != -1)
      {
        next;
      }

      #For the vtty instance, find any logind sessions matching the PTY
      foreach (@SessionTTYs)
      {
        my $SessionTTY=$_;
        my $PtsFile="";

        if (-e "/run/vtty/${VttyInstanceName}/loginpty")
        {
          $PtsFile=readlink("/run/vtty/${VttyInstanceName}/loginpty");
        }

        if ($PtsFile eq "/dev/$SessionTTY")
        {
          $VttyBackendUsed=1;
          last;
        }
      }
    }

    #If this instance is not used, select it, if one hasn't alrady been selected
    if ($VttyBackendUsed == 0 && $SelectedSession == -1)
    {
      $SelectedSession=$SessionIterator;
    }
  }

  #Return 0 if a running backend with a missing frontend was found and started
  #This skips starting a new backend/frontend
  if ($SkipSelectedSession == 0)
  {
    return $SelectedSession;
  } else {
    return 0;
  }
}

#When NAutoVTs is used up, don't start any more sessions, instead, switch through all sessions on the seat
#logind populates the seat's Sessions array in reverse order
sub SwitchToNextSession
{
  my $SeatName=$_[0];

  my $LogindSeatPath=$SeatManager{Login1ManagerCallObject}->GetSeat($SeatName);
  my $LogindSeatCallObject=$SeatManager{Login1Service}->get_object($LogindSeatPath, "org.freedesktop.login1.Seat");
  my $LogindSeatPropertiesObject=$SeatManager{Login1Service}->get_object($LogindSeatPath, "org.freedesktop.DBus.Properties");

  #Get the active session
  my $LogindSeatActiveSession=$LogindSeatPropertiesObject->Get("org.freedesktop.login1.Seat", "ActiveSession");
  my $LogindSeatActiveSessionName=$LogindSeatActiveSession->[0];
  my $LogindSeatActiveSessionPath=$LogindSeatActiveSession->[1];

  #Get all sessions
  my @LogindSeatSessions=@{$LogindSeatPropertiesObject->Get("org.freedesktop.login1.Seat", "Sessions")};
  my $LogindSeatSessionsCount=scalar @LogindSeatSessions;

  my $NextSessionIndex;

  #Get the next session in the $LogindSeatSessions array, backwards (as the first session is the last one)
  for (my $SessionIterator=$LogindSeatSessionsCount - 1; $SessionIterator >= 0; $SessionIterator--)
  {
    my $SessionData=$LogindSeatSessions[$SessionIterator];
    my $SessionName=$SessionData->[0];
    my $SessionPath=$SessionData->[1];

    if ($SessionName eq $LogindSeatActiveSessionName)
    {
      $NextSessionIndex=$SessionIterator - 1;
      if ($NextSessionIndex < 0)
      {
        $NextSessionIndex=$SessionIterator - 1;
      }
      last;
    }
  }

  eval{$LogindSeatCallObject->ActivateSession($LogindSeatSessions[$NextSessionIndex]->[0])};
}

#Get the MainPID attribute of a unit
#Takes a "something.service" as an argument, returns 0 if it is not running
sub GetUnitMainPID
{
  my $UnitName=$_[0];

  #If the unit doesn't resolve, it's not running
  my $UnitPath;
  if (! eval{$UnitPath=$SeatManager{Systemd1ManagerCallObject}->GetUnit($UnitName)})
  {
    return 0;
  }

  #Get the MainPID of the seat's vtty frontend service.
  my $UnitPropertiesObject=$SeatManager{Systemd1Service}->get_object($UnitPath, "org.freedesktop.DBus.Properties");
  my $UnitMainPID=$UnitPropertiesObject->Get("org.freedesktop.systemd1.Service", "MainPID");
  if ($UnitMainPID == 0)
  {
    return 0;
  }

  return $UnitMainPID;
}

sub StartOrSwitchToVttyFrontend
{
  my $SeatName=$_[0];
  my $SeatPath=$_[1];

  my $FreeVttyInstance=GetSeatFreeVttyInstance($SeatName);

  #If GetSeatFreeVttyInstance returns -1, it is out of instances.
  #If GetSeatFreeVttyInstance returns 0, skip as it started a frontend for a running backend, and logind activated it
  if ($FreeVttyInstance == -1)
  {
    SwitchToNextSession($SeatName);
    return;
  } elsif ($FreeVttyInstance == 0)
  {
    return;
  }

  my $VttyUnitMainPID=GetUnitMainPID("vtty-frontend\@${SeatName}\@vtty${FreeVttyInstance}.service");

  if ($VttyUnitMainPID == 0)
  {
    eval{$SeatManager{Systemd1ManagerCallObject}->StartUnit("vtty-frontend\@${SeatName}\@vtty${FreeVttyInstance}.service", "replace")};
    return;
  }

  #Look for the logind session with the Leader that matches the MainPID of the service.
  my @Sessions=@{$SeatManager{Login1ManagerCallObject}->ListSessions()};
  foreach my $Session ( @Sessions )
  {
    my $SessionName=$Session->[0];
    my $SessionUID=$Session->[1];
    my $SessionUsername=$Session->[2];
    my $SessionSeat=$Session->[3];
    my $SessionPath=$Session->[4];

    my $SessionPropertiesObject=$SeatManager{Login1Service}->get_object($SessionPath, "org.freedesktop.DBus.Properties");
    my $SessionLeaderPID=$SessionPropertiesObject->Get("org.freedesktop.login1.Session", "Leader");

    if ($SessionLeaderPID == $VttyUnitMainPID)
    {
      eval{$SeatManager{Login1ManagerCallObject}->ActivateSession($SessionName)};
      return;
    }
  }
}

sub HandleSecureAttentionKey
{
  my $SecureAttentionKeySeatName=$_[0];
  my $SecureAttentionKeySeatPath=$_[1];

  my $SecureAttentionKeySeatPropertiesObject=$SeatManager{Login1Service}->get_object($SecureAttentionKeySeatPath, "org.freedesktop.DBus.Properties");
  my $SecureAttentionKeySeatCanGraphical=$SecureAttentionKeySeatPropertiesObject->Get("org.freedesktop.login1.Seat", "CanGraphical");

  if ($SecureAttentionKeySeatName eq "seat-vtty" || ($SecureAttentionKeySeatCanGraphical == 0))
  {
    return;
  }

  StartOrSwitchToVttyFrontend($SecureAttentionKeySeatName, $SecureAttentionKeySeatPath);

  return;
}

sub HandleSessionRemoved
{
  my $SessionRemovedSessionName=$_[0];
  my $SessionRemovedSessionPath=$_[1];

  #When a session is removed, the impacted seat is not emitted in dbus, only the session, which is no longer queryable once gone
  #Enumerate through all seats to find one with no active sessions
  my @Seats=@{$SeatManager{Login1ManagerCallObject}->ListSeats()};
  foreach my $Seat ( @Seats )
  {
    my $SeatName=$Seat->[0];
    my $SeatPath=$Seat->[1];

    my $SeatPropertiesObject=$SeatManager{Login1Service}->get_object($SeatPath, "org.freedesktop.DBus.Properties");
    my $SeatCanGraphical=$SeatPropertiesObject->Get("org.freedesktop.login1.Seat", "CanGraphical");
    my $SeatActiveSession=$SeatPropertiesObject->Get("org.freedesktop.login1.Seat", "ActiveSession");

    my $SeatActiveSessionName=$SeatActiveSession->[0];
    my $SeatActiveSessionPath=$SeatActiveSession->[1];

    my $SeatHasInhibitedSession=0;

    #Don't start a vtty-frontend on the virtual seat-vtty seat, or on seats that don't have GPUs
    if (($SeatName eq "seat-vtty") || ($SeatCanGraphical == 0))
    {
      next;
    }

    for (my $InstanceIterator=1; $InstanceIterator <= $SeatManager{MaxSessionCount}; $InstanceIterator++)
    {
      if (-e "/run/vtty/${$SeatName}\@vtty${InstanceIterator}/vttylaunchinhibit")
      {
        $SeatHasInhibitedSession=1;
        last;
      }
    }

    #Skip switching back if vtty-launch is inhibiting a session on the seat
    if ($SeatHasInhibitedSession == 1)
    {
      next;
    }

    if ($SeatActiveSessionName eq "")
    {
      StartOrSwitchToVttyFrontend($SeatName, $SeatPath);
    }
  }

  return;
}

sub HandleSeatNew
{
  my $SeatNewSeatName=$_[0];
  my $SeatNewSeatPath=$_[1];

  my $SeatNewPropertiesObject=$SeatManager{Login1Service}->get_object($SeatNewSeatPath, "org.freedesktop.DBus.Properties");
  my $SeatNewCanGraphical=$SeatNewPropertiesObject->Get("org.freedesktop.login1.Seat", "CanGraphical");

  if ($SeatNewSeatName eq "seat-vtty" || ($SeatNewCanGraphical == 0))
  {
    return;
  }

  #Start the first vtty frontend for the new seat
  eval{$SeatManager{Systemd1ManagerCallObject}->StartUnit("vtty-frontend\@${SeatNewSeatName}\@vtty1.service", "replace")};

  return;
}

sub HandleSeatRemoved
{
  my $SeatRemovedSeatName=$_[0];
  my $SeatRemovedSeatPath=$_[1];

  #Only ignore on seat-vtty, can't query the CanGraphical property on a seat that no longer exists
  if ($SeatRemovedSeatName eq "seat-vtty")
  {
    return;
  }

  #Only stop the frontend, and NOT the backend when a seat is removed.
  #
  #The seat removal could be accidental, or caused by a loose USB GPU, stopping the backend
  #would result in terminated sessions otherwise
  for (my $InstanceIterator=1; $InstanceIterator <= $SeatManager{MaxSessionCount}; $InstanceIterator++)
  {
    eval{$SeatManager{Systemd1ManagerCallObject}->StopUnit("vtty-frontend\@${SeatRemovedSeatName}\@vtty${InstanceIterator}.service", "replace")};
  }

  return;
}


#These prevent a failed dbus call (like a seat going away mid call) from stopping the entire script
sub HandleSecureAttentionKeySafe
{
  eval{HandleSecureAttentionKey($_[0], $_[1])};
}

sub HandleSessionRemovedSafe
{
  eval{HandleSessionRemoved($_[0], $_[1])};
}

sub HandleSeatNewSafe
{
  eval{HandleSeatNew($_[0], $_[1])};
}

sub HandleSeatRemovedSafe
{
  eval{HandleSeatRemoved($_[0], $_[1])};
}



sub main
{
  #This script must be run as root.
  if ($> != 0)
  {
    print("Must be run as root\n");
    exit 1
  }

  my $SystemBus=Net::DBus->system();

  my $Login1Service=$SystemBus->get_service("org.freedesktop.login1");
  my $Login1ManagerCallObject=$Login1Service->get_object("/org/freedesktop/login1", "org.freedesktop.login1.Manager");
  my $Login1ManagerPropertiesObject=$Login1Service->get_object("/org/freedesktop/login1", "org.freedesktop.DBus.Properties");

  my $Systemd1Service=$SystemBus->get_service("org.freedesktop.systemd1");
  my $Systemd1ManagerCallObject=$Systemd1Service->get_object("/org/freedesktop/systemd1", "org.freedesktop.systemd1.Manager");

  #Get the number of sessions that logind is configured for
  my $MaxSessionCount=$Login1ManagerPropertiesObject->Get("org.freedesktop.login1.Manager", "NAutoVTs");

  %SeatManager = (
                    Login1Service => $Login1Service,
                    Login1ManagerCallObject => $Login1ManagerCallObject,
                    Login1ManagerPropertiesObject => $Login1ManagerPropertiesObject,

                    Systemd1Service => $Systemd1Service,
                    Systemd1ManagerCallObject => $Systemd1ManagerCallObject,

                    MaxSessionCount => $MaxSessionCount,
                 );

  #Start vtty-frontend@.service on all running seats.
  my @Seats=@{$SeatManager{Login1ManagerCallObject}->ListSeats()};
  foreach my $Seat ( @Seats )
  {
    my $SeatName=$Seat->[0];
    my $SeatPath=$Seat->[1];

    my $SeatObject=$SeatManager{Login1Service}->get_object($SeatPath, "org.freedesktop.DBus.Properties");
    my $SeatCanGraphical=$SeatObject->Get("org.freedesktop.login1.Seat", "CanGraphical");

    #Don't start a vtty-frontend on the virtual seat-vtty seat, or on seats that don't have GPUs, or has VTs
    if (($SeatName eq "seat-vtty") || ($SeatCanGraphical == 0))
    {
      next;
    }

    eval{$SeatManager{Systemd1ManagerCallObject}->StartUnit("vtty-frontend\@${SeatName}\@vtty1.service", "replace")};
  }

  $SeatManager{Login1ManagerCallObject}->connect_to_signal("SecureAttentionKey", \&HandleSecureAttentionKeySafe);
  $SeatManager{Login1ManagerCallObject}->connect_to_signal("SessionRemoved", \&HandleSessionRemovedSafe);
  $SeatManager{Login1ManagerCallObject}->connect_to_signal("SeatNew", \&HandleSeatNewSafe);
  $SeatManager{Login1ManagerCallObject}->connect_to_signal("SeatRemoved", \&HandleSeatRemovedSafe);

  my $DbusReactor=Net::DBus::Reactor->main();
  $DbusReactor->run();
  exit 0;
}

main();
